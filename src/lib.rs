/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}

impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self {
            storage,
            align: [],
        }
    }

    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];

        let bit_index = index % 8;
        let mask = 1 << bit_index;

        byte & mask == mask
    }

    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];

        let bit_index = index % 8;
        let mask = 1 << bit_index;

        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }

    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        let mut val = 0;

        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                val |= 1 << i;
            }
        }

        val
    }

    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            self.set_bit(i + bit_offset, val_bit_is_set);
        }
    }
}
 # [ repr ( C ) ] # [ derive ( Default ) ] pub struct __IncompleteArrayField < T > ( :: std :: marker :: PhantomData < T > ) ; impl < T > __IncompleteArrayField < T > { # [ inline ] pub fn new ( ) -> Self { __IncompleteArrayField ( :: std :: marker :: PhantomData ) } # [ inline ] pub unsafe fn as_ptr ( & self ) -> * const T { :: std :: mem :: transmute ( self ) } # [ inline ] pub unsafe fn as_mut_ptr ( & mut self ) -> * mut T { :: std :: mem :: transmute ( self ) } # [ inline ] pub unsafe fn as_slice ( & self , len : usize ) -> & [ T ] { :: std :: slice :: from_raw_parts ( self . as_ptr ( ) , len ) } # [ inline ] pub unsafe fn as_mut_slice ( & mut self , len : usize ) -> & mut [ T ] { :: std :: slice :: from_raw_parts_mut ( self . as_mut_ptr ( ) , len ) } } impl < T > :: std :: fmt :: Debug for __IncompleteArrayField < T > { fn fmt ( & self , fmt : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { fmt . write_str ( "__IncompleteArrayField" ) } } impl < T > :: std :: clone :: Clone for __IncompleteArrayField < T > { # [ inline ] fn clone ( & self ) -> Self { Self :: new ( ) } } impl < T > :: std :: marker :: Copy for __IncompleteArrayField < T > { } # [ repr ( C ) ] pub struct __BindgenUnionField < T > ( :: std :: marker :: PhantomData < T > ) ; impl < T > __BindgenUnionField < T > { # [ inline ] pub fn new ( ) -> Self { __BindgenUnionField ( :: std :: marker :: PhantomData ) } # [ inline ] pub unsafe fn as_ref ( & self ) -> & T { :: std :: mem :: transmute ( self ) } # [ inline ] pub unsafe fn as_mut ( & mut self ) -> & mut T { :: std :: mem :: transmute ( self ) } } impl < T > :: std :: default :: Default for __BindgenUnionField < T > { # [ inline ] fn default ( ) -> Self { Self :: new ( ) } } impl < T > :: std :: clone :: Clone for __BindgenUnionField < T > { # [ inline ] fn clone ( & self ) -> Self { Self :: new ( ) } } impl < T > :: std :: marker :: Copy for __BindgenUnionField < T > { } impl < T > :: std :: fmt :: Debug for __BindgenUnionField < T > { fn fmt ( & self , fmt : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { fmt . write_str ( "__BindgenUnionField" ) } } impl < T > :: std :: hash :: Hash for __BindgenUnionField < T > { fn hash < H : :: std :: hash :: Hasher > ( & self , _state : & mut H ) { } } impl < T > :: std :: cmp :: PartialEq for __BindgenUnionField < T > { fn eq ( & self , _other : & __BindgenUnionField < T > ) -> bool { true } } impl < T > :: std :: cmp :: Eq for __BindgenUnionField < T > { } pub const _X86_ : u32 = 1 ; pub const i386 : u32 = 1 ; pub const DEPRECATE_DDK_FUNCTIONS : u32 = 1 ; pub const _WIN32_WINNT : u32 = 2560 ; pub const WINVER : u32 = 2560 ; pub const WINNT : u32 = 1 ; pub const NTDDI_VERSION : u32 = 167772164 ; pub const _STRSAFE_USE_SECURE_CRT : u32 = 0 ; pub const _SAL_VERSION : u32 = 20 ; pub const __SAL_H_VERSION : u32 = 180000000 ; pub const _USE_DECLSPECS_FOR_SAL : u32 = 0 ; pub const _USE_ATTRIBUTES_FOR_SAL : u32 = 0 ; pub const _CRT_PACKING : u32 = 8 ; pub const _HAS_EXCEPTIONS : u32 = 1 ; pub const EXCEPTION_EXECUTE_HANDLER : u32 = 1 ; pub const EXCEPTION_CONTINUE_SEARCH : u32 = 0 ; pub const EXCEPTION_CONTINUE_EXECUTION : i32 = -1 ; pub const _ARGMAX : u32 = 100 ; pub const _CRT_INT_MAX : u32 = 2147483647 ; pub const _CRT_FUNCTIONS_REQUIRED : u32 = 1 ; pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE : u32 = 0 ; pub const _CRT_BUILD_DESKTOP_APP : u32 = 1 ; pub const __STDC_SECURE_LIB__ : u32 = 200411 ; pub const __GOT_SECURE_LIB__ : u32 = 200411 ; pub const __STDC_WANT_SECURE_LIB__ : u32 = 1 ; pub const _SECURECRT_FILL_BUFFER_PATTERN : u32 = 254 ; pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES : u32 = 0 ; pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT : u32 = 0 ; pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES : u32 = 1 ; pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY : u32 = 0 ; pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY : u32 = 0 ; pub const _UPPER : u32 = 1 ; pub const _LOWER : u32 = 2 ; pub const _DIGIT : u32 = 4 ; pub const _SPACE : u32 = 8 ; pub const _PUNCT : u32 = 16 ; pub const _CONTROL : u32 = 32 ; pub const _BLANK : u32 = 64 ; pub const _HEX : u32 = 128 ; pub const _LEADBYTE : u32 = 32768 ; pub const _ALPHA : u32 = 259 ; pub const WINAPI_FAMILY_PC_APP : u32 = 2 ; pub const WINAPI_FAMILY_PHONE_APP : u32 = 3 ; pub const WINAPI_FAMILY_SYSTEM : u32 = 4 ; pub const WINAPI_FAMILY_SERVER : u32 = 5 ; pub const WINAPI_FAMILY_DESKTOP_APP : u32 = 100 ; pub const WINAPI_FAMILY_APP : u32 = 2 ; pub const WINAPI_FAMILY : u32 = 100 ; pub const ANYSIZE_ARRAY : u32 = 1 ; pub const __SAL_H_FULL_VER : u32 = 140050727 ; pub const __SPECSTRINGS_STRICT_LEVEL : u32 = 1 ; pub const __drv_typeConst : u32 = 0 ; pub const __drv_typeCond : u32 = 1 ; pub const __drv_typeBitset : u32 = 2 ; pub const __drv_typeExpr : u32 = 3 ; pub const DISPATCH_LEVEL : u32 = 2 ; pub const APC_LEVEL : u32 = 1 ; pub const PASSIVE_LEVEL : u32 = 0 ; pub const HIGH_LEVEL : u32 = 31 ; pub const MEMORY_ALLOCATION_ALIGNMENT : u32 = 16 ; pub const SYSTEM_CACHE_ALIGNMENT_SIZE : u32 = 64 ; pub const PRAGMA_DEPRECATED_DDK : u32 = 1 ; pub const UCSCHAR_INVALID_CHARACTER : u32 = 4294967295 ; pub const MIN_UCSCHAR : u32 = 0 ; pub const MAX_UCSCHAR : u32 = 1114111 ; pub const STRICT : u32 = 1 ; pub const ALL_PROCESSOR_GROUPS : u32 = 65535 ; pub const MAXIMUM_PROC_PER_GROUP : u32 = 64 ; pub const MAXIMUM_PROCESSORS : u32 = 64 ; pub const OBJ_HANDLE_TAGBITS : u32 = 3 ; pub const APPLICATION_ERROR_MASK : u32 = 536870912 ; pub const ERROR_SEVERITY_SUCCESS : u32 = 0 ; pub const ERROR_SEVERITY_INFORMATIONAL : u32 = 1073741824 ; pub const ERROR_SEVERITY_WARNING : u32 = 2147483648 ; pub const ERROR_SEVERITY_ERROR : u32 = 3221225472 ; pub const MAXLONGLONG : u64 = 9223372036854775807 ; pub const UNICODE_STRING_MAX_CHARS : u32 = 32767 ; pub const RTL_BALANCED_NODE_RESERVED_PARENT_MASK : u32 = 3 ; pub const OBJ_INHERIT : u32 = 2 ; pub const OBJ_PERMANENT : u32 = 16 ; pub const OBJ_EXCLUSIVE : u32 = 32 ; pub const OBJ_CASE_INSENSITIVE : u32 = 64 ; pub const OBJ_OPENIF : u32 = 128 ; pub const OBJ_OPENLINK : u32 = 256 ; pub const OBJ_KERNEL_HANDLE : u32 = 512 ; pub const OBJ_FORCE_ACCESS_CHECK : u32 = 1024 ; pub const OBJ_IGNORE_IMPERSONATED_DEVICEMAP : u32 = 2048 ; pub const OBJ_DONT_REPARSE : u32 = 4096 ; pub const OBJ_VALID_ATTRIBUTES : u32 = 8178 ; pub const FALSE : u32 = 0 ; pub const TRUE : u32 = 1 ; pub const EPERM : u32 = 1 ; pub const ENOENT : u32 = 2 ; pub const ESRCH : u32 = 3 ; pub const EINTR : u32 = 4 ; pub const EIO : u32 = 5 ; pub const ENXIO : u32 = 6 ; pub const E2BIG : u32 = 7 ; pub const ENOEXEC : u32 = 8 ; pub const EBADF : u32 = 9 ; pub const ECHILD : u32 = 10 ; pub const EAGAIN : u32 = 11 ; pub const ENOMEM : u32 = 12 ; pub const EACCES : u32 = 13 ; pub const EFAULT : u32 = 14 ; pub const EBUSY : u32 = 16 ; pub const EEXIST : u32 = 17 ; pub const EXDEV : u32 = 18 ; pub const ENODEV : u32 = 19 ; pub const ENOTDIR : u32 = 20 ; pub const EISDIR : u32 = 21 ; pub const ENFILE : u32 = 23 ; pub const EMFILE : u32 = 24 ; pub const ENOTTY : u32 = 25 ; pub const EFBIG : u32 = 27 ; pub const ENOSPC : u32 = 28 ; pub const ESPIPE : u32 = 29 ; pub const EROFS : u32 = 30 ; pub const EMLINK : u32 = 31 ; pub const EPIPE : u32 = 32 ; pub const EDOM : u32 = 33 ; pub const EDEADLK : u32 = 36 ; pub const ENAMETOOLONG : u32 = 38 ; pub const ENOLCK : u32 = 39 ; pub const ENOSYS : u32 = 40 ; pub const ENOTEMPTY : u32 = 41 ; pub const EINVAL : u32 = 22 ; pub const ERANGE : u32 = 34 ; pub const EILSEQ : u32 = 42 ; pub const STRUNCATE : u32 = 80 ; pub const EDEADLOCK : u32 = 36 ; pub const EADDRINUSE : u32 = 100 ; pub const EADDRNOTAVAIL : u32 = 101 ; pub const EAFNOSUPPORT : u32 = 102 ; pub const EALREADY : u32 = 103 ; pub const EBADMSG : u32 = 104 ; pub const ECANCELED : u32 = 105 ; pub const ECONNABORTED : u32 = 106 ; pub const ECONNREFUSED : u32 = 107 ; pub const ECONNRESET : u32 = 108 ; pub const EDESTADDRREQ : u32 = 109 ; pub const EHOSTUNREACH : u32 = 110 ; pub const EIDRM : u32 = 111 ; pub const EINPROGRESS : u32 = 112 ; pub const EISCONN : u32 = 113 ; pub const ELOOP : u32 = 114 ; pub const EMSGSIZE : u32 = 115 ; pub const ENETDOWN : u32 = 116 ; pub const ENETRESET : u32 = 117 ; pub const ENETUNREACH : u32 = 118 ; pub const ENOBUFS : u32 = 119 ; pub const ENODATA : u32 = 120 ; pub const ENOLINK : u32 = 121 ; pub const ENOMSG : u32 = 122 ; pub const ENOPROTOOPT : u32 = 123 ; pub const ENOSR : u32 = 124 ; pub const ENOSTR : u32 = 125 ; pub const ENOTCONN : u32 = 126 ; pub const ENOTRECOVERABLE : u32 = 127 ; pub const ENOTSOCK : u32 = 128 ; pub const ENOTSUP : u32 = 129 ; pub const EOPNOTSUPP : u32 = 130 ; pub const EOTHER : u32 = 131 ; pub const EOVERFLOW : u32 = 132 ; pub const EOWNERDEAD : u32 = 133 ; pub const EPROTO : u32 = 134 ; pub const EPROTONOSUPPORT : u32 = 135 ; pub const EPROTOTYPE : u32 = 136 ; pub const ETIME : u32 = 137 ; pub const ETIMEDOUT : u32 = 138 ; pub const ETXTBSY : u32 = 139 ; pub const EWOULDBLOCK : u32 = 140 ; pub const _NLSCMPERROR : u32 = 2147483647 ; pub const MINCHAR : u32 = 128 ; pub const MAXCHAR : u32 = 127 ; pub const MINSHORT : u32 = 32768 ; pub const MAXSHORT : u32 = 32767 ; pub const MINLONG : u32 = 2147483648 ; pub const MAXLONG : u32 = 2147483647 ; pub const MAXUCHAR : u32 = 255 ; pub const MAXUSHORT : u32 = 65535 ; pub const MAXULONG : u32 = 4294967295 ; pub const VER_SERVER_NT : u32 = 2147483648 ; pub const VER_WORKSTATION_NT : u32 = 1073741824 ; pub const VER_SUITE_SMALLBUSINESS : u32 = 1 ; pub const VER_SUITE_ENTERPRISE : u32 = 2 ; pub const VER_SUITE_BACKOFFICE : u32 = 4 ; pub const VER_SUITE_COMMUNICATIONS : u32 = 8 ; pub const VER_SUITE_TERMINAL : u32 = 16 ; pub const VER_SUITE_SMALLBUSINESS_RESTRICTED : u32 = 32 ; pub const VER_SUITE_EMBEDDEDNT : u32 = 64 ; pub const VER_SUITE_DATACENTER : u32 = 128 ; pub const VER_SUITE_SINGLEUSERTS : u32 = 256 ; pub const VER_SUITE_PERSONAL : u32 = 512 ; pub const VER_SUITE_BLADE : u32 = 1024 ; pub const VER_SUITE_EMBEDDED_RESTRICTED : u32 = 2048 ; pub const VER_SUITE_SECURITY_APPLIANCE : u32 = 4096 ; pub const VER_SUITE_STORAGE_SERVER : u32 = 8192 ; pub const VER_SUITE_COMPUTE_SERVER : u32 = 16384 ; pub const VER_SUITE_WH_SERVER : u32 = 32768 ; pub const PRODUCT_UNDEFINED : u32 = 0 ; pub const PRODUCT_ULTIMATE : u32 = 1 ; pub const PRODUCT_HOME_BASIC : u32 = 2 ; pub const PRODUCT_HOME_PREMIUM : u32 = 3 ; pub const PRODUCT_ENTERPRISE : u32 = 4 ; pub const PRODUCT_HOME_BASIC_N : u32 = 5 ; pub const PRODUCT_BUSINESS : u32 = 6 ; pub const PRODUCT_STANDARD_SERVER : u32 = 7 ; pub const PRODUCT_DATACENTER_SERVER : u32 = 8 ; pub const PRODUCT_SMALLBUSINESS_SERVER : u32 = 9 ; pub const PRODUCT_ENTERPRISE_SERVER : u32 = 10 ; pub const PRODUCT_STARTER : u32 = 11 ; pub const PRODUCT_DATACENTER_SERVER_CORE : u32 = 12 ; pub const PRODUCT_STANDARD_SERVER_CORE : u32 = 13 ; pub const PRODUCT_ENTERPRISE_SERVER_CORE : u32 = 14 ; pub const PRODUCT_ENTERPRISE_SERVER_IA64 : u32 = 15 ; pub const PRODUCT_BUSINESS_N : u32 = 16 ; pub const PRODUCT_WEB_SERVER : u32 = 17 ; pub const PRODUCT_CLUSTER_SERVER : u32 = 18 ; pub const PRODUCT_HOME_SERVER : u32 = 19 ; pub const PRODUCT_STORAGE_EXPRESS_SERVER : u32 = 20 ; pub const PRODUCT_STORAGE_STANDARD_SERVER : u32 = 21 ; pub const PRODUCT_STORAGE_WORKGROUP_SERVER : u32 = 22 ; pub const PRODUCT_STORAGE_ENTERPRISE_SERVER : u32 = 23 ; pub const PRODUCT_SERVER_FOR_SMALLBUSINESS : u32 = 24 ; pub const PRODUCT_SMALLBUSINESS_SERVER_PREMIUM : u32 = 25 ; pub const PRODUCT_HOME_PREMIUM_N : u32 = 26 ; pub const PRODUCT_ENTERPRISE_N : u32 = 27 ; pub const PRODUCT_ULTIMATE_N : u32 = 28 ; pub const PRODUCT_WEB_SERVER_CORE : u32 = 29 ; pub const PRODUCT_MEDIUMBUSINESS_SERVER_MANAGEMENT : u32 = 30 ; pub const PRODUCT_MEDIUMBUSINESS_SERVER_SECURITY : u32 = 31 ; pub const PRODUCT_MEDIUMBUSINESS_SERVER_MESSAGING : u32 = 32 ; pub const PRODUCT_SERVER_FOUNDATION : u32 = 33 ; pub const PRODUCT_HOME_PREMIUM_SERVER : u32 = 34 ; pub const PRODUCT_SERVER_FOR_SMALLBUSINESS_V : u32 = 35 ; pub const PRODUCT_STANDARD_SERVER_V : u32 = 36 ; pub const PRODUCT_DATACENTER_SERVER_V : u32 = 37 ; pub const PRODUCT_ENTERPRISE_SERVER_V : u32 = 38 ; pub const PRODUCT_DATACENTER_SERVER_CORE_V : u32 = 39 ; pub const PRODUCT_STANDARD_SERVER_CORE_V : u32 = 40 ; pub const PRODUCT_ENTERPRISE_SERVER_CORE_V : u32 = 41 ; pub const PRODUCT_HYPERV : u32 = 42 ; pub const PRODUCT_STORAGE_EXPRESS_SERVER_CORE : u32 = 43 ; pub const PRODUCT_STORAGE_STANDARD_SERVER_CORE : u32 = 44 ; pub const PRODUCT_STORAGE_WORKGROUP_SERVER_CORE : u32 = 45 ; pub const PRODUCT_STORAGE_ENTERPRISE_SERVER_CORE : u32 = 46 ; pub const PRODUCT_STARTER_N : u32 = 47 ; pub const PRODUCT_PROFESSIONAL : u32 = 48 ; pub const PRODUCT_PROFESSIONAL_N : u32 = 49 ; pub const PRODUCT_SB_SOLUTION_SERVER : u32 = 50 ; pub const PRODUCT_SERVER_FOR_SB_SOLUTIONS : u32 = 51 ; pub const PRODUCT_STANDARD_SERVER_SOLUTIONS : u32 = 52 ; pub const PRODUCT_STANDARD_SERVER_SOLUTIONS_CORE : u32 = 53 ; pub const PRODUCT_SB_SOLUTION_SERVER_EM : u32 = 54 ; pub const PRODUCT_SERVER_FOR_SB_SOLUTIONS_EM : u32 = 55 ; pub const PRODUCT_SOLUTION_EMBEDDEDSERVER : u32 = 56 ; pub const PRODUCT_SOLUTION_EMBEDDEDSERVER_CORE : u32 = 57 ; pub const PRODUCT_PROFESSIONAL_EMBEDDED : u32 = 58 ; pub const PRODUCT_ESSENTIALBUSINESS_SERVER_MGMT : u32 = 59 ; pub const PRODUCT_ESSENTIALBUSINESS_SERVER_ADDL : u32 = 60 ; pub const PRODUCT_ESSENTIALBUSINESS_SERVER_MGMTSVC : u32 = 61 ; pub const PRODUCT_ESSENTIALBUSINESS_SERVER_ADDLSVC : u32 = 62 ; pub const PRODUCT_SMALLBUSINESS_SERVER_PREMIUM_CORE : u32 = 63 ; pub const PRODUCT_CLUSTER_SERVER_V : u32 = 64 ; pub const PRODUCT_EMBEDDED : u32 = 65 ; pub const PRODUCT_STARTER_E : u32 = 66 ; pub const PRODUCT_HOME_BASIC_E : u32 = 67 ; pub const PRODUCT_HOME_PREMIUM_E : u32 = 68 ; pub const PRODUCT_PROFESSIONAL_E : u32 = 69 ; pub const PRODUCT_ENTERPRISE_E : u32 = 70 ; pub const PRODUCT_ULTIMATE_E : u32 = 71 ; pub const PRODUCT_ENTERPRISE_EVALUATION : u32 = 72 ; pub const PRODUCT_MULTIPOINT_STANDARD_SERVER : u32 = 76 ; pub const PRODUCT_MULTIPOINT_PREMIUM_SERVER : u32 = 77 ; pub const PRODUCT_STANDARD_EVALUATION_SERVER : u32 = 79 ; pub const PRODUCT_DATACENTER_EVALUATION_SERVER : u32 = 80 ; pub const PRODUCT_ENTERPRISE_N_EVALUATION : u32 = 84 ; pub const PRODUCT_EMBEDDED_AUTOMOTIVE : u32 = 85 ; pub const PRODUCT_EMBEDDED_INDUSTRY_A : u32 = 86 ; pub const PRODUCT_THINPC : u32 = 87 ; pub const PRODUCT_EMBEDDED_A : u32 = 88 ; pub const PRODUCT_EMBEDDED_INDUSTRY : u32 = 89 ; pub const PRODUCT_EMBEDDED_E : u32 = 90 ; pub const PRODUCT_EMBEDDED_INDUSTRY_E : u32 = 91 ; pub const PRODUCT_EMBEDDED_INDUSTRY_A_E : u32 = 92 ; pub const PRODUCT_STORAGE_WORKGROUP_EVALUATION_SERVER : u32 = 95 ; pub const PRODUCT_STORAGE_STANDARD_EVALUATION_SERVER : u32 = 96 ; pub const PRODUCT_CORE_ARM : u32 = 97 ; pub const PRODUCT_CORE_N : u32 = 98 ; pub const PRODUCT_CORE_COUNTRYSPECIFIC : u32 = 99 ; pub const PRODUCT_CORE_SINGLELANGUAGE : u32 = 100 ; pub const PRODUCT_CORE : u32 = 101 ; pub const PRODUCT_PROFESSIONAL_WMC : u32 = 103 ; pub const PRODUCT_MOBILE_CORE : u32 = 104 ; pub const PRODUCT_EMBEDDED_INDUSTRY_EVAL : u32 = 105 ; pub const PRODUCT_EMBEDDED_INDUSTRY_E_EVAL : u32 = 106 ; pub const PRODUCT_EMBEDDED_EVAL : u32 = 107 ; pub const PRODUCT_EMBEDDED_E_EVAL : u32 = 108 ; pub const PRODUCT_NANO_SERVER : u32 = 109 ; pub const PRODUCT_CLOUD_STORAGE_SERVER : u32 = 110 ; pub const PRODUCT_CORE_CONNECTED : u32 = 111 ; pub const PRODUCT_PROFESSIONAL_STUDENT : u32 = 112 ; pub const PRODUCT_CORE_CONNECTED_N : u32 = 113 ; pub const PRODUCT_PROFESSIONAL_STUDENT_N : u32 = 114 ; pub const PRODUCT_CORE_CONNECTED_SINGLELANGUAGE : u32 = 115 ; pub const PRODUCT_CORE_CONNECTED_COUNTRYSPECIFIC : u32 = 116 ; pub const PRODUCT_CONNECTED_CAR : u32 = 117 ; pub const PRODUCT_INDUSTRY_HANDHELD : u32 = 118 ; pub const PRODUCT_PPI_PRO : u32 = 119 ; pub const PRODUCT_ARM64_SERVER : u32 = 120 ; pub const PRODUCT_EDUCATION : u32 = 121 ; pub const PRODUCT_EDUCATION_N : u32 = 122 ; pub const PRODUCT_IOTUAP : u32 = 123 ; pub const PRODUCT_CLOUD_HOST_INFRASTRUCTURE_SERVER : u32 = 124 ; pub const PRODUCT_ENTERPRISE_S : u32 = 125 ; pub const PRODUCT_ENTERPRISE_S_N : u32 = 126 ; pub const PRODUCT_PROFESSIONAL_S : u32 = 127 ; pub const PRODUCT_PROFESSIONAL_S_N : u32 = 128 ; pub const PRODUCT_ENTERPRISE_S_EVALUATION : u32 = 129 ; pub const PRODUCT_ENTERPRISE_S_N_EVALUATION : u32 = 130 ; pub const PRODUCT_HOLOGRAPHIC : u32 = 135 ; pub const PRODUCT_PRO_SINGLE_LANGUAGE : u32 = 138 ; pub const PRODUCT_PRO_CHINA : u32 = 139 ; pub const PRODUCT_ENTERPRISE_SUBSCRIPTION : u32 = 140 ; pub const PRODUCT_ENTERPRISE_SUBSCRIPTION_N : u32 = 141 ; pub const PRODUCT_DATACENTER_NANO_SERVER : u32 = 143 ; pub const PRODUCT_STANDARD_NANO_SERVER : u32 = 144 ; pub const PRODUCT_DATACENTER_A_SERVER_CORE : u32 = 145 ; pub const PRODUCT_STANDARD_A_SERVER_CORE : u32 = 146 ; pub const PRODUCT_DATACENTER_WS_SERVER_CORE : u32 = 147 ; pub const PRODUCT_STANDARD_WS_SERVER_CORE : u32 = 148 ; pub const PRODUCT_UTILITY_VM : u32 = 149 ; pub const PRODUCT_DATACENTER_EVALUATION_SERVER_CORE : u32 = 159 ; pub const PRODUCT_STANDARD_EVALUATION_SERVER_CORE : u32 = 160 ; pub const PRODUCT_PRO_WORKSTATION : u32 = 161 ; pub const PRODUCT_PRO_WORKSTATION_N : u32 = 162 ; pub const PRODUCT_PRO_FOR_EDUCATION : u32 = 164 ; pub const PRODUCT_PRO_FOR_EDUCATION_N : u32 = 165 ; pub const PRODUCT_AZURE_SERVER_CORE : u32 = 168 ; pub const PRODUCT_AZURE_NANO_SERVER : u32 = 169 ; pub const PRODUCT_ENTERPRISEG : u32 = 171 ; pub const PRODUCT_ENTERPRISEGN : u32 = 172 ; pub const PRODUCT_SERVERRDSH : u32 = 175 ; pub const PRODUCT_CLOUD : u32 = 178 ; pub const PRODUCT_CLOUDN : u32 = 179 ; pub const PRODUCT_UNLICENSED : u32 = 2882382797 ; pub const _WIN32_WINNT_NT4 : u32 = 1024 ; pub const _WIN32_WINNT_WIN2K : u32 = 1280 ; pub const _WIN32_WINNT_WINXP : u32 = 1281 ; pub const _WIN32_WINNT_WS03 : u32 = 1282 ; pub const _WIN32_WINNT_WIN6 : u32 = 1536 ; pub const _WIN32_WINNT_VISTA : u32 = 1536 ; pub const _WIN32_WINNT_WS08 : u32 = 1536 ; pub const _WIN32_WINNT_LONGHORN : u32 = 1536 ; pub const _WIN32_WINNT_WIN7 : u32 = 1537 ; pub const _WIN32_WINNT_WIN8 : u32 = 1538 ; pub const _WIN32_WINNT_WINBLUE : u32 = 1539 ; pub const _WIN32_WINNT_WINTHRESHOLD : u32 = 2560 ; pub const _WIN32_WINNT_WIN10 : u32 = 2560 ; pub const _WIN32_IE_IE20 : u32 = 512 ; pub const _WIN32_IE_IE30 : u32 = 768 ; pub const _WIN32_IE_IE302 : u32 = 770 ; pub const _WIN32_IE_IE40 : u32 = 1024 ; pub const _WIN32_IE_IE401 : u32 = 1025 ; pub const _WIN32_IE_IE50 : u32 = 1280 ; pub const _WIN32_IE_IE501 : u32 = 1281 ; pub const _WIN32_IE_IE55 : u32 = 1360 ; pub const _WIN32_IE_IE60 : u32 = 1536 ; pub const _WIN32_IE_IE60SP1 : u32 = 1537 ; pub const _WIN32_IE_IE60SP2 : u32 = 1539 ; pub const _WIN32_IE_IE70 : u32 = 1792 ; pub const _WIN32_IE_IE80 : u32 = 2048 ; pub const _WIN32_IE_IE90 : u32 = 2304 ; pub const _WIN32_IE_IE100 : u32 = 2560 ; pub const _WIN32_IE_IE110 : u32 = 2560 ; pub const _WIN32_IE_NT4 : u32 = 512 ; pub const _WIN32_IE_NT4SP1 : u32 = 512 ; pub const _WIN32_IE_NT4SP2 : u32 = 512 ; pub const _WIN32_IE_NT4SP3 : u32 = 770 ; pub const _WIN32_IE_NT4SP4 : u32 = 1025 ; pub const _WIN32_IE_NT4SP5 : u32 = 1025 ; pub const _WIN32_IE_NT4SP6 : u32 = 1280 ; pub const _WIN32_IE_WIN98 : u32 = 1025 ; pub const _WIN32_IE_WIN98SE : u32 = 1280 ; pub const _WIN32_IE_WINME : u32 = 1360 ; pub const _WIN32_IE_WIN2K : u32 = 1281 ; pub const _WIN32_IE_WIN2KSP1 : u32 = 1281 ; pub const _WIN32_IE_WIN2KSP2 : u32 = 1281 ; pub const _WIN32_IE_WIN2KSP3 : u32 = 1281 ; pub const _WIN32_IE_WIN2KSP4 : u32 = 1281 ; pub const _WIN32_IE_XP : u32 = 1536 ; pub const _WIN32_IE_XPSP1 : u32 = 1537 ; pub const _WIN32_IE_XPSP2 : u32 = 1539 ; pub const _WIN32_IE_WS03 : u32 = 1538 ; pub const _WIN32_IE_WS03SP1 : u32 = 1539 ; pub const _WIN32_IE_WIN6 : u32 = 1792 ; pub const _WIN32_IE_LONGHORN : u32 = 1792 ; pub const _WIN32_IE_WIN7 : u32 = 2048 ; pub const _WIN32_IE_WIN8 : u32 = 2560 ; pub const _WIN32_IE_WINBLUE : u32 = 2560 ; pub const _WIN32_IE_WINTHRESHOLD : u32 = 2560 ; pub const _WIN32_IE_WIN10 : u32 = 2560 ; pub const NTDDI_WIN2K : u32 = 83886080 ; pub const NTDDI_WIN2KSP1 : u32 = 83886336 ; pub const NTDDI_WIN2KSP2 : u32 = 83886592 ; pub const NTDDI_WIN2KSP3 : u32 = 83886848 ; pub const NTDDI_WIN2KSP4 : u32 = 83887104 ; pub const NTDDI_WINXP : u32 = 83951616 ; pub const NTDDI_WINXPSP1 : u32 = 83951872 ; pub const NTDDI_WINXPSP2 : u32 = 83952128 ; pub const NTDDI_WINXPSP3 : u32 = 83952384 ; pub const NTDDI_WINXPSP4 : u32 = 83952640 ; pub const NTDDI_WS03 : u32 = 84017152 ; pub const NTDDI_WS03SP1 : u32 = 84017408 ; pub const NTDDI_WS03SP2 : u32 = 84017664 ; pub const NTDDI_WS03SP3 : u32 = 84017920 ; pub const NTDDI_WS03SP4 : u32 = 84018176 ; pub const NTDDI_WIN6 : u32 = 100663296 ; pub const NTDDI_WIN6SP1 : u32 = 100663552 ; pub const NTDDI_WIN6SP2 : u32 = 100663808 ; pub const NTDDI_WIN6SP3 : u32 = 100664064 ; pub const NTDDI_WIN6SP4 : u32 = 100664320 ; pub const NTDDI_VISTA : u32 = 100663296 ; pub const NTDDI_VISTASP1 : u32 = 100663552 ; pub const NTDDI_VISTASP2 : u32 = 100663808 ; pub const NTDDI_VISTASP3 : u32 = 100664064 ; pub const NTDDI_VISTASP4 : u32 = 100664320 ; pub const NTDDI_LONGHORN : u32 = 100663296 ; pub const NTDDI_WS08 : u32 = 100663552 ; pub const NTDDI_WS08SP2 : u32 = 100663808 ; pub const NTDDI_WS08SP3 : u32 = 100664064 ; pub const NTDDI_WS08SP4 : u32 = 100664320 ; pub const NTDDI_WIN7 : u32 = 100728832 ; pub const NTDDI_WIN8 : u32 = 100794368 ; pub const NTDDI_WINBLUE : u32 = 100859904 ; pub const NTDDI_WINTHRESHOLD : u32 = 167772160 ; pub const NTDDI_WIN10 : u32 = 167772160 ; pub const NTDDI_WIN10_TH2 : u32 = 167772161 ; pub const NTDDI_WIN10_RS1 : u32 = 167772162 ; pub const NTDDI_WIN10_RS2 : u32 = 167772163 ; pub const NTDDI_WIN10_RS3 : u32 = 167772164 ; pub const WDK_NTDDI_VERSION : u32 = 167772164 ; pub const OSVERSION_MASK : u32 = 4294901760 ; pub const SPVERSION_MASK : u32 = 65280 ; pub const SUBVERSION_MASK : u32 = 255 ; pub const _WIN32_IE : u32 = 2560 ; pub const LANG_NEUTRAL : u32 = 0 ; pub const LANG_INVARIANT : u32 = 127 ; pub const LANG_AFRIKAANS : u32 = 54 ; pub const LANG_ALBANIAN : u32 = 28 ; pub const LANG_ALSATIAN : u32 = 132 ; pub const LANG_AMHARIC : u32 = 94 ; pub const LANG_ARABIC : u32 = 1 ; pub const LANG_ARMENIAN : u32 = 43 ; pub const LANG_ASSAMESE : u32 = 77 ; pub const LANG_AZERI : u32 = 44 ; pub const LANG_AZERBAIJANI : u32 = 44 ; pub const LANG_BANGLA : u32 = 69 ; pub const LANG_BASHKIR : u32 = 109 ; pub const LANG_BASQUE : u32 = 45 ; pub const LANG_BELARUSIAN : u32 = 35 ; pub const LANG_BENGALI : u32 = 69 ; pub const LANG_BRETON : u32 = 126 ; pub const LANG_BOSNIAN : u32 = 26 ; pub const LANG_BOSNIAN_NEUTRAL : u32 = 30746 ; pub const LANG_BULGARIAN : u32 = 2 ; pub const LANG_CATALAN : u32 = 3 ; pub const LANG_CENTRAL_KURDISH : u32 = 146 ; pub const LANG_CHEROKEE : u32 = 92 ; pub const LANG_CHINESE : u32 = 4 ; pub const LANG_CHINESE_SIMPLIFIED : u32 = 4 ; pub const LANG_CHINESE_TRADITIONAL : u32 = 31748 ; pub const LANG_CORSICAN : u32 = 131 ; pub const LANG_CROATIAN : u32 = 26 ; pub const LANG_CZECH : u32 = 5 ; pub const LANG_DANISH : u32 = 6 ; pub const LANG_DARI : u32 = 140 ; pub const LANG_DIVEHI : u32 = 101 ; pub const LANG_DUTCH : u32 = 19 ; pub const LANG_ENGLISH : u32 = 9 ; pub const LANG_ESTONIAN : u32 = 37 ; pub const LANG_FAEROESE : u32 = 56 ; pub const LANG_FARSI : u32 = 41 ; pub const LANG_FILIPINO : u32 = 100 ; pub const LANG_FINNISH : u32 = 11 ; pub const LANG_FRENCH : u32 = 12 ; pub const LANG_FRISIAN : u32 = 98 ; pub const LANG_FULAH : u32 = 103 ; pub const LANG_GALICIAN : u32 = 86 ; pub const LANG_GEORGIAN : u32 = 55 ; pub const LANG_GERMAN : u32 = 7 ; pub const LANG_GREEK : u32 = 8 ; pub const LANG_GREENLANDIC : u32 = 111 ; pub const LANG_GUJARATI : u32 = 71 ; pub const LANG_HAUSA : u32 = 104 ; pub const LANG_HAWAIIAN : u32 = 117 ; pub const LANG_HEBREW : u32 = 13 ; pub const LANG_HINDI : u32 = 57 ; pub const LANG_HUNGARIAN : u32 = 14 ; pub const LANG_ICELANDIC : u32 = 15 ; pub const LANG_IGBO : u32 = 112 ; pub const LANG_INDONESIAN : u32 = 33 ; pub const LANG_INUKTITUT : u32 = 93 ; pub const LANG_IRISH : u32 = 60 ; pub const LANG_ITALIAN : u32 = 16 ; pub const LANG_JAPANESE : u32 = 17 ; pub const LANG_KANNADA : u32 = 75 ; pub const LANG_KASHMIRI : u32 = 96 ; pub const LANG_KAZAK : u32 = 63 ; pub const LANG_KHMER : u32 = 83 ; pub const LANG_KICHE : u32 = 134 ; pub const LANG_KINYARWANDA : u32 = 135 ; pub const LANG_KONKANI : u32 = 87 ; pub const LANG_KOREAN : u32 = 18 ; pub const LANG_KYRGYZ : u32 = 64 ; pub const LANG_LAO : u32 = 84 ; pub const LANG_LATVIAN : u32 = 38 ; pub const LANG_LITHUANIAN : u32 = 39 ; pub const LANG_LOWER_SORBIAN : u32 = 46 ; pub const LANG_LUXEMBOURGISH : u32 = 110 ; pub const LANG_MACEDONIAN : u32 = 47 ; pub const LANG_MALAY : u32 = 62 ; pub const LANG_MALAYALAM : u32 = 76 ; pub const LANG_MALTESE : u32 = 58 ; pub const LANG_MANIPURI : u32 = 88 ; pub const LANG_MAORI : u32 = 129 ; pub const LANG_MAPUDUNGUN : u32 = 122 ; pub const LANG_MARATHI : u32 = 78 ; pub const LANG_MOHAWK : u32 = 124 ; pub const LANG_MONGOLIAN : u32 = 80 ; pub const LANG_NEPALI : u32 = 97 ; pub const LANG_NORWEGIAN : u32 = 20 ; pub const LANG_OCCITAN : u32 = 130 ; pub const LANG_ODIA : u32 = 72 ; pub const LANG_ORIYA : u32 = 72 ; pub const LANG_PASHTO : u32 = 99 ; pub const LANG_PERSIAN : u32 = 41 ; pub const LANG_POLISH : u32 = 21 ; pub const LANG_PORTUGUESE : u32 = 22 ; pub const LANG_PULAR : u32 = 103 ; pub const LANG_PUNJABI : u32 = 70 ; pub const LANG_QUECHUA : u32 = 107 ; pub const LANG_ROMANIAN : u32 = 24 ; pub const LANG_ROMANSH : u32 = 23 ; pub const LANG_RUSSIAN : u32 = 25 ; pub const LANG_SAKHA : u32 = 133 ; pub const LANG_SAMI : u32 = 59 ; pub const LANG_SANSKRIT : u32 = 79 ; pub const LANG_SCOTTISH_GAELIC : u32 = 145 ; pub const LANG_SERBIAN : u32 = 26 ; pub const LANG_SERBIAN_NEUTRAL : u32 = 31770 ; pub const LANG_SINDHI : u32 = 89 ; pub const LANG_SINHALESE : u32 = 91 ; pub const LANG_SLOVAK : u32 = 27 ; pub const LANG_SLOVENIAN : u32 = 36 ; pub const LANG_SOTHO : u32 = 108 ; pub const LANG_SPANISH : u32 = 10 ; pub const LANG_SWAHILI : u32 = 65 ; pub const LANG_SWEDISH : u32 = 29 ; pub const LANG_SYRIAC : u32 = 90 ; pub const LANG_TAJIK : u32 = 40 ; pub const LANG_TAMAZIGHT : u32 = 95 ; pub const LANG_TAMIL : u32 = 73 ; pub const LANG_TATAR : u32 = 68 ; pub const LANG_TELUGU : u32 = 74 ; pub const LANG_THAI : u32 = 30 ; pub const LANG_TIBETAN : u32 = 81 ; pub const LANG_TIGRIGNA : u32 = 115 ; pub const LANG_TIGRINYA : u32 = 115 ; pub const LANG_TSWANA : u32 = 50 ; pub const LANG_TURKISH : u32 = 31 ; pub const LANG_TURKMEN : u32 = 66 ; pub const LANG_UIGHUR : u32 = 128 ; pub const LANG_UKRAINIAN : u32 = 34 ; pub const LANG_UPPER_SORBIAN : u32 = 46 ; pub const LANG_URDU : u32 = 32 ; pub const LANG_UZBEK : u32 = 67 ; pub const LANG_VALENCIAN : u32 = 3 ; pub const LANG_VIETNAMESE : u32 = 42 ; pub const LANG_WELSH : u32 = 82 ; pub const LANG_WOLOF : u32 = 136 ; pub const LANG_XHOSA : u32 = 52 ; pub const LANG_YAKUT : u32 = 133 ; pub const LANG_YI : u32 = 120 ; pub const LANG_YORUBA : u32 = 106 ; pub const LANG_ZULU : u32 = 53 ; pub const SUBLANG_NEUTRAL : u32 = 0 ; pub const SUBLANG_DEFAULT : u32 = 1 ; pub const SUBLANG_SYS_DEFAULT : u32 = 2 ; pub const SUBLANG_CUSTOM_DEFAULT : u32 = 3 ; pub const SUBLANG_CUSTOM_UNSPECIFIED : u32 = 4 ; pub const SUBLANG_UI_CUSTOM_DEFAULT : u32 = 5 ; pub const SUBLANG_AFRIKAANS_SOUTH_AFRICA : u32 = 1 ; pub const SUBLANG_ALBANIAN_ALBANIA : u32 = 1 ; pub const SUBLANG_ALSATIAN_FRANCE : u32 = 1 ; pub const SUBLANG_AMHARIC_ETHIOPIA : u32 = 1 ; pub const SUBLANG_ARABIC_SAUDI_ARABIA : u32 = 1 ; pub const SUBLANG_ARABIC_IRAQ : u32 = 2 ; pub const SUBLANG_ARABIC_EGYPT : u32 = 3 ; pub const SUBLANG_ARABIC_LIBYA : u32 = 4 ; pub const SUBLANG_ARABIC_ALGERIA : u32 = 5 ; pub const SUBLANG_ARABIC_MOROCCO : u32 = 6 ; pub const SUBLANG_ARABIC_TUNISIA : u32 = 7 ; pub const SUBLANG_ARABIC_OMAN : u32 = 8 ; pub const SUBLANG_ARABIC_YEMEN : u32 = 9 ; pub const SUBLANG_ARABIC_SYRIA : u32 = 10 ; pub const SUBLANG_ARABIC_JORDAN : u32 = 11 ; pub const SUBLANG_ARABIC_LEBANON : u32 = 12 ; pub const SUBLANG_ARABIC_KUWAIT : u32 = 13 ; pub const SUBLANG_ARABIC_UAE : u32 = 14 ; pub const SUBLANG_ARABIC_BAHRAIN : u32 = 15 ; pub const SUBLANG_ARABIC_QATAR : u32 = 16 ; pub const SUBLANG_ARMENIAN_ARMENIA : u32 = 1 ; pub const SUBLANG_ASSAMESE_INDIA : u32 = 1 ; pub const SUBLANG_AZERI_LATIN : u32 = 1 ; pub const SUBLANG_AZERI_CYRILLIC : u32 = 2 ; pub const SUBLANG_AZERBAIJANI_AZERBAIJAN_LATIN : u32 = 1 ; pub const SUBLANG_AZERBAIJANI_AZERBAIJAN_CYRILLIC : u32 = 2 ; pub const SUBLANG_BANGLA_INDIA : u32 = 1 ; pub const SUBLANG_BANGLA_BANGLADESH : u32 = 2 ; pub const SUBLANG_BASHKIR_RUSSIA : u32 = 1 ; pub const SUBLANG_BASQUE_BASQUE : u32 = 1 ; pub const SUBLANG_BELARUSIAN_BELARUS : u32 = 1 ; pub const SUBLANG_BENGALI_INDIA : u32 = 1 ; pub const SUBLANG_BENGALI_BANGLADESH : u32 = 2 ; pub const SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN : u32 = 5 ; pub const SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC : u32 = 8 ; pub const SUBLANG_BRETON_FRANCE : u32 = 1 ; pub const SUBLANG_BULGARIAN_BULGARIA : u32 = 1 ; pub const SUBLANG_CATALAN_CATALAN : u32 = 1 ; pub const SUBLANG_CENTRAL_KURDISH_IRAQ : u32 = 1 ; pub const SUBLANG_CHEROKEE_CHEROKEE : u32 = 1 ; pub const SUBLANG_CHINESE_TRADITIONAL : u32 = 1 ; pub const SUBLANG_CHINESE_SIMPLIFIED : u32 = 2 ; pub const SUBLANG_CHINESE_HONGKONG : u32 = 3 ; pub const SUBLANG_CHINESE_SINGAPORE : u32 = 4 ; pub const SUBLANG_CHINESE_MACAU : u32 = 5 ; pub const SUBLANG_CORSICAN_FRANCE : u32 = 1 ; pub const SUBLANG_CZECH_CZECH_REPUBLIC : u32 = 1 ; pub const SUBLANG_CROATIAN_CROATIA : u32 = 1 ; pub const SUBLANG_CROATIAN_BOSNIA_HERZEGOVINA_LATIN : u32 = 4 ; pub const SUBLANG_DANISH_DENMARK : u32 = 1 ; pub const SUBLANG_DARI_AFGHANISTAN : u32 = 1 ; pub const SUBLANG_DIVEHI_MALDIVES : u32 = 1 ; pub const SUBLANG_DUTCH : u32 = 1 ; pub const SUBLANG_DUTCH_BELGIAN : u32 = 2 ; pub const SUBLANG_ENGLISH_US : u32 = 1 ; pub const SUBLANG_ENGLISH_UK : u32 = 2 ; pub const SUBLANG_ENGLISH_AUS : u32 = 3 ; pub const SUBLANG_ENGLISH_CAN : u32 = 4 ; pub const SUBLANG_ENGLISH_NZ : u32 = 5 ; pub const SUBLANG_ENGLISH_EIRE : u32 = 6 ; pub const SUBLANG_ENGLISH_SOUTH_AFRICA : u32 = 7 ; pub const SUBLANG_ENGLISH_JAMAICA : u32 = 8 ; pub const SUBLANG_ENGLISH_CARIBBEAN : u32 = 9 ; pub const SUBLANG_ENGLISH_BELIZE : u32 = 10 ; pub const SUBLANG_ENGLISH_TRINIDAD : u32 = 11 ; pub const SUBLANG_ENGLISH_ZIMBABWE : u32 = 12 ; pub const SUBLANG_ENGLISH_PHILIPPINES : u32 = 13 ; pub const SUBLANG_ENGLISH_INDIA : u32 = 16 ; pub const SUBLANG_ENGLISH_MALAYSIA : u32 = 17 ; pub const SUBLANG_ENGLISH_SINGAPORE : u32 = 18 ; pub const SUBLANG_ESTONIAN_ESTONIA : u32 = 1 ; pub const SUBLANG_FAEROESE_FAROE_ISLANDS : u32 = 1 ; pub const SUBLANG_FILIPINO_PHILIPPINES : u32 = 1 ; pub const SUBLANG_FINNISH_FINLAND : u32 = 1 ; pub const SUBLANG_FRENCH : u32 = 1 ; pub const SUBLANG_FRENCH_BELGIAN : u32 = 2 ; pub const SUBLANG_FRENCH_CANADIAN : u32 = 3 ; pub const SUBLANG_FRENCH_SWISS : u32 = 4 ; pub const SUBLANG_FRENCH_LUXEMBOURG : u32 = 5 ; pub const SUBLANG_FRENCH_MONACO : u32 = 6 ; pub const SUBLANG_FRISIAN_NETHERLANDS : u32 = 1 ; pub const SUBLANG_FULAH_SENEGAL : u32 = 2 ; pub const SUBLANG_GALICIAN_GALICIAN : u32 = 1 ; pub const SUBLANG_GEORGIAN_GEORGIA : u32 = 1 ; pub const SUBLANG_GERMAN : u32 = 1 ; pub const SUBLANG_GERMAN_SWISS : u32 = 2 ; pub const SUBLANG_GERMAN_AUSTRIAN : u32 = 3 ; pub const SUBLANG_GERMAN_LUXEMBOURG : u32 = 4 ; pub const SUBLANG_GERMAN_LIECHTENSTEIN : u32 = 5 ; pub const SUBLANG_GREEK_GREECE : u32 = 1 ; pub const SUBLANG_GREENLANDIC_GREENLAND : u32 = 1 ; pub const SUBLANG_GUJARATI_INDIA : u32 = 1 ; pub const SUBLANG_HAUSA_NIGERIA_LATIN : u32 = 1 ; pub const SUBLANG_HAWAIIAN_US : u32 = 1 ; pub const SUBLANG_HEBREW_ISRAEL : u32 = 1 ; pub const SUBLANG_HINDI_INDIA : u32 = 1 ; pub const SUBLANG_HUNGARIAN_HUNGARY : u32 = 1 ; pub const SUBLANG_ICELANDIC_ICELAND : u32 = 1 ; pub const SUBLANG_IGBO_NIGERIA : u32 = 1 ; pub const SUBLANG_INDONESIAN_INDONESIA : u32 = 1 ; pub const SUBLANG_INUKTITUT_CANADA : u32 = 1 ; pub const SUBLANG_INUKTITUT_CANADA_LATIN : u32 = 2 ; pub const SUBLANG_IRISH_IRELAND : u32 = 2 ; pub const SUBLANG_ITALIAN : u32 = 1 ; pub const SUBLANG_ITALIAN_SWISS : u32 = 2 ; pub const SUBLANG_JAPANESE_JAPAN : u32 = 1 ; pub const SUBLANG_KANNADA_INDIA : u32 = 1 ; pub const SUBLANG_KASHMIRI_SASIA : u32 = 2 ; pub const SUBLANG_KASHMIRI_INDIA : u32 = 2 ; pub const SUBLANG_KAZAK_KAZAKHSTAN : u32 = 1 ; pub const SUBLANG_KHMER_CAMBODIA : u32 = 1 ; pub const SUBLANG_KICHE_GUATEMALA : u32 = 1 ; pub const SUBLANG_KINYARWANDA_RWANDA : u32 = 1 ; pub const SUBLANG_KONKANI_INDIA : u32 = 1 ; pub const SUBLANG_KOREAN : u32 = 1 ; pub const SUBLANG_KYRGYZ_KYRGYZSTAN : u32 = 1 ; pub const SUBLANG_LAO_LAO : u32 = 1 ; pub const SUBLANG_LATVIAN_LATVIA : u32 = 1 ; pub const SUBLANG_LITHUANIAN : u32 = 1 ; pub const SUBLANG_LOWER_SORBIAN_GERMANY : u32 = 2 ; pub const SUBLANG_LUXEMBOURGISH_LUXEMBOURG : u32 = 1 ; pub const SUBLANG_MACEDONIAN_MACEDONIA : u32 = 1 ; pub const SUBLANG_MALAY_MALAYSIA : u32 = 1 ; pub const SUBLANG_MALAY_BRUNEI_DARUSSALAM : u32 = 2 ; pub const SUBLANG_MALAYALAM_INDIA : u32 = 1 ; pub const SUBLANG_MALTESE_MALTA : u32 = 1 ; pub const SUBLANG_MAORI_NEW_ZEALAND : u32 = 1 ; pub const SUBLANG_MAPUDUNGUN_CHILE : u32 = 1 ; pub const SUBLANG_MARATHI_INDIA : u32 = 1 ; pub const SUBLANG_MOHAWK_MOHAWK : u32 = 1 ; pub const SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA : u32 = 1 ; pub const SUBLANG_MONGOLIAN_PRC : u32 = 2 ; pub const SUBLANG_NEPALI_INDIA : u32 = 2 ; pub const SUBLANG_NEPALI_NEPAL : u32 = 1 ; pub const SUBLANG_NORWEGIAN_BOKMAL : u32 = 1 ; pub const SUBLANG_NORWEGIAN_NYNORSK : u32 = 2 ; pub const SUBLANG_OCCITAN_FRANCE : u32 = 1 ; pub const SUBLANG_ODIA_INDIA : u32 = 1 ; pub const SUBLANG_ORIYA_INDIA : u32 = 1 ; pub const SUBLANG_PASHTO_AFGHANISTAN : u32 = 1 ; pub const SUBLANG_PERSIAN_IRAN : u32 = 1 ; pub const SUBLANG_POLISH_POLAND : u32 = 1 ; pub const SUBLANG_PORTUGUESE : u32 = 2 ; pub const SUBLANG_PORTUGUESE_BRAZILIAN : u32 = 1 ; pub const SUBLANG_PULAR_SENEGAL : u32 = 2 ; pub const SUBLANG_PUNJABI_INDIA : u32 = 1 ; pub const SUBLANG_PUNJABI_PAKISTAN : u32 = 2 ; pub const SUBLANG_QUECHUA_BOLIVIA : u32 = 1 ; pub const SUBLANG_QUECHUA_ECUADOR : u32 = 2 ; pub const SUBLANG_QUECHUA_PERU : u32 = 3 ; pub const SUBLANG_ROMANIAN_ROMANIA : u32 = 1 ; pub const SUBLANG_ROMANSH_SWITZERLAND : u32 = 1 ; pub const SUBLANG_RUSSIAN_RUSSIA : u32 = 1 ; pub const SUBLANG_SAKHA_RUSSIA : u32 = 1 ; pub const SUBLANG_SAMI_NORTHERN_NORWAY : u32 = 1 ; pub const SUBLANG_SAMI_NORTHERN_SWEDEN : u32 = 2 ; pub const SUBLANG_SAMI_NORTHERN_FINLAND : u32 = 3 ; pub const SUBLANG_SAMI_LULE_NORWAY : u32 = 4 ; pub const SUBLANG_SAMI_LULE_SWEDEN : u32 = 5 ; pub const SUBLANG_SAMI_SOUTHERN_NORWAY : u32 = 6 ; pub const SUBLANG_SAMI_SOUTHERN_SWEDEN : u32 = 7 ; pub const SUBLANG_SAMI_SKOLT_FINLAND : u32 = 8 ; pub const SUBLANG_SAMI_INARI_FINLAND : u32 = 9 ; pub const SUBLANG_SANSKRIT_INDIA : u32 = 1 ; pub const SUBLANG_SCOTTISH_GAELIC : u32 = 1 ; pub const SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_LATIN : u32 = 6 ; pub const SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_CYRILLIC : u32 = 7 ; pub const SUBLANG_SERBIAN_MONTENEGRO_LATIN : u32 = 11 ; pub const SUBLANG_SERBIAN_MONTENEGRO_CYRILLIC : u32 = 12 ; pub const SUBLANG_SERBIAN_SERBIA_LATIN : u32 = 9 ; pub const SUBLANG_SERBIAN_SERBIA_CYRILLIC : u32 = 10 ; pub const SUBLANG_SERBIAN_CROATIA : u32 = 1 ; pub const SUBLANG_SERBIAN_LATIN : u32 = 2 ; pub const SUBLANG_SERBIAN_CYRILLIC : u32 = 3 ; pub const SUBLANG_SINDHI_INDIA : u32 = 1 ; pub const SUBLANG_SINDHI_PAKISTAN : u32 = 2 ; pub const SUBLANG_SINDHI_AFGHANISTAN : u32 = 2 ; pub const SUBLANG_SINHALESE_SRI_LANKA : u32 = 1 ; pub const SUBLANG_SOTHO_NORTHERN_SOUTH_AFRICA : u32 = 1 ; pub const SUBLANG_SLOVAK_SLOVAKIA : u32 = 1 ; pub const SUBLANG_SLOVENIAN_SLOVENIA : u32 = 1 ; pub const SUBLANG_SPANISH : u32 = 1 ; pub const SUBLANG_SPANISH_MEXICAN : u32 = 2 ; pub const SUBLANG_SPANISH_MODERN : u32 = 3 ; pub const SUBLANG_SPANISH_GUATEMALA : u32 = 4 ; pub const SUBLANG_SPANISH_COSTA_RICA : u32 = 5 ; pub const SUBLANG_SPANISH_PANAMA : u32 = 6 ; pub const SUBLANG_SPANISH_DOMINICAN_REPUBLIC : u32 = 7 ; pub const SUBLANG_SPANISH_VENEZUELA : u32 = 8 ; pub const SUBLANG_SPANISH_COLOMBIA : u32 = 9 ; pub const SUBLANG_SPANISH_PERU : u32 = 10 ; pub const SUBLANG_SPANISH_ARGENTINA : u32 = 11 ; pub const SUBLANG_SPANISH_ECUADOR : u32 = 12 ; pub const SUBLANG_SPANISH_CHILE : u32 = 13 ; pub const SUBLANG_SPANISH_URUGUAY : u32 = 14 ; pub const SUBLANG_SPANISH_PARAGUAY : u32 = 15 ; pub const SUBLANG_SPANISH_BOLIVIA : u32 = 16 ; pub const SUBLANG_SPANISH_EL_SALVADOR : u32 = 17 ; pub const SUBLANG_SPANISH_HONDURAS : u32 = 18 ; pub const SUBLANG_SPANISH_NICARAGUA : u32 = 19 ; pub const SUBLANG_SPANISH_PUERTO_RICO : u32 = 20 ; pub const SUBLANG_SPANISH_US : u32 = 21 ; pub const SUBLANG_SWAHILI_KENYA : u32 = 1 ; pub const SUBLANG_SWEDISH : u32 = 1 ; pub const SUBLANG_SWEDISH_FINLAND : u32 = 2 ; pub const SUBLANG_SYRIAC_SYRIA : u32 = 1 ; pub const SUBLANG_TAJIK_TAJIKISTAN : u32 = 1 ; pub const SUBLANG_TAMAZIGHT_ALGERIA_LATIN : u32 = 2 ; pub const SUBLANG_TAMAZIGHT_MOROCCO_TIFINAGH : u32 = 4 ; pub const SUBLANG_TAMIL_INDIA : u32 = 1 ; pub const SUBLANG_TAMIL_SRI_LANKA : u32 = 2 ; pub const SUBLANG_TATAR_RUSSIA : u32 = 1 ; pub const SUBLANG_TELUGU_INDIA : u32 = 1 ; pub const SUBLANG_THAI_THAILAND : u32 = 1 ; pub const SUBLANG_TIBETAN_PRC : u32 = 1 ; pub const SUBLANG_TIGRIGNA_ERITREA : u32 = 2 ; pub const SUBLANG_TIGRINYA_ERITREA : u32 = 2 ; pub const SUBLANG_TIGRINYA_ETHIOPIA : u32 = 1 ; pub const SUBLANG_TSWANA_BOTSWANA : u32 = 2 ; pub const SUBLANG_TSWANA_SOUTH_AFRICA : u32 = 1 ; pub const SUBLANG_TURKISH_TURKEY : u32 = 1 ; pub const SUBLANG_TURKMEN_TURKMENISTAN : u32 = 1 ; pub const SUBLANG_UIGHUR_PRC : u32 = 1 ; pub const SUBLANG_UKRAINIAN_UKRAINE : u32 = 1 ; pub const SUBLANG_UPPER_SORBIAN_GERMANY : u32 = 1 ; pub const SUBLANG_URDU_PAKISTAN : u32 = 1 ; pub const SUBLANG_URDU_INDIA : u32 = 2 ; pub const SUBLANG_UZBEK_LATIN : u32 = 1 ; pub const SUBLANG_UZBEK_CYRILLIC : u32 = 2 ; pub const SUBLANG_VALENCIAN_VALENCIA : u32 = 2 ; pub const SUBLANG_VIETNAMESE_VIETNAM : u32 = 1 ; pub const SUBLANG_WELSH_UNITED_KINGDOM : u32 = 1 ; pub const SUBLANG_WOLOF_SENEGAL : u32 = 1 ; pub const SUBLANG_XHOSA_SOUTH_AFRICA : u32 = 1 ; pub const SUBLANG_YAKUT_RUSSIA : u32 = 1 ; pub const SUBLANG_YI_PRC : u32 = 1 ; pub const SUBLANG_YORUBA_NIGERIA : u32 = 1 ; pub const SUBLANG_ZULU_SOUTH_AFRICA : u32 = 1 ; pub const SORT_DEFAULT : u32 = 0 ; pub const SORT_INVARIANT_MATH : u32 = 1 ; pub const SORT_JAPANESE_XJIS : u32 = 0 ; pub const SORT_JAPANESE_UNICODE : u32 = 1 ; pub const SORT_JAPANESE_RADICALSTROKE : u32 = 4 ; pub const SORT_CHINESE_BIG5 : u32 = 0 ; pub const SORT_CHINESE_PRCP : u32 = 0 ; pub const SORT_CHINESE_UNICODE : u32 = 1 ; pub const SORT_CHINESE_PRC : u32 = 2 ; pub const SORT_CHINESE_BOPOMOFO : u32 = 3 ; pub const SORT_CHINESE_RADICALSTROKE : u32 = 4 ; pub const SORT_KOREAN_KSC : u32 = 0 ; pub const SORT_KOREAN_UNICODE : u32 = 1 ; pub const SORT_GERMAN_PHONE_BOOK : u32 = 1 ; pub const SORT_HUNGARIAN_DEFAULT : u32 = 0 ; pub const SORT_HUNGARIAN_TECHNICAL : u32 = 1 ; pub const SORT_GEORGIAN_TRADITIONAL : u32 = 0 ; pub const SORT_GEORGIAN_MODERN : u32 = 1 ; pub const NLS_VALID_LOCALE_MASK : u32 = 1048575 ; pub const LOCALE_NAME_MAX_LENGTH : u32 = 85 ; pub const LOCALE_TRANSIENT_KEYBOARD1 : u32 = 8192 ; pub const LOCALE_TRANSIENT_KEYBOARD2 : u32 = 9216 ; pub const LOCALE_TRANSIENT_KEYBOARD3 : u32 = 10240 ; pub const LOCALE_TRANSIENT_KEYBOARD4 : u32 = 11264 ; pub const FACILITY_DEBUGGER : u32 = 1 ; pub const FACILITY_RPC_RUNTIME : u32 = 2 ; pub const FACILITY_RPC_STUBS : u32 = 3 ; pub const FACILITY_IO_ERROR_CODE : u32 = 4 ; pub const FACILITY_CODCLASS_ERROR_CODE : u32 = 6 ; pub const FACILITY_NTWIN32 : u32 = 7 ; pub const FACILITY_NTCERT : u32 = 8 ; pub const FACILITY_NTSSPI : u32 = 9 ; pub const FACILITY_TERMINAL_SERVER : u32 = 10 ; pub const FACILTIY_MUI_ERROR_CODE : u32 = 11 ; pub const FACILITY_USB_ERROR_CODE : u32 = 16 ; pub const FACILITY_HID_ERROR_CODE : u32 = 17 ; pub const FACILITY_FIREWIRE_ERROR_CODE : u32 = 18 ; pub const FACILITY_CLUSTER_ERROR_CODE : u32 = 19 ; pub const FACILITY_ACPI_ERROR_CODE : u32 = 20 ; pub const FACILITY_SXS_ERROR_CODE : u32 = 21 ; pub const FACILITY_TRANSACTION : u32 = 25 ; pub const FACILITY_COMMONLOG : u32 = 26 ; pub const FACILITY_VIDEO : u32 = 27 ; pub const FACILITY_FILTER_MANAGER : u32 = 28 ; pub const FACILITY_MONITOR : u32 = 29 ; pub const FACILITY_GRAPHICS_KERNEL : u32 = 30 ; pub const FACILITY_DRIVER_FRAMEWORK : u32 = 32 ; pub const FACILITY_FVE_ERROR_CODE : u32 = 33 ; pub const FACILITY_FWP_ERROR_CODE : u32 = 34 ; pub const FACILITY_NDIS_ERROR_CODE : u32 = 35 ; pub const FACILITY_TPM : u32 = 41 ; pub const FACILITY_RTPM : u32 = 42 ; pub const FACILITY_HYPERVISOR : u32 = 53 ; pub const FACILITY_IPSEC : u32 = 54 ; pub const FACILITY_VIRTUALIZATION : u32 = 55 ; pub const FACILITY_VOLMGR : u32 = 56 ; pub const FACILITY_BCD_ERROR_CODE : u32 = 57 ; pub const FACILITY_WIN32K_NTUSER : u32 = 62 ; pub const FACILITY_WIN32K_NTGDI : u32 = 63 ; pub const FACILITY_RESUME_KEY_FILTER : u32 = 64 ; pub const FACILITY_RDBSS : u32 = 65 ; pub const FACILITY_BTH_ATT : u32 = 66 ; pub const FACILITY_SECUREBOOT : u32 = 67 ; pub const FACILITY_AUDIO_KERNEL : u32 = 68 ; pub const FACILITY_VSM : u32 = 69 ; pub const FACILITY_VOLSNAP : u32 = 80 ; pub const FACILITY_SDBUS : u32 = 81 ; pub const FACILITY_SHARED_VHDX : u32 = 92 ; pub const FACILITY_SMB : u32 = 93 ; pub const FACILITY_INTERIX : u32 = 153 ; pub const FACILITY_SPACES : u32 = 231 ; pub const FACILITY_SECURITY_CORE : u32 = 232 ; pub const FACILITY_SYSTEM_INTEGRITY : u32 = 233 ; pub const FACILITY_LICENSING : u32 = 234 ; pub const FACILITY_PLATFORM_MANIFEST : u32 = 235 ; pub const FACILITY_MAXIMUM_VALUE : u32 = 236 ; pub const STATUS_SEVERITY_SUCCESS : u32 = 0 ; pub const STATUS_SEVERITY_INFORMATIONAL : u32 = 1 ; pub const STATUS_SEVERITY_WARNING : u32 = 2 ; pub const STATUS_SEVERITY_ERROR : u32 = 3 ; pub const BUGCHECK_CONTEXT_MODIFIER : u32 = 2147483648 ; pub const FACILITY_MCA_ERROR_CODE : u32 = 5 ; pub const MCA_EXTREG_V2MAX : u32 = 24 ; pub const LOW_LEVEL : u32 = 0 ; pub const CMCI_LEVEL : u32 = 5 ; pub const PROFILE_LEVEL : u32 = 27 ; pub const CLOCK1_LEVEL : u32 = 28 ; pub const CLOCK2_LEVEL : u32 = 28 ; pub const IPI_LEVEL : u32 = 29 ; pub const POWER_LEVEL : u32 = 30 ; pub const CLOCK_LEVEL : u32 = 28 ; pub const LOW_PRIORITY : u32 = 0 ; pub const LOW_REALTIME_PRIORITY : u32 = 16 ; pub const HIGH_PRIORITY : u32 = 31 ; pub const MAXIMUM_PRIORITY : u32 = 32 ; pub const MAXIMUM_WAIT_OBJECTS : u32 = 64 ; pub const MAXIMUM_SUSPEND_COUNT : u32 = 127 ; pub const LOCK_QUEUE_WAIT : u32 = 1 ; pub const LOCK_QUEUE_WAIT_BIT : u32 = 0 ; pub const LOCK_QUEUE_OWNER : u32 = 2 ; pub const LOCK_QUEUE_OWNER_BIT : u32 = 1 ; pub const DPC_WATCHDOG_GLOBAL_TRIAGE_BLOCK_SIGNATURE : u32 = 2931740382 ; pub const DPC_WATCHDOG_GLOBAL_TRIAGE_BLOCK_REVISION_1 : u32 = 1 ; pub const MAXIMUM_SUPPORTED_EXTENSION : u32 = 512 ; pub const DELETE : u32 = 65536 ; pub const READ_CONTROL : u32 = 131072 ; pub const WRITE_DAC : u32 = 262144 ; pub const WRITE_OWNER : u32 = 524288 ; pub const SYNCHRONIZE : u32 = 1048576 ; pub const STANDARD_RIGHTS_REQUIRED : u32 = 983040 ; pub const STANDARD_RIGHTS_READ : u32 = 131072 ; pub const STANDARD_RIGHTS_WRITE : u32 = 131072 ; pub const STANDARD_RIGHTS_EXECUTE : u32 = 131072 ; pub const STANDARD_RIGHTS_ALL : u32 = 2031616 ; pub const SPECIFIC_RIGHTS_ALL : u32 = 65535 ; pub const ACCESS_SYSTEM_SECURITY : u32 = 16777216 ; pub const MAXIMUM_ALLOWED : u32 = 33554432 ; pub const GENERIC_READ : u32 = 2147483648 ; pub const GENERIC_WRITE : u32 = 1073741824 ; pub const GENERIC_EXECUTE : u32 = 536870912 ; pub const GENERIC_ALL : u32 = 268435456 ; pub const ACL_REVISION : u32 = 2 ; pub const ACL_REVISION_DS : u32 = 4 ; pub const ACL_REVISION1 : u32 = 1 ; pub const ACL_REVISION2 : u32 = 2 ; pub const ACL_REVISION3 : u32 = 3 ; pub const ACL_REVISION4 : u32 = 4 ; pub const MAX_ACL_REVISION : u32 = 4 ; pub const SECURITY_DESCRIPTOR_REVISION : u32 = 1 ; pub const SECURITY_DESCRIPTOR_REVISION1 : u32 = 1 ; pub const SE_PRIVILEGE_ENABLED_BY_DEFAULT : u32 = 1 ; pub const SE_PRIVILEGE_ENABLED : u32 = 2 ; pub const SE_PRIVILEGE_USED_FOR_ACCESS : u32 = 2147483648 ; pub const PRIVILEGE_SET_ALL_NECESSARY : u32 = 1 ; pub const SE_MIN_WELL_KNOWN_PRIVILEGE : u32 = 2 ; pub const SE_CREATE_TOKEN_PRIVILEGE : u32 = 2 ; pub const SE_ASSIGNPRIMARYTOKEN_PRIVILEGE : u32 = 3 ; pub const SE_LOCK_MEMORY_PRIVILEGE : u32 = 4 ; pub const SE_INCREASE_QUOTA_PRIVILEGE : u32 = 5 ; pub const SE_MACHINE_ACCOUNT_PRIVILEGE : u32 = 6 ; pub const SE_TCB_PRIVILEGE : u32 = 7 ; pub const SE_SECURITY_PRIVILEGE : u32 = 8 ; pub const SE_TAKE_OWNERSHIP_PRIVILEGE : u32 = 9 ; pub const SE_LOAD_DRIVER_PRIVILEGE : u32 = 10 ; pub const SE_SYSTEM_PROFILE_PRIVILEGE : u32 = 11 ; pub const SE_SYSTEMTIME_PRIVILEGE : u32 = 12 ; pub const SE_PROF_SINGLE_PROCESS_PRIVILEGE : u32 = 13 ; pub const SE_INC_BASE_PRIORITY_PRIVILEGE : u32 = 14 ; pub const SE_CREATE_PAGEFILE_PRIVILEGE : u32 = 15 ; pub const SE_CREATE_PERMANENT_PRIVILEGE : u32 = 16 ; pub const SE_BACKUP_PRIVILEGE : u32 = 17 ; pub const SE_RESTORE_PRIVILEGE : u32 = 18 ; pub const SE_SHUTDOWN_PRIVILEGE : u32 = 19 ; pub const SE_DEBUG_PRIVILEGE : u32 = 20 ; pub const SE_AUDIT_PRIVILEGE : u32 = 21 ; pub const SE_SYSTEM_ENVIRONMENT_PRIVILEGE : u32 = 22 ; pub const SE_CHANGE_NOTIFY_PRIVILEGE : u32 = 23 ; pub const SE_REMOTE_SHUTDOWN_PRIVILEGE : u32 = 24 ; pub const SE_UNDOCK_PRIVILEGE : u32 = 25 ; pub const SE_SYNC_AGENT_PRIVILEGE : u32 = 26 ; pub const SE_ENABLE_DELEGATION_PRIVILEGE : u32 = 27 ; pub const SE_MANAGE_VOLUME_PRIVILEGE : u32 = 28 ; pub const SE_IMPERSONATE_PRIVILEGE : u32 = 29 ; pub const SE_CREATE_GLOBAL_PRIVILEGE : u32 = 30 ; pub const SE_TRUSTED_CREDMAN_ACCESS_PRIVILEGE : u32 = 31 ; pub const SE_RELABEL_PRIVILEGE : u32 = 32 ; pub const SE_INC_WORKING_SET_PRIVILEGE : u32 = 33 ; pub const SE_TIME_ZONE_PRIVILEGE : u32 = 34 ; pub const SE_CREATE_SYMBOLIC_LINK_PRIVILEGE : u32 = 35 ; pub const SE_DELEGATE_SESSION_USER_IMPERSONATE_PRIVILEGE : u32 = 36 ; pub const SE_MAX_WELL_KNOWN_PRIVILEGE : u32 = 36 ; pub const SECURITY_DYNAMIC_TRACKING : u32 = 1 ; pub const SECURITY_STATIC_TRACKING : u32 = 0 ; pub const OWNER_SECURITY_INFORMATION : u32 = 1 ; pub const GROUP_SECURITY_INFORMATION : u32 = 2 ; pub const DACL_SECURITY_INFORMATION : u32 = 4 ; pub const SACL_SECURITY_INFORMATION : u32 = 8 ; pub const LABEL_SECURITY_INFORMATION : u32 = 16 ; pub const ATTRIBUTE_SECURITY_INFORMATION : u32 = 32 ; pub const SCOPE_SECURITY_INFORMATION : u32 = 64 ; pub const PROCESS_TRUST_LABEL_SECURITY_INFORMATION : u32 = 128 ; pub const ACCESS_FILTER_SECURITY_INFORMATION : u32 = 256 ; pub const BACKUP_SECURITY_INFORMATION : u32 = 65536 ; pub const PROTECTED_DACL_SECURITY_INFORMATION : u32 = 2147483648 ; pub const PROTECTED_SACL_SECURITY_INFORMATION : u32 = 1073741824 ; pub const UNPROTECTED_DACL_SECURITY_INFORMATION : u32 = 536870912 ; pub const UNPROTECTED_SACL_SECURITY_INFORMATION : u32 = 268435456 ; pub const SE_ADT_OBJECT_ONLY : u32 = 1 ; pub const SE_MAX_AUDIT_PARAMETERS : u32 = 32 ; pub const SE_MAX_GENERIC_AUDIT_PARAMETERS : u32 = 28 ; pub const SE_ADT_PARAMETERS_SELF_RELATIVE : u32 = 1 ; pub const SE_ADT_PARAMETERS_SEND_TO_LSA : u32 = 2 ; pub const SE_ADT_PARAMETER_EXTENSIBLE_AUDIT : u32 = 4 ; pub const SE_ADT_PARAMETER_GENERIC_AUDIT : u32 = 8 ; pub const SE_ADT_PARAMETER_WRITE_SYNCHRONOUS : u32 = 16 ; pub const FILE_DEVICE_BEEP : u32 = 1 ; pub const FILE_DEVICE_CD_ROM : u32 = 2 ; pub const FILE_DEVICE_CD_ROM_FILE_SYSTEM : u32 = 3 ; pub const FILE_DEVICE_CONTROLLER : u32 = 4 ; pub const FILE_DEVICE_DATALINK : u32 = 5 ; pub const FILE_DEVICE_DFS : u32 = 6 ; pub const FILE_DEVICE_DISK : u32 = 7 ; pub const FILE_DEVICE_DISK_FILE_SYSTEM : u32 = 8 ; pub const FILE_DEVICE_FILE_SYSTEM : u32 = 9 ; pub const FILE_DEVICE_INPORT_PORT : u32 = 10 ; pub const FILE_DEVICE_KEYBOARD : u32 = 11 ; pub const FILE_DEVICE_MAILSLOT : u32 = 12 ; pub const FILE_DEVICE_MIDI_IN : u32 = 13 ; pub const FILE_DEVICE_MIDI_OUT : u32 = 14 ; pub const FILE_DEVICE_MOUSE : u32 = 15 ; pub const FILE_DEVICE_MULTI_UNC_PROVIDER : u32 = 16 ; pub const FILE_DEVICE_NAMED_PIPE : u32 = 17 ; pub const FILE_DEVICE_NETWORK : u32 = 18 ; pub const FILE_DEVICE_NETWORK_BROWSER : u32 = 19 ; pub const FILE_DEVICE_NETWORK_FILE_SYSTEM : u32 = 20 ; pub const FILE_DEVICE_NULL : u32 = 21 ; pub const FILE_DEVICE_PARALLEL_PORT : u32 = 22 ; pub const FILE_DEVICE_PHYSICAL_NETCARD : u32 = 23 ; pub const FILE_DEVICE_PRINTER : u32 = 24 ; pub const FILE_DEVICE_SCANNER : u32 = 25 ; pub const FILE_DEVICE_SERIAL_MOUSE_PORT : u32 = 26 ; pub const FILE_DEVICE_SERIAL_PORT : u32 = 27 ; pub const FILE_DEVICE_SCREEN : u32 = 28 ; pub const FILE_DEVICE_SOUND : u32 = 29 ; pub const FILE_DEVICE_STREAMS : u32 = 30 ; pub const FILE_DEVICE_TAPE : u32 = 31 ; pub const FILE_DEVICE_TAPE_FILE_SYSTEM : u32 = 32 ; pub const FILE_DEVICE_TRANSPORT : u32 = 33 ; pub const FILE_DEVICE_UNKNOWN : u32 = 34 ; pub const FILE_DEVICE_VIDEO : u32 = 35 ; pub const FILE_DEVICE_VIRTUAL_DISK : u32 = 36 ; pub const FILE_DEVICE_WAVE_IN : u32 = 37 ; pub const FILE_DEVICE_WAVE_OUT : u32 = 38 ; pub const FILE_DEVICE_8042_PORT : u32 = 39 ; pub const FILE_DEVICE_NETWORK_REDIRECTOR : u32 = 40 ; pub const FILE_DEVICE_BATTERY : u32 = 41 ; pub const FILE_DEVICE_BUS_EXTENDER : u32 = 42 ; pub const FILE_DEVICE_MODEM : u32 = 43 ; pub const FILE_DEVICE_VDM : u32 = 44 ; pub const FILE_DEVICE_MASS_STORAGE : u32 = 45 ; pub const FILE_DEVICE_SMB : u32 = 46 ; pub const FILE_DEVICE_KS : u32 = 47 ; pub const FILE_DEVICE_CHANGER : u32 = 48 ; pub const FILE_DEVICE_SMARTCARD : u32 = 49 ; pub const FILE_DEVICE_ACPI : u32 = 50 ; pub const FILE_DEVICE_DVD : u32 = 51 ; pub const FILE_DEVICE_FULLSCREEN_VIDEO : u32 = 52 ; pub const FILE_DEVICE_DFS_FILE_SYSTEM : u32 = 53 ; pub const FILE_DEVICE_DFS_VOLUME : u32 = 54 ; pub const FILE_DEVICE_SERENUM : u32 = 55 ; pub const FILE_DEVICE_TERMSRV : u32 = 56 ; pub const FILE_DEVICE_KSEC : u32 = 57 ; pub const FILE_DEVICE_FIPS : u32 = 58 ; pub const FILE_DEVICE_INFINIBAND : u32 = 59 ; pub const FILE_DEVICE_VMBUS : u32 = 62 ; pub const FILE_DEVICE_CRYPT_PROVIDER : u32 = 63 ; pub const FILE_DEVICE_WPD : u32 = 64 ; pub const FILE_DEVICE_BLUETOOTH : u32 = 65 ; pub const FILE_DEVICE_MT_COMPOSITE : u32 = 66 ; pub const FILE_DEVICE_MT_TRANSPORT : u32 = 67 ; pub const FILE_DEVICE_BIOMETRIC : u32 = 68 ; pub const FILE_DEVICE_PMI : u32 = 69 ; pub const FILE_DEVICE_EHSTOR : u32 = 70 ; pub const FILE_DEVICE_DEVAPI : u32 = 71 ; pub const FILE_DEVICE_GPIO : u32 = 72 ; pub const FILE_DEVICE_USBEX : u32 = 73 ; pub const FILE_DEVICE_CONSOLE : u32 = 80 ; pub const FILE_DEVICE_NFP : u32 = 81 ; pub const FILE_DEVICE_SYSENV : u32 = 82 ; pub const FILE_DEVICE_VIRTUAL_BLOCK : u32 = 83 ; pub const FILE_DEVICE_POINT_OF_SERVICE : u32 = 84 ; pub const FILE_DEVICE_STORAGE_REPLICATION : u32 = 85 ; pub const FILE_DEVICE_TRUST_ENV : u32 = 86 ; pub const FILE_DEVICE_UCM : u32 = 87 ; pub const FILE_DEVICE_UCMTCPCI : u32 = 88 ; pub const FILE_DEVICE_PERSISTENT_MEMORY : u32 = 89 ; pub const FILE_DEVICE_NVDIMM : u32 = 90 ; pub const FILE_DEVICE_HOLOGRAPHIC : u32 = 91 ; pub const FILE_DEVICE_SDFXHCI : u32 = 92 ; pub const METHOD_BUFFERED : u32 = 0 ; pub const METHOD_IN_DIRECT : u32 = 1 ; pub const METHOD_OUT_DIRECT : u32 = 2 ; pub const METHOD_NEITHER : u32 = 3 ; pub const METHOD_DIRECT_TO_HARDWARE : u32 = 1 ; pub const METHOD_DIRECT_FROM_HARDWARE : u32 = 2 ; pub const FILE_ANY_ACCESS : u32 = 0 ; pub const FILE_SPECIAL_ACCESS : u32 = 0 ; pub const FILE_READ_ACCESS : u32 = 1 ; pub const FILE_WRITE_ACCESS : u32 = 2 ; pub const FILE_READ_DATA : u32 = 1 ; pub const FILE_LIST_DIRECTORY : u32 = 1 ; pub const FILE_WRITE_DATA : u32 = 2 ; pub const FILE_ADD_FILE : u32 = 2 ; pub const FILE_APPEND_DATA : u32 = 4 ; pub const FILE_ADD_SUBDIRECTORY : u32 = 4 ; pub const FILE_CREATE_PIPE_INSTANCE : u32 = 4 ; pub const FILE_READ_EA : u32 = 8 ; pub const FILE_WRITE_EA : u32 = 16 ; pub const FILE_EXECUTE : u32 = 32 ; pub const FILE_TRAVERSE : u32 = 32 ; pub const FILE_DELETE_CHILD : u32 = 64 ; pub const FILE_READ_ATTRIBUTES : u32 = 128 ; pub const FILE_WRITE_ATTRIBUTES : u32 = 256 ; pub const FILE_ALL_ACCESS : u32 = 2032127 ; pub const FILE_GENERIC_READ : u32 = 1179785 ; pub const FILE_GENERIC_WRITE : u32 = 1179926 ; pub const FILE_GENERIC_EXECUTE : u32 = 1179808 ; pub const FILE_SHARE_READ : u32 = 1 ; pub const FILE_SHARE_WRITE : u32 = 2 ; pub const FILE_SHARE_DELETE : u32 = 4 ; pub const FILE_SHARE_VALID_FLAGS : u32 = 7 ; pub const FILE_ATTRIBUTE_READONLY : u32 = 1 ; pub const FILE_ATTRIBUTE_HIDDEN : u32 = 2 ; pub const FILE_ATTRIBUTE_SYSTEM : u32 = 4 ; pub const FILE_ATTRIBUTE_DIRECTORY : u32 = 16 ; pub const FILE_ATTRIBUTE_ARCHIVE : u32 = 32 ; pub const FILE_ATTRIBUTE_DEVICE : u32 = 64 ; pub const FILE_ATTRIBUTE_NORMAL : u32 = 128 ; pub const FILE_ATTRIBUTE_TEMPORARY : u32 = 256 ; pub const FILE_ATTRIBUTE_SPARSE_FILE : u32 = 512 ; pub const FILE_ATTRIBUTE_REPARSE_POINT : u32 = 1024 ; pub const FILE_ATTRIBUTE_COMPRESSED : u32 = 2048 ; pub const FILE_ATTRIBUTE_OFFLINE : u32 = 4096 ; pub const FILE_ATTRIBUTE_NOT_CONTENT_INDEXED : u32 = 8192 ; pub const FILE_ATTRIBUTE_ENCRYPTED : u32 = 16384 ; pub const FILE_ATTRIBUTE_INTEGRITY_STREAM : u32 = 32768 ; pub const FILE_ATTRIBUTE_VIRTUAL : u32 = 65536 ; pub const FILE_ATTRIBUTE_NO_SCRUB_DATA : u32 = 131072 ; pub const FILE_ATTRIBUTE_EA : u32 = 262144 ; pub const FILE_ATTRIBUTE_PINNED : u32 = 524288 ; pub const FILE_ATTRIBUTE_UNPINNED : u32 = 1048576 ; pub const FILE_ATTRIBUTE_RECALL_ON_OPEN : u32 = 262144 ; pub const FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS : u32 = 4194304 ; pub const TREE_CONNECT_ATTRIBUTE_PRIVACY : u32 = 16384 ; pub const TREE_CONNECT_ATTRIBUTE_INTEGRITY : u32 = 32768 ; pub const TREE_CONNECT_ATTRIBUTE_GLOBAL : u32 = 4 ; pub const FILE_ATTRIBUTE_STRICTLY_SEQUENTIAL : u32 = 536870912 ; pub const FILE_ATTRIBUTE_VALID_FLAGS : u32 = 5963703 ; pub const FILE_ATTRIBUTE_VALID_SET_FLAGS : u32 = 1716647 ; pub const FILE_ATTRIBUTE_VALID_KERNEL_SET_FLAGS : u32 = 5910951 ; pub const FILE_SUPERSEDE : u32 = 0 ; pub const FILE_OPEN : u32 = 1 ; pub const FILE_CREATE : u32 = 2 ; pub const FILE_OPEN_IF : u32 = 3 ; pub const FILE_OVERWRITE : u32 = 4 ; pub const FILE_OVERWRITE_IF : u32 = 5 ; pub const FILE_MAXIMUM_DISPOSITION : u32 = 5 ; pub const FILE_DIRECTORY_FILE : u32 = 1 ; pub const FILE_WRITE_THROUGH : u32 = 2 ; pub const FILE_SEQUENTIAL_ONLY : u32 = 4 ; pub const FILE_NO_INTERMEDIATE_BUFFERING : u32 = 8 ; pub const FILE_SYNCHRONOUS_IO_ALERT : u32 = 16 ; pub const FILE_SYNCHRONOUS_IO_NONALERT : u32 = 32 ; pub const FILE_NON_DIRECTORY_FILE : u32 = 64 ; pub const FILE_CREATE_TREE_CONNECTION : u32 = 128 ; pub const FILE_COMPLETE_IF_OPLOCKED : u32 = 256 ; pub const FILE_NO_EA_KNOWLEDGE : u32 = 512 ; pub const FILE_OPEN_REMOTE_INSTANCE : u32 = 1024 ; pub const FILE_RANDOM_ACCESS : u32 = 2048 ; pub const FILE_DELETE_ON_CLOSE : u32 = 4096 ; pub const FILE_OPEN_BY_FILE_ID : u32 = 8192 ; pub const FILE_OPEN_FOR_BACKUP_INTENT : u32 = 16384 ; pub const FILE_NO_COMPRESSION : u32 = 32768 ; pub const FILE_OPEN_REQUIRING_OPLOCK : u32 = 65536 ; pub const FILE_DISALLOW_EXCLUSIVE : u32 = 131072 ; pub const FILE_SESSION_AWARE : u32 = 262144 ; pub const FILE_RESERVE_OPFILTER : u32 = 1048576 ; pub const FILE_OPEN_REPARSE_POINT : u32 = 2097152 ; pub const FILE_OPEN_NO_RECALL : u32 = 4194304 ; pub const FILE_OPEN_FOR_FREE_SPACE_QUERY : u32 = 8388608 ; pub const FILE_VALID_OPTION_FLAGS : u32 = 16777215 ; pub const FILE_VALID_PIPE_OPTION_FLAGS : u32 = 50 ; pub const FILE_VALID_MAILSLOT_OPTION_FLAGS : u32 = 50 ; pub const FILE_VALID_SET_FLAGS : u32 = 54 ; pub const FILE_SUPERSEDED : u32 = 0 ; pub const FILE_OPENED : u32 = 1 ; pub const FILE_CREATED : u32 = 2 ; pub const FILE_OVERWRITTEN : u32 = 3 ; pub const FILE_EXISTS : u32 = 4 ; pub const FILE_DOES_NOT_EXIST : u32 = 5 ; pub const FILE_WRITE_TO_END_OF_FILE : u32 = 4294967295 ; pub const FILE_USE_FILE_POINTER_POSITION : u32 = 4294967294 ; pub const FILE_BYTE_ALIGNMENT : u32 = 0 ; pub const FILE_WORD_ALIGNMENT : u32 = 1 ; pub const FILE_LONG_ALIGNMENT : u32 = 3 ; pub const FILE_QUAD_ALIGNMENT : u32 = 7 ; pub const FILE_OCTA_ALIGNMENT : u32 = 15 ; pub const FILE_32_BYTE_ALIGNMENT : u32 = 31 ; pub const FILE_64_BYTE_ALIGNMENT : u32 = 63 ; pub const FILE_128_BYTE_ALIGNMENT : u32 = 127 ; pub const FILE_256_BYTE_ALIGNMENT : u32 = 255 ; pub const FILE_512_BYTE_ALIGNMENT : u32 = 511 ; pub const MAXIMUM_FILENAME_LENGTH : u32 = 256 ; pub const FILE_REMOVABLE_MEDIA : u32 = 1 ; pub const FILE_READ_ONLY_DEVICE : u32 = 2 ; pub const FILE_FLOPPY_DISKETTE : u32 = 4 ; pub const FILE_WRITE_ONCE_MEDIA : u32 = 8 ; pub const FILE_REMOTE_DEVICE : u32 = 16 ; pub const FILE_DEVICE_IS_MOUNTED : u32 = 32 ; pub const FILE_VIRTUAL_VOLUME : u32 = 64 ; pub const FILE_AUTOGENERATED_DEVICE_NAME : u32 = 128 ; pub const FILE_DEVICE_SECURE_OPEN : u32 = 256 ; pub const FILE_CHARACTERISTIC_PNP_DEVICE : u32 = 2048 ; pub const FILE_CHARACTERISTIC_TS_DEVICE : u32 = 4096 ; pub const FILE_CHARACTERISTIC_WEBDAV_DEVICE : u32 = 8192 ; pub const FILE_CHARACTERISTIC_CSV : u32 = 65536 ; pub const FILE_DEVICE_ALLOW_APPCONTAINER_TRAVERSAL : u32 = 131072 ; pub const FILE_PORTABLE_DEVICE : u32 = 262144 ; pub const IO_SESSION_STATE_ALL_EVENTS : u32 = 4294967295 ; pub const IO_SESSION_STATE_CREATION_EVENT : u32 = 1 ; pub const IO_SESSION_STATE_TERMINATION_EVENT : u32 = 2 ; pub const IO_SESSION_STATE_CONNECT_EVENT : u32 = 4 ; pub const IO_SESSION_STATE_DISCONNECT_EVENT : u32 = 8 ; pub const IO_SESSION_STATE_LOGON_EVENT : u32 = 16 ; pub const IO_SESSION_STATE_LOGOFF_EVENT : u32 = 32 ; pub const IO_SESSION_STATE_VALID_EVENT_MASK : u32 = 63 ; pub const IO_SESSION_MAX_PAYLOAD_SIZE : u32 = 256 ; pub const FILE_SKIP_COMPLETION_PORT_ON_SUCCESS : u32 = 1 ; pub const FILE_SKIP_SET_EVENT_ON_HANDLE : u32 = 2 ; pub const FILE_SKIP_SET_USER_EVENT_ON_FAST_IO : u32 = 4 ; pub const FLUSH_FLAGS_FILE_DATA_ONLY : u32 = 1 ; pub const FLUSH_FLAGS_NO_SYNC : u32 = 2 ; pub const FLUSH_FLAGS_FILE_DATA_SYNC_ONLY : u32 = 4 ; pub const ERROR_LOG_LIMIT_SIZE : u32 = 240 ; pub const PORT_MAXIMUM_MESSAGE_LENGTH : u32 = 512 ; pub const KEY_QUERY_VALUE : u32 = 1 ; pub const KEY_SET_VALUE : u32 = 2 ; pub const KEY_CREATE_SUB_KEY : u32 = 4 ; pub const KEY_ENUMERATE_SUB_KEYS : u32 = 8 ; pub const KEY_NOTIFY : u32 = 16 ; pub const KEY_CREATE_LINK : u32 = 32 ; pub const KEY_WOW64_32KEY : u32 = 512 ; pub const KEY_WOW64_64KEY : u32 = 256 ; pub const KEY_WOW64_RES : u32 = 768 ; pub const KEY_READ : u32 = 131097 ; pub const KEY_WRITE : u32 = 131078 ; pub const KEY_EXECUTE : u32 = 131097 ; pub const KEY_ALL_ACCESS : u32 = 983103 ; pub const REG_OPTION_RESERVED : u32 = 0 ; pub const REG_OPTION_NON_VOLATILE : u32 = 0 ; pub const REG_OPTION_VOLATILE : u32 = 1 ; pub const REG_OPTION_CREATE_LINK : u32 = 2 ; pub const REG_OPTION_BACKUP_RESTORE : u32 = 4 ; pub const REG_OPTION_OPEN_LINK : u32 = 8 ; pub const REG_OPTION_DONT_VIRTUALIZE : u32 = 16 ; pub const REG_LEGAL_OPTION : u32 = 31 ; pub const REG_OPEN_LEGAL_OPTION : u32 = 28 ; pub const REG_CREATED_NEW_KEY : u32 = 1 ; pub const REG_OPENED_EXISTING_KEY : u32 = 2 ; pub const REG_STANDARD_FORMAT : u32 = 1 ; pub const REG_LATEST_FORMAT : u32 = 2 ; pub const REG_NO_COMPRESSION : u32 = 4 ; pub const REG_WHOLE_HIVE_VOLATILE : u32 = 1 ; pub const REG_REFRESH_HIVE : u32 = 2 ; pub const REG_NO_LAZY_FLUSH : u32 = 4 ; pub const REG_FORCE_RESTORE : u32 = 8 ; pub const REG_APP_HIVE : u32 = 16 ; pub const REG_PROCESS_PRIVATE : u32 = 32 ; pub const REG_START_JOURNAL : u32 = 64 ; pub const REG_HIVE_EXACT_FILE_GROWTH : u32 = 128 ; pub const REG_HIVE_NO_RM : u32 = 256 ; pub const REG_HIVE_SINGLE_LOG : u32 = 512 ; pub const REG_BOOT_HIVE : u32 = 1024 ; pub const REG_LOAD_HIVE_OPEN_HANDLE : u32 = 2048 ; pub const REG_FLUSH_HIVE_FILE_GROWTH : u32 = 4096 ; pub const REG_OPEN_READ_ONLY : u32 = 8192 ; pub const REG_IMMUTABLE : u32 = 16384 ; pub const REG_APP_HIVE_OPEN_READ_ONLY : u32 = 8192 ; pub const REG_FORCE_UNLOAD : u32 = 1 ; pub const REG_UNLOAD_LEGAL_FLAGS : u32 = 1 ; pub const REG_NOTIFY_CHANGE_NAME : u32 = 1 ; pub const REG_NOTIFY_CHANGE_ATTRIBUTES : u32 = 2 ; pub const REG_NOTIFY_CHANGE_LAST_SET : u32 = 4 ; pub const REG_NOTIFY_CHANGE_SECURITY : u32 = 8 ; pub const REG_NOTIFY_THREAD_AGNOSTIC : u32 = 268435456 ; pub const REG_LEGAL_CHANGE_FILTER : u32 = 268435471 ; pub const OBJECT_TYPE_CREATE : u32 = 1 ; pub const OBJECT_TYPE_ALL_ACCESS : u32 = 983041 ; pub const DIRECTORY_QUERY : u32 = 1 ; pub const DIRECTORY_TRAVERSE : u32 = 2 ; pub const DIRECTORY_CREATE_OBJECT : u32 = 4 ; pub const DIRECTORY_CREATE_SUBDIRECTORY : u32 = 8 ; pub const DIRECTORY_ALL_ACCESS : u32 = 983055 ; pub const SYMBOLIC_LINK_QUERY : u32 = 1 ; pub const SYMBOLIC_LINK_SET : u32 = 2 ; pub const SYMBOLIC_LINK_ALL_ACCESS : u32 = 983041 ; pub const SYMBOLIC_LINK_ALL_ACCESS_EX : u32 = 1048575 ; pub const DUPLICATE_CLOSE_SOURCE : u32 = 1 ; pub const DUPLICATE_SAME_ACCESS : u32 = 2 ; pub const DUPLICATE_SAME_ATTRIBUTES : u32 = 4 ; pub const SECTION_QUERY : u32 = 1 ; pub const SECTION_MAP_WRITE : u32 = 2 ; pub const SECTION_MAP_READ : u32 = 4 ; pub const SECTION_MAP_EXECUTE : u32 = 8 ; pub const SECTION_EXTEND_SIZE : u32 = 16 ; pub const SECTION_MAP_EXECUTE_EXPLICIT : u32 = 32 ; pub const SECTION_ALL_ACCESS : u32 = 983071 ; pub const SESSION_QUERY_ACCESS : u32 = 1 ; pub const SESSION_MODIFY_ACCESS : u32 = 2 ; pub const SESSION_ALL_ACCESS : u32 = 983043 ; pub const SEGMENT_ALL_ACCESS : u32 = 983071 ; pub const PAGE_NOACCESS : u32 = 1 ; pub const PAGE_READONLY : u32 = 2 ; pub const PAGE_READWRITE : u32 = 4 ; pub const PAGE_WRITECOPY : u32 = 8 ; pub const PAGE_EXECUTE : u32 = 16 ; pub const PAGE_EXECUTE_READ : u32 = 32 ; pub const PAGE_EXECUTE_READWRITE : u32 = 64 ; pub const PAGE_EXECUTE_WRITECOPY : u32 = 128 ; pub const PAGE_GUARD : u32 = 256 ; pub const PAGE_NOCACHE : u32 = 512 ; pub const PAGE_WRITECOMBINE : u32 = 1024 ; pub const PAGE_REVERT_TO_FILE_MAP : u32 = 2147483648 ; pub const PAGE_ENCLAVE_THREAD_CONTROL : u32 = 2147483648 ; pub const PAGE_TARGETS_NO_UPDATE : u32 = 1073741824 ; pub const PAGE_TARGETS_INVALID : u32 = 1073741824 ; pub const PAGE_ENCLAVE_UNVALIDATED : u32 = 536870912 ; pub const PAGE_ENCLAVE_NO_CHANGE : u32 = 536870912 ; pub const MEM_COMMIT : u32 = 4096 ; pub const MEM_RESERVE : u32 = 8192 ; pub const MEM_DECOMMIT : u32 = 16384 ; pub const MEM_RELEASE : u32 = 32768 ; pub const MEM_FREE : u32 = 65536 ; pub const MEM_PRIVATE : u32 = 131072 ; pub const MEM_MAPPED : u32 = 262144 ; pub const MEM_RESET : u32 = 524288 ; pub const MEM_TOP_DOWN : u32 = 1048576 ; pub const MEM_RESET_UNDO : u32 = 16777216 ; pub const MEM_LARGE_PAGES : u32 = 536870912 ; pub const MEM_4MB_PAGES : u32 = 2147483648 ; pub const SEC_64K_PAGES : u32 = 524288 ; pub const SEC_FILE : u32 = 8388608 ; pub const SEC_RESERVE : u32 = 67108864 ; pub const SEC_COMMIT : u32 = 134217728 ; pub const SEC_LARGE_PAGES : u32 = 2147483648 ; pub const PROCESS_DUP_HANDLE : u32 = 64 ; pub const PROCESS_ALL_ACCESS : u32 = 2097151 ; pub const THREAD_TERMINATE : u32 = 1 ; pub const THREAD_SUSPEND_RESUME : u32 = 2 ; pub const THREAD_ALERT : u32 = 4 ; pub const THREAD_GET_CONTEXT : u32 = 8 ; pub const THREAD_SET_CONTEXT : u32 = 16 ; pub const THREAD_SET_INFORMATION : u32 = 32 ; pub const THREAD_SET_LIMITED_INFORMATION : u32 = 1024 ; pub const THREAD_QUERY_LIMITED_INFORMATION : u32 = 2048 ; pub const THREAD_RESUME : u32 = 4096 ; pub const THREAD_ALL_ACCESS : u32 = 2097151 ; pub const POWERBUTTON_ACTION_INDEX_NOTHING : u32 = 0 ; pub const POWERBUTTON_ACTION_INDEX_SLEEP : u32 = 1 ; pub const POWERBUTTON_ACTION_INDEX_HIBERNATE : u32 = 2 ; pub const POWERBUTTON_ACTION_INDEX_SHUTDOWN : u32 = 3 ; pub const POWERBUTTON_ACTION_INDEX_TURN_OFF_THE_DISPLAY : u32 = 4 ; pub const POWERBUTTON_ACTION_VALUE_NOTHING : u32 = 0 ; pub const POWERBUTTON_ACTION_VALUE_SLEEP : u32 = 2 ; pub const POWERBUTTON_ACTION_VALUE_HIBERNATE : u32 = 3 ; pub const POWERBUTTON_ACTION_VALUE_SHUTDOWN : u32 = 6 ; pub const POWERBUTTON_ACTION_VALUE_TURN_OFF_THE_DISPLAY : u32 = 8 ; pub const PERFSTATE_POLICY_CHANGE_IDEAL : u32 = 0 ; pub const PERFSTATE_POLICY_CHANGE_SINGLE : u32 = 1 ; pub const PERFSTATE_POLICY_CHANGE_ROCKET : u32 = 2 ; pub const PERFSTATE_POLICY_CHANGE_IDEAL_AGGRESSIVE : u32 = 3 ; pub const PERFSTATE_POLICY_CHANGE_DECREASE_MAX : u32 = 2 ; pub const PERFSTATE_POLICY_CHANGE_INCREASE_MAX : u32 = 3 ; pub const PROCESSOR_THROTTLE_DISABLED : u32 = 0 ; pub const PROCESSOR_THROTTLE_ENABLED : u32 = 1 ; pub const PROCESSOR_THROTTLE_AUTOMATIC : u32 = 2 ; pub const PROCESSOR_PERF_BOOST_POLICY_DISABLED : u32 = 0 ; pub const PROCESSOR_PERF_BOOST_POLICY_MAX : u32 = 100 ; pub const PROCESSOR_PERF_BOOST_MODE_DISABLED : u32 = 0 ; pub const PROCESSOR_PERF_BOOST_MODE_ENABLED : u32 = 1 ; pub const PROCESSOR_PERF_BOOST_MODE_AGGRESSIVE : u32 = 2 ; pub const PROCESSOR_PERF_BOOST_MODE_EFFICIENT_ENABLED : u32 = 3 ; pub const PROCESSOR_PERF_BOOST_MODE_EFFICIENT_AGGRESSIVE : u32 = 4 ; pub const PROCESSOR_PERF_BOOST_MODE_AGGRESSIVE_AT_GUARANTEED : u32 = 5 ; pub const PROCESSOR_PERF_BOOST_MODE_EFFICIENT_AGGRESSIVE_AT_GUARANTEED : u32 = 6 ; pub const PROCESSOR_PERF_BOOST_MODE_MAX : u32 = 6 ; pub const PROCESSOR_PERF_AUTONOMOUS_MODE_DISABLED : u32 = 0 ; pub const PROCESSOR_PERF_AUTONOMOUS_MODE_ENABLED : u32 = 1 ; pub const PROCESSOR_PERF_PERFORMANCE_PREFERENCE : u32 = 255 ; pub const PROCESSOR_PERF_ENERGY_PREFERENCE : u32 = 0 ; pub const PROCESSOR_PERF_MINIMUM_ACTIVITY_WINDOW : u32 = 0 ; pub const PROCESSOR_PERF_MAXIMUM_ACTIVITY_WINDOW : u32 = 1270000000 ; pub const PROCESSOR_DUTY_CYCLING_DISABLED : u32 = 0 ; pub const PROCESSOR_DUTY_CYCLING_ENABLED : u32 = 1 ; pub const CORE_PARKING_POLICY_CHANGE_IDEAL : u32 = 0 ; pub const CORE_PARKING_POLICY_CHANGE_SINGLE : u32 = 1 ; pub const CORE_PARKING_POLICY_CHANGE_ROCKET : u32 = 2 ; pub const CORE_PARKING_POLICY_CHANGE_MULTISTEP : u32 = 3 ; pub const CORE_PARKING_POLICY_CHANGE_MAX : u32 = 3 ; pub const POWER_DEVICE_IDLE_POLICY_PERFORMANCE : u32 = 0 ; pub const POWER_DEVICE_IDLE_POLICY_CONSERVATIVE : u32 = 1 ; pub const POWER_CONNECTIVITY_IN_STANDBY_DISABLED : u32 = 0 ; pub const POWER_CONNECTIVITY_IN_STANDBY_ENABLED : u32 = 1 ; pub const POWER_CONNECTIVITY_IN_STANDBY_SYSTEM_MANAGED : u32 = 2 ; pub const POWER_DISCONNECTED_STANDBY_MODE_NORMAL : u32 = 0 ; pub const POWER_DISCONNECTED_STANDBY_MODE_AGGRESSIVE : u32 = 1 ; pub const POWER_SYSTEM_MAXIMUM : u32 = 7 ; pub const DIAGNOSTIC_REASON_VERSION : u32 = 0 ; pub const DIAGNOSTIC_REASON_SIMPLE_STRING : u32 = 1 ; pub const DIAGNOSTIC_REASON_DETAILED_STRING : u32 = 2 ; pub const DIAGNOSTIC_REASON_NOT_SPECIFIED : u32 = 2147483648 ; pub const DIAGNOSTIC_REASON_INVALID_FLAGS : i64 = -2147483656 ; pub const POWER_REQUEST_CONTEXT_VERSION : u32 = 0 ; pub const POWER_REQUEST_CONTEXT_SIMPLE_STRING : u32 = 1 ; pub const POWER_REQUEST_CONTEXT_DETAILED_STRING : u32 = 2 ; pub const PDCAP_D0_SUPPORTED : u32 = 1 ; pub const PDCAP_D1_SUPPORTED : u32 = 2 ; pub const PDCAP_D2_SUPPORTED : u32 = 4 ; pub const PDCAP_D3_SUPPORTED : u32 = 8 ; pub const PDCAP_WAKE_FROM_D0_SUPPORTED : u32 = 16 ; pub const PDCAP_WAKE_FROM_D1_SUPPORTED : u32 = 32 ; pub const PDCAP_WAKE_FROM_D2_SUPPORTED : u32 = 64 ; pub const PDCAP_WAKE_FROM_D3_SUPPORTED : u32 = 128 ; pub const PDCAP_WARM_EJECT_SUPPORTED : u32 = 256 ; pub const POWER_SETTING_VALUE_VERSION : u32 = 1 ; pub const POWER_PLATFORM_ROLE_V1 : u32 = 1 ; pub const POWER_PLATFORM_ROLE_V2 : u32 = 2 ; pub const POWER_PLATFORM_ROLE_VERSION : u32 = 2 ; pub const REG_NONE : u32 = 0 ; pub const REG_SZ : u32 = 1 ; pub const REG_EXPAND_SZ : u32 = 2 ; pub const REG_BINARY : u32 = 3 ; pub const REG_DWORD : u32 = 4 ; pub const REG_DWORD_LITTLE_ENDIAN : u32 = 4 ; pub const REG_DWORD_BIG_ENDIAN : u32 = 5 ; pub const REG_LINK : u32 = 6 ; pub const REG_MULTI_SZ : u32 = 7 ; pub const REG_RESOURCE_LIST : u32 = 8 ; pub const REG_FULL_RESOURCE_DESCRIPTOR : u32 = 9 ; pub const REG_RESOURCE_REQUIREMENTS_LIST : u32 = 10 ; pub const REG_QWORD : u32 = 11 ; pub const REG_QWORD_LITTLE_ENDIAN : u32 = 11 ; pub const SERVICE_KERNEL_DRIVER : u32 = 1 ; pub const SERVICE_FILE_SYSTEM_DRIVER : u32 = 2 ; pub const SERVICE_ADAPTER : u32 = 4 ; pub const SERVICE_RECOGNIZER_DRIVER : u32 = 8 ; pub const SERVICE_DRIVER : u32 = 11 ; pub const SERVICE_WIN32_OWN_PROCESS : u32 = 16 ; pub const SERVICE_WIN32_SHARE_PROCESS : u32 = 32 ; pub const SERVICE_WIN32 : u32 = 48 ; pub const SERVICE_USER_SERVICE : u32 = 64 ; pub const SERVICE_USERSERVICE_INSTANCE : u32 = 128 ; pub const SERVICE_USER_SHARE_PROCESS : u32 = 96 ; pub const SERVICE_USER_OWN_PROCESS : u32 = 80 ; pub const SERVICE_INTERACTIVE_PROCESS : u32 = 256 ; pub const SERVICE_PKG_SERVICE : u32 = 512 ; pub const SERVICE_TYPE_ALL : u32 = 1023 ; pub const SERVICE_BOOT_START : u32 = 0 ; pub const SERVICE_SYSTEM_START : u32 = 1 ; pub const SERVICE_AUTO_START : u32 = 2 ; pub const SERVICE_DEMAND_START : u32 = 3 ; pub const SERVICE_DISABLED : u32 = 4 ; pub const SERVICE_ERROR_IGNORE : u32 = 0 ; pub const SERVICE_ERROR_NORMAL : u32 = 1 ; pub const SERVICE_ERROR_SEVERE : u32 = 2 ; pub const SERVICE_ERROR_CRITICAL : u32 = 3 ; pub const CM_SERVICE_NETWORK_BOOT_LOAD : u32 = 1 ; pub const CM_SERVICE_VIRTUAL_DISK_BOOT_LOAD : u32 = 2 ; pub const CM_SERVICE_USB_DISK_BOOT_LOAD : u32 = 4 ; pub const CM_SERVICE_SD_DISK_BOOT_LOAD : u32 = 8 ; pub const CM_SERVICE_USB3_DISK_BOOT_LOAD : u32 = 16 ; pub const CM_SERVICE_MEASURED_BOOT_LOAD : u32 = 32 ; pub const CM_SERVICE_VERIFIER_BOOT_LOAD : u32 = 64 ; pub const CM_SERVICE_WINPE_BOOT_LOAD : u32 = 128 ; pub const CM_SERVICE_VALID_PROMOTION_MASK : u32 = 255 ; pub const CmResourceTypeNull : u32 = 0 ; pub const CmResourceTypePort : u32 = 1 ; pub const CmResourceTypeInterrupt : u32 = 2 ; pub const CmResourceTypeMemory : u32 = 3 ; pub const CmResourceTypeDma : u32 = 4 ; pub const CmResourceTypeDeviceSpecific : u32 = 5 ; pub const CmResourceTypeBusNumber : u32 = 6 ; pub const CmResourceTypeMemoryLarge : u32 = 7 ; pub const CmResourceTypeNonArbitrated : u32 = 128 ; pub const CmResourceTypeConfigData : u32 = 128 ; pub const CmResourceTypeDevicePrivate : u32 = 129 ; pub const CmResourceTypePcCardConfig : u32 = 130 ; pub const CmResourceTypeMfCardConfig : u32 = 131 ; pub const CmResourceTypeConnection : u32 = 132 ; pub const CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE : u32 = 0 ; pub const CM_RESOURCE_INTERRUPT_LATCHED : u32 = 1 ; pub const CM_RESOURCE_INTERRUPT_MESSAGE : u32 = 2 ; pub const CM_RESOURCE_INTERRUPT_POLICY_INCLUDED : u32 = 4 ; pub const CM_RESOURCE_INTERRUPT_SECONDARY_INTERRUPT : u32 = 16 ; pub const CM_RESOURCE_INTERRUPT_WAKE_HINT : u32 = 32 ; pub const CM_RESOURCE_INTERRUPT_LEVEL_LATCHED_BITS : u32 = 1 ; pub const CM_RESOURCE_MEMORY_READ_WRITE : u32 = 0 ; pub const CM_RESOURCE_MEMORY_READ_ONLY : u32 = 1 ; pub const CM_RESOURCE_MEMORY_WRITE_ONLY : u32 = 2 ; pub const CM_RESOURCE_MEMORY_WRITEABILITY_MASK : u32 = 3 ; pub const CM_RESOURCE_MEMORY_PREFETCHABLE : u32 = 4 ; pub const CM_RESOURCE_MEMORY_COMBINEDWRITE : u32 = 8 ; pub const CM_RESOURCE_MEMORY_24 : u32 = 16 ; pub const CM_RESOURCE_MEMORY_CACHEABLE : u32 = 32 ; pub const CM_RESOURCE_MEMORY_WINDOW_DECODE : u32 = 64 ; pub const CM_RESOURCE_MEMORY_BAR : u32 = 128 ; pub const CM_RESOURCE_MEMORY_COMPAT_FOR_INACCESSIBLE_RANGE : u32 = 256 ; pub const CM_RESOURCE_MEMORY_LARGE : u32 = 3584 ; pub const CM_RESOURCE_MEMORY_LARGE_40 : u32 = 512 ; pub const CM_RESOURCE_MEMORY_LARGE_48 : u32 = 1024 ; pub const CM_RESOURCE_MEMORY_LARGE_64 : u32 = 2048 ; pub const CM_RESOURCE_MEMORY_LARGE_40_MAXLEN : u64 = 1099511627520 ; pub const CM_RESOURCE_MEMORY_LARGE_48_MAXLEN : u64 = 281474976645120 ; pub const CM_RESOURCE_MEMORY_LARGE_64_MAXLEN : i64 = -4294967296 ; pub const CM_RESOURCE_PORT_MEMORY : u32 = 0 ; pub const CM_RESOURCE_PORT_IO : u32 = 1 ; pub const CM_RESOURCE_PORT_10_BIT_DECODE : u32 = 4 ; pub const CM_RESOURCE_PORT_12_BIT_DECODE : u32 = 8 ; pub const CM_RESOURCE_PORT_16_BIT_DECODE : u32 = 16 ; pub const CM_RESOURCE_PORT_POSITIVE_DECODE : u32 = 32 ; pub const CM_RESOURCE_PORT_PASSIVE_DECODE : u32 = 64 ; pub const CM_RESOURCE_PORT_WINDOW_DECODE : u32 = 128 ; pub const CM_RESOURCE_PORT_BAR : u32 = 256 ; pub const CM_RESOURCE_DMA_8 : u32 = 0 ; pub const CM_RESOURCE_DMA_16 : u32 = 1 ; pub const CM_RESOURCE_DMA_32 : u32 = 2 ; pub const CM_RESOURCE_DMA_8_AND_16 : u32 = 4 ; pub const CM_RESOURCE_DMA_BUS_MASTER : u32 = 8 ; pub const CM_RESOURCE_DMA_TYPE_A : u32 = 16 ; pub const CM_RESOURCE_DMA_TYPE_B : u32 = 32 ; pub const CM_RESOURCE_DMA_TYPE_F : u32 = 64 ; pub const CM_RESOURCE_DMA_V3 : u32 = 128 ; pub const DMAV3_TRANFER_WIDTH_8 : u32 = 0 ; pub const DMAV3_TRANFER_WIDTH_16 : u32 = 1 ; pub const DMAV3_TRANFER_WIDTH_32 : u32 = 2 ; pub const DMAV3_TRANFER_WIDTH_64 : u32 = 3 ; pub const DMAV3_TRANFER_WIDTH_128 : u32 = 4 ; pub const DMAV3_TRANFER_WIDTH_256 : u32 = 5 ; pub const CM_RESOURCE_CONNECTION_CLASS_GPIO : u32 = 1 ; pub const CM_RESOURCE_CONNECTION_CLASS_SERIAL : u32 = 2 ; pub const CM_RESOURCE_CONNECTION_CLASS_FUNCTION_CONFIG : u32 = 3 ; pub const CM_RESOURCE_CONNECTION_TYPE_GPIO_IO : u32 = 2 ; pub const CM_RESOURCE_CONNECTION_TYPE_SERIAL_I2C : u32 = 1 ; pub const CM_RESOURCE_CONNECTION_TYPE_SERIAL_SPI : u32 = 2 ; pub const CM_RESOURCE_CONNECTION_TYPE_SERIAL_UART : u32 = 3 ; pub const CM_RESOURCE_CONNECTION_TYPE_FUNCTION_CONFIG : u32 = 1 ; pub const EISA_FUNCTION_ENABLED : u32 = 128 ; pub const EISA_FREE_FORM_DATA : u32 = 64 ; pub const EISA_HAS_PORT_INIT_ENTRY : u32 = 32 ; pub const EISA_HAS_PORT_RANGE : u32 = 16 ; pub const EISA_HAS_DMA_ENTRY : u32 = 8 ; pub const EISA_HAS_IRQ_ENTRY : u32 = 4 ; pub const EISA_HAS_MEMORY_ENTRY : u32 = 2 ; pub const EISA_HAS_TYPE_ENTRY : u32 = 1 ; pub const EISA_HAS_INFORMATION : u32 = 31 ; pub const EISA_MORE_ENTRIES : u32 = 128 ; pub const EISA_SYSTEM_MEMORY : u32 = 0 ; pub const EISA_MEMORY_TYPE_RAM : u32 = 1 ; pub const EISA_INVALID_SLOT : u32 = 128 ; pub const EISA_INVALID_FUNCTION : u32 = 129 ; pub const EISA_INVALID_CONFIGURATION : u32 = 130 ; pub const EISA_EMPTY_SLOT : u32 = 131 ; pub const EISA_INVALID_BIOS_CALL : u32 = 134 ; pub const IO_RESOURCE_PREFERRED : u32 = 1 ; pub const IO_RESOURCE_DEFAULT : u32 = 2 ; pub const IO_RESOURCE_ALTERNATIVE : u32 = 8 ; pub const FAST_FAIL_LEGACY_GS_VIOLATION : u32 = 0 ; pub const FAST_FAIL_VTGUARD_CHECK_FAILURE : u32 = 1 ; pub const FAST_FAIL_STACK_COOKIE_CHECK_FAILURE : u32 = 2 ; pub const FAST_FAIL_CORRUPT_LIST_ENTRY : u32 = 3 ; pub const FAST_FAIL_INCORRECT_STACK : u32 = 4 ; pub const FAST_FAIL_INVALID_ARG : u32 = 5 ; pub const FAST_FAIL_GS_COOKIE_INIT : u32 = 6 ; pub const FAST_FAIL_FATAL_APP_EXIT : u32 = 7 ; pub const FAST_FAIL_RANGE_CHECK_FAILURE : u32 = 8 ; pub const FAST_FAIL_UNSAFE_REGISTRY_ACCESS : u32 = 9 ; pub const FAST_FAIL_GUARD_ICALL_CHECK_FAILURE : u32 = 10 ; pub const FAST_FAIL_GUARD_WRITE_CHECK_FAILURE : u32 = 11 ; pub const FAST_FAIL_INVALID_FIBER_SWITCH : u32 = 12 ; pub const FAST_FAIL_INVALID_SET_OF_CONTEXT : u32 = 13 ; pub const FAST_FAIL_INVALID_REFERENCE_COUNT : u32 = 14 ; pub const FAST_FAIL_INVALID_JUMP_BUFFER : u32 = 18 ; pub const FAST_FAIL_MRDATA_MODIFIED : u32 = 19 ; pub const FAST_FAIL_CERTIFICATION_FAILURE : u32 = 20 ; pub const FAST_FAIL_INVALID_EXCEPTION_CHAIN : u32 = 21 ; pub const FAST_FAIL_CRYPTO_LIBRARY : u32 = 22 ; pub const FAST_FAIL_INVALID_CALL_IN_DLL_CALLOUT : u32 = 23 ; pub const FAST_FAIL_INVALID_IMAGE_BASE : u32 = 24 ; pub const FAST_FAIL_DLOAD_PROTECTION_FAILURE : u32 = 25 ; pub const FAST_FAIL_UNSAFE_EXTENSION_CALL : u32 = 26 ; pub const FAST_FAIL_DEPRECATED_SERVICE_INVOKED : u32 = 27 ; pub const FAST_FAIL_INVALID_BUFFER_ACCESS : u32 = 28 ; pub const FAST_FAIL_INVALID_BALANCED_TREE : u32 = 29 ; pub const FAST_FAIL_INVALID_NEXT_THREAD : u32 = 30 ; pub const FAST_FAIL_GUARD_ICALL_CHECK_SUPPRESSED : u32 = 31 ; pub const FAST_FAIL_APCS_DISABLED : u32 = 32 ; pub const FAST_FAIL_INVALID_IDLE_STATE : u32 = 33 ; pub const FAST_FAIL_MRDATA_PROTECTION_FAILURE : u32 = 34 ; pub const FAST_FAIL_UNEXPECTED_HEAP_EXCEPTION : u32 = 35 ; pub const FAST_FAIL_INVALID_LOCK_STATE : u32 = 36 ; pub const FAST_FAIL_GUARD_JUMPTABLE : u32 = 37 ; pub const FAST_FAIL_INVALID_LONGJUMP_TARGET : u32 = 38 ; pub const FAST_FAIL_INVALID_DISPATCH_CONTEXT : u32 = 39 ; pub const FAST_FAIL_INVALID_THREAD : u32 = 40 ; pub const FAST_FAIL_INVALID_SYSCALL_NUMBER : u32 = 41 ; pub const FAST_FAIL_INVALID_FILE_OPERATION : u32 = 42 ; pub const FAST_FAIL_LPAC_ACCESS_DENIED : u32 = 43 ; pub const FAST_FAIL_GUARD_SS_FAILURE : u32 = 44 ; pub const FAST_FAIL_LOADER_CONTINUITY_FAILURE : u32 = 45 ; pub const FAST_FAIL_GUARD_EXPORT_SUPPRESSION_FAILURE : u32 = 46 ; pub const FAST_FAIL_INVALID_CONTROL_STACK : u32 = 47 ; pub const FAST_FAIL_SET_CONTEXT_DENIED : u32 = 48 ; pub const FAST_FAIL_INVALID_IAT : u32 = 49 ; pub const FAST_FAIL_HEAP_METADATA_CORRUPTION : u32 = 50 ; pub const FAST_FAIL_PAYLOAD_RESTRICTION_VIOLATION : u32 = 51 ; pub const FAST_FAIL_LOW_LABEL_ACCESS_DENIED : u32 = 52 ; pub const FAST_FAIL_ENCLAVE_CALL_FAILURE : u32 = 53 ; pub const FAST_FAIL_UNHANDLED_LSS_EXCEPTON : u32 = 54 ; pub const FAST_FAIL_INVALID_FAST_FAIL_CODE : u32 = 4294967295 ; pub const RTL_QUERY_REGISTRY_SUBKEY : u32 = 1 ; pub const RTL_QUERY_REGISTRY_TOPKEY : u32 = 2 ; pub const RTL_QUERY_REGISTRY_REQUIRED : u32 = 4 ; pub const RTL_QUERY_REGISTRY_NOVALUE : u32 = 8 ; pub const RTL_QUERY_REGISTRY_NOEXPAND : u32 = 16 ; pub const RTL_QUERY_REGISTRY_DIRECT : u32 = 32 ; pub const RTL_QUERY_REGISTRY_DELETE : u32 = 64 ; pub const RTL_QUERY_REGISTRY_NOSTRING : u32 = 128 ; pub const RTL_QUERY_REGISTRY_TYPECHECK : u32 = 256 ; pub const RTL_QUERY_REGISTRY_TYPECHECK_SHIFT : u32 = 24 ; pub const RTL_QUERY_REGISTRY_TYPECHECK_MASK : u32 = 4278190080 ; pub const RTL_REGISTRY_ABSOLUTE : u32 = 0 ; pub const RTL_REGISTRY_SERVICES : u32 = 1 ; pub const RTL_REGISTRY_CONTROL : u32 = 2 ; pub const RTL_REGISTRY_WINDOWS_NT : u32 = 3 ; pub const RTL_REGISTRY_DEVICEMAP : u32 = 4 ; pub const RTL_REGISTRY_USER : u32 = 5 ; pub const RTL_REGISTRY_MAXIMUM : u32 = 6 ; pub const RTL_REGISTRY_HANDLE : u32 = 1073741824 ; pub const RTL_REGISTRY_OPTIONAL : u32 = 2147483648 ; pub const HASH_STRING_ALGORITHM_DEFAULT : u32 = 0 ; pub const HASH_STRING_ALGORITHM_X65599 : u32 = 1 ; pub const HASH_STRING_ALGORITHM_INVALID : u32 = 4294967295 ; pub const RTL_GUID_STRING_SIZE : u32 = 38 ; pub const DBG_STATUS_CONTROL_C : u32 = 1 ; pub const DBG_STATUS_SYSRQ : u32 = 2 ; pub const DBG_STATUS_BUGCHECK_FIRST : u32 = 3 ; pub const DBG_STATUS_BUGCHECK_SECOND : u32 = 4 ; pub const DBG_STATUS_FATAL : u32 = 5 ; pub const DBG_STATUS_DEBUG_CONTROL : u32 = 6 ; pub const DBG_STATUS_WORKER : u32 = 7 ; pub const LOWBYTE_MASK : u32 = 255 ; pub const SHORT_LEAST_SIGNIFICANT_BIT : u32 = 0 ; pub const SHORT_MOST_SIGNIFICANT_BIT : u32 = 1 ; pub const LONG_LEAST_SIGNIFICANT_BIT : u32 = 0 ; pub const LONG_3RD_MOST_SIGNIFICANT_BIT : u32 = 1 ; pub const LONG_2ND_MOST_SIGNIFICANT_BIT : u32 = 2 ; pub const LONG_MOST_SIGNIFICANT_BIT : u32 = 3 ; pub const SEF_DACL_AUTO_INHERIT : u32 = 1 ; pub const SEF_SACL_AUTO_INHERIT : u32 = 2 ; pub const SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT : u32 = 4 ; pub const SEF_AVOID_PRIVILEGE_CHECK : u32 = 8 ; pub const SEF_AVOID_OWNER_CHECK : u32 = 16 ; pub const SEF_DEFAULT_OWNER_FROM_PARENT : u32 = 32 ; pub const SEF_DEFAULT_GROUP_FROM_PARENT : u32 = 64 ; pub const SEF_MACL_NO_WRITE_UP : u32 = 256 ; pub const SEF_MACL_NO_READ_UP : u32 = 512 ; pub const SEF_MACL_NO_EXECUTE_UP : u32 = 1024 ; pub const SEF_AI_USE_EXTRA_PARAMS : u32 = 2048 ; pub const SEF_AVOID_OWNER_RESTRICTION : u32 = 4096 ; pub const SEF_MACL_VALID_FLAGS : u32 = 1792 ; pub const VER_EQUAL : u32 = 1 ; pub const VER_GREATER : u32 = 2 ; pub const VER_GREATER_EQUAL : u32 = 3 ; pub const VER_LESS : u32 = 4 ; pub const VER_LESS_EQUAL : u32 = 5 ; pub const VER_AND : u32 = 6 ; pub const VER_OR : u32 = 7 ; pub const VER_CONDITION_MASK : u32 = 7 ; pub const VER_NUM_BITS_PER_CONDITION_MASK : u32 = 3 ; pub const VER_MINORVERSION : u32 = 1 ; pub const VER_MAJORVERSION : u32 = 2 ; pub const VER_BUILDNUMBER : u32 = 4 ; pub const VER_PLATFORMID : u32 = 8 ; pub const VER_SERVICEPACKMINOR : u32 = 16 ; pub const VER_SERVICEPACKMAJOR : u32 = 32 ; pub const VER_SUITENAME : u32 = 64 ; pub const VER_PRODUCT_TYPE : u32 = 128 ; pub const VER_NT_WORKSTATION : u32 = 1 ; pub const VER_NT_DOMAIN_CONTROLLER : u32 = 2 ; pub const VER_NT_SERVER : u32 = 3 ; pub const VER_PLATFORM_WIN32s : u32 = 0 ; pub const VER_PLATFORM_WIN32_WINDOWS : u32 = 1 ; pub const VER_PLATFORM_WIN32_NT : u32 = 2 ; pub const DPFLTR_ERROR_LEVEL : u32 = 0 ; pub const DPFLTR_WARNING_LEVEL : u32 = 1 ; pub const DPFLTR_TRACE_LEVEL : u32 = 2 ; pub const DPFLTR_INFO_LEVEL : u32 = 3 ; pub const DPFLTR_MASK : u32 = 2147483648 ; pub const VRL_PREDEFINED_CLASS_BEGIN : u32 = 1 ; pub const VRL_CUSTOM_CLASS_BEGIN : u32 = 256 ; pub const VRL_CLASS_CONSISTENCY : u32 = 1 ; pub const VRL_ENABLE_KERNEL_BREAKS : u32 = 2147483648 ; pub const CTMF_INCLUDE_APPCONTAINER : u32 = 1 ; pub const CTMF_INCLUDE_LPAC : u32 = 2 ; pub const CTMF_VALID_FLAGS : u32 = 3 ; pub const IMAGE_POLICY_METADATA_VERSION : u32 = 1 ; pub const IMAGE_POLICY_SECTION_NAME : & 'static [ u8 ; 9usize ] = b".tPolicy\0" ; pub const TRANSACTION_MANAGER_VOLATILE : u32 = 1 ; pub const TRANSACTION_MANAGER_COMMIT_DEFAULT : u32 = 0 ; pub const TRANSACTION_MANAGER_COMMIT_SYSTEM_VOLUME : u32 = 2 ; pub const TRANSACTION_MANAGER_COMMIT_SYSTEM_HIVES : u32 = 4 ; pub const TRANSACTION_MANAGER_COMMIT_LOWEST : u32 = 8 ; pub const TRANSACTION_MANAGER_CORRUPT_FOR_RECOVERY : u32 = 16 ; pub const TRANSACTION_MANAGER_CORRUPT_FOR_PROGRESS : u32 = 32 ; pub const TRANSACTION_MANAGER_MAXIMUM_OPTION : u32 = 63 ; pub const TRANSACTION_DO_NOT_PROMOTE : u32 = 1 ; pub const TRANSACTION_MAXIMUM_OPTION : u32 = 1 ; pub const RESOURCE_MANAGER_VOLATILE : u32 = 1 ; pub const RESOURCE_MANAGER_COMMUNICATION : u32 = 2 ; pub const RESOURCE_MANAGER_MAXIMUM_OPTION : u32 = 3 ; pub const CRM_PROTOCOL_EXPLICIT_MARSHAL_ONLY : u32 = 1 ; pub const CRM_PROTOCOL_DYNAMIC_MARSHAL_INFO : u32 = 2 ; pub const CRM_PROTOCOL_MAXIMUM_OPTION : u32 = 3 ; pub const ENLISTMENT_SUPERIOR : u32 = 1 ; pub const ENLISTMENT_MAXIMUM_OPTION : u32 = 1 ; pub const TRANSACTION_NOTIFY_MASK : u32 = 1073741823 ; pub const TRANSACTION_NOTIFY_PREPREPARE : u32 = 1 ; pub const TRANSACTION_NOTIFY_PREPARE : u32 = 2 ; pub const TRANSACTION_NOTIFY_COMMIT : u32 = 4 ; pub const TRANSACTION_NOTIFY_ROLLBACK : u32 = 8 ; pub const TRANSACTION_NOTIFY_PREPREPARE_COMPLETE : u32 = 16 ; pub const TRANSACTION_NOTIFY_PREPARE_COMPLETE : u32 = 32 ; pub const TRANSACTION_NOTIFY_COMMIT_COMPLETE : u32 = 64 ; pub const TRANSACTION_NOTIFY_ROLLBACK_COMPLETE : u32 = 128 ; pub const TRANSACTION_NOTIFY_RECOVER : u32 = 256 ; pub const TRANSACTION_NOTIFY_SINGLE_PHASE_COMMIT : u32 = 512 ; pub const TRANSACTION_NOTIFY_DELEGATE_COMMIT : u32 = 1024 ; pub const TRANSACTION_NOTIFY_RECOVER_QUERY : u32 = 2048 ; pub const TRANSACTION_NOTIFY_ENLIST_PREPREPARE : u32 = 4096 ; pub const TRANSACTION_NOTIFY_LAST_RECOVER : u32 = 8192 ; pub const TRANSACTION_NOTIFY_INDOUBT : u32 = 16384 ; pub const TRANSACTION_NOTIFY_PROPAGATE_PULL : u32 = 32768 ; pub const TRANSACTION_NOTIFY_PROPAGATE_PUSH : u32 = 65536 ; pub const TRANSACTION_NOTIFY_MARSHAL : u32 = 131072 ; pub const TRANSACTION_NOTIFY_ENLIST_MASK : u32 = 262144 ; pub const TRANSACTION_NOTIFY_RM_DISCONNECTED : u32 = 16777216 ; pub const TRANSACTION_NOTIFY_TM_ONLINE : u32 = 33554432 ; pub const TRANSACTION_NOTIFY_COMMIT_REQUEST : u32 = 67108864 ; pub const TRANSACTION_NOTIFY_PROMOTE : u32 = 134217728 ; pub const TRANSACTION_NOTIFY_PROMOTE_NEW : u32 = 268435456 ; pub const TRANSACTION_NOTIFY_REQUEST_OUTCOME : u32 = 536870912 ; pub const TRANSACTION_NOTIFY_COMMIT_FINALIZE : u32 = 1073741824 ; pub const TRANSACTIONMANAGER_OBJECT_PATH : & 'static [ u8 ; 22usize ] = b"\\TransactionManager\\\\\0" ; pub const TRANSACTION_OBJECT_PATH : & 'static [ u8 ; 15usize ] = b"\\Transaction\\\\\0" ; pub const ENLISTMENT_OBJECT_PATH : & 'static [ u8 ; 14usize ] = b"\\Enlistment\\\\\0" ; pub const RESOURCE_MANAGER_OBJECT_PATH : & 'static [ u8 ; 19usize ] = b"\\ResourceManager\\\\\0" ; pub const TRANSACTION_NOTIFICATION_TM_ONLINE_FLAG_IS_CLUSTERED : u32 = 1 ; pub const KTM_MARSHAL_BLOB_VERSION_MAJOR : u32 = 1 ; pub const KTM_MARSHAL_BLOB_VERSION_MINOR : u32 = 1 ; pub const MAX_TRANSACTION_DESCRIPTION_LENGTH : u32 = 64 ; pub const MAX_RESOURCEMANAGER_DESCRIPTION_LENGTH : u32 = 64 ; pub const TRANSACTIONMANAGER_QUERY_INFORMATION : u32 = 1 ; pub const TRANSACTIONMANAGER_SET_INFORMATION : u32 = 2 ; pub const TRANSACTIONMANAGER_RECOVER : u32 = 4 ; pub const TRANSACTIONMANAGER_RENAME : u32 = 8 ; pub const TRANSACTIONMANAGER_CREATE_RM : u32 = 16 ; pub const TRANSACTIONMANAGER_BIND_TRANSACTION : u32 = 32 ; pub const TRANSACTIONMANAGER_GENERIC_READ : u32 = 131073 ; pub const TRANSACTIONMANAGER_GENERIC_WRITE : u32 = 131102 ; pub const TRANSACTIONMANAGER_GENERIC_EXECUTE : u32 = 131072 ; pub const TRANSACTIONMANAGER_ALL_ACCESS : u32 = 983103 ; pub const TRANSACTION_QUERY_INFORMATION : u32 = 1 ; pub const TRANSACTION_SET_INFORMATION : u32 = 2 ; pub const TRANSACTION_ENLIST : u32 = 4 ; pub const TRANSACTION_COMMIT : u32 = 8 ; pub const TRANSACTION_ROLLBACK : u32 = 16 ; pub const TRANSACTION_PROPAGATE : u32 = 32 ; pub const TRANSACTION_RIGHT_RESERVED1 : u32 = 64 ; pub const TRANSACTION_GENERIC_READ : u32 = 1179649 ; pub const TRANSACTION_GENERIC_WRITE : u32 = 1179710 ; pub const TRANSACTION_GENERIC_EXECUTE : u32 = 1179672 ; pub const TRANSACTION_ALL_ACCESS : u32 = 2031679 ; pub const TRANSACTION_RESOURCE_MANAGER_RIGHTS : u32 = 1179703 ; pub const RESOURCEMANAGER_QUERY_INFORMATION : u32 = 1 ; pub const RESOURCEMANAGER_SET_INFORMATION : u32 = 2 ; pub const RESOURCEMANAGER_RECOVER : u32 = 4 ; pub const RESOURCEMANAGER_ENLIST : u32 = 8 ; pub const RESOURCEMANAGER_GET_NOTIFICATION : u32 = 16 ; pub const RESOURCEMANAGER_REGISTER_PROTOCOL : u32 = 32 ; pub const RESOURCEMANAGER_COMPLETE_PROPAGATION : u32 = 64 ; pub const RESOURCEMANAGER_GENERIC_READ : u32 = 1179649 ; pub const RESOURCEMANAGER_GENERIC_WRITE : u32 = 1179774 ; pub const RESOURCEMANAGER_GENERIC_EXECUTE : u32 = 1179740 ; pub const RESOURCEMANAGER_ALL_ACCESS : u32 = 2031743 ; pub const ENLISTMENT_QUERY_INFORMATION : u32 = 1 ; pub const ENLISTMENT_SET_INFORMATION : u32 = 2 ; pub const ENLISTMENT_RECOVER : u32 = 4 ; pub const ENLISTMENT_SUBORDINATE_RIGHTS : u32 = 8 ; pub const ENLISTMENT_SUPERIOR_RIGHTS : u32 = 16 ; pub const ENLISTMENT_GENERIC_READ : u32 = 131073 ; pub const ENLISTMENT_GENERIC_WRITE : u32 = 131102 ; pub const ENLISTMENT_GENERIC_EXECUTE : u32 = 131100 ; pub const ENLISTMENT_ALL_ACCESS : u32 = 983071 ; pub const POOL_TAGGING : u32 = 1 ; pub const DPC_NORMAL : u32 = 0 ; pub const DPC_THREADED : u32 = 1 ; pub const PAGE_SIZE : u32 = 4096 ; pub const PAGE_SHIFT : u32 = 12 ; pub const MDL_MAPPED_TO_SYSTEM_VA : u32 = 1 ; pub const MDL_PAGES_LOCKED : u32 = 2 ; pub const MDL_SOURCE_IS_NONPAGED_POOL : u32 = 4 ; pub const MDL_ALLOCATED_FIXED_SIZE : u32 = 8 ; pub const MDL_PARTIAL : u32 = 16 ; pub const MDL_PARTIAL_HAS_BEEN_MAPPED : u32 = 32 ; pub const MDL_IO_PAGE_READ : u32 = 64 ; pub const MDL_WRITE_OPERATION : u32 = 128 ; pub const MDL_LOCKED_PAGE_TABLES : u32 = 256 ; pub const MDL_PARENT_MAPPED_SYSTEM_VA : u32 = 256 ; pub const MDL_FREE_EXTRA_PTES : u32 = 512 ; pub const MDL_DESCRIBES_AWE : u32 = 1024 ; pub const MDL_IO_SPACE : u32 = 2048 ; pub const MDL_NETWORK_HEADER : u32 = 4096 ; pub const MDL_MAPPING_CAN_FAIL : u32 = 8192 ; pub const MDL_PAGE_CONTENTS_INVARIANT : u32 = 16384 ; pub const MDL_ALLOCATED_MUST_SUCCEED : u32 = 16384 ; pub const MDL_INTERNAL : u32 = 32768 ; pub const KENCODED_TIMER_PROCESSOR : u32 = 1 ; pub const TIMER_TOLERABLE_DELAY_BITS : u32 = 6 ; pub const TIMER_EXPIRED_INDEX_BITS : u32 = 6 ; pub const TIMER_PROCESSOR_INDEX_BITS : u32 = 5 ; pub const FLUSH_MULTIPLE_MAXIMUM : u32 = 32 ; pub const ALLOC_PRAGMA : u32 = 1 ; pub const ALLOC_DATA_PRAGMA : u32 = 1 ; pub const EFLAG_SIGN : u32 = 32768 ; pub const EFLAG_ZERO : u32 = 16384 ; pub const EFLAG_SELECT : u32 = 49152 ; pub const RESULT_NEGATIVE : u32 = 32768 ; pub const RESULT_ZERO : u32 = 16384 ; pub const RESULT_POSITIVE : u32 = 0 ; pub const EVENT_QUERY_STATE : u32 = 1 ; pub const EVENT_MODIFY_STATE : u32 = 2 ; pub const EVENT_ALL_ACCESS : u32 = 2031619 ; pub const SEMAPHORE_QUERY_STATE : u32 = 1 ; pub const SEMAPHORE_MODIFY_STATE : u32 = 2 ; pub const SEMAPHORE_ALL_ACCESS : u32 = 2031619 ; pub const LTP_PC_SMT : u32 = 1 ; pub const CACHE_FULLY_ASSOCIATIVE : u32 = 255 ; pub const SYSTEM_CPU_SET_INFORMATION_PARKED : u32 = 1 ; pub const SYSTEM_CPU_SET_INFORMATION_ALLOCATED : u32 = 2 ; pub const SYSTEM_CPU_SET_INFORMATION_ALLOCATED_TO_TARGET_PROCESS : u32 = 4 ; pub const SYSTEM_CPU_SET_INFORMATION_REALTIME : u32 = 8 ; pub const PF_FLOATING_POINT_PRECISION_ERRATA : u32 = 0 ; pub const PF_FLOATING_POINT_EMULATED : u32 = 1 ; pub const PF_COMPARE_EXCHANGE_DOUBLE : u32 = 2 ; pub const PF_MMX_INSTRUCTIONS_AVAILABLE : u32 = 3 ; pub const PF_PPC_MOVEMEM_64BIT_OK : u32 = 4 ; pub const PF_ALPHA_BYTE_INSTRUCTIONS : u32 = 5 ; pub const PF_XMMI_INSTRUCTIONS_AVAILABLE : u32 = 6 ; pub const PF_3DNOW_INSTRUCTIONS_AVAILABLE : u32 = 7 ; pub const PF_RDTSC_INSTRUCTION_AVAILABLE : u32 = 8 ; pub const PF_PAE_ENABLED : u32 = 9 ; pub const PF_XMMI64_INSTRUCTIONS_AVAILABLE : u32 = 10 ; pub const PF_SSE_DAZ_MODE_AVAILABLE : u32 = 11 ; pub const PF_NX_ENABLED : u32 = 12 ; pub const PF_SSE3_INSTRUCTIONS_AVAILABLE : u32 = 13 ; pub const PF_COMPARE_EXCHANGE128 : u32 = 14 ; pub const PF_COMPARE64_EXCHANGE128 : u32 = 15 ; pub const PF_CHANNELS_ENABLED : u32 = 16 ; pub const PF_XSAVE_ENABLED : u32 = 17 ; pub const PF_ARM_VFP_32_REGISTERS_AVAILABLE : u32 = 18 ; pub const PF_ARM_NEON_INSTRUCTIONS_AVAILABLE : u32 = 19 ; pub const PF_SECOND_LEVEL_ADDRESS_TRANSLATION : u32 = 20 ; pub const PF_VIRT_FIRMWARE_ENABLED : u32 = 21 ; pub const PF_RDWRFSGSBASE_AVAILABLE : u32 = 22 ; pub const PF_FASTFAIL_AVAILABLE : u32 = 23 ; pub const PF_ARM_DIVIDE_INSTRUCTION_AVAILABLE : u32 = 24 ; pub const PF_ARM_64BIT_LOADSTORE_ATOMIC : u32 = 25 ; pub const PF_ARM_EXTERNAL_CACHE_AVAILABLE : u32 = 26 ; pub const PF_ARM_FMAC_INSTRUCTIONS_AVAILABLE : u32 = 27 ; pub const PF_RDRAND_INSTRUCTION_AVAILABLE : u32 = 28 ; pub const PF_ARM_V8_INSTRUCTIONS_AVAILABLE : u32 = 29 ; pub const PF_ARM_V8_CRYPTO_INSTRUCTIONS_AVAILABLE : u32 = 30 ; pub const PF_ARM_V8_CRC32_INSTRUCTIONS_AVAILABLE : u32 = 31 ; pub const PF_RDTSCP_INSTRUCTION_AVAILABLE : u32 = 32 ; pub const PROCESSOR_FEATURE_MAX : u32 = 64 ; pub const EXCEPTION_NONCONTINUABLE : u32 = 1 ; pub const EXCEPTION_UNWINDING : u32 = 2 ; pub const EXCEPTION_EXIT_UNWIND : u32 = 4 ; pub const EXCEPTION_STACK_INVALID : u32 = 8 ; pub const EXCEPTION_NESTED_CALL : u32 = 16 ; pub const EXCEPTION_TARGET_UNWIND : u32 = 32 ; pub const EXCEPTION_COLLIDED_UNWIND : u32 = 64 ; pub const EXCEPTION_UNWIND : u32 = 102 ; pub const EXCEPTION_MAXIMUM_PARAMETERS : u32 = 15 ; pub const THREAD_WAIT_OBJECTS : u32 = 3 ; pub const SINGLE_GROUP_LEGACY_API : u32 = 1 ; pub const KB_SECONDARY_DATA_FLAG_ADDITIONAL_DATA : u32 = 1 ; pub const KB_SECONDARY_DATA_FLAG_NO_DEVICE_ACCESS : u32 = 2 ; pub const KB_ADD_PAGES_FLAG_VIRTUAL_ADDRESS : u32 = 1 ; pub const KB_ADD_PAGES_FLAG_PHYSICAL_ADDRESS : u32 = 2 ; pub const KB_ADD_PAGES_FLAG_ADDITIONAL_RANGES_EXIST : u32 = 2147483648 ; pub const KB_REMOVE_PAGES_FLAG_VIRTUAL_ADDRESS : u32 = 1 ; pub const KB_REMOVE_PAGES_FLAG_PHYSICAL_ADDRESS : u32 = 2 ; pub const KB_REMOVE_PAGES_FLAG_ADDITIONAL_RANGES_EXIST : u32 = 2147483648 ; pub const EXCEPTION_DIVIDED_BY_ZERO : u32 = 0 ; pub const EXCEPTION_DEBUG : u32 = 1 ; pub const EXCEPTION_NMI : u32 = 2 ; pub const EXCEPTION_INT3 : u32 = 3 ; pub const EXCEPTION_BOUND_CHECK : u32 = 5 ; pub const EXCEPTION_INVALID_OPCODE : u32 = 6 ; pub const EXCEPTION_NPX_NOT_AVAILABLE : u32 = 7 ; pub const EXCEPTION_DOUBLE_FAULT : u32 = 8 ; pub const EXCEPTION_NPX_OVERRUN : u32 = 9 ; pub const EXCEPTION_INVALID_TSS : u32 = 10 ; pub const EXCEPTION_SEGMENT_NOT_PRESENT : u32 = 11 ; pub const EXCEPTION_STACK_FAULT : u32 = 12 ; pub const EXCEPTION_GP_FAULT : u32 = 13 ; pub const EXCEPTION_RESERVED_TRAP : u32 = 15 ; pub const EXCEPTION_NPX_ERROR : u32 = 16 ; pub const EXCEPTION_ALIGNMENT_CHECK : u32 = 17 ; pub const EXCEPTION_VIRTUALIZATION_FAULT : u32 = 32 ; pub const KE_PROCESSOR_CHANGE_ADD_EXISTING : u32 = 1 ; pub const INVALID_PROCESSOR_INDEX : u32 = 4294967295 ; pub const POOL_COLD_ALLOCATION : u32 = 256 ; pub const POOL_NX_ALLOCATION : u32 = 512 ; pub const POOL_QUOTA_FAIL_INSTEAD_OF_RAISE : u32 = 8 ; pub const POOL_RAISE_IF_ALLOCATION_FAILURE : u32 = 16 ; pub const FM_LOCK_BIT : u32 = 1 ; pub const FM_LOCK_BIT_V : u32 = 0 ; pub const EX_LOOKASIDE_LIST_EX_FLAGS_RAISE_ON_FAIL : u32 = 1 ; pub const EX_LOOKASIDE_LIST_EX_FLAGS_FAIL_NO_RAISE : u32 = 2 ; pub const EX_MAXIMUM_LOOKASIDE_DEPTH_BASE : u32 = 256 ; pub const EX_MAXIMUM_LOOKASIDE_DEPTH_LIMIT : u32 = 1024 ; pub const ResourceNeverExclusive : u32 = 16 ; pub const ResourceReleaseByOtherThread : u32 = 32 ; pub const ResourceOwnedExclusive : u32 = 128 ; pub const RESOURCE_HASH_TABLE_SIZE : u32 = 64 ; pub const FLAG_OWNER_POINTER_IS_THREAD : u32 = 1 ; pub const EX_RUNDOWN_ACTIVE : u32 = 1 ; pub const EX_RUNDOWN_COUNT_SHIFT : u32 = 1 ; pub const EX_RUNDOWN_COUNT_INC : u32 = 2 ; pub const EX_TIMER_HIGH_RESOLUTION : u32 = 4 ; pub const EX_TIMER_NO_WAKE : u32 = 8 ; pub const EX_TIMER_NOTIFICATION : u32 = 2147483648 ; pub const EX_CARR_ALLOCATE_PAGED_POOL : u32 = 0 ; pub const EX_CARR_ALLOCATE_NONPAGED_POOL : u32 = 1 ; pub const EX_CARR_DISABLE_EXPANSION : u32 = 2 ; pub const EX_CARR_VALID_FLAGS : u32 = 3 ; pub const EVENT_INCREMENT : u32 = 1 ; pub const IO_NO_INCREMENT : u32 = 0 ; pub const IO_CD_ROM_INCREMENT : u32 = 1 ; pub const IO_DISK_INCREMENT : u32 = 1 ; pub const IO_KEYBOARD_INCREMENT : u32 = 6 ; pub const IO_MAILSLOT_INCREMENT : u32 = 2 ; pub const IO_MOUSE_INCREMENT : u32 = 6 ; pub const IO_NAMED_PIPE_INCREMENT : u32 = 2 ; pub const IO_NETWORK_INCREMENT : u32 = 2 ; pub const IO_PARALLEL_INCREMENT : u32 = 1 ; pub const IO_SERIAL_INCREMENT : u32 = 2 ; pub const IO_SOUND_INCREMENT : u32 = 8 ; pub const IO_VIDEO_INCREMENT : u32 = 1 ; pub const SEMAPHORE_INCREMENT : u32 = 1 ; pub const MM_MAXIMUM_DISK_IO_SIZE : u32 = 65536 ; pub const MM_PERMANENT_ADDRESS_IS_IO_SPACE : u32 = 1 ; pub const MdlMappingNoWrite : u32 = 2147483648 ; pub const MdlMappingNoExecute : u32 = 1073741824 ; pub const MM_DONT_ZERO_ALLOCATION : u32 = 1 ; pub const MM_ALLOCATE_FROM_LOCAL_NODE_ONLY : u32 = 2 ; pub const MM_ALLOCATE_FULLY_REQUIRED : u32 = 4 ; pub const MM_ALLOCATE_NO_WAIT : u32 = 8 ; pub const MM_ALLOCATE_PREFER_CONTIGUOUS : u32 = 16 ; pub const MM_ALLOCATE_REQUIRE_CONTIGUOUS_CHUNKS : u32 = 32 ; pub const MM_ALLOCATE_FAST_LARGE_PAGES : u32 = 64 ; pub const MM_ALLOCATE_TRIM_IF_NECESSARY : u32 = 128 ; pub const MM_ALLOCATE_AND_HOT_REMOVE : u32 = 256 ; pub const MM_FREE_MDL_PAGES_ZERO : u32 = 1 ; pub const MM_ANY_NODE_OK : u32 = 2147483648 ; pub const INITIAL_PRIVILEGE_COUNT : u32 = 3 ; pub const IO_TYPE_ADAPTER : u32 = 1 ; pub const IO_TYPE_CONTROLLER : u32 = 2 ; pub const IO_TYPE_DEVICE : u32 = 3 ; pub const IO_TYPE_DRIVER : u32 = 4 ; pub const IO_TYPE_FILE : u32 = 5 ; pub const IO_TYPE_IRP : u32 = 6 ; pub const IO_TYPE_MASTER_ADAPTER : u32 = 7 ; pub const IO_TYPE_OPEN_PACKET : u32 = 8 ; pub const IO_TYPE_TIMER : u32 = 9 ; pub const IO_TYPE_VPB : u32 = 10 ; pub const IO_TYPE_ERROR_LOG : u32 = 11 ; pub const IO_TYPE_ERROR_MESSAGE : u32 = 12 ; pub const IO_TYPE_DEVICE_OBJECT_EXTENSION : u32 = 13 ; pub const IRP_MJ_CREATE : u32 = 0 ; pub const IRP_MJ_CREATE_NAMED_PIPE : u32 = 1 ; pub const IRP_MJ_CLOSE : u32 = 2 ; pub const IRP_MJ_READ : u32 = 3 ; pub const IRP_MJ_WRITE : u32 = 4 ; pub const IRP_MJ_QUERY_INFORMATION : u32 = 5 ; pub const IRP_MJ_SET_INFORMATION : u32 = 6 ; pub const IRP_MJ_QUERY_EA : u32 = 7 ; pub const IRP_MJ_SET_EA : u32 = 8 ; pub const IRP_MJ_FLUSH_BUFFERS : u32 = 9 ; pub const IRP_MJ_QUERY_VOLUME_INFORMATION : u32 = 10 ; pub const IRP_MJ_SET_VOLUME_INFORMATION : u32 = 11 ; pub const IRP_MJ_DIRECTORY_CONTROL : u32 = 12 ; pub const IRP_MJ_FILE_SYSTEM_CONTROL : u32 = 13 ; pub const IRP_MJ_DEVICE_CONTROL : u32 = 14 ; pub const IRP_MJ_INTERNAL_DEVICE_CONTROL : u32 = 15 ; pub const IRP_MJ_SHUTDOWN : u32 = 16 ; pub const IRP_MJ_LOCK_CONTROL : u32 = 17 ; pub const IRP_MJ_CLEANUP : u32 = 18 ; pub const IRP_MJ_CREATE_MAILSLOT : u32 = 19 ; pub const IRP_MJ_QUERY_SECURITY : u32 = 20 ; pub const IRP_MJ_SET_SECURITY : u32 = 21 ; pub const IRP_MJ_POWER : u32 = 22 ; pub const IRP_MJ_SYSTEM_CONTROL : u32 = 23 ; pub const IRP_MJ_DEVICE_CHANGE : u32 = 24 ; pub const IRP_MJ_QUERY_QUOTA : u32 = 25 ; pub const IRP_MJ_SET_QUOTA : u32 = 26 ; pub const IRP_MJ_PNP : u32 = 27 ; pub const IRP_MJ_PNP_POWER : u32 = 27 ; pub const IRP_MJ_MAXIMUM_FUNCTION : u32 = 27 ; pub const IRP_MJ_SCSI : u32 = 15 ; pub const IRP_MN_SCSI_CLASS : u32 = 1 ; pub const IRP_MN_START_DEVICE : u32 = 0 ; pub const IRP_MN_QUERY_REMOVE_DEVICE : u32 = 1 ; pub const IRP_MN_REMOVE_DEVICE : u32 = 2 ; pub const IRP_MN_CANCEL_REMOVE_DEVICE : u32 = 3 ; pub const IRP_MN_STOP_DEVICE : u32 = 4 ; pub const IRP_MN_QUERY_STOP_DEVICE : u32 = 5 ; pub const IRP_MN_CANCEL_STOP_DEVICE : u32 = 6 ; pub const IRP_MN_QUERY_DEVICE_RELATIONS : u32 = 7 ; pub const IRP_MN_QUERY_INTERFACE : u32 = 8 ; pub const IRP_MN_QUERY_CAPABILITIES : u32 = 9 ; pub const IRP_MN_QUERY_RESOURCES : u32 = 10 ; pub const IRP_MN_QUERY_RESOURCE_REQUIREMENTS : u32 = 11 ; pub const IRP_MN_QUERY_DEVICE_TEXT : u32 = 12 ; pub const IRP_MN_FILTER_RESOURCE_REQUIREMENTS : u32 = 13 ; pub const IRP_MN_READ_CONFIG : u32 = 15 ; pub const IRP_MN_WRITE_CONFIG : u32 = 16 ; pub const IRP_MN_EJECT : u32 = 17 ; pub const IRP_MN_SET_LOCK : u32 = 18 ; pub const IRP_MN_QUERY_ID : u32 = 19 ; pub const IRP_MN_QUERY_PNP_DEVICE_STATE : u32 = 20 ; pub const IRP_MN_QUERY_BUS_INFORMATION : u32 = 21 ; pub const IRP_MN_DEVICE_USAGE_NOTIFICATION : u32 = 22 ; pub const IRP_MN_SURPRISE_REMOVAL : u32 = 23 ; pub const IRP_MN_DEVICE_ENUMERATED : u32 = 25 ; pub const IRP_MN_WAIT_WAKE : u32 = 0 ; pub const IRP_MN_POWER_SEQUENCE : u32 = 1 ; pub const IRP_MN_SET_POWER : u32 = 2 ; pub const IRP_MN_QUERY_POWER : u32 = 3 ; pub const IRP_MN_QUERY_ALL_DATA : u32 = 0 ; pub const IRP_MN_QUERY_SINGLE_INSTANCE : u32 = 1 ; pub const IRP_MN_CHANGE_SINGLE_INSTANCE : u32 = 2 ; pub const IRP_MN_CHANGE_SINGLE_ITEM : u32 = 3 ; pub const IRP_MN_ENABLE_EVENTS : u32 = 4 ; pub const IRP_MN_DISABLE_EVENTS : u32 = 5 ; pub const IRP_MN_ENABLE_COLLECTION : u32 = 6 ; pub const IRP_MN_DISABLE_COLLECTION : u32 = 7 ; pub const IRP_MN_REGINFO : u32 = 8 ; pub const IRP_MN_EXECUTE_METHOD : u32 = 9 ; pub const IRP_MN_REGINFO_EX : u32 = 11 ; pub const IO_FORCE_ACCESS_CHECK : u32 = 1 ; pub const IO_NO_PARAMETER_CHECKING : u32 = 256 ; pub const IO_REPARSE : u32 = 0 ; pub const IO_REMOUNT : u32 = 1 ; pub const IO_REPARSE_GLOBAL : u32 = 2 ; pub const VPB_MOUNTED : u32 = 1 ; pub const VPB_LOCKED : u32 = 2 ; pub const VPB_PERSISTENT : u32 = 4 ; pub const VPB_REMOVE_PENDING : u32 = 8 ; pub const VPB_RAW_MOUNT : u32 = 16 ; pub const VPB_DIRECT_WRITES_ALLOWED : u32 = 32 ; pub const DO_VERIFY_VOLUME : u32 = 2 ; pub const DO_BUFFERED_IO : u32 = 4 ; pub const DO_EXCLUSIVE : u32 = 8 ; pub const DO_DIRECT_IO : u32 = 16 ; pub const DO_MAP_IO_BUFFER : u32 = 32 ; pub const DO_DEVICE_INITIALIZING : u32 = 128 ; pub const DO_SHUTDOWN_REGISTERED : u32 = 2048 ; pub const DO_BUS_ENUMERATED_DEVICE : u32 = 4096 ; pub const DO_POWER_PAGABLE : u32 = 8192 ; pub const DO_POWER_INRUSH : u32 = 16384 ; pub const DO_DEVICE_TO_BE_RESET : u32 = 67108864 ; pub const DO_DAX_VOLUME : u32 = 268435456 ; pub const DRVO_UNLOAD_INVOKED : u32 = 1 ; pub const DRVO_LEGACY_DRIVER : u32 = 2 ; pub const DRVO_BUILTIN_DRIVER : u32 = 4 ; pub const FO_FILE_OPEN : u32 = 1 ; pub const FO_SYNCHRONOUS_IO : u32 = 2 ; pub const FO_ALERTABLE_IO : u32 = 4 ; pub const FO_NO_INTERMEDIATE_BUFFERING : u32 = 8 ; pub const FO_WRITE_THROUGH : u32 = 16 ; pub const FO_SEQUENTIAL_ONLY : u32 = 32 ; pub const FO_CACHE_SUPPORTED : u32 = 64 ; pub const FO_NAMED_PIPE : u32 = 128 ; pub const FO_STREAM_FILE : u32 = 256 ; pub const FO_MAILSLOT : u32 = 512 ; pub const FO_GENERATE_AUDIT_ON_CLOSE : u32 = 1024 ; pub const FO_QUEUE_IRP_TO_THREAD : u32 = 1024 ; pub const FO_DIRECT_DEVICE_OPEN : u32 = 2048 ; pub const FO_FILE_MODIFIED : u32 = 4096 ; pub const FO_FILE_SIZE_CHANGED : u32 = 8192 ; pub const FO_CLEANUP_COMPLETE : u32 = 16384 ; pub const FO_TEMPORARY_FILE : u32 = 32768 ; pub const FO_DELETE_ON_CLOSE : u32 = 65536 ; pub const FO_OPENED_CASE_SENSITIVE : u32 = 131072 ; pub const FO_HANDLE_CREATED : u32 = 262144 ; pub const FO_FILE_FAST_IO_READ : u32 = 524288 ; pub const FO_RANDOM_ACCESS : u32 = 1048576 ; pub const FO_FILE_OPEN_CANCELLED : u32 = 2097152 ; pub const FO_VOLUME_OPEN : u32 = 4194304 ; pub const FO_REMOTE_ORIGIN : u32 = 16777216 ; pub const FO_DISALLOW_EXCLUSIVE : u32 = 33554432 ; pub const FO_SKIP_COMPLETION_PORT : u32 = 33554432 ; pub const FO_SKIP_SET_EVENT : u32 = 67108864 ; pub const FO_SKIP_SET_FAST_IO : u32 = 134217728 ; pub const FO_INDIRECT_WAIT_OBJECT : u32 = 268435456 ; pub const FO_SECTION_MINSTORE_TREATMENT : u32 = 536870912 ; pub const FO_FLAGS_VALID_ONLY_DURING_CREATE : u32 = 33554432 ; pub const IRP_NOCACHE : u32 = 1 ; pub const IRP_PAGING_IO : u32 = 2 ; pub const IRP_MOUNT_COMPLETION : u32 = 2 ; pub const IRP_SYNCHRONOUS_API : u32 = 4 ; pub const IRP_ASSOCIATED_IRP : u32 = 8 ; pub const IRP_BUFFERED_IO : u32 = 16 ; pub const IRP_DEALLOCATE_BUFFER : u32 = 32 ; pub const IRP_INPUT_OPERATION : u32 = 64 ; pub const IRP_SYNCHRONOUS_PAGING_IO : u32 = 64 ; pub const IRP_CREATE_OPERATION : u32 = 128 ; pub const IRP_READ_OPERATION : u32 = 256 ; pub const IRP_WRITE_OPERATION : u32 = 512 ; pub const IRP_CLOSE_OPERATION : u32 = 1024 ; pub const IRP_DEFER_IO_COMPLETION : u32 = 2048 ; pub const IRP_OB_QUERY_NAME : u32 = 4096 ; pub const IRP_HOLD_DEVICE_QUEUE : u32 = 8192 ; pub const IRP_UM_DRIVER_INITIATED_IO : u32 = 4194304 ; pub const IRP_QUOTA_CHARGED : u32 = 1 ; pub const IRP_ALLOCATED_MUST_SUCCEED : u32 = 2 ; pub const IRP_ALLOCATED_FIXED_SIZE : u32 = 4 ; pub const IRP_LOOKASIDE_ALLOCATION : u32 = 8 ; pub const SL_PENDING_RETURNED : u32 = 1 ; pub const SL_ERROR_RETURNED : u32 = 2 ; pub const SL_INVOKE_ON_CANCEL : u32 = 32 ; pub const SL_INVOKE_ON_SUCCESS : u32 = 64 ; pub const SL_INVOKE_ON_ERROR : u32 = 128 ; pub const SL_FORCE_ACCESS_CHECK : u32 = 1 ; pub const SL_OPEN_PAGING_FILE : u32 = 2 ; pub const SL_OPEN_TARGET_DIRECTORY : u32 = 4 ; pub const SL_STOP_ON_SYMLINK : u32 = 8 ; pub const SL_IGNORE_READONLY_ATTRIBUTE : u32 = 64 ; pub const SL_CASE_SENSITIVE : u32 = 128 ; pub const SL_KEY_SPECIFIED : u32 = 1 ; pub const SL_OVERRIDE_VERIFY_VOLUME : u32 = 2 ; pub const SL_WRITE_THROUGH : u32 = 4 ; pub const SL_FT_SEQUENTIAL_WRITE : u32 = 8 ; pub const SL_FORCE_DIRECT_WRITE : u32 = 16 ; pub const SL_REALTIME_STREAM : u32 = 32 ; pub const SL_PERSISTENT_MEMORY_FIXED_MAPPING : u32 = 32 ; pub const SL_FORCE_ASYNCHRONOUS : u32 = 1 ; pub const SL_READ_ACCESS_GRANTED : u32 = 1 ; pub const SL_WRITE_ACCESS_GRANTED : u32 = 4 ; pub const SL_FAIL_IMMEDIATELY : u32 = 1 ; pub const SL_EXCLUSIVE_LOCK : u32 = 2 ; pub const SL_RESTART_SCAN : u32 = 1 ; pub const SL_RETURN_SINGLE_ENTRY : u32 = 2 ; pub const SL_INDEX_SPECIFIED : u32 = 4 ; pub const SL_RETURN_ON_DISK_ENTRIES_ONLY : u32 = 8 ; pub const SL_QUERY_DIRECTORY_MASK : u32 = 11 ; pub const SL_WATCH_TREE : u32 = 1 ; pub const SL_ALLOW_RAW_MOUNT : u32 = 1 ; pub const SL_BYPASS_ACCESS_CHECK : u32 = 1 ; pub const PNP_DEVICE_DISABLED : u32 = 1 ; pub const PNP_DEVICE_DONT_DISPLAY_IN_UI : u32 = 2 ; pub const PNP_DEVICE_FAILED : u32 = 4 ; pub const PNP_DEVICE_REMOVED : u32 = 8 ; pub const PNP_DEVICE_RESOURCE_REQUIREMENTS_CHANGED : u32 = 16 ; pub const PNP_DEVICE_NOT_DISABLEABLE : u32 = 32 ; pub const PNP_DEVICE_DISCONNECTED : u32 = 64 ; pub const IO_SHARE_ACCESS_NO_WRITE_PERMISSION : u32 = 2147483648 ; pub const IO_CHECK_SHARE_ACCESS_UPDATE_SHARE_ACCESS : u32 = 1 ; pub const CONNECT_FULLY_SPECIFIED : u32 = 1 ; pub const CONNECT_LINE_BASED : u32 = 2 ; pub const CONNECT_MESSAGE_BASED : u32 = 3 ; pub const CONNECT_FULLY_SPECIFIED_GROUP : u32 = 4 ; pub const CONNECT_MESSAGE_BASED_PASSIVE : u32 = 5 ; pub const CONNECT_CURRENT_VERSION : u32 = 5 ; pub const WDM_MAJORVERSION : u32 = 6 ; pub const WDM_MINORVERSION : u32 = 0 ; pub const WMIREG_ACTION_REGISTER : u32 = 1 ; pub const WMIREG_ACTION_DEREGISTER : u32 = 2 ; pub const WMIREG_ACTION_REREGISTER : u32 = 3 ; pub const WMIREG_ACTION_UPDATE_GUIDS : u32 = 4 ; pub const WMIREG_ACTION_BLOCK_IRPS : u32 = 5 ; pub const WMIREGISTER : u32 = 0 ; pub const WMIUPDATE : u32 = 1 ; pub const IO_TYPE_CSQ_IRP_CONTEXT : u32 = 1 ; pub const IO_TYPE_CSQ : u32 = 2 ; pub const IO_TYPE_CSQ_EX : u32 = 3 ; pub const IO_ATTRIBUTION_INFO_V1 : u32 = 1 ; pub const IO_SET_IRP_IO_ATTRIBUTION_FROM_THREAD : u32 = 1 ; pub const IO_SET_IRP_IO_ATTRIBUTION_FROM_PROCESS : u32 = 2 ; pub const IO_SET_IRP_IO_ATTRIBUTION_FLAGS_MASK : u32 = 3 ; pub const EVENT_MIN_LEVEL : u32 = 0 ; pub const EVENT_MAX_LEVEL : u32 = 255 ; pub const EVENT_ACTIVITY_CTRL_GET_ID : u32 = 1 ; pub const EVENT_ACTIVITY_CTRL_SET_ID : u32 = 2 ; pub const EVENT_ACTIVITY_CTRL_CREATE_ID : u32 = 3 ; pub const EVENT_ACTIVITY_CTRL_GET_SET_ID : u32 = 4 ; pub const EVENT_ACTIVITY_CTRL_CREATE_SET_ID : u32 = 5 ; pub const MAX_EVENT_DATA_DESCRIPTORS : u32 = 128 ; pub const MAX_EVENT_FILTER_DATA_SIZE : u32 = 1024 ; pub const MAX_EVENT_FILTER_PAYLOAD_SIZE : u32 = 4096 ; pub const MAX_EVENT_FILTER_EVENT_NAME_SIZE : u32 = 4096 ; pub const MAX_EVENT_FILTERS_COUNT : u32 = 13 ; pub const MAX_EVENT_FILTER_PID_COUNT : u32 = 8 ; pub const MAX_EVENT_FILTER_EVENT_ID_COUNT : u32 = 64 ; pub const EVENT_FILTER_TYPE_NONE : u32 = 0 ; pub const EVENT_FILTER_TYPE_SCHEMATIZED : u32 = 2147483648 ; pub const EVENT_FILTER_TYPE_SYSTEM_FLAGS : u32 = 2147483649 ; pub const EVENT_FILTER_TYPE_TRACEHANDLE : u32 = 2147483650 ; pub const EVENT_FILTER_TYPE_PID : u32 = 2147483652 ; pub const EVENT_FILTER_TYPE_EXECUTABLE_NAME : u32 = 2147483656 ; pub const EVENT_FILTER_TYPE_PACKAGE_ID : u32 = 2147483664 ; pub const EVENT_FILTER_TYPE_PACKAGE_APP_ID : u32 = 2147483680 ; pub const EVENT_FILTER_TYPE_PAYLOAD : u32 = 2147483904 ; pub const EVENT_FILTER_TYPE_EVENT_ID : u32 = 2147484160 ; pub const EVENT_FILTER_TYPE_EVENT_NAME : u32 = 2147484672 ; pub const EVENT_FILTER_TYPE_STACKWALK : u32 = 2147487744 ; pub const EVENT_FILTER_TYPE_STACKWALK_NAME : u32 = 2147491840 ; pub const EVENT_FILTER_TYPE_STACKWALK_LEVEL_KW : u32 = 2147500032 ; pub const EVENT_DATA_DESCRIPTOR_TYPE_NONE : u32 = 0 ; pub const EVENT_DATA_DESCRIPTOR_TYPE_EVENT_METADATA : u32 = 1 ; pub const EVENT_DATA_DESCRIPTOR_TYPE_PROVIDER_METADATA : u32 = 2 ; pub const EVENT_DATA_DESCRIPTOR_TYPE_TIMESTAMP_OVERRIDE : u32 = 3 ; pub const EVENT_WRITE_FLAG_NO_FAULTING : u32 = 1 ; pub const EVENT_WRITE_FLAG_INPRIVATE : u32 = 2 ; pub const __string_type : u32 = 0 ; pub const __guid_type : u32 = 0 ; pub const __multiString_type : u32 = 0 ; pub const PCI_SECURITY_INTERFACE_VERSION : u32 = 1 ; pub const PNP_EXTENDED_ADDRESS_INTERFACE_VERSION : u32 = 1 ; pub const D3COLD_SUPPORT_INTERFACE_VERSION : u32 = 1 ; pub const PLUGPLAY_REGKEY_DEVICE : u32 = 1 ; pub const PLUGPLAY_REGKEY_DRIVER : u32 = 2 ; pub const PLUGPLAY_REGKEY_CURRENT_HWPROFILE : u32 = 4 ; pub const DEVICE_INTERFACE_INCLUDE_NONACTIVE : u32 = 1 ; pub const PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES : u32 = 1 ; pub const DEVPROP_TYPEMOD_ARRAY : u32 = 4096 ; pub const DEVPROP_TYPEMOD_LIST : u32 = 8192 ; pub const DEVPROP_TYPE_EMPTY : u32 = 0 ; pub const DEVPROP_TYPE_NULL : u32 = 1 ; pub const DEVPROP_TYPE_SBYTE : u32 = 2 ; pub const DEVPROP_TYPE_BYTE : u32 = 3 ; pub const DEVPROP_TYPE_INT16 : u32 = 4 ; pub const DEVPROP_TYPE_UINT16 : u32 = 5 ; pub const DEVPROP_TYPE_INT32 : u32 = 6 ; pub const DEVPROP_TYPE_UINT32 : u32 = 7 ; pub const DEVPROP_TYPE_INT64 : u32 = 8 ; pub const DEVPROP_TYPE_UINT64 : u32 = 9 ; pub const DEVPROP_TYPE_FLOAT : u32 = 10 ; pub const DEVPROP_TYPE_DOUBLE : u32 = 11 ; pub const DEVPROP_TYPE_DECIMAL : u32 = 12 ; pub const DEVPROP_TYPE_GUID : u32 = 13 ; pub const DEVPROP_TYPE_CURRENCY : u32 = 14 ; pub const DEVPROP_TYPE_DATE : u32 = 15 ; pub const DEVPROP_TYPE_FILETIME : u32 = 16 ; pub const DEVPROP_TYPE_BOOLEAN : u32 = 17 ; pub const DEVPROP_TYPE_STRING : u32 = 18 ; pub const DEVPROP_TYPE_STRING_LIST : u32 = 8210 ; pub const DEVPROP_TYPE_SECURITY_DESCRIPTOR : u32 = 19 ; pub const DEVPROP_TYPE_SECURITY_DESCRIPTOR_STRING : u32 = 20 ; pub const DEVPROP_TYPE_DEVPROPKEY : u32 = 21 ; pub const DEVPROP_TYPE_DEVPROPTYPE : u32 = 22 ; pub const DEVPROP_TYPE_BINARY : u32 = 4099 ; pub const DEVPROP_TYPE_ERROR : u32 = 23 ; pub const DEVPROP_TYPE_NTSTATUS : u32 = 24 ; pub const DEVPROP_TYPE_STRING_INDIRECT : u32 = 25 ; pub const MAX_DEVPROP_TYPE : u32 = 25 ; pub const MAX_DEVPROP_TYPEMOD : u32 = 8192 ; pub const DEVPROP_MASK_TYPE : u32 = 4095 ; pub const DEVPROP_MASK_TYPEMOD : u32 = 61440 ; pub const DEVPROPID_FIRST_USABLE : u32 = 2 ; pub const PLUGPLAY_PROPERTY_PERSISTENT : u32 = 1 ; pub const PNP_REPLACE_NO_MAP : u64 = 9223372036854775807 ; pub const PNP_REPLACE_PARAMETERS_VERSION : u32 = 2 ; pub const PNP_REPLACE_DRIVER_INTERFACE_VERSION : u32 = 1 ; pub const PNP_REPLACE_MEMORY_SUPPORTED : u32 = 1 ; pub const PNP_REPLACE_PROCESSOR_SUPPORTED : u32 = 2 ; pub const PNP_REPLACE_HARDWARE_MEMORY_MIRRORING : u32 = 4 ; pub const PNP_REPLACE_HARDWARE_PAGE_COPY : u32 = 8 ; pub const PNP_REPLACE_HARDWARE_QUIESCE : u32 = 16 ; pub const DEVICE_RESET_INTERFACE_VERSION : u32 = 1 ; pub const SECURE_DRIVER_INTERFACE_VERSION : u32 = 1 ; pub const SDEV_IDENTIFIER_INTERFACE_VERSION : u32 = 1 ; pub const DEVICE_DESCRIPTION_VERSION : u32 = 0 ; pub const DEVICE_DESCRIPTION_VERSION1 : u32 = 1 ; pub const DEVICE_DESCRIPTION_VERSION2 : u32 = 2 ; pub const DEVICE_DESCRIPTION_VERSION3 : u32 = 3 ; pub const DMA_ADAPTER_INFO_VERSION1 : u32 = 1 ; pub const DMA_TRANSFER_INFO_VERSION1 : u32 = 1 ; pub const ADAPTER_INFO_SYNCHRONOUS_CALLBACK : u32 = 1 ; pub const ADAPTER_INFO_API_BYPASS : u32 = 2 ; pub const DMA_TRANSFER_CONTEXT_VERSION1 : u32 = 1 ; pub const DMA_TRANSFER_CONTEXT_SIZE_V1 : u32 = 128 ; pub const DMA_SYNCHRONOUS_CALLBACK : u32 = 1 ; pub const DMA_ZERO_BUFFERS : u32 = 2 ; pub const HAL_MASK_UNMASK_FLAGS_NONE : u32 = 0 ; pub const HAL_MASK_UNMASK_FLAGS_SERVICING_DEFERRED : u32 = 1 ; pub const HAL_MASK_UNMASK_FLAGS_SERVICING_COMPLETE : u32 = 2 ; pub const HAL_DMA_ADAPTER_VERSION_1 : u32 = 1 ; pub const DOMAIN_COMMON_BUFFER_LARGE_PAGE : u32 = 1 ; pub const PO_MEM_PRESERVE : u32 = 1 ; pub const PO_MEM_CLONE : u32 = 2 ; pub const PO_MEM_CL_OR_NCHK : u32 = 4 ; pub const PO_MEM_DISCARD : u32 = 32768 ; pub const PO_MEM_PAGE_ADDRESS : u32 = 16384 ; pub const PO_MEM_BOOT_PHASE : u32 = 65536 ; pub const PO_CB_SYSTEM_POWER_POLICY : u32 = 0 ; pub const PO_CB_AC_STATUS : u32 = 1 ; pub const PO_CB_BUTTON_COLLISION : u32 = 2 ; pub const PO_CB_SYSTEM_STATE_LOCK : u32 = 3 ; pub const PO_CB_LID_SWITCH_STATE : u32 = 4 ; pub const PO_CB_PROCESSOR_POWER_POLICY : u32 = 5 ; pub const PO_FX_VERSION_V1 : u32 = 1 ; pub const PO_FX_VERSION_V2 : u32 = 2 ; pub const PO_FX_VERSION : u32 = 1 ; pub const PO_FX_COMPONENT_FLAG_F0_ON_DX : u32 = 1 ; pub const PO_FX_COMPONENT_FLAG_NO_DEBOUNCE : u32 = 2 ; pub const PO_FX_UNKNOWN_POWER : u32 = 4294967295 ; pub const PO_FX_UNKNOWN_TIME : i32 = -1 ; pub const PO_FX_FLAG_BLOCKING : u32 = 1 ; pub const PO_FX_FLAG_ASYNC_ONLY : u32 = 2 ; pub const PO_FX_FLAG_PERF_PEP_OPTIONAL : u32 = 1 ; pub const PO_FX_FLAG_PERF_QUERY_ON_F0 : u32 = 2 ; pub const PO_FX_FLAG_PERF_QUERY_ON_ALL_IDLE_STATES : u32 = 4 ; pub const OB_FLT_REGISTRATION_VERSION_0100 : u32 = 256 ; pub const OB_FLT_REGISTRATION_VERSION : u32 = 256 ; pub const OB_OPERATION_HANDLE_CREATE : u32 = 1 ; pub const OB_OPERATION_HANDLE_DUPLICATE : u32 = 2 ; pub const PCI_TYPE0_ADDRESSES : u32 = 6 ; pub const PCI_TYPE1_ADDRESSES : u32 = 2 ; pub const PCI_TYPE2_ADDRESSES : u32 = 5 ; pub const PCI_EXTENDED_CONFIG_LENGTH : u32 = 4096 ; pub const PCI_MAX_DEVICES : u32 = 32 ; pub const PCI_MAX_FUNCTION : u32 = 8 ; pub const PCI_MAX_BRIDGE_NUMBER : u32 = 255 ; pub const PCI_INVALID_VENDORID : u32 = 65535 ; pub const PCI_MULTIFUNCTION : u32 = 128 ; pub const PCI_DEVICE_TYPE : u32 = 0 ; pub const PCI_BRIDGE_TYPE : u32 = 1 ; pub const PCI_CARDBUS_BRIDGE_TYPE : u32 = 2 ; pub const PCI_ENABLE_IO_SPACE : u32 = 1 ; pub const PCI_ENABLE_MEMORY_SPACE : u32 = 2 ; pub const PCI_ENABLE_BUS_MASTER : u32 = 4 ; pub const PCI_ENABLE_SPECIAL_CYCLES : u32 = 8 ; pub const PCI_ENABLE_WRITE_AND_INVALIDATE : u32 = 16 ; pub const PCI_ENABLE_VGA_COMPATIBLE_PALETTE : u32 = 32 ; pub const PCI_ENABLE_PARITY : u32 = 64 ; pub const PCI_ENABLE_WAIT_CYCLE : u32 = 128 ; pub const PCI_ENABLE_SERR : u32 = 256 ; pub const PCI_ENABLE_FAST_BACK_TO_BACK : u32 = 512 ; pub const PCI_DISABLE_LEVEL_INTERRUPT : u32 = 1024 ; pub const PCI_STATUS_INTERRUPT_PENDING : u32 = 8 ; pub const PCI_STATUS_CAPABILITIES_LIST : u32 = 16 ; pub const PCI_STATUS_66MHZ_CAPABLE : u32 = 32 ; pub const PCI_STATUS_UDF_SUPPORTED : u32 = 64 ; pub const PCI_STATUS_FAST_BACK_TO_BACK : u32 = 128 ; pub const PCI_STATUS_DATA_PARITY_DETECTED : u32 = 256 ; pub const PCI_STATUS_DEVSEL : u32 = 1536 ; pub const PCI_STATUS_SIGNALED_TARGET_ABORT : u32 = 2048 ; pub const PCI_STATUS_RECEIVED_TARGET_ABORT : u32 = 4096 ; pub const PCI_STATUS_RECEIVED_MASTER_ABORT : u32 = 8192 ; pub const PCI_STATUS_SIGNALED_SYSTEM_ERROR : u32 = 16384 ; pub const PCI_STATUS_DETECTED_PARITY_ERROR : u32 = 32768 ; pub const PCI_WHICHSPACE_CONFIG : u32 = 0 ; pub const PCI_WHICHSPACE_ROM : u32 = 1382638416 ; pub const PCI_CAPABILITY_ID_POWER_MANAGEMENT : u32 = 1 ; pub const PCI_CAPABILITY_ID_AGP : u32 = 2 ; pub const PCI_CAPABILITY_ID_VPD : u32 = 3 ; pub const PCI_CAPABILITY_ID_SLOT_ID : u32 = 4 ; pub const PCI_CAPABILITY_ID_MSI : u32 = 5 ; pub const PCI_CAPABILITY_ID_CPCI_HOTSWAP : u32 = 6 ; pub const PCI_CAPABILITY_ID_PCIX : u32 = 7 ; pub const PCI_CAPABILITY_ID_HYPERTRANSPORT : u32 = 8 ; pub const PCI_CAPABILITY_ID_VENDOR_SPECIFIC : u32 = 9 ; pub const PCI_CAPABILITY_ID_DEBUG_PORT : u32 = 10 ; pub const PCI_CAPABILITY_ID_CPCI_RES_CTRL : u32 = 11 ; pub const PCI_CAPABILITY_ID_SHPC : u32 = 12 ; pub const PCI_CAPABILITY_ID_P2P_SSID : u32 = 13 ; pub const PCI_CAPABILITY_ID_AGP_TARGET : u32 = 14 ; pub const PCI_CAPABILITY_ID_SECURE : u32 = 15 ; pub const PCI_CAPABILITY_ID_PCI_EXPRESS : u32 = 16 ; pub const PCI_CAPABILITY_ID_MSIX : u32 = 17 ; pub const PCI_CAPABILITY_ID_SATA_CONFIG : u32 = 18 ; pub const PCI_CAPABILITY_ID_ADVANCED_FEATURES : u32 = 19 ; pub const PCI_EXPRESS_ADVANCED_ERROR_REPORTING_CAP_ID : u32 = 1 ; pub const PCI_EXPRESS_VIRTUAL_CHANNEL_CAP_ID : u32 = 2 ; pub const PCI_EXPRESS_DEVICE_SERIAL_NUMBER_CAP_ID : u32 = 3 ; pub const PCI_EXPRESS_POWER_BUDGETING_CAP_ID : u32 = 4 ; pub const PCI_EXPRESS_RC_LINK_DECLARATION_CAP_ID : u32 = 5 ; pub const PCI_EXPRESS_RC_INTERNAL_LINK_CONTROL_CAP_ID : u32 = 6 ; pub const PCI_EXPRESS_RC_EVENT_COLLECTOR_ENDPOINT_ASSOCIATION_CAP_ID : u32 = 7 ; pub const PCI_EXPRESS_MFVC_CAP_ID : u32 = 8 ; pub const PCI_EXPRESS_VC_AND_MFVC_CAP_ID : u32 = 9 ; pub const PCI_EXPRESS_RCRB_HEADER_CAP_ID : u32 = 10 ; pub const PCI_EXPRESS_VENDOR_SPECIFIC_CAP_ID : u32 = 11 ; pub const PCI_EXPRESS_CONFIGURATION_ACCESS_CORRELATION_CAP_ID : u32 = 12 ; pub const PCI_EXPRESS_ACCESS_CONTROL_SERVICES_CAP_ID : u32 = 13 ; pub const PCI_EXPRESS_ARI_CAP_ID : u32 = 14 ; pub const PCI_EXPRESS_ATS_CAP_ID : u32 = 15 ; pub const PCI_EXPRESS_SINGLE_ROOT_IO_VIRTUALIZATION_CAP_ID : u32 = 16 ; pub const PCI_EXPRESS_MULTI_ROOT_IO_VIRTUALIZATION_CAP_ID : u32 = 17 ; pub const PCI_EXPRESS_MULTICAST_CAP_ID : u32 = 18 ; pub const PCI_EXPRESS_PAGE_REQUEST_CAP_ID : u32 = 19 ; pub const PCI_EXPRESS_RESERVED_FOR_AMD_CAP_ID : u32 = 20 ; pub const PCI_EXPRESS_RESIZABLE_BAR_CAP_ID : u32 = 21 ; pub const PCI_EXPRESS_DPA_CAP_ID : u32 = 22 ; pub const PCI_EXPRESS_TPH_REQUESTER_CAP_ID : u32 = 23 ; pub const PCI_EXPRESS_LTR_CAP_ID : u32 = 24 ; pub const PCI_EXPRESS_SECONDARY_PCI_EXPRESS_CAP_ID : u32 = 25 ; pub const PCI_EXPRESS_PMUX_CAP_ID : u32 = 26 ; pub const PCI_EXPRESS_PASID_CAP_ID : u32 = 27 ; pub const PCI_EXPRESS_LN_REQUESTER_CAP_ID : u32 = 28 ; pub const PCI_EXPRESS_DPC_CAP_ID : u32 = 29 ; pub const PCI_EXPRESS_L1_PM_SS_CAP_ID : u32 = 30 ; pub const PCI_EXPRESS_PTM_CAP_ID : u32 = 31 ; pub const PCI_EXPRESS_MPCIE_CAP_ID : u32 = 32 ; pub const PCI_EXPRESS_FRS_QUEUEING_CAP_ID : u32 = 33 ; pub const PCI_EXPRESS_READINESS_TIME_REPORTING_CAP_ID : u32 = 34 ; pub const ROOT_CMD_ENABLE_CORRECTABLE_ERROR_REPORTING : u32 = 1 ; pub const ROOT_CMD_ENABLE_NONFATAL_ERROR_REPORTING : u32 = 2 ; pub const ROOT_CMD_ENABLE_FATAL_ERROR_REPORTING : u32 = 4 ; pub const ROOT_CMD_ERROR_REPORTING_ENABLE_MASK : u32 = 7 ; pub const PCI_CLASS_PRE_20 : u32 = 0 ; pub const PCI_CLASS_MASS_STORAGE_CTLR : u32 = 1 ; pub const PCI_CLASS_NETWORK_CTLR : u32 = 2 ; pub const PCI_CLASS_DISPLAY_CTLR : u32 = 3 ; pub const PCI_CLASS_MULTIMEDIA_DEV : u32 = 4 ; pub const PCI_CLASS_MEMORY_CTLR : u32 = 5 ; pub const PCI_CLASS_BRIDGE_DEV : u32 = 6 ; pub const PCI_CLASS_SIMPLE_COMMS_CTLR : u32 = 7 ; pub const PCI_CLASS_BASE_SYSTEM_DEV : u32 = 8 ; pub const PCI_CLASS_INPUT_DEV : u32 = 9 ; pub const PCI_CLASS_DOCKING_STATION : u32 = 10 ; pub const PCI_CLASS_PROCESSOR : u32 = 11 ; pub const PCI_CLASS_SERIAL_BUS_CTLR : u32 = 12 ; pub const PCI_CLASS_WIRELESS_CTLR : u32 = 13 ; pub const PCI_CLASS_INTELLIGENT_IO_CTLR : u32 = 14 ; pub const PCI_CLASS_SATELLITE_COMMS_CTLR : u32 = 15 ; pub const PCI_CLASS_ENCRYPTION_DECRYPTION : u32 = 16 ; pub const PCI_CLASS_DATA_ACQ_SIGNAL_PROC : u32 = 17 ; pub const PCI_CLASS_NOT_DEFINED : u32 = 255 ; pub const PCI_SUBCLASS_PRE_20_NON_VGA : u32 = 0 ; pub const PCI_SUBCLASS_PRE_20_VGA : u32 = 1 ; pub const PCI_SUBCLASS_MSC_SCSI_BUS_CTLR : u32 = 0 ; pub const PCI_SUBCLASS_MSC_IDE_CTLR : u32 = 1 ; pub const PCI_SUBCLASS_MSC_FLOPPY_CTLR : u32 = 2 ; pub const PCI_SUBCLASS_MSC_IPI_CTLR : u32 = 3 ; pub const PCI_SUBCLASS_MSC_RAID_CTLR : u32 = 4 ; pub const PCI_SUBCLASS_MSC_AHCI_CTLR : u32 = 6 ; pub const PCI_SUBCLASS_MSC_NVM_CTLR : u32 = 8 ; pub const PCI_SUBCLASS_MSC_OTHER : u32 = 128 ; pub const PCI_PROGRAMMING_INTERFACE_MSC_NVM_EXPRESS : u32 = 2 ; pub const PCI_SUBCLASS_NET_ETHERNET_CTLR : u32 = 0 ; pub const PCI_SUBCLASS_NET_TOKEN_RING_CTLR : u32 = 1 ; pub const PCI_SUBCLASS_NET_FDDI_CTLR : u32 = 2 ; pub const PCI_SUBCLASS_NET_ATM_CTLR : u32 = 3 ; pub const PCI_SUBCLASS_NET_ISDN_CTLR : u32 = 4 ; pub const PCI_SUBCLASS_NET_OTHER : u32 = 128 ; pub const PCI_SUBCLASS_VID_VGA_CTLR : u32 = 0 ; pub const PCI_SUBCLASS_VID_XGA_CTLR : u32 = 1 ; pub const PCI_SUBLCASS_VID_3D_CTLR : u32 = 2 ; pub const PCI_SUBCLASS_VID_OTHER : u32 = 128 ; pub const PCI_SUBCLASS_MM_VIDEO_DEV : u32 = 0 ; pub const PCI_SUBCLASS_MM_AUDIO_DEV : u32 = 1 ; pub const PCI_SUBCLASS_MM_TELEPHONY_DEV : u32 = 2 ; pub const PCI_SUBCLASS_MM_OTHER : u32 = 128 ; pub const PCI_SUBCLASS_MEM_RAM : u32 = 0 ; pub const PCI_SUBCLASS_MEM_FLASH : u32 = 1 ; pub const PCI_SUBCLASS_MEM_OTHER : u32 = 128 ; pub const PCI_SUBCLASS_BR_HOST : u32 = 0 ; pub const PCI_SUBCLASS_BR_ISA : u32 = 1 ; pub const PCI_SUBCLASS_BR_EISA : u32 = 2 ; pub const PCI_SUBCLASS_BR_MCA : u32 = 3 ; pub const PCI_SUBCLASS_BR_PCI_TO_PCI : u32 = 4 ; pub const PCI_SUBCLASS_BR_PCMCIA : u32 = 5 ; pub const PCI_SUBCLASS_BR_NUBUS : u32 = 6 ; pub const PCI_SUBCLASS_BR_CARDBUS : u32 = 7 ; pub const PCI_SUBCLASS_BR_RACEWAY : u32 = 8 ; pub const PCI_SUBCLASS_BR_OTHER : u32 = 128 ; pub const PCI_SUBCLASS_COM_SERIAL : u32 = 0 ; pub const PCI_SUBCLASS_COM_PARALLEL : u32 = 1 ; pub const PCI_SUBCLASS_COM_MULTIPORT : u32 = 2 ; pub const PCI_SUBCLASS_COM_MODEM : u32 = 3 ; pub const PCI_SUBCLASS_COM_OTHER : u32 = 128 ; pub const PCI_SUBCLASS_SYS_INTERRUPT_CTLR : u32 = 0 ; pub const PCI_SUBCLASS_SYS_DMA_CTLR : u32 = 1 ; pub const PCI_SUBCLASS_SYS_SYSTEM_TIMER : u32 = 2 ; pub const PCI_SUBCLASS_SYS_REAL_TIME_CLOCK : u32 = 3 ; pub const PCI_SUBCLASS_SYS_GEN_HOTPLUG_CTLR : u32 = 4 ; pub const PCI_SUBCLASS_SYS_SDIO_CTRL : u32 = 5 ; pub const PCI_SUBCLASS_SYS_OTHER : u32 = 128 ; pub const PCI_SUBCLASS_INP_KEYBOARD : u32 = 0 ; pub const PCI_SUBCLASS_INP_DIGITIZER : u32 = 1 ; pub const PCI_SUBCLASS_INP_MOUSE : u32 = 2 ; pub const PCI_SUBCLASS_INP_SCANNER : u32 = 3 ; pub const PCI_SUBCLASS_INP_GAMEPORT : u32 = 4 ; pub const PCI_SUBCLASS_INP_OTHER : u32 = 128 ; pub const PCI_SUBCLASS_DOC_GENERIC : u32 = 0 ; pub const PCI_SUBCLASS_DOC_OTHER : u32 = 128 ; pub const PCI_SUBCLASS_PROC_386 : u32 = 0 ; pub const PCI_SUBCLASS_PROC_486 : u32 = 1 ; pub const PCI_SUBCLASS_PROC_PENTIUM : u32 = 2 ; pub const PCI_SUBCLASS_PROC_ALPHA : u32 = 16 ; pub const PCI_SUBCLASS_PROC_POWERPC : u32 = 32 ; pub const PCI_SUBCLASS_PROC_COPROCESSOR : u32 = 64 ; pub const PCI_SUBCLASS_SB_IEEE1394 : u32 = 0 ; pub const PCI_SUBCLASS_SB_ACCESS : u32 = 1 ; pub const PCI_SUBCLASS_SB_SSA : u32 = 2 ; pub const PCI_SUBCLASS_SB_USB : u32 = 3 ; pub const PCI_SUBCLASS_SB_FIBRE_CHANNEL : u32 = 4 ; pub const PCI_SUBCLASS_SB_SMBUS : u32 = 5 ; pub const PCI_SUBCLASS_SB_THUNDERBOLT : u32 = 10 ; pub const PCI_SUBCLASS_WIRELESS_IRDA : u32 = 0 ; pub const PCI_SUBCLASS_WIRELESS_CON_IR : u32 = 1 ; pub const PCI_SUBCLASS_WIRELESS_RF : u32 = 16 ; pub const PCI_SUBCLASS_WIRELESS_OTHER : u32 = 128 ; pub const PCI_SUBCLASS_INTIO_I2O : u32 = 0 ; pub const PCI_SUBCLASS_SAT_TV : u32 = 1 ; pub const PCI_SUBCLASS_SAT_AUDIO : u32 = 2 ; pub const PCI_SUBCLASS_SAT_VOICE : u32 = 3 ; pub const PCI_SUBCLASS_SAT_DATA : u32 = 4 ; pub const PCI_SUBCLASS_CRYPTO_NET_COMP : u32 = 0 ; pub const PCI_SUBCLASS_CRYPTO_ENTERTAINMENT : u32 = 16 ; pub const PCI_SUBCLASS_CRYPTO_OTHER : u32 = 128 ; pub const PCI_SUBCLASS_DASP_DPIO : u32 = 0 ; pub const PCI_SUBCLASS_DASP_OTHER : u32 = 128 ; pub const PCI_ADDRESS_IO_SPACE : u32 = 1 ; pub const PCI_ADDRESS_MEMORY_TYPE_MASK : u32 = 6 ; pub const PCI_ADDRESS_MEMORY_PREFETCHABLE : u32 = 8 ; pub const PCI_ADDRESS_IO_ADDRESS_MASK : u32 = 4294967292 ; pub const PCI_ADDRESS_MEMORY_ADDRESS_MASK : u32 = 4294967280 ; pub const PCI_ADDRESS_ROM_ADDRESS_MASK : u32 = 4294965248 ; pub const PCI_TYPE_32BIT : u32 = 0 ; pub const PCI_TYPE_20BIT : u32 = 2 ; pub const PCI_TYPE_64BIT : u32 = 4 ; pub const PCI_ROMADDRESS_ENABLED : u32 = 1 ; pub const PCI_DEVICE_PRESENT_INTERFACE_VERSION : u32 = 1 ; pub const PCI_USE_SUBSYSTEM_IDS : u32 = 1 ; pub const PCI_USE_REVISION : u32 = 2 ; pub const PCI_USE_VENDEV_IDS : u32 = 4 ; pub const PCI_USE_CLASS_SUBCLASS : u32 = 8 ; pub const PCI_USE_PROGIF : u32 = 16 ; pub const PCI_USE_LOCAL_BUS : u32 = 32 ; pub const PCI_USE_LOCAL_DEVICE : u32 = 64 ; pub const PCI_EXPRESS_LINK_QUIESCENT_INTERFACE_VERSION : u32 = 1 ; pub const PCI_EXPRESS_ROOT_PORT_INTERFACE_VERSION : u32 = 1 ; pub const PCI_MSIX_TABLE_CONFIG_INTERFACE_VERSION : u32 = 1 ; pub const FILE_ATTRIBUTE_DEDICATED : u32 = 256 ; pub const EA_CONTAINER_NAME : & 'static [ u8 ; 14usize ] = b"ContainerName\0" ; pub const EA_CONTAINER_SIZE : & 'static [ u8 ; 14usize ] = b"ContainerSize\0" ; pub const CLFS_BASELOG_EXTENSION : & 'static [ u8 ; 5usize ] = b".blf\0" ; pub const CLFS_FLAG_NO_FLAGS : u32 = 0 ; pub const CLFS_FLAG_FORCE_APPEND : u32 = 1 ; pub const CLFS_FLAG_FORCE_FLUSH : u32 = 2 ; pub const CLFS_FLAG_USE_RESERVATION : u32 = 4 ; pub const CLFS_FLAG_REENTRANT_FILE_SYSTEM : u32 = 8 ; pub const CLFS_FLAG_NON_REENTRANT_FILTER : u32 = 16 ; pub const CLFS_FLAG_REENTRANT_FILTER : u32 = 32 ; pub const CLFS_FLAG_IGNORE_SHARE_ACCESS : u32 = 64 ; pub const CLFS_FLAG_READ_IN_PROGRESS : u32 = 128 ; pub const CLFS_FLAG_MINIFILTER_LEVEL : u32 = 256 ; pub const CLFS_FLAG_HIDDEN_SYSTEM_LOG : u32 = 512 ; pub const CLFS_FLAG_FILTER_INTERMEDIATE_LEVEL : u32 = 16 ; pub const CLFS_FLAG_FILTER_TOP_LEVEL : u32 = 32 ; pub const ClfsNullRecord : u32 = 0 ; pub const ClfsDataRecord : u32 = 1 ; pub const ClfsRestartRecord : u32 = 2 ; pub const ClfsClientRecord : u32 = 3 ; pub const CLFS_CONTAINER_STREAM_PREFIX : & 'static [ u8 ; 7usize ] = b"%BLF%:\0" ; pub const CLFS_CONTAINER_RELATIVE_PREFIX : & 'static [ u8 ; 8usize ] = b"%BLF%\\\\\0" ; pub const ClsContainerInitializing : u32 = 1 ; pub const ClsContainerInactive : u32 = 2 ; pub const ClsContainerActive : u32 = 4 ; pub const ClsContainerActivePendingDelete : u32 = 8 ; pub const ClsContainerPendingArchive : u32 = 16 ; pub const ClsContainerPendingArchiveAndDelete : u32 = 32 ; pub const ClfsContainerInitializing : u32 = 1 ; pub const ClfsContainerInactive : u32 = 2 ; pub const ClfsContainerActive : u32 = 4 ; pub const ClfsContainerActivePendingDelete : u32 = 8 ; pub const ClfsContainerPendingArchive : u32 = 16 ; pub const ClfsContainerPendingArchiveAndDelete : u32 = 32 ; pub const CLFS_MAX_CONTAINER_INFO : u32 = 256 ; pub const CLFS_SCAN_INIT : u32 = 1 ; pub const CLFS_SCAN_FORWARD : u32 = 2 ; pub const CLFS_SCAN_BACKWARD : u32 = 4 ; pub const CLFS_SCAN_CLOSE : u32 = 8 ; pub const CLFS_SCAN_INITIALIZED : u32 = 16 ; pub const CLFS_SCAN_BUFFERED : u32 = 32 ; pub const CLFS_MGMT_POLICY_VERSION : u32 = 1 ; pub const LOG_POLICY_OVERWRITE : u32 = 1 ; pub const LOG_POLICY_PERSIST : u32 = 2 ; pub const CLFS_MGMT_CLIENT_REGISTRATION_VERSION : u32 = 1 ; pub const PCW_VERSION_1 : u32 = 256 ; pub const PCW_CURRENT_VERSION : u32 = 256 ; pub const SECURE_SECTION_ALLOW_PARTIAL_MDL : u32 = 1 ; pub const KERNEL_STACK_SIZE : u32 = 12288 ; pub const KERNEL_LARGE_STACK_SIZE : u32 = 61440 ; pub const KERNEL_LARGE_STACK_COMMIT : u32 = 12288 ; pub const SIZE_OF_80387_REGISTERS : u32 = 80 ; pub const CONTEXT_i386 : u32 = 65536 ; pub const CONTEXT_i486 : u32 = 65536 ; pub const CONTEXT_CONTROL : u32 = 65537 ; pub const CONTEXT_INTEGER : u32 = 65538 ; pub const CONTEXT_SEGMENTS : u32 = 65540 ; pub const CONTEXT_FLOATING_POINT : u32 = 65544 ; pub const CONTEXT_DEBUG_REGISTERS : u32 = 65552 ; pub const CONTEXT_EXTENDED_REGISTERS : u32 = 65568 ; pub const CONTEXT_FULL : u32 = 65543 ; pub const CONTEXT_ALL : u32 = 65599 ; pub const CONTEXT_XSTATE : u32 = 65600 ; pub const CONTEXT_EXCEPTION_ACTIVE : u32 = 134217728 ; pub const CONTEXT_SERVICE_ACTIVE : u32 = 268435456 ; pub const CONTEXT_EXCEPTION_REQUEST : u32 = 1073741824 ; pub const CONTEXT_EXCEPTION_REPORTING : u32 = 2147483648 ; pub const CONTEXT_ARM64 : u32 = 4194304 ; pub const CONTEXT_ARM64_CONTROL : u32 = 4194305 ; pub const CONTEXT_ARM64_INTEGER : u32 = 4194306 ; pub const CONTEXT_ARM64_FLOATING_POINT : u32 = 4194308 ; pub const CONTEXT_ARM64_DEBUG_REGISTERS : u32 = 4194312 ; pub const CONTEXT_ARM64_FULL : u32 = 4194311 ; pub const CONTEXT_ARM64_ALL : u32 = 4194319 ; pub const CONTEXT_UNWOUND_TO_CALL : u32 = 536870912 ; pub const CONTEXT_RET_TO_GUEST : u32 = 67108864 ; pub const ARM64_MAX_BREAKPOINTS : u32 = 8 ; pub const ARM64_MAX_WATCHPOINTS : u32 = 2 ; pub const SE_UNSOLICITED_INPUT_PRIVILEGE : u32 = 6 ; pub const SE_SIGNING_LEVEL_UNCHECKED : u32 = 0 ; pub const SE_SIGNING_LEVEL_UNSIGNED : u32 = 1 ; pub const SE_SIGNING_LEVEL_ENTERPRISE : u32 = 2 ; pub const SE_SIGNING_LEVEL_CUSTOM_1 : u32 = 3 ; pub const SE_SIGNING_LEVEL_AUTHENTICODE : u32 = 4 ; pub const SE_SIGNING_LEVEL_CUSTOM_2 : u32 = 5 ; pub const SE_SIGNING_LEVEL_STORE : u32 = 6 ; pub const SE_SIGNING_LEVEL_CUSTOM_3 : u32 = 7 ; pub const SE_SIGNING_LEVEL_ANTIMALWARE : u32 = 7 ; pub const SE_SIGNING_LEVEL_MICROSOFT : u32 = 8 ; pub const SE_SIGNING_LEVEL_CUSTOM_4 : u32 = 9 ; pub const SE_SIGNING_LEVEL_CUSTOM_5 : u32 = 10 ; pub const SE_SIGNING_LEVEL_DYNAMIC_CODEGEN : u32 = 11 ; pub const SE_SIGNING_LEVEL_WINDOWS : u32 = 12 ; pub const SE_SIGNING_LEVEL_CUSTOM_7 : u32 = 13 ; pub const SE_SIGNING_LEVEL_WINDOWS_TCB : u32 = 14 ; pub const SE_SIGNING_LEVEL_CUSTOM_6 : u32 = 15 ; pub const RTL_RUN_ONCE_CHECK_ONLY : u32 = 1 ; pub const RTL_RUN_ONCE_ASYNC : u32 = 2 ; pub const RTL_RUN_ONCE_INIT_FAILED : u32 = 4 ; pub const RTL_RUN_ONCE_CTX_RESERVED_BITS : u32 = 2 ; pub const RTL_HASH_ALLOCATED_HEADER : u32 = 1 ; pub const RTL_HASH_RESERVED_SIGNATURE : u32 = 0 ; pub const RTL_STACK_WALKING_MODE_FRAMES_TO_SKIP_SHIFT : u32 = 8 ; pub const RTL_CORRELATION_VECTOR_STRING_LENGTH : u32 = 129 ; pub const RTL_CORRELATION_VECTOR_V1_PREFIX_LENGTH : u32 = 16 ; pub const RTL_CORRELATION_VECTOR_V1_LENGTH : u32 = 64 ; pub const RTL_CORRELATION_VECTOR_V2_PREFIX_LENGTH : u32 = 22 ; pub const RTL_CORRELATION_VECTOR_V2_LENGTH : u32 = 128 ; pub const FILE_CHARACTERISTICS_EXPECT_ORDERLY_REMOVAL_EX : u32 = 16384 ; pub const FILE_CHARACTERISTICS_EXPECT_SURPRISE_REMOVAL_EX : u32 = 32768 ; pub const FILE_CHARACTERISTICS_REMOVAL_POLICY_MASK_EX : u32 = 49152 ; pub const FILE_CHARACTERISTICS_EXPECT_ORDERLY_REMOVAL_DEPRECATED : u32 = 512 ; pub const FILE_CHARACTERISTICS_EXPECT_SURPRISE_REMOVAL_DEPRECATED : u32 = 768 ; pub const FILE_CHARACTERISTICS_REMOVAL_POLICY_MASK_DEPRECATED : u32 = 768 ; pub const FILE_CHARACTERISTICS_PROPAGATED : u32 = 327951 ; pub const FILE_DISPOSITION_DO_NOT_DELETE : u32 = 0 ; pub const FILE_DISPOSITION_DELETE : u32 = 1 ; pub const FILE_DISPOSITION_POSIX_SEMANTICS : u32 = 2 ; pub const FILE_DISPOSITION_FORCE_IMAGE_SECTION_CHECK : u32 = 4 ; pub const FILE_DISPOSITION_ON_CLOSE : u32 = 8 ; pub const SSINFO_FLAGS_ALIGNED_DEVICE : u32 = 1 ; pub const SSINFO_FLAGS_PARTITION_ALIGNED_ON_DEVICE : u32 = 2 ; pub const SSINFO_FLAGS_NO_SEEK_PENALTY : u32 = 4 ; pub const SSINFO_FLAGS_TRIM_ENABLED : u32 = 8 ; pub const SSINFO_FLAGS_BYTE_ADDRESSABLE : u32 = 16 ; pub const SSINFO_OFFSET_UNKNOWN : u32 = 4294967295 ; pub const THREAD_CSWITCH_PMU_DISABLE : u32 = 0 ; pub const THREAD_CSWITCH_PMU_ENABLE : u32 = 1 ; pub const MEMORY_PRIORITY_LOWEST : u32 = 0 ; pub const MEMORY_PRIORITY_VERY_LOW : u32 = 1 ; pub const MEMORY_PRIORITY_LOW : u32 = 2 ; pub const MEMORY_PRIORITY_MEDIUM : u32 = 3 ; pub const MEMORY_PRIORITY_BELOW_NORMAL : u32 = 4 ; pub const MEMORY_PRIORITY_NORMAL : u32 = 5 ; pub const PROCESS_LUID_DOSDEVICES_ONLY : u32 = 1 ; pub const PROCESS_HANDLE_EXCEPTIONS_ENABLED : u32 = 1 ; pub const PROCESS_HANDLE_RAISE_UM_EXCEPTION_ON_INVALID_HANDLE_CLOSE_DISABLED : u32 = 0 ; pub const PROCESS_HANDLE_RAISE_UM_EXCEPTION_ON_INVALID_HANDLE_CLOSE_ENABLED : u32 = 1 ; pub const PROCESS_HANDLE_TRACING_MAX_STACKS : u32 = 16 ; pub const QUOTA_LIMITS_HARDWS_MIN_ENABLE : u32 = 1 ; pub const QUOTA_LIMITS_HARDWS_MIN_DISABLE : u32 = 2 ; pub const QUOTA_LIMITS_HARDWS_MAX_ENABLE : u32 = 4 ; pub const QUOTA_LIMITS_HARDWS_MAX_DISABLE : u32 = 8 ; pub const QUOTA_LIMITS_USE_DEFAULT_LIMITS : u32 = 16 ; pub const MAX_HW_COUNTERS : u32 = 16 ; pub const THREAD_PROFILING_FLAG_DISPATCH : u32 = 1 ; pub const PROCESS_READWRITEVM_LOGGING_ENABLE_READVM : u32 = 1 ; pub const PROCESS_READWRITEVM_LOGGING_ENABLE_READVM_V : u32 = 1 ; pub const PROCESS_READWRITEVM_LOGGING_ENABLE_WRITEVM : u32 = 2 ; pub const PROCESS_READWRITEVM_LOGGING_ENABLE_WRITEVM_V : u32 = 2 ; pub const PROCESS_EXCEPTION_PORT_ALL_STATE_BITS : u32 = 3 ; pub const POWER_THROTTLING_PROCESS_CURRENT_VERSION : u32 = 1 ; pub const POWER_THROTTLING_PROCESS_EXECUTION_SPEED : u32 = 1 ; pub const POWER_THROTTLING_PROCESS_DELAYTIMERS : u32 = 2 ; pub const POWER_THROTTLING_PROCESS_VALID_FLAGS : u32 = 3 ; pub const POWER_THROTTLING_THREAD_CURRENT_VERSION : u32 = 1 ; pub const POWER_THROTTLING_THREAD_EXECUTION_SPEED : u32 = 1 ; pub const POWER_THROTTLING_THREAD_VALID_FLAGS : u32 = 1 ; pub const PCR_MINOR_VERSION : u32 = 1 ; pub const PCR_MAJOR_VERSION : u32 = 1 ; pub const PDI_SHIFT : u32 = 21 ; pub const PPI_SHIFT : u32 = 30 ; pub const PTI_SHIFT : u32 = 12 ; pub const PTE_PER_PAGE : u32 = 512 ; pub const PDE_PER_PAGE : u32 = 512 ; pub const MM_SYSTEM_SPACE_END : u32 = 4294967295 ; pub const DRIVER_VERIFIER_SPECIAL_POOLING : u32 = 1 ; pub const DRIVER_VERIFIER_FORCE_IRQL_CHECKING : u32 = 2 ; pub const DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES : u32 = 4 ; pub const DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS : u32 = 8 ; pub const DRIVER_VERIFIER_IO_CHECKING : u32 = 16 ; pub const XSTATE_LEGACY_FLOATING_POINT : u32 = 0 ; pub const XSTATE_LEGACY_SSE : u32 = 1 ; pub const XSTATE_GSSE : u32 = 2 ; pub const XSTATE_AVX : u32 = 2 ; pub const XSTATE_MPX_BNDREGS : u32 = 3 ; pub const XSTATE_MPX_BNDCSR : u32 = 4 ; pub const XSTATE_AVX512_KMASK : u32 = 5 ; pub const XSTATE_AVX512_ZMM_H : u32 = 6 ; pub const XSTATE_AVX512_ZMM : u32 = 7 ; pub const XSTATE_IPT : u32 = 8 ; pub const XSTATE_LWP : u32 = 62 ; pub const MAXIMUM_XSTATE_FEATURES : u32 = 64 ; pub const XSTATE_COMPACTION_ENABLE : u32 = 63 ; pub const XSTATE_ALIGN_BIT : u32 = 1 ; pub const XSTATE_CONTROLFLAG_XSAVEOPT_MASK : u32 = 1 ; pub const XSTATE_CONTROLFLAG_XSAVEC_MASK : u32 = 2 ; pub const XSTATE_CONTROLFLAG_VALID_MASK : u32 = 3 ; pub const NX_SUPPORT_POLICY_ALWAYSOFF : u32 = 0 ; pub const NX_SUPPORT_POLICY_ALWAYSON : u32 = 1 ; pub const NX_SUPPORT_POLICY_OPTIN : u32 = 2 ; pub const NX_SUPPORT_POLICY_OPTOUT : u32 = 3 ; pub const SEH_VALIDATION_POLICY_ON : u32 = 0 ; pub const SEH_VALIDATION_POLICY_OFF : u32 = 1 ; pub const SEH_VALIDATION_POLICY_TELEMETRY : u32 = 2 ; pub const SEH_VALIDATION_POLICY_DEFER : u32 = 3 ; pub const SHARED_GLOBAL_FLAGS_ERROR_PORT_V : u32 = 0 ; pub const SHARED_GLOBAL_FLAGS_ERROR_PORT : u32 = 1 ; pub const SHARED_GLOBAL_FLAGS_ELEVATION_ENABLED_V : u32 = 1 ; pub const SHARED_GLOBAL_FLAGS_ELEVATION_ENABLED : u32 = 2 ; pub const SHARED_GLOBAL_FLAGS_VIRT_ENABLED_V : u32 = 2 ; pub const SHARED_GLOBAL_FLAGS_VIRT_ENABLED : u32 = 4 ; pub const SHARED_GLOBAL_FLAGS_INSTALLER_DETECT_ENABLED_V : u32 = 3 ; pub const SHARED_GLOBAL_FLAGS_INSTALLER_DETECT_ENABLED : u32 = 8 ; pub const SHARED_GLOBAL_FLAGS_LKG_ENABLED_V : u32 = 4 ; pub const SHARED_GLOBAL_FLAGS_LKG_ENABLED : u32 = 16 ; pub const SHARED_GLOBAL_FLAGS_DYNAMIC_PROC_ENABLED_V : u32 = 5 ; pub const SHARED_GLOBAL_FLAGS_DYNAMIC_PROC_ENABLED : u32 = 32 ; pub const SHARED_GLOBAL_FLAGS_CONSOLE_BROKER_ENABLED_V : u32 = 6 ; pub const SHARED_GLOBAL_FLAGS_CONSOLE_BROKER_ENABLED : u32 = 64 ; pub const SHARED_GLOBAL_FLAGS_SECURE_BOOT_ENABLED_V : u32 = 7 ; pub const SHARED_GLOBAL_FLAGS_SECURE_BOOT_ENABLED : u32 = 128 ; pub const SHARED_GLOBAL_FLAGS_MULTI_SESSION_SKU_V : u32 = 8 ; pub const SHARED_GLOBAL_FLAGS_MULTI_SESSION_SKU : u32 = 256 ; pub const SHARED_GLOBAL_FLAGS_MULTIUSERS_IN_SESSION_SKU_V : u32 = 9 ; pub const SHARED_GLOBAL_FLAGS_MULTIUSERS_IN_SESSION_SKU : u32 = 512 ; pub const SHARED_GLOBAL_FLAGS_STATE_SEPARATION_ENABLED_V : u32 = 10 ; pub const SHARED_GLOBAL_FLAGS_STATE_SEPARATION_ENABLED : u32 = 1024 ; pub const SYSTEM_CALL_SYSCALL : u32 = 0 ; pub const SYSTEM_CALL_INT_2E : u32 = 1 ; pub const SHARED_GLOBAL_FLAGS_QPC_BYPASS_ENABLED : u32 = 1 ; pub const SHARED_GLOBAL_FLAGS_QPC_BYPASS_USE_MFENCE : u32 = 16 ; pub const SHARED_GLOBAL_FLAGS_QPC_BYPASS_USE_LFENCE : u32 = 32 ; pub const SHARED_GLOBAL_FLAGS_QPC_BYPASS_A73_ERRATA : u32 = 64 ; pub const SHARED_GLOBAL_FLAGS_QPC_BYPASS_USE_RDTSCP : u32 = 128 ; pub const CmResourceTypeMaximum : u32 = 8 ; pub const PCCARD_MAP_ERROR : u32 = 1 ; pub const PCCARD_DEVICE_PCI : u32 = 16 ; pub const PCCARD_SCAN_DISABLED : u32 = 1 ; pub const PCCARD_MAP_ZERO : u32 = 2 ; pub const PCCARD_NO_TIMER : u32 = 3 ; pub const PCCARD_NO_PIC : u32 = 4 ; pub const PCCARD_NO_LEGACY_BASE : u32 = 5 ; pub const PCCARD_DUP_LEGACY_BASE : u32 = 6 ; pub const PCCARD_NO_CONTROLLERS : u32 = 7 ; pub const MAXIMUM_EXPANSION_SIZE : u32 = 59392 ; pub const CP_GET_SUCCESS : u32 = 0 ; pub const CP_GET_NODATA : u32 = 1 ; pub const CP_GET_ERROR : u32 = 2 ; pub const PROTECTED_POOL : u32 = 0 ; pub const MM_ADD_PHYSICAL_MEMORY_ALREADY_ZEROED : u32 = 1 ; pub const MM_COPY_MEMORY_PHYSICAL : u32 = 1 ; pub const MM_COPY_MEMORY_VIRTUAL : u32 = 2 ; pub const MM_SYSTEM_VIEW_EXCEPTIONS_FOR_INPAGE_ERRORS : u32 = 1 ; pub const IMAGE_ADDRESSING_MODE_32BIT : u32 = 3 ; pub const PS_IMAGE_NOTIFY_CONFLICTING_ARCHITECTURE : u32 = 1 ; pub const SILO_MONITOR_REGISTRATION_VERSION : u32 = 1 ; pub const PS_INVALID_SILO_CONTEXT_SLOT : u32 = 4294967295 ; pub const IRP_MN_QUERY_DIRECTORY : u32 = 1 ; pub const IRP_MN_NOTIFY_CHANGE_DIRECTORY : u32 = 2 ; pub const IRP_MN_NOTIFY_CHANGE_DIRECTORY_EX : u32 = 3 ; pub const IRP_MN_USER_FS_REQUEST : u32 = 0 ; pub const IRP_MN_MOUNT_VOLUME : u32 = 1 ; pub const IRP_MN_VERIFY_VOLUME : u32 = 2 ; pub const IRP_MN_LOAD_FILE_SYSTEM : u32 = 3 ; pub const IRP_MN_TRACK_LINK : u32 = 4 ; pub const IRP_MN_KERNEL_CALL : u32 = 4 ; pub const IRP_MN_LOCK : u32 = 1 ; pub const IRP_MN_UNLOCK_SINGLE : u32 = 2 ; pub const IRP_MN_UNLOCK_ALL : u32 = 3 ; pub const IRP_MN_UNLOCK_ALL_BY_KEY : u32 = 4 ; pub const IRP_MN_FLUSH_AND_PURGE : u32 = 1 ; pub const IRP_MN_FLUSH_DATA_ONLY : u32 = 2 ; pub const IRP_MN_FLUSH_NO_SYNC : u32 = 3 ; pub const IRP_MN_FLUSH_DATA_SYNC_ONLY : u32 = 4 ; pub const IRP_MN_NORMAL : u32 = 0 ; pub const IRP_MN_DPC : u32 = 1 ; pub const IRP_MN_MDL : u32 = 2 ; pub const IRP_MN_COMPLETE : u32 = 4 ; pub const IRP_MN_COMPRESSED : u32 = 8 ; pub const IRP_MN_MDL_DPC : u32 = 3 ; pub const IRP_MN_COMPLETE_MDL : u32 = 6 ; pub const IRP_MN_COMPLETE_MDL_DPC : u32 = 7 ; pub const IRP_MN_QUERY_LEGACY_BUS_INFORMATION : u32 = 24 ; pub const IO_CHECK_CREATE_PARAMETERS : u32 = 512 ; pub const IO_ATTACH_DEVICE : u32 = 1024 ; pub const IO_IGNORE_SHARE_ACCESS_CHECK : u32 = 2048 ; pub const DO_DEVICE_HAS_NAME : u32 = 64 ; pub const DO_SYSTEM_BOOT_PARTITION : u32 = 256 ; pub const DO_LONG_TERM_REQUESTS : u32 = 512 ; pub const DO_NEVER_LAST_DEVICE : u32 = 1024 ; pub const DO_LOW_PRIORITY_FILESYSTEM : u32 = 65536 ; pub const DO_SUPPORTS_TRANSACTIONS : u32 = 262144 ; pub const DO_FORCE_NEITHER_IO : u32 = 524288 ; pub const DO_VOLUME_DEVICE_OBJECT : u32 = 1048576 ; pub const DO_SYSTEM_SYSTEM_PARTITION : u32 = 2097152 ; pub const DO_SYSTEM_CRITICAL_PARTITION : u32 = 4194304 ; pub const DO_DISALLOW_EXECUTE : u32 = 8388608 ; pub const DO_DEVICE_IRP_REQUIRES_EXTENSION : u32 = 134217728 ; pub const DRVO_REINIT_REGISTERED : u32 = 8 ; pub const DRVO_INITIALIZED : u32 = 16 ; pub const DRVO_BOOTREINIT_REGISTERED : u32 = 32 ; pub const DRVO_LEGACY_RESOURCES : u32 = 64 ; pub const TXF_MINIVERSION_DEFAULT_VIEW : u32 = 65534 ; pub const OPLOCK_KEY_VERSION_WIN7 : u32 = 1 ; pub const OPLOCK_KEY_VERSION_WIN8 : u32 = 2 ; pub const OPLOCK_KEY_FLAG_PARENT_KEY : u32 = 1 ; pub const OPLOCK_KEY_FLAG_TARGET_KEY : u32 = 2 ; pub const BDCB_IMAGEFLAGS_FAILED_CODE_INTEGRITY : u32 = 1 ; pub const ARBITER_FLAG_BOOT_CONFIG : u32 = 1 ; pub const ARBITER_FLAG_ROOT_ENUM : u32 = 2 ; pub const ARBITER_FLAG_OTHER_ENUM : u32 = 4 ; pub const ARBITER_PARTIAL : u32 = 1 ; pub const MAXIMUM_DEBUG_BARS : u32 = 6 ; pub const DBG_DEVICE_FLAG_HAL_SCRATCH_ALLOCATED : u32 = 1 ; pub const DBG_DEVICE_FLAG_BARS_MAPPED : u32 = 2 ; pub const DBG_DEVICE_FLAG_SCRATCH_ALLOCATED : u32 = 4 ; pub const DBG_DEVICE_FLAG_UNCACHED_MEMORY : u32 = 8 ; pub const DBG_DEVICE_FLAG_SYNTHETIC : u32 = 16 ; pub const HAL_DISPATCH_VERSION : u32 = 4 ; pub const HAL_PLATFORM_DISABLE_WRITE_COMBINING : u32 = 1 ; pub const HAL_PLATFORM_DISABLE_PTCG : u32 = 4 ; pub const HAL_PLATFORM_DISABLE_UC_MAIN_MEMORY : u32 = 8 ; pub const HAL_PLATFORM_ENABLE_WRITE_COMBINING_MMIO : u32 = 16 ; pub const HAL_PLATFORM_ACPI_TABLES_CACHED : u32 = 32 ; pub const PCI_AGP_RATE_1X : u32 = 1 ; pub const PCI_AGP_RATE_2X : u32 = 2 ; pub const PCI_AGP_RATE_4X : u32 = 4 ; pub const PCIX_MODE_CONVENTIONAL_PCI : u32 = 0 ; pub const PCIX_MODE1_66MHZ : u32 = 1 ; pub const PCIX_MODE1_100MHZ : u32 = 2 ; pub const PCIX_MODE1_133MHZ : u32 = 3 ; pub const PCIX_MODE2_266_66MHZ : u32 = 9 ; pub const PCIX_MODE2_266_100MHZ : u32 = 10 ; pub const PCIX_MODE2_266_133MHZ : u32 = 11 ; pub const PCIX_MODE2_533_66MHZ : u32 = 13 ; pub const PCIX_MODE2_533_100MHZ : u32 = 14 ; pub const PCIX_MODE2_533_133MHZ : u32 = 15 ; pub const PCIX_VERSION_MODE1_ONLY : u32 = 0 ; pub const PCIX_VERSION_MODE2_ECC : u32 = 1 ; pub const PCIX_VERSION_DUAL_MODE_ECC : u32 = 2 ; pub const OSC_FIRMWARE_FAILURE : u32 = 2 ; pub const OSC_UNRECOGNIZED_UUID : u32 = 4 ; pub const OSC_UNRECOGNIZED_REVISION : u32 = 8 ; pub const OSC_CAPABILITIES_MASKED : u32 = 16 ; pub const PCI_ROOT_BUS_OSC_METHOD_CAPABILITY_REVISION : u32 = 1 ; pub const PCI_EXPRESS_AER_DEVICE_CONTROL_MASK : u32 = 7 ; pub const PCI_EXPRESS_AER_DEVICE_STATUS_MASK : u32 = 15 ; pub const PCI_DATA_VERSION : u32 = 1 ; pub const PCI_EXPRESS_TPH_ST_LOCATION_NONE : u32 = 0 ; pub const PCI_EXPRESS_TPH_ST_LOCATION_TPH_CAPABILITY : u32 = 1 ; pub const PCI_EXPRESS_TPH_ST_LOCATION_MSIX_TABLE : u32 = 2 ; pub const PCI_EXPRESS_TPH_ST_LOCATION_RESERVED : u32 = 3 ; pub const PCI_BUS_INTERFACE_STANDARD_VERSION : u32 = 2 ; pub const WHEA_ERROR_SOURCE_DESCRIPTOR_VERSION_10 : u32 = 10 ; pub const WHEA_MAX_MC_BANKS : u32 = 32 ; pub const WHEA_ERROR_SOURCE_FLAG_FIRMWAREFIRST : u32 = 1 ; pub const WHEA_ERROR_SOURCE_FLAG_GLOBAL : u32 = 2 ; pub const WHEA_ERROR_SOURCE_FLAG_PREALLOCATE_PER_PROCESSOR : u32 = 4 ; pub const WHEA_ERROR_SOURCE_FLAG_DEFAULTSOURCE : u32 = 2147483648 ; pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_XPFMCE : u32 = 0 ; pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_XPFCMC : u32 = 1 ; pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_XPFNMI : u32 = 2 ; pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_IPFMCA : u32 = 3 ; pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_IPFCMC : u32 = 4 ; pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_IPFCPE : u32 = 5 ; pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_AERROOTPORT : u32 = 6 ; pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_AERENDPOINT : u32 = 7 ; pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_AERBRIDGE : u32 = 8 ; pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_GENERIC : u32 = 9 ; pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_GENERIC_V2 : u32 = 10 ; pub const WHEA_XPF_MC_BANK_STATUSFORMAT_IA32MCA : u32 = 0 ; pub const WHEA_XPF_MC_BANK_STATUSFORMAT_Intel64MCA : u32 = 1 ; pub const WHEA_XPF_MC_BANK_STATUSFORMAT_AMD64MCA : u32 = 2 ; pub const WHEA_NOTIFICATION_TYPE_POLLED : u32 = 0 ; pub const WHEA_NOTIFICATION_TYPE_EXTERNALINTERRUPT : u32 = 1 ; pub const WHEA_NOTIFICATION_TYPE_LOCALINTERRUPT : u32 = 2 ; pub const WHEA_NOTIFICATION_TYPE_SCI : u32 = 3 ; pub const WHEA_NOTIFICATION_TYPE_NMI : u32 = 4 ; pub const WHEA_NOTIFICATION_TYPE_CMCI : u32 = 5 ; pub const WHEA_NOTIFICATION_TYPE_MCE : u32 = 6 ; pub const WHEA_NOTIFICATION_TYPE_GPIO_SIGNAL : u32 = 7 ; pub const WHEA_NOTIFICATION_TYPE_ARMV8_SEA : u32 = 8 ; pub const WHEA_NOTIFICATION_TYPE_ARMV8_SEI : u32 = 9 ; pub const WHEA_NOTIFICATION_TYPE_EXTERNALINTERRUPT_GSIV : u32 = 10 ; pub const WHEA_DISABLE_OFFLINE : u32 = 0 ; pub const WHEA_MEM_PERSISTOFFLINE : u32 = 1 ; pub const WHEA_MEM_PFA_DISABLE : u32 = 2 ; pub const WHEA_MEM_PFA_PAGECOUNT : u32 = 3 ; pub const WHEA_MEM_PFA_THRESHOLD : u32 = 4 ; pub const WHEA_MEM_PFA_TIMEOUT : u32 = 5 ; pub const WHEA_DISABLE_DUMMY_WRITE : u32 = 6 ; pub const ERRTYP_INTERNAL : u32 = 1 ; pub const ERRTYP_BUS : u32 = 16 ; pub const ERRTYP_MEM : u32 = 4 ; pub const ERRTYP_TLB : u32 = 5 ; pub const ERRTYP_CACHE : u32 = 6 ; pub const ERRTYP_FUNCTION : u32 = 7 ; pub const ERRTYP_SELFTEST : u32 = 8 ; pub const ERRTYP_FLOW : u32 = 9 ; pub const ERRTYP_MAP : u32 = 17 ; pub const ERRTYP_IMPROPER : u32 = 18 ; pub const ERRTYP_UNIMPL : u32 = 19 ; pub const ERRTYP_LOSSOFLOCKSTEP : u32 = 20 ; pub const ERRTYP_RESPONSE : u32 = 21 ; pub const ERRTYP_PARITY : u32 = 22 ; pub const ERRTYP_PROTOCOL : u32 = 23 ; pub const ERRTYP_PATHERROR : u32 = 24 ; pub const ERRTYP_TIMEOUT : u32 = 25 ; pub const ERRTYP_POISONED : u32 = 26 ; pub const WHEA_ERROR_RECORD_VALID_PLATFORMID : u32 = 1 ; pub const WHEA_ERROR_RECORD_VALID_TIMESTAMP : u32 = 2 ; pub const WHEA_ERROR_RECORD_VALID_PARTITIONID : u32 = 4 ; pub const WHEA_ERROR_RECORD_FLAGS_RECOVERED : u32 = 1 ; pub const WHEA_ERROR_RECORD_FLAGS_PREVIOUSERROR : u32 = 2 ; pub const WHEA_ERROR_RECORD_FLAGS_SIMULATED : u32 = 4 ; pub const WHEA_ERROR_RECORD_REVISION : u32 = 528 ; pub const WHEA_ERROR_RECORD_SIGNATURE_END : u32 = 4294967295 ; pub const WHEA_SECTION_DESCRIPTOR_FLAGS_PRIMARY : u32 = 1 ; pub const WHEA_SECTION_DESCRIPTOR_FLAGS_CONTAINMENTWRN : u32 = 2 ; pub const WHEA_SECTION_DESCRIPTOR_FLAGS_RESET : u32 = 4 ; pub const WHEA_SECTION_DESCRIPTOR_FLAGS_THRESHOLDEXCEEDED : u32 = 8 ; pub const WHEA_SECTION_DESCRIPTOR_FLAGS_RESOURCENA : u32 = 16 ; pub const WHEA_SECTION_DESCRIPTOR_FLAGS_LATENTERROR : u32 = 32 ; pub const WHEA_SECTION_DESCRIPTOR_FLAGS_PROPAGATED : u32 = 64 ; pub const WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_REVISION : u32 = 768 ; pub const GENPROC_PROCTYPE_XPF : u32 = 0 ; pub const GENPROC_PROCTYPE_IPF : u32 = 1 ; pub const GENPROC_PROCTYPE_ARM : u32 = 2 ; pub const GENPROC_PROCISA_X86 : u32 = 0 ; pub const GENPROC_PROCISA_IPF : u32 = 1 ; pub const GENPROC_PROCISA_X64 : u32 = 2 ; pub const GENPROC_PROCISA_ARM32 : u32 = 4 ; pub const GENPROC_PROCISA_ARM64 : u32 = 8 ; pub const GENPROC_PROCERRTYPE_UNKNOWN : u32 = 0 ; pub const GENPROC_PROCERRTYPE_CACHE : u32 = 1 ; pub const GENPROC_PROCERRTYPE_TLB : u32 = 2 ; pub const GENPROC_PROCERRTYPE_BUS : u32 = 4 ; pub const GENPROC_PROCERRTYPE_MAE : u32 = 8 ; pub const GENPROC_OP_GENERIC : u32 = 0 ; pub const GENPROC_OP_DATAREAD : u32 = 1 ; pub const GENPROC_OP_DATAWRITE : u32 = 2 ; pub const GENPROC_OP_INSTRUCTIONEXE : u32 = 3 ; pub const GENPROC_FLAGS_RESTARTABLE : u32 = 1 ; pub const GENPROC_FLAGS_PRECISEIP : u32 = 2 ; pub const GENPROC_FLAGS_OVERFLOW : u32 = 4 ; pub const GENPROC_FLAGS_CORRECTED : u32 = 8 ; pub const XPF_CACHE_CHECK_TRANSACTIONTYPE_INSTRUCTION : u32 = 0 ; pub const XPF_CACHE_CHECK_TRANSACTIONTYPE_DATAACCESS : u32 = 1 ; pub const XPF_CACHE_CHECK_TRANSACTIONTYPE_GENERIC : u32 = 2 ; pub const XPF_CACHE_CHECK_OPERATION_GENERIC : u32 = 0 ; pub const XPF_CACHE_CHECK_OPERATION_GENREAD : u32 = 1 ; pub const XPF_CACHE_CHECK_OPERATION_GENWRITE : u32 = 2 ; pub const XPF_CACHE_CHECK_OPERATION_DATAREAD : u32 = 3 ; pub const XPF_CACHE_CHECK_OPERATION_DATAWRITE : u32 = 4 ; pub const XPF_CACHE_CHECK_OPERATION_INSTRUCTIONFETCH : u32 = 5 ; pub const XPF_CACHE_CHECK_OPERATION_PREFETCH : u32 = 6 ; pub const XPF_CACHE_CHECK_OPERATION_EVICTION : u32 = 7 ; pub const XPF_CACHE_CHECK_OPERATION_SNOOP : u32 = 8 ; pub const XPF_TLB_CHECK_TRANSACTIONTYPE_INSTRUCTION : u32 = 0 ; pub const XPF_TLB_CHECK_TRANSACTIONTYPE_DATAACCESS : u32 = 1 ; pub const XPF_TLB_CHECK_TRANSACTIONTYPE_GENERIC : u32 = 2 ; pub const XPF_TLB_CHECK_OPERATION_GENERIC : u32 = 0 ; pub const XPF_TLB_CHECK_OPERATION_GENREAD : u32 = 1 ; pub const XPF_TLB_CHECK_OPERATION_GENWRITE : u32 = 2 ; pub const XPF_TLB_CHECK_OPERATION_DATAREAD : u32 = 3 ; pub const XPF_TLB_CHECK_OPERATION_DATAWRITE : u32 = 4 ; pub const XPF_TLB_CHECK_OPERATION_INSTRUCTIONFETCH : u32 = 5 ; pub const XPF_TLB_CHECK_OPERATION_PREFETCH : u32 = 6 ; pub const XPF_BUS_CHECK_TRANSACTIONTYPE_INSTRUCTION : u32 = 0 ; pub const XPF_BUS_CHECK_TRANSACTIONTYPE_DATAACCESS : u32 = 1 ; pub const XPF_BUS_CHECK_TRANSACTIONTYPE_GENERIC : u32 = 2 ; pub const XPF_BUS_CHECK_OPERATION_GENERIC : u32 = 0 ; pub const XPF_BUS_CHECK_OPERATION_GENREAD : u32 = 1 ; pub const XPF_BUS_CHECK_OPERATION_GENWRITE : u32 = 2 ; pub const XPF_BUS_CHECK_OPERATION_DATAREAD : u32 = 3 ; pub const XPF_BUS_CHECK_OPERATION_DATAWRITE : u32 = 4 ; pub const XPF_BUS_CHECK_OPERATION_INSTRUCTIONFETCH : u32 = 5 ; pub const XPF_BUS_CHECK_OPERATION_PREFETCH : u32 = 6 ; pub const XPF_BUS_CHECK_PARTICIPATION_PROCORIGINATED : u32 = 0 ; pub const XPF_BUS_CHECK_PARTICIPATION_PROCRESPONDED : u32 = 1 ; pub const XPF_BUS_CHECK_PARTICIPATION_PROCOBSERVED : u32 = 2 ; pub const XPF_BUS_CHECK_PARTICIPATION_GENERIC : u32 = 3 ; pub const XPF_BUS_CHECK_ADDRESS_MEMORY : u32 = 0 ; pub const XPF_BUS_CHECK_ADDRESS_RESERVED : u32 = 1 ; pub const XPF_BUS_CHECK_ADDRESS_IO : u32 = 2 ; pub const XPF_BUS_CHECK_ADDRESS_OTHER : u32 = 3 ; pub const XPF_MS_CHECK_ERRORTYPE_NOERROR : u32 = 0 ; pub const XPF_MS_CHECK_ERRORTYPE_UNCLASSIFIED : u32 = 1 ; pub const XPF_MS_CHECK_ERRORTYPE_MCROMPARITY : u32 = 2 ; pub const XPF_MS_CHECK_ERRORTYPE_EXTERNAL : u32 = 3 ; pub const XPF_MS_CHECK_ERRORTYPE_FRC : u32 = 4 ; pub const XPF_MS_CHECK_ERRORTYPE_INTERNALUNCLASSIFIED : u32 = 5 ; pub const XPF_CONTEXT_INFO_UNCLASSIFIEDDATA : u32 = 0 ; pub const XPF_CONTEXT_INFO_MSRREGISTERS : u32 = 1 ; pub const XPF_CONTEXT_INFO_32BITCONTEXT : u32 = 2 ; pub const XPF_CONTEXT_INFO_64BITCONTEXT : u32 = 3 ; pub const XPF_CONTEXT_INFO_FXSAVE : u32 = 4 ; pub const XPF_CONTEXT_INFO_32BITDEBUGREGS : u32 = 5 ; pub const XPF_CONTEXT_INFO_64BITDEBUGREGS : u32 = 6 ; pub const XPF_CONTEXT_INFO_MMREGISTERS : u32 = 7 ; pub const WHEA_MEMERRTYPE_UNKNOWN : u32 = 0 ; pub const WHEA_MEMERRTYPE_NOERROR : u32 = 1 ; pub const WHEA_MEMERRTYPE_SINGLEBITECC : u32 = 2 ; pub const WHEA_MEMERRTYPE_MULTIBITECC : u32 = 3 ; pub const WHEA_MEMERRTYPE_SINGLESYMCHIPKILL : u32 = 4 ; pub const WHEA_MEMERRTYPE_MULTISYMCHIPKILL : u32 = 5 ; pub const WHEA_MEMERRTYPE_MASTERABORT : u32 = 6 ; pub const WHEA_MEMERRTYPE_TARGETABORT : u32 = 7 ; pub const WHEA_MEMERRTYPE_PARITYERROR : u32 = 8 ; pub const WHEA_MEMERRTYPE_WATCHDOGTIMEOUT : u32 = 9 ; pub const WHEA_MEMERRTYPE_INVALIDADDRESS : u32 = 10 ; pub const WHEA_MEMERRTYPE_MIRRORBROKEN : u32 = 11 ; pub const WHEA_MEMERRTYPE_MEMORYSPARING : u32 = 12 ; pub const PCIXBUS_ERRTYPE_UNKNOWN : u32 = 0 ; pub const PCIXBUS_ERRTYPE_DATAPARITY : u32 = 1 ; pub const PCIXBUS_ERRTYPE_SYSTEM : u32 = 2 ; pub const PCIXBUS_ERRTYPE_MASTERABORT : u32 = 3 ; pub const PCIXBUS_ERRTYPE_BUSTIMEOUT : u32 = 4 ; pub const PCIXBUS_ERRTYPE_MASTERDATAPARITY : u32 = 5 ; pub const PCIXBUS_ERRTYPE_ADDRESSPARITY : u32 = 6 ; pub const PCIXBUS_ERRTYPE_COMMANDPARITY : u32 = 7 ; pub const WHEA_FIRMWARE_RECORD_TYPE_IPFSAL : u32 = 0 ; pub const WHEA_XPF_MCA_EXTREG_MAX_COUNT : u32 = 24 ; pub const WHEA_XPF_MCA_SECTION_VERSION : u32 = 1 ; pub const WHEA_ERROR_PACKET_V1_VERSION : u32 = 2 ; pub const WHEA_ERROR_PACKET_V2_VERSION : u32 = 3 ; pub const WHEA_ERROR_PACKET_VERSION : u32 = 3 ; pub const WHEA_GENERIC_ENTRY_V2_VERSION : u32 = 768 ; pub const WHEA_GENERIC_ENTRY_VERSION : u32 = 768 ; pub const INJECT_ERRTYPE_PROCESSOR_CORRECTABLE : u32 = 1 ; pub const INJECT_ERRTYPE_PROCESSOR_UNCORRECTABLENONFATAL : u32 = 2 ; pub const INJECT_ERRTYPE_PROCESSOR_UNCORRECTABLEFATAL : u32 = 4 ; pub const INJECT_ERRTYPE_MEMORY_CORRECTABLE : u32 = 8 ; pub const INJECT_ERRTYPE_MEMORY_UNCORRECTABLENONFATAL : u32 = 16 ; pub const INJECT_ERRTYPE_MEMORY_UNCORRECTABLEFATAL : u32 = 32 ; pub const INJECT_ERRTYPE_PCIEXPRESS_CORRECTABLE : u32 = 64 ; pub const INJECT_ERRTYPE_PCIEXPRESS_UNCORRECTABLENONFATAL : u32 = 128 ; pub const INJECT_ERRTYPE_PCIEXPRESS_UNCORRECTABLEFATAL : u32 = 256 ; pub const INJECT_ERRTYPE_PLATFORM_CORRECTABLE : u32 = 512 ; pub const INJECT_ERRTYPE_PLATFORM_UNCORRECTABLENONFATAL : u32 = 1024 ; pub const INJECT_ERRTYPE_PLATFORM_UNCORRECTABLEFATAL : u32 = 2048 ; pub const WHEA_PLUGIN_REGISTRATION_PACKET_VERSION : u32 = 65536 ; pub const PshedFADiscovery : u32 = 1 ; pub const PshedFAErrorSourceControl : u32 = 2 ; pub const PshedFAErrorRecordPersistence : u32 = 4 ; pub const PshedFAErrorInfoRetrieval : u32 = 8 ; pub const PshedFAErrorRecovery : u32 = 16 ; pub const PshedFAErrorInjection : u32 = 32 ; pub const WHEA_WRITE_FLAG_DUMMY : u32 = 1 ; pub const WDF_DRIVER_GLOBALS_NAME_LEN : u32 = 32 ; pub const WDF_TYPE_INIT_BASE_SECTION_NAME : & 'static [ u8 ; 14usize ] = b".kmdftypeinit\0" ; pub const WDF_TYPE_INIT_SECTION_NAME : & 'static [ u8 ; 16usize ] = b".kmdftypeinit$b\0" ; pub const WDF_TYPE_DEFAULT_SECTION_NAME : & 'static [ u8 ; 6usize ] = b".data\0" ; pub const WDF_S0_IDLE_ENABLED_VALUE_NAME : & 'static [ u8 ; 19usize ] = b"IdleInWorkingState\0" ; pub const WDF_SX_WAKE_ENABLED_VALUE_NAME : & 'static [ u8 ; 19usize ] = b"WakeFromSleepState\0" ; pub const WDF_S0_IDLE_DEFAULT_VALUE_NAME : & 'static [ u8 ; 29usize ] = b"WdfDefaultIdleInWorkingState\0" ; pub const WDF_SX_WAKE_DEFAULT_VALUE_NAME : & 'static [ u8 ; 29usize ] = b"WdfDefaultWakeFromSleepState\0" ; pub const WDF_REGKEY_DEVICE_SUBKEY : u32 = 0 ; pub const WDF_REGKEY_DRIVER_SUBKEY : u32 = 0 ; pub type va_list = * mut :: std :: os :: raw :: c_char ; extern "C" { pub fn __va_start ( arg1 : * mut va_list , ... ) ; } pub type __vcrt_bool = bool ; pub type wchar_t = :: std :: os :: raw :: c_ushort ; extern "C" { pub fn __security_init_cookie ( ) ; } extern "C" { pub fn __security_check_cookie ( _StackCookie : usize ) ; } extern "C" { pub fn __report_gsfailure ( _StackCookie : usize ) ; } extern "C" { # [ link_name = "\u{1}__security_cookie" ] pub static mut __security_cookie : usize ; } pub const _EXCEPTION_DISPOSITION_ExceptionContinueExecution : _EXCEPTION_DISPOSITION = 0 ; pub const _EXCEPTION_DISPOSITION_ExceptionContinueSearch : _EXCEPTION_DISPOSITION = 1 ; pub const _EXCEPTION_DISPOSITION_ExceptionNestedException : _EXCEPTION_DISPOSITION = 2 ; pub const _EXCEPTION_DISPOSITION_ExceptionCollidedUnwind : _EXCEPTION_DISPOSITION = 3 ; pub type _EXCEPTION_DISPOSITION = i32 ; pub use self :: _EXCEPTION_DISPOSITION as EXCEPTION_DISPOSITION ; # [ repr ( C ) ] pub struct _DISPATCHER_CONTEXT { _unused : [ u8 ; 0 ] , } extern "C" { pub fn __C_specific_handler ( ExceptionRecord : * mut _EXCEPTION_RECORD , EstablisherFrame : * mut :: std :: os :: raw :: c_void , ContextRecord : * mut _CONTEXT , DispatcherContext : * mut _DISPATCHER_CONTEXT ) -> EXCEPTION_DISPOSITION ; } extern "C" { pub fn _exception_code ( ) -> :: std :: os :: raw :: c_ulong ; } extern "C" { pub fn _exception_info ( ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn _abnormal_termination ( ) -> :: std :: os :: raw :: c_int ; } pub type __crt_bool = bool ; extern "C" { pub fn _invalid_parameter_noinfo ( ) ; } extern "C" { pub fn _invalid_parameter_noinfo_noreturn ( ) ; } extern "C" { pub fn _invoke_watson ( _Expression : * const wchar_t , _FunctionName : * const wchar_t , _FileName : * const wchar_t , _LineNo : :: std :: os :: raw :: c_uint , _Reserved : usize ) ; } pub type errno_t = :: std :: os :: raw :: c_int ; pub type wint_t = :: std :: os :: raw :: c_ushort ; pub type wctype_t = :: std :: os :: raw :: c_ushort ; pub type __time32_t = :: std :: os :: raw :: c_long ; pub type __time64_t = :: std :: os :: raw :: c_longlong ; # [ repr ( C ) ] pub struct __crt_locale_data_public { pub _locale_pctype : * const :: std :: os :: raw :: c_ushort , pub _locale_mb_cur_max : :: std :: os :: raw :: c_int , pub _locale_lc_codepage : :: std :: os :: raw :: c_uint , } # [ repr ( C ) ] pub struct __crt_locale_pointers { pub locinfo : * mut __crt_locale_data , pub mbcinfo : * mut __crt_multibyte_data , } pub type _locale_t = * mut __crt_locale_pointers ; # [ repr ( C ) ] pub struct _Mbstatet { pub _Wchar : :: std :: os :: raw :: c_ulong , pub _Byte : :: std :: os :: raw :: c_ushort , pub _State : :: std :: os :: raw :: c_ushort , } pub type mbstate_t = _Mbstatet ; pub type time_t = __time64_t ; pub type rsize_t = usize ; extern "C" { pub fn iswalnum ( _C : wint_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn iswalpha ( _C : wint_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn iswascii ( _C : wint_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn iswblank ( _C : wint_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn iswcntrl ( _C : wint_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn iswdigit ( _C : wint_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn iswgraph ( _C : wint_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn iswlower ( _C : wint_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn iswprint ( _C : wint_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn iswpunct ( _C : wint_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn iswspace ( _C : wint_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn iswupper ( _C : wint_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn iswxdigit ( _C : wint_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __iswcsymf ( _C : wint_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __iswcsym ( _C : wint_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _iswalnum_l ( _C : wint_t , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _iswalpha_l ( _C : wint_t , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _iswblank_l ( _C : wint_t , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _iswcntrl_l ( _C : wint_t , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _iswdigit_l ( _C : wint_t , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _iswgraph_l ( _C : wint_t , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _iswlower_l ( _C : wint_t , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _iswprint_l ( _C : wint_t , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _iswpunct_l ( _C : wint_t , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _iswspace_l ( _C : wint_t , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _iswupper_l ( _C : wint_t , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _iswxdigit_l ( _C : wint_t , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _iswcsymf_l ( _C : wint_t , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _iswcsym_l ( _C : wint_t , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn towupper ( _C : wint_t ) -> wint_t ; } extern "C" { pub fn towlower ( _C : wint_t ) -> wint_t ; } extern "C" { pub fn iswctype ( _C : wint_t , _Type : wctype_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _towupper_l ( _C : wint_t , _Locale : _locale_t ) -> wint_t ; } extern "C" { pub fn _towlower_l ( _C : wint_t , _Locale : _locale_t ) -> wint_t ; } extern "C" { pub fn _iswctype_l ( _C : wint_t , _Type : wctype_t , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn isleadbyte ( _C : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _isleadbyte_l ( _C : :: std :: os :: raw :: c_int , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn is_wctype ( _C : wint_t , _Type : wctype_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _isctype ( _C : :: std :: os :: raw :: c_int , _Type : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _isctype_l ( _C : :: std :: os :: raw :: c_int , _Type : :: std :: os :: raw :: c_int , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn isalpha ( _C : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _isalpha_l ( _C : :: std :: os :: raw :: c_int , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn isupper ( _C : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _isupper_l ( _C : :: std :: os :: raw :: c_int , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn islower ( _C : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _islower_l ( _C : :: std :: os :: raw :: c_int , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn isdigit ( _C : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _isdigit_l ( _C : :: std :: os :: raw :: c_int , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn isxdigit ( _C : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _isxdigit_l ( _C : :: std :: os :: raw :: c_int , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn isspace ( _C : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _isspace_l ( _C : :: std :: os :: raw :: c_int , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ispunct ( _C : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _ispunct_l ( _C : :: std :: os :: raw :: c_int , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn isblank ( _C : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _isblank_l ( _C : :: std :: os :: raw :: c_int , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn isalnum ( _C : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _isalnum_l ( _C : :: std :: os :: raw :: c_int , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn isprint ( _C : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _isprint_l ( _C : :: std :: os :: raw :: c_int , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn isgraph ( _C : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _isgraph_l ( _C : :: std :: os :: raw :: c_int , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn iscntrl ( _C : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _iscntrl_l ( _C : :: std :: os :: raw :: c_int , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn toupper ( _C : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn tolower ( _C : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _tolower ( _C : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _tolower_l ( _C : :: std :: os :: raw :: c_int , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _toupper ( _C : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _toupper_l ( _C : :: std :: os :: raw :: c_int , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __isascii ( _C : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __toascii ( _C : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __iscsymf ( _C : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __iscsym ( _C : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } pub type POINTER_64_INT = :: std :: os :: raw :: c_ulonglong ; pub type INT8 = :: std :: os :: raw :: c_schar ; pub type PINT8 = * mut :: std :: os :: raw :: c_schar ; pub type INT16 = :: std :: os :: raw :: c_short ; pub type PINT16 = * mut :: std :: os :: raw :: c_short ; pub type INT32 = :: std :: os :: raw :: c_int ; pub type PINT32 = * mut :: std :: os :: raw :: c_int ; pub type INT64 = :: std :: os :: raw :: c_longlong ; pub type PINT64 = * mut :: std :: os :: raw :: c_longlong ; pub type UINT8 = :: std :: os :: raw :: c_uchar ; pub type PUINT8 = * mut :: std :: os :: raw :: c_uchar ; pub type UINT16 = :: std :: os :: raw :: c_ushort ; pub type PUINT16 = * mut :: std :: os :: raw :: c_ushort ; pub type UINT32 = :: std :: os :: raw :: c_uint ; pub type PUINT32 = * mut :: std :: os :: raw :: c_uint ; pub type UINT64 = :: std :: os :: raw :: c_ulonglong ; pub type PUINT64 = * mut :: std :: os :: raw :: c_ulonglong ; pub type LONG32 = :: std :: os :: raw :: c_int ; pub type PLONG32 = * mut :: std :: os :: raw :: c_int ; pub type ULONG32 = :: std :: os :: raw :: c_uint ; pub type PULONG32 = * mut :: std :: os :: raw :: c_uint ; pub type DWORD32 = :: std :: os :: raw :: c_uint ; pub type PDWORD32 = * mut :: std :: os :: raw :: c_uint ; pub type INT_PTR = :: std :: os :: raw :: c_longlong ; pub type PINT_PTR = * mut :: std :: os :: raw :: c_longlong ; pub type UINT_PTR = :: std :: os :: raw :: c_ulonglong ; pub type PUINT_PTR = * mut :: std :: os :: raw :: c_ulonglong ; pub type LONG_PTR = :: std :: os :: raw :: c_longlong ; pub type PLONG_PTR = * mut :: std :: os :: raw :: c_longlong ; pub type ULONG_PTR = :: std :: os :: raw :: c_ulonglong ; pub type PULONG_PTR = * mut :: std :: os :: raw :: c_ulonglong ; pub type SHANDLE_PTR = :: std :: os :: raw :: c_longlong ; pub type HANDLE_PTR = :: std :: os :: raw :: c_ulonglong ; pub type UHALF_PTR = :: std :: os :: raw :: c_uint ; pub type PUHALF_PTR = * mut :: std :: os :: raw :: c_uint ; pub type HALF_PTR = :: std :: os :: raw :: c_int ; pub type PHALF_PTR = * mut :: std :: os :: raw :: c_int ; pub type SIZE_T = ULONG_PTR ; pub type PSIZE_T = * mut ULONG_PTR ; pub type SSIZE_T = LONG_PTR ; pub type PSSIZE_T = * mut LONG_PTR ; pub type DWORD_PTR = ULONG_PTR ; pub type PDWORD_PTR = * mut ULONG_PTR ; pub type LONG64 = :: std :: os :: raw :: c_longlong ; pub type PLONG64 = * mut :: std :: os :: raw :: c_longlong ; pub type ULONG64 = :: std :: os :: raw :: c_ulonglong ; pub type PULONG64 = * mut :: std :: os :: raw :: c_ulonglong ; pub type DWORD64 = :: std :: os :: raw :: c_ulonglong ; pub type PDWORD64 = * mut :: std :: os :: raw :: c_ulonglong ; pub type KAFFINITY = ULONG_PTR ; pub type PKAFFINITY = * mut KAFFINITY ; pub type PVOID = * mut :: std :: os :: raw :: c_void ; pub type CHAR = :: std :: os :: raw :: c_char ; pub type SHORT = :: std :: os :: raw :: c_short ; pub type LONG = :: std :: os :: raw :: c_long ; pub type INT = :: std :: os :: raw :: c_int ; pub type WCHAR = wchar_t ; pub type PWCHAR = * mut WCHAR ; pub type LPWCH = * mut WCHAR ; pub type PWCH = * mut WCHAR ; pub type LPCWCH = * const WCHAR ; pub type PCWCH = * const WCHAR ; pub type NWPSTR = * mut WCHAR ; pub type LPWSTR = * mut WCHAR ; pub type PWSTR = * mut WCHAR ; pub type PZPWSTR = * mut PWSTR ; pub type PCZPWSTR = * const PWSTR ; pub type LPUWSTR = * mut WCHAR ; pub type PUWSTR = * mut WCHAR ; pub type LPCWSTR = * const WCHAR ; pub type PCWSTR = * const WCHAR ; pub type PZPCWSTR = * mut PCWSTR ; pub type PCZPCWSTR = * const PCWSTR ; pub type LPCUWSTR = * const WCHAR ; pub type PCUWSTR = * const WCHAR ; pub type PZZWSTR = * mut WCHAR ; pub type PCZZWSTR = * const WCHAR ; pub type PUZZWSTR = * mut WCHAR ; pub type PCUZZWSTR = * const WCHAR ; pub type PNZWCH = * mut WCHAR ; pub type PCNZWCH = * const WCHAR ; pub type PUNZWCH = * mut WCHAR ; pub type PCUNZWCH = * const WCHAR ; pub type LPCWCHAR = * const WCHAR ; pub type PCWCHAR = * const WCHAR ; pub type LPCUWCHAR = * const WCHAR ; pub type PCUWCHAR = * const WCHAR ; pub type UCSCHAR = :: std :: os :: raw :: c_ulong ; pub type PUCSCHAR = * mut UCSCHAR ; pub type PCUCSCHAR = * const UCSCHAR ; pub type PUCSSTR = * mut UCSCHAR ; pub type PUUCSSTR = * mut UCSCHAR ; pub type PCUCSSTR = * const UCSCHAR ; pub type PCUUCSSTR = * const UCSCHAR ; pub type PUUCSCHAR = * mut UCSCHAR ; pub type PCUUCSCHAR = * const UCSCHAR ; pub type PCHAR = * mut CHAR ; pub type LPCH = * mut CHAR ; pub type PCH = * mut CHAR ; pub type LPCCH = * const CHAR ; pub type PCCH = * const CHAR ; pub type NPSTR = * mut CHAR ; pub type LPSTR = * mut CHAR ; pub type PSTR = * mut CHAR ; pub type PZPSTR = * mut PSTR ; pub type PCZPSTR = * const PSTR ; pub type LPCSTR = * const CHAR ; pub type PCSTR = * const CHAR ; pub type PZPCSTR = * mut PCSTR ; pub type PCZPCSTR = * const PCSTR ; pub type PZZSTR = * mut CHAR ; pub type PCZZSTR = * const CHAR ; pub type PNZCH = * mut CHAR ; pub type PCNZCH = * const CHAR ; pub type TCHAR = :: std :: os :: raw :: c_char ; pub type PTCHAR = * mut :: std :: os :: raw :: c_char ; pub type TUCHAR = :: std :: os :: raw :: c_uchar ; pub type PTUCHAR = * mut :: std :: os :: raw :: c_uchar ; pub type LPTCH = LPCH ; pub type PTCH = LPCH ; pub type LPCTCH = LPCCH ; pub type PCTCH = LPCCH ; pub type PTSTR = LPSTR ; pub type LPTSTR = LPSTR ; pub type PUTSTR = LPSTR ; pub type LPUTSTR = LPSTR ; pub type PCTSTR = LPCSTR ; pub type LPCTSTR = LPCSTR ; pub type PCUTSTR = LPCSTR ; pub type LPCUTSTR = LPCSTR ; pub type PZZTSTR = PZZSTR ; pub type PUZZTSTR = PZZSTR ; pub type PCZZTSTR = PCZZSTR ; pub type PCUZZTSTR = PCZZSTR ; pub type PZPTSTR = PZPSTR ; pub type PNZTCH = PNZCH ; pub type PUNZTCH = PNZCH ; pub type PCNZTCH = PCNZCH ; pub type PCUNZTCH = PCNZCH ; pub type DOUBLE = f64 ; # [ repr ( C ) ] pub struct _QUAD { pub __bindgen_anon_1 : _QUAD__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _QUAD__bindgen_ty_1 { pub UseThisFieldToCopy : __BindgenUnionField < :: std :: os :: raw :: c_longlong > , pub DoNotUseThisField : __BindgenUnionField < f64 > , pub bindgen_union_field : u64 , } pub type QUAD = _QUAD ; pub type PSHORT = * mut SHORT ; pub type PLONG = * mut LONG ; pub type PQUAD = * mut QUAD ; pub type UCHAR = :: std :: os :: raw :: c_uchar ; pub type USHORT = :: std :: os :: raw :: c_ushort ; pub type ULONG = :: std :: os :: raw :: c_ulong ; pub type UQUAD = QUAD ; pub type PUCHAR = * mut UCHAR ; pub type PUSHORT = * mut USHORT ; pub type PULONG = * mut ULONG ; pub type PUQUAD = * mut UQUAD ; pub type PCUCHAR = * const UCHAR ; pub type PCUSHORT = * const USHORT ; pub type PCULONG = * const ULONG ; pub type PCUQUAD = * const UQUAD ; pub type SCHAR = :: std :: os :: raw :: c_schar ; pub type PSCHAR = * mut SCHAR ; pub type PCSCHAR = * const SCHAR ; # [ repr ( C ) ] pub struct _PROCESSOR_NUMBER { pub Group : USHORT , pub Number : UCHAR , pub Reserved : UCHAR , } pub type PROCESSOR_NUMBER = _PROCESSOR_NUMBER ; pub type PPROCESSOR_NUMBER = * mut _PROCESSOR_NUMBER ; # [ repr ( C ) ] pub struct _GROUP_AFFINITY { pub Mask : KAFFINITY , pub Group : USHORT , pub Reserved : [ USHORT ; 3usize ] , } pub type GROUP_AFFINITY = _GROUP_AFFINITY ; pub type PGROUP_AFFINITY = * mut _GROUP_AFFINITY ; pub type HANDLE = * mut :: std :: os :: raw :: c_void ; pub type PHANDLE = * mut HANDLE ; pub type FCHAR = UCHAR ; pub type FSHORT = USHORT ; pub type FLONG = ULONG ; pub type HRESULT = :: std :: os :: raw :: c_long ; pub type CCHAR = :: std :: os :: raw :: c_char ; pub type CSHORT = :: std :: os :: raw :: c_short ; pub type CLONG = ULONG ; pub type PCCHAR = * mut CCHAR ; pub type PCSHORT = * mut CSHORT ; pub type PCLONG = * mut CLONG ; pub type LCID = ULONG ; pub type PLCID = PULONG ; pub type LANGID = USHORT ; pub const COMPARTMENT_ID_UNSPECIFIED_COMPARTMENT_ID : COMPARTMENT_ID = 0 ; pub const COMPARTMENT_ID_DEFAULT_COMPARTMENT_ID : COMPARTMENT_ID = 1 ; pub type COMPARTMENT_ID = i32 ; pub type PCOMPARTMENT_ID = * mut COMPARTMENT_ID ; pub type LOGICAL = ULONG ; pub type PLOGICAL = * mut ULONG ; pub type NTSTATUS = LONG ; pub type PNTSTATUS = * mut NTSTATUS ; pub type PCNTSTATUS = * const NTSTATUS ; pub type SECURITY_STATUS = :: std :: os :: raw :: c_long ; # [ repr ( C ) ] pub struct _FLOAT128 { pub LowPart : :: std :: os :: raw :: c_longlong , pub HighPart : :: std :: os :: raw :: c_longlong , } pub type FLOAT128 = _FLOAT128 ; pub type PFLOAT128 = * mut FLOAT128 ; pub type LONGLONG = :: std :: os :: raw :: c_longlong ; pub type ULONGLONG = :: std :: os :: raw :: c_ulonglong ; pub type PLONGLONG = * mut LONGLONG ; pub type PULONGLONG = * mut ULONGLONG ; pub type USN = LONGLONG ; # [ repr ( C ) ] pub struct _LARGE_INTEGER { pub __bindgen_anon_1 : __BindgenUnionField < _LARGE_INTEGER__bindgen_ty_1 > , pub u : __BindgenUnionField < _LARGE_INTEGER__bindgen_ty_2 > , pub QuadPart : __BindgenUnionField < LONGLONG > , pub bindgen_union_field : u64 , } # [ repr ( C ) ] pub struct _LARGE_INTEGER__bindgen_ty_1 { pub LowPart : ULONG , pub HighPart : LONG , } # [ repr ( C ) ] pub struct _LARGE_INTEGER__bindgen_ty_2 { pub LowPart : ULONG , pub HighPart : LONG , } pub type LARGE_INTEGER = _LARGE_INTEGER ; pub type PLARGE_INTEGER = * mut LARGE_INTEGER ; # [ repr ( C ) ] pub struct _ULARGE_INTEGER { pub __bindgen_anon_1 : __BindgenUnionField < _ULARGE_INTEGER__bindgen_ty_1 > , pub u : __BindgenUnionField < _ULARGE_INTEGER__bindgen_ty_2 > , pub QuadPart : __BindgenUnionField < ULONGLONG > , pub bindgen_union_field : u64 , } # [ repr ( C ) ] pub struct _ULARGE_INTEGER__bindgen_ty_1 { pub LowPart : ULONG , pub HighPart : ULONG , } # [ repr ( C ) ] pub struct _ULARGE_INTEGER__bindgen_ty_2 { pub LowPart : ULONG , pub HighPart : ULONG , } pub type ULARGE_INTEGER = _ULARGE_INTEGER ; pub type PULARGE_INTEGER = * mut ULARGE_INTEGER ; pub type RTL_REFERENCE_COUNT = LONG_PTR ; pub type PRTL_REFERENCE_COUNT = * mut LONG_PTR ; pub type RTL_REFERENCE_COUNT32 = LONG ; pub type PRTL_REFERENCE_COUNT32 = * mut LONG ; # [ repr ( C ) ] pub struct _LUID { pub LowPart : ULONG , pub HighPart : LONG , } pub type LUID = _LUID ; pub type PLUID = * mut _LUID ; pub type DWORDLONG = ULONGLONG ; pub type PDWORDLONG = * mut DWORDLONG ; pub type PHYSICAL_ADDRESS = LARGE_INTEGER ; pub type PPHYSICAL_ADDRESS = * mut LARGE_INTEGER ; extern "C" { pub fn _rotl8 ( Value : :: std :: os :: raw :: c_uchar , Shift : :: std :: os :: raw :: c_uchar ) -> :: std :: os :: raw :: c_uchar ; } extern "C" { pub fn _rotl16 ( Value : :: std :: os :: raw :: c_ushort , Shift : :: std :: os :: raw :: c_uchar ) -> :: std :: os :: raw :: c_ushort ; } extern "C" { pub fn _rotr8 ( Value : :: std :: os :: raw :: c_uchar , Shift : :: std :: os :: raw :: c_uchar ) -> :: std :: os :: raw :: c_uchar ; } extern "C" { pub fn _rotr16 ( Value : :: std :: os :: raw :: c_ushort , Shift : :: std :: os :: raw :: c_uchar ) -> :: std :: os :: raw :: c_ushort ; } extern "C" { pub fn _rotl ( Value : :: std :: os :: raw :: c_uint , Shift : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_uint ; } extern "C" { pub fn _rotl64 ( Value : :: std :: os :: raw :: c_ulonglong , Shift : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_ulonglong ; } extern "C" { pub fn _rotr ( Value : :: std :: os :: raw :: c_uint , Shift : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_uint ; } extern "C" { pub fn _rotr64 ( Value : :: std :: os :: raw :: c_ulonglong , Shift : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_ulonglong ; } pub const _EVENT_TYPE_NotificationEvent : _EVENT_TYPE = 0 ; pub const _EVENT_TYPE_SynchronizationEvent : _EVENT_TYPE = 1 ; pub type _EVENT_TYPE = i32 ; pub use self :: _EVENT_TYPE as EVENT_TYPE ; pub const _TIMER_TYPE_NotificationTimer : _TIMER_TYPE = 0 ; pub const _TIMER_TYPE_SynchronizationTimer : _TIMER_TYPE = 1 ; pub type _TIMER_TYPE = i32 ; pub use self :: _TIMER_TYPE as TIMER_TYPE ; pub const _WAIT_TYPE_WaitAll : _WAIT_TYPE = 0 ; pub const _WAIT_TYPE_WaitAny : _WAIT_TYPE = 1 ; pub const _WAIT_TYPE_WaitNotification : _WAIT_TYPE = 2 ; pub const _WAIT_TYPE_WaitDequeue : _WAIT_TYPE = 3 ; pub type _WAIT_TYPE = i32 ; pub use self :: _WAIT_TYPE as WAIT_TYPE ; pub type PSZ = * mut CHAR ; pub type PCSZ = * const :: std :: os :: raw :: c_char ; pub type RTL_STRING_LENGTH_TYPE = USHORT ; # [ repr ( C ) ] pub struct _STRING { pub Length : USHORT , pub MaximumLength : USHORT , pub Buffer : PCHAR , } pub type STRING = _STRING ; pub type PSTRING = * mut STRING ; pub type ANSI_STRING = STRING ; pub type PANSI_STRING = PSTRING ; pub type OEM_STRING = STRING ; pub type POEM_STRING = PSTRING ; pub type PCOEM_STRING = * const STRING ; # [ repr ( C ) ] pub struct _CSTRING { pub Length : USHORT , pub MaximumLength : USHORT , pub Buffer : * const :: std :: os :: raw :: c_char , } pub type CSTRING = _CSTRING ; pub type PCSTRING = * mut CSTRING ; pub type CANSI_STRING = STRING ; pub type PCANSI_STRING = PSTRING ; # [ repr ( C ) ] pub struct _UNICODE_STRING { pub Length : USHORT , pub MaximumLength : USHORT , pub Buffer : PWCH , } pub type UNICODE_STRING = _UNICODE_STRING ; pub type PUNICODE_STRING = * mut UNICODE_STRING ; pub type PCUNICODE_STRING = * const UNICODE_STRING ; pub type BOOLEAN = UCHAR ; pub type PBOOLEAN = * mut BOOLEAN ; # [ repr ( C ) ] pub struct _LIST_ENTRY { pub Flink : * mut _LIST_ENTRY , pub Blink : * mut _LIST_ENTRY , } pub type LIST_ENTRY = _LIST_ENTRY ; pub type PLIST_ENTRY = * mut _LIST_ENTRY ; pub type PRLIST_ENTRY = * mut _LIST_ENTRY ; # [ repr ( C ) ] pub struct _SINGLE_LIST_ENTRY { pub Next : * mut _SINGLE_LIST_ENTRY , } pub type SINGLE_LIST_ENTRY = _SINGLE_LIST_ENTRY ; pub type PSINGLE_LIST_ENTRY = * mut _SINGLE_LIST_ENTRY ; # [ repr ( C ) ] pub struct _RTL_BALANCED_NODE { pub __bindgen_anon_1 : _RTL_BALANCED_NODE__bindgen_ty_1 , pub __bindgen_anon_2 : _RTL_BALANCED_NODE__bindgen_ty_2 , } # [ repr ( C ) ] pub struct _RTL_BALANCED_NODE__bindgen_ty_1 { pub Children : __BindgenUnionField < [ * mut _RTL_BALANCED_NODE ; 2usize ] > , pub __bindgen_anon_1 : __BindgenUnionField < _RTL_BALANCED_NODE__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : [ u64 ; 2usize ] , } # [ repr ( C ) ] pub struct _RTL_BALANCED_NODE__bindgen_ty_1__bindgen_ty_1 { pub Left : * mut _RTL_BALANCED_NODE , pub Right : * mut _RTL_BALANCED_NODE , } # [ repr ( C ) ] pub struct _RTL_BALANCED_NODE__bindgen_ty_2 { pub _bitfield_1 : __BindgenUnionField < __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > > , pub ParentValue : __BindgenUnionField < ULONG_PTR > , pub bindgen_union_field : u64 , } impl _RTL_BALANCED_NODE__bindgen_ty_2 { # [ inline ] pub fn Red ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . as_ref ( ) . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_Red ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . as_mut ( ) . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Balance ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . as_ref ( ) . get ( 1usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_Balance ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . as_mut ( ) . set ( 1usize , 2u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Red : UCHAR , Balance : UCHAR ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let Red : u8 = unsafe { :: std :: mem :: transmute ( Red ) } ; Red as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 2u8 , { let Balance : u8 = unsafe { :: std :: mem :: transmute ( Balance ) } ; Balance as u64 } ) ; __bindgen_bitfield_unit } } pub type RTL_BALANCED_NODE = _RTL_BALANCED_NODE ; pub type PRTL_BALANCED_NODE = * mut _RTL_BALANCED_NODE ; # [ repr ( C ) ] pub struct LIST_ENTRY32 { pub Flink : ULONG , pub Blink : ULONG , } pub type PLIST_ENTRY32 = * mut LIST_ENTRY32 ; # [ repr ( C ) ] pub struct LIST_ENTRY64 { pub Flink : ULONGLONG , pub Blink : ULONGLONG , } pub type PLIST_ENTRY64 = * mut LIST_ENTRY64 ; # [ repr ( C ) ] pub struct _SINGLE_LIST_ENTRY32 { pub Next : ULONG , } pub type SINGLE_LIST_ENTRY32 = _SINGLE_LIST_ENTRY32 ; pub type PSINGLE_LIST_ENTRY32 = * mut _SINGLE_LIST_ENTRY32 ; # [ repr ( C ) ] pub struct _WNF_STATE_NAME { pub Data : [ ULONG ; 2usize ] , } pub type WNF_STATE_NAME = _WNF_STATE_NAME ; pub type PWNF_STATE_NAME = * mut _WNF_STATE_NAME ; pub type PCWNF_STATE_NAME = * const _WNF_STATE_NAME ; # [ repr ( C ) ] pub struct _STRING32 { pub Length : USHORT , pub MaximumLength : USHORT , pub Buffer : ULONG , } pub type STRING32 = _STRING32 ; pub type PSTRING32 = * mut STRING32 ; pub type UNICODE_STRING32 = STRING32 ; pub type PUNICODE_STRING32 = * mut UNICODE_STRING32 ; pub type ANSI_STRING32 = STRING32 ; pub type PANSI_STRING32 = * mut ANSI_STRING32 ; # [ repr ( C ) ] pub struct _STRING64 { pub Length : USHORT , pub MaximumLength : USHORT , pub Buffer : ULONGLONG , } pub type STRING64 = _STRING64 ; pub type PSTRING64 = * mut STRING64 ; pub type UNICODE_STRING64 = STRING64 ; pub type PUNICODE_STRING64 = * mut UNICODE_STRING64 ; pub type ANSI_STRING64 = STRING64 ; pub type PANSI_STRING64 = * mut ANSI_STRING64 ; # [ repr ( C ) ] pub struct _OBJECT_ATTRIBUTES64 { pub Length : ULONG , pub RootDirectory : ULONG64 , pub ObjectName : ULONG64 , pub Attributes : ULONG , pub SecurityDescriptor : ULONG64 , pub SecurityQualityOfService : ULONG64 , } pub type OBJECT_ATTRIBUTES64 = _OBJECT_ATTRIBUTES64 ; pub type POBJECT_ATTRIBUTES64 = * mut OBJECT_ATTRIBUTES64 ; pub type PCOBJECT_ATTRIBUTES64 = * const OBJECT_ATTRIBUTES64 ; # [ repr ( C ) ] pub struct _OBJECT_ATTRIBUTES32 { pub Length : ULONG , pub RootDirectory : ULONG , pub ObjectName : ULONG , pub Attributes : ULONG , pub SecurityDescriptor : ULONG , pub SecurityQualityOfService : ULONG , } pub type OBJECT_ATTRIBUTES32 = _OBJECT_ATTRIBUTES32 ; pub type POBJECT_ATTRIBUTES32 = * mut OBJECT_ATTRIBUTES32 ; pub type PCOBJECT_ATTRIBUTES32 = * const OBJECT_ATTRIBUTES32 ; # [ repr ( C ) ] pub struct _OBJECT_ATTRIBUTES { pub Length : ULONG , pub RootDirectory : HANDLE , pub ObjectName : PUNICODE_STRING , pub Attributes : ULONG , pub SecurityDescriptor : PVOID , pub SecurityQualityOfService : PVOID , } pub type OBJECT_ATTRIBUTES = _OBJECT_ATTRIBUTES ; pub type POBJECT_ATTRIBUTES = * mut OBJECT_ATTRIBUTES ; pub type PCOBJECT_ATTRIBUTES = * const OBJECT_ATTRIBUTES ; # [ repr ( C ) ] pub struct _GUID { pub Data1 : :: std :: os :: raw :: c_ulong , pub Data2 : :: std :: os :: raw :: c_ushort , pub Data3 : :: std :: os :: raw :: c_ushort , pub Data4 : [ :: std :: os :: raw :: c_uchar ; 8usize ] , } pub type GUID = _GUID ; pub type LPGUID = * mut GUID ; pub type LPCGUID = * const GUID ; pub type IID = GUID ; pub type LPIID = * mut IID ; pub type CLSID = GUID ; pub type LPCLSID = * mut CLSID ; pub type FMTID = GUID ; pub type LPFMTID = * mut FMTID ; extern "C" { pub fn _errno ( ) -> * mut :: std :: os :: raw :: c_int ; } extern "C" { pub fn _set_errno ( _Value : :: std :: os :: raw :: c_int ) -> errno_t ; } extern "C" { pub fn _get_errno ( _Value : * mut :: std :: os :: raw :: c_int ) -> errno_t ; } extern "C" { pub fn __doserrno ( ) -> * mut :: std :: os :: raw :: c_ulong ; } extern "C" { pub fn _set_doserrno ( _Value : :: std :: os :: raw :: c_ulong ) -> errno_t ; } extern "C" { pub fn _get_doserrno ( _Value : * mut :: std :: os :: raw :: c_ulong ) -> errno_t ; } extern "C" { pub fn memchr ( _Buf : * const :: std :: os :: raw :: c_void , _Val : :: std :: os :: raw :: c_int , _MaxCount : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn memcmp ( _Buf1 : * const :: std :: os :: raw :: c_void , _Buf2 : * const :: std :: os :: raw :: c_void , _Size : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn memcpy ( _Dst : * mut :: std :: os :: raw :: c_void , _Src : * const :: std :: os :: raw :: c_void , _Size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn memmove ( _Dst : * mut :: std :: os :: raw :: c_void , _Src : * const :: std :: os :: raw :: c_void , _Size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn memset ( _Dst : * mut :: std :: os :: raw :: c_void , _Val : :: std :: os :: raw :: c_int , _Size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn strchr ( _Str : * const :: std :: os :: raw :: c_char , _Val : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strrchr ( _Str : * const :: std :: os :: raw :: c_char , _Ch : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strstr ( _Str : * const :: std :: os :: raw :: c_char , _SubStr : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn wcschr ( _Str : * const wchar_t , _Ch : wchar_t ) -> * mut :: std :: os :: raw :: c_ushort ; } extern "C" { pub fn wcsrchr ( _Str : * const wchar_t , _Ch : wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn wcsstr ( _Str : * const wchar_t , _SubStr : * const wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn _memicmp ( _Buf1 : * const :: std :: os :: raw :: c_void , _Buf2 : * const :: std :: os :: raw :: c_void , _Size : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _memicmp_l ( _Buf1 : * const :: std :: os :: raw :: c_void , _Buf2 : * const :: std :: os :: raw :: c_void , _Size : usize , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn memccpy ( _Dst : * mut :: std :: os :: raw :: c_void , _Src : * const :: std :: os :: raw :: c_void , _Val : :: std :: os :: raw :: c_int , _Size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn memicmp ( _Buf1 : * const :: std :: os :: raw :: c_void , _Buf2 : * const :: std :: os :: raw :: c_void , _Size : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn wcscat_s ( _Destination : * mut wchar_t , _SizeInWords : rsize_t , _Source : * const wchar_t ) -> errno_t ; } extern "C" { pub fn wcscpy_s ( _Destination : * mut wchar_t , _SizeInWords : rsize_t , _Source : * const wchar_t ) -> errno_t ; } extern "C" { pub fn wcsncat_s ( _Destination : * mut wchar_t , _SizeInWords : rsize_t , _Source : * const wchar_t , _MaxCount : rsize_t ) -> errno_t ; } extern "C" { pub fn wcsncpy_s ( _Destination : * mut wchar_t , _SizeInWords : rsize_t , _Source : * const wchar_t , _MaxCount : rsize_t ) -> errno_t ; } extern "C" { pub fn wcstok_s ( _String : * mut wchar_t , _Delimiter : * const wchar_t , _Context : * mut * mut wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn _wcsdup ( _String : * const wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn wcscat ( _Destination : * mut wchar_t , _Source : * const wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn wcscmp ( _String1 : * const wchar_t , _String2 : * const wchar_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn wcscpy ( _Destination : * mut wchar_t , _Source : * const wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn wcscspn ( _String : * const wchar_t , _Control : * const wchar_t ) -> usize ; } extern "C" { pub fn wcslen ( _String : * const wchar_t ) -> :: std :: os :: raw :: c_ulonglong ; } extern "C" { pub fn wcsnlen ( _Source : * const wchar_t , _MaxCount : usize ) -> usize ; } extern "C" { pub fn wcsncat ( _Destination : * mut wchar_t , _Source : * const wchar_t , _Count : usize ) -> * mut wchar_t ; } extern "C" { pub fn wcsncmp ( _String1 : * const wchar_t , _String2 : * const wchar_t , _MaxCount : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn wcsncpy ( _Destination : * mut wchar_t , _Source : * const wchar_t , _Count : usize ) -> * mut wchar_t ; } extern "C" { pub fn wcspbrk ( _String : * const wchar_t , _Control : * const wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn wcsspn ( _String : * const wchar_t , _Control : * const wchar_t ) -> usize ; } extern "C" { pub fn wcstok ( _String : * mut wchar_t , _Delimiter : * const wchar_t , _Context : * mut * mut wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn _wcserror ( _ErrorNumber : :: std :: os :: raw :: c_int ) -> * mut wchar_t ; } extern "C" { pub fn _wcserror_s ( _Buffer : * mut wchar_t , _SizeInWords : usize , _ErrorNumber : :: std :: os :: raw :: c_int ) -> errno_t ; } extern "C" { pub fn __wcserror ( _String : * const wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn __wcserror_s ( _Buffer : * mut wchar_t , _SizeInWords : usize , _ErrorMessage : * const wchar_t ) -> errno_t ; } extern "C" { pub fn _wcsicmp ( _String1 : * const wchar_t , _String2 : * const wchar_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _wcsicmp_l ( _String1 : * const wchar_t , _String2 : * const wchar_t , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _wcsnicmp ( _String1 : * const wchar_t , _String2 : * const wchar_t , _MaxCount : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _wcsnicmp_l ( _String1 : * const wchar_t , _String2 : * const wchar_t , _MaxCount : usize , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _wcsnset_s ( _Destination : * mut wchar_t , _SizeInWords : usize , _Value : wchar_t , _MaxCount : usize ) -> errno_t ; } extern "C" { pub fn _wcsnset ( _String : * mut wchar_t , _Value : wchar_t , _MaxCount : usize ) -> * mut wchar_t ; } extern "C" { pub fn _wcsrev ( _String : * mut wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn _wcsset_s ( _Destination : * mut wchar_t , _SizeInWords : usize , _Value : wchar_t ) -> errno_t ; } extern "C" { pub fn _wcsset ( _String : * mut wchar_t , _Value : wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn _wcslwr_s ( _String : * mut wchar_t , _SizeInWords : usize ) -> errno_t ; } extern "C" { pub fn _wcslwr ( _String : * mut wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn _wcslwr_s_l ( _String : * mut wchar_t , _SizeInWords : usize , _Locale : _locale_t ) -> errno_t ; } extern "C" { pub fn _wcslwr_l ( _String : * mut wchar_t , _Locale : _locale_t ) -> * mut wchar_t ; } extern "C" { pub fn _wcsupr_s ( _String : * mut wchar_t , _Size : usize ) -> errno_t ; } extern "C" { pub fn _wcsupr ( _String : * mut wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn _wcsupr_s_l ( _String : * mut wchar_t , _Size : usize , _Locale : _locale_t ) -> errno_t ; } extern "C" { pub fn _wcsupr_l ( _String : * mut wchar_t , _Locale : _locale_t ) -> * mut wchar_t ; } extern "C" { pub fn wcsxfrm ( _Destination : * mut wchar_t , _Source : * const wchar_t , _MaxCount : usize ) -> usize ; } extern "C" { pub fn _wcsxfrm_l ( _Destination : * mut wchar_t , _Source : * const wchar_t , _MaxCount : usize , _Locale : _locale_t ) -> usize ; } extern "C" { pub fn wcscoll ( _String1 : * const wchar_t , _String2 : * const wchar_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _wcscoll_l ( _String1 : * const wchar_t , _String2 : * const wchar_t , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _wcsicoll ( _String1 : * const wchar_t , _String2 : * const wchar_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _wcsicoll_l ( _String1 : * const wchar_t , _String2 : * const wchar_t , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _wcsncoll ( _String1 : * const wchar_t , _String2 : * const wchar_t , _MaxCount : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _wcsncoll_l ( _String1 : * const wchar_t , _String2 : * const wchar_t , _MaxCount : usize , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _wcsnicoll ( _String1 : * const wchar_t , _String2 : * const wchar_t , _MaxCount : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _wcsnicoll_l ( _String1 : * const wchar_t , _String2 : * const wchar_t , _MaxCount : usize , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn wcsdup ( _String : * const wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn wcsicmp ( _String1 : * const wchar_t , _String2 : * const wchar_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn wcsnicmp ( _String1 : * const wchar_t , _String2 : * const wchar_t , _MaxCount : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn wcsnset ( _String : * mut wchar_t , _Value : wchar_t , _MaxCount : usize ) -> * mut wchar_t ; } extern "C" { pub fn wcsrev ( _String : * mut wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn wcsset ( _String : * mut wchar_t , _Value : wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn wcslwr ( _String : * mut wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn wcsupr ( _String : * mut wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn wcsicoll ( _String1 : * const wchar_t , _String2 : * const wchar_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strcpy_s ( _Destination : * mut :: std :: os :: raw :: c_char , _SizeInBytes : rsize_t , _Source : * const :: std :: os :: raw :: c_char ) -> errno_t ; } extern "C" { pub fn strcat_s ( _Destination : * mut :: std :: os :: raw :: c_char , _SizeInBytes : rsize_t , _Source : * const :: std :: os :: raw :: c_char ) -> errno_t ; } extern "C" { pub fn strerror_s ( _Buffer : * mut :: std :: os :: raw :: c_char , _SizeInBytes : usize , _ErrorNumber : :: std :: os :: raw :: c_int ) -> errno_t ; } extern "C" { pub fn strncat_s ( _Destination : * mut :: std :: os :: raw :: c_char , _SizeInBytes : rsize_t , _Source : * const :: std :: os :: raw :: c_char , _MaxCount : rsize_t ) -> errno_t ; } extern "C" { pub fn strncpy_s ( _Destination : * mut :: std :: os :: raw :: c_char , _SizeInBytes : rsize_t , _Source : * const :: std :: os :: raw :: c_char , _MaxCount : rsize_t ) -> errno_t ; } extern "C" { pub fn strtok_s ( _String : * mut :: std :: os :: raw :: c_char , _Delimiter : * const :: std :: os :: raw :: c_char , _Context : * mut * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn _memccpy ( _Dst : * mut :: std :: os :: raw :: c_void , _Src : * const :: std :: os :: raw :: c_void , _Val : :: std :: os :: raw :: c_int , _MaxCount : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn strcat ( _Destination : * mut :: std :: os :: raw :: c_char , _Source : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strcmp ( _Str1 : * const :: std :: os :: raw :: c_char , _Str2 : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _strcmpi ( _String1 : * const :: std :: os :: raw :: c_char , _String2 : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strcoll ( _String1 : * const :: std :: os :: raw :: c_char , _String2 : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _strcoll_l ( _String1 : * const :: std :: os :: raw :: c_char , _String2 : * const :: std :: os :: raw :: c_char , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strcpy ( _Destination : * mut :: std :: os :: raw :: c_char , _Source : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strcspn ( _Str : * const :: std :: os :: raw :: c_char , _Control : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_ulonglong ; } extern "C" { pub fn _strdup ( _Source : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn _strerror ( _ErrorMessage : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn _strerror_s ( _Buffer : * mut :: std :: os :: raw :: c_char , _SizeInBytes : usize , _ErrorMessage : * const :: std :: os :: raw :: c_char ) -> errno_t ; } extern "C" { pub fn strerror ( _ErrorMessage : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn _stricmp ( _String1 : * const :: std :: os :: raw :: c_char , _String2 : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _stricoll ( _String1 : * const :: std :: os :: raw :: c_char , _String2 : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _stricoll_l ( _String1 : * const :: std :: os :: raw :: c_char , _String2 : * const :: std :: os :: raw :: c_char , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _stricmp_l ( _String1 : * const :: std :: os :: raw :: c_char , _String2 : * const :: std :: os :: raw :: c_char , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strlen ( _Str : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_ulonglong ; } extern "C" { pub fn _strlwr_s ( _String : * mut :: std :: os :: raw :: c_char , _Size : usize ) -> errno_t ; } extern "C" { pub fn _strlwr ( _String : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn _strlwr_s_l ( _String : * mut :: std :: os :: raw :: c_char , _Size : usize , _Locale : _locale_t ) -> errno_t ; } extern "C" { pub fn _strlwr_l ( _String : * mut :: std :: os :: raw :: c_char , _Locale : _locale_t ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strncat ( _Destination : * mut :: std :: os :: raw :: c_char , _Source : * const :: std :: os :: raw :: c_char , _Count : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strncmp ( _Str1 : * const :: std :: os :: raw :: c_char , _Str2 : * const :: std :: os :: raw :: c_char , _MaxCount : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _strnicmp ( _String1 : * const :: std :: os :: raw :: c_char , _String2 : * const :: std :: os :: raw :: c_char , _MaxCount : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _strnicmp_l ( _String1 : * const :: std :: os :: raw :: c_char , _String2 : * const :: std :: os :: raw :: c_char , _MaxCount : usize , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _strnicoll ( _String1 : * const :: std :: os :: raw :: c_char , _String2 : * const :: std :: os :: raw :: c_char , _MaxCount : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _strnicoll_l ( _String1 : * const :: std :: os :: raw :: c_char , _String2 : * const :: std :: os :: raw :: c_char , _MaxCount : usize , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _strncoll ( _String1 : * const :: std :: os :: raw :: c_char , _String2 : * const :: std :: os :: raw :: c_char , _MaxCount : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _strncoll_l ( _String1 : * const :: std :: os :: raw :: c_char , _String2 : * const :: std :: os :: raw :: c_char , _MaxCount : usize , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __strncnt ( _String : * const :: std :: os :: raw :: c_char , _Count : usize ) -> usize ; } extern "C" { pub fn strncpy ( _Destination : * mut :: std :: os :: raw :: c_char , _Source : * const :: std :: os :: raw :: c_char , _Count : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strnlen ( _String : * const :: std :: os :: raw :: c_char , _MaxCount : usize ) -> usize ; } extern "C" { pub fn _strnset_s ( _String : * mut :: std :: os :: raw :: c_char , _SizeInBytes : usize , _Value : :: std :: os :: raw :: c_int , _MaxCount : usize ) -> errno_t ; } extern "C" { pub fn _strnset ( _Destination : * mut :: std :: os :: raw :: c_char , _Value : :: std :: os :: raw :: c_int , _Count : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strpbrk ( _Str : * const :: std :: os :: raw :: c_char , _Control : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn _strrev ( _Str : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn _strset_s ( _Destination : * mut :: std :: os :: raw :: c_char , _DestinationSize : usize , _Value : :: std :: os :: raw :: c_int ) -> errno_t ; } extern "C" { pub fn _strset ( _Destination : * mut :: std :: os :: raw :: c_char , _Value : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strspn ( _Str : * const :: std :: os :: raw :: c_char , _Control : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_ulonglong ; } extern "C" { pub fn strtok ( _String : * mut :: std :: os :: raw :: c_char , _Delimiter : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn _strupr_s ( _String : * mut :: std :: os :: raw :: c_char , _Size : usize ) -> errno_t ; } extern "C" { pub fn _strupr ( _String : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn _strupr_s_l ( _String : * mut :: std :: os :: raw :: c_char , _Size : usize , _Locale : _locale_t ) -> errno_t ; } extern "C" { pub fn _strupr_l ( _String : * mut :: std :: os :: raw :: c_char , _Locale : _locale_t ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strxfrm ( _Destination : * mut :: std :: os :: raw :: c_char , _Source : * const :: std :: os :: raw :: c_char , _MaxCount : usize ) -> :: std :: os :: raw :: c_ulonglong ; } extern "C" { pub fn _strxfrm_l ( _Destination : * mut :: std :: os :: raw :: c_char , _Source : * const :: std :: os :: raw :: c_char , _MaxCount : usize , _Locale : _locale_t ) -> usize ; } extern "C" { pub fn strdup ( _String : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strcmpi ( _String1 : * const :: std :: os :: raw :: c_char , _String2 : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn stricmp ( _String1 : * const :: std :: os :: raw :: c_char , _String2 : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strlwr ( _String : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strnicmp ( _String1 : * const :: std :: os :: raw :: c_char , _String2 : * const :: std :: os :: raw :: c_char , _MaxCount : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strnset ( _String : * mut :: std :: os :: raw :: c_char , _Value : :: std :: os :: raw :: c_int , _MaxCount : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strrev ( _String : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strset ( _String : * mut :: std :: os :: raw :: c_char , _Value : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strupr ( _String : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } # [ repr ( C ) ] pub struct _OBJECTID { pub Lineage : GUID , pub Uniquifier : ULONG , } pub type OBJECTID = _OBJECTID ; extern "C" { pub fn _RTL_CONSTANT_STRING_type_check ( s : * const :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_char ; } pub type PEXCEPTION_ROUTINE = :: std :: option :: Option < unsafe extern "C" fn ( ) -> EXCEPTION_DISPOSITION > ; pub type KIRQL = UCHAR ; pub type PKIRQL = * mut KIRQL ; pub const _NT_PRODUCT_TYPE_NtProductWinNt : _NT_PRODUCT_TYPE = 1 ; pub const _NT_PRODUCT_TYPE_NtProductLanManNt : _NT_PRODUCT_TYPE = 2 ; pub const _NT_PRODUCT_TYPE_NtProductServer : _NT_PRODUCT_TYPE = 3 ; pub type _NT_PRODUCT_TYPE = i32 ; pub use self :: _NT_PRODUCT_TYPE as NT_PRODUCT_TYPE ; pub type PNT_PRODUCT_TYPE = * mut _NT_PRODUCT_TYPE ; pub const _SUITE_TYPE_SmallBusiness : _SUITE_TYPE = 0 ; pub const _SUITE_TYPE_Enterprise : _SUITE_TYPE = 1 ; pub const _SUITE_TYPE_BackOffice : _SUITE_TYPE = 2 ; pub const _SUITE_TYPE_CommunicationServer : _SUITE_TYPE = 3 ; pub const _SUITE_TYPE_TerminalServer : _SUITE_TYPE = 4 ; pub const _SUITE_TYPE_SmallBusinessRestricted : _SUITE_TYPE = 5 ; pub const _SUITE_TYPE_EmbeddedNT : _SUITE_TYPE = 6 ; pub const _SUITE_TYPE_DataCenter : _SUITE_TYPE = 7 ; pub const _SUITE_TYPE_SingleUserTS : _SUITE_TYPE = 8 ; pub const _SUITE_TYPE_Personal : _SUITE_TYPE = 9 ; pub const _SUITE_TYPE_Blade : _SUITE_TYPE = 10 ; pub const _SUITE_TYPE_EmbeddedRestricted : _SUITE_TYPE = 11 ; pub const _SUITE_TYPE_SecurityAppliance : _SUITE_TYPE = 12 ; pub const _SUITE_TYPE_StorageServer : _SUITE_TYPE = 13 ; pub const _SUITE_TYPE_ComputeServer : _SUITE_TYPE = 14 ; pub const _SUITE_TYPE_WHServer : _SUITE_TYPE = 15 ; pub const _SUITE_TYPE_PhoneNT : _SUITE_TYPE = 16 ; pub const _SUITE_TYPE_MaxSuiteType : _SUITE_TYPE = 17 ; pub type _SUITE_TYPE = i32 ; pub use self :: _SUITE_TYPE as SUITE_TYPE ; pub type __prefast_analysis_mode_flag0 = :: std :: os :: raw :: c_int ; pub type __prefast_analysis_mode_flag1 = :: std :: os :: raw :: c_int ; pub type PACCESS_STATE = * mut _ACCESS_STATE ; # [ repr ( C ) ] pub struct _CALLBACK_OBJECT { _unused : [ u8 ; 0 ] , } pub type PCALLBACK_OBJECT = * mut _CALLBACK_OBJECT ; # [ repr ( C ) ] pub struct _EPROCESS { _unused : [ u8 ; 0 ] , } pub type PEPROCESS = * mut _EPROCESS ; # [ repr ( C ) ] pub struct _ETHREAD { _unused : [ u8 ; 0 ] , } pub type PETHREAD = * mut _ETHREAD ; # [ repr ( C ) ] pub struct _IO_TIMER { _unused : [ u8 ; 0 ] , } pub type PIO_TIMER = * mut _IO_TIMER ; # [ repr ( C ) ] pub struct _KINTERRUPT { _unused : [ u8 ; 0 ] , } pub type PKINTERRUPT = * mut _KINTERRUPT ; # [ repr ( C ) ] pub struct _KTHREAD { _unused : [ u8 ; 0 ] , } pub type PKTHREAD = * mut _KTHREAD ; pub type PRKTHREAD = * mut _KTHREAD ; # [ repr ( C ) ] pub struct _KPROCESS { _unused : [ u8 ; 0 ] , } pub type PKPROCESS = * mut _KPROCESS ; pub type PRKPROCESS = * mut _KPROCESS ; # [ repr ( C ) ] pub struct _OBJECT_TYPE { _unused : [ u8 ; 0 ] , } pub type POBJECT_TYPE = * mut _OBJECT_TYPE ; pub type PSECURITY_QUALITY_OF_SERVICE = * mut _SECURITY_QUALITY_OF_SERVICE ; pub type PCONTEXT = * mut _CONTEXT ; pub type PIO_STACK_LOCATION = * mut _IO_STACK_LOCATION ; pub type PVPB = * mut _VPB ; # [ repr ( C ) ] pub struct _FILE_GET_QUOTA_INFORMATION { _unused : [ u8 ; 0 ] , } pub type PFILE_GET_QUOTA_INFORMATION = * mut _FILE_GET_QUOTA_INFORMATION ; extern "C" { pub fn __readgsqword ( Offset : ULONG ) -> :: std :: os :: raw :: c_ulonglong ; } pub const MCA_EXCEPTION_TYPE_HAL_MCE_RECORD : MCA_EXCEPTION_TYPE = 0 ; pub const MCA_EXCEPTION_TYPE_HAL_MCA_RECORD : MCA_EXCEPTION_TYPE = 1 ; pub type MCA_EXCEPTION_TYPE = i32 ; # [ repr ( C ) ] pub struct _MCI_ADDR { pub __bindgen_anon_1 : __BindgenUnionField < _MCI_ADDR__bindgen_ty_1 > , pub QuadPart : __BindgenUnionField < ULONGLONG > , pub bindgen_union_field : u64 , } # [ repr ( C ) ] pub struct _MCI_ADDR__bindgen_ty_1 { pub Address : ULONG , pub Reserved : ULONG , } pub type MCI_ADDR = _MCI_ADDR ; pub type PMCI_ADDR = * mut _MCI_ADDR ; # [ repr ( C ) ] pub struct _MCI_STATS { pub MciStats : __BindgenUnionField < _MCI_STATS__bindgen_ty_1 > , pub QuadPart : __BindgenUnionField < ULONGLONG > , pub bindgen_union_field : u64 , } # [ repr ( C ) ] pub struct _MCI_STATS__bindgen_ty_1 { pub McaCod : USHORT , pub MsCod : USHORT , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _MCI_STATS__bindgen_ty_1 { # [ inline ] pub fn OtherInfo ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 25u8 ) as u32 ) } } # [ inline ] pub fn set_OtherInfo ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 25u8 , val as u64 ) } } # [ inline ] pub fn Damage ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 25usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Damage ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 25usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AddressValid ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 26usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AddressValid ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 26usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MiscValid ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 27usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_MiscValid ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 27usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Enabled ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 28usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Enabled ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 28usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UnCorrected ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 29usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_UnCorrected ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 29usize , 1u8 , val as u64 ) } } # [ inline ] pub fn OverFlow ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 30usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_OverFlow ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 30usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Valid ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 31usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Valid ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 31usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( OtherInfo : ULONG , Damage : ULONG , AddressValid : ULONG , MiscValid : ULONG , Enabled : ULONG , UnCorrected : ULONG , OverFlow : ULONG , Valid : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 25u8 , { let OtherInfo : u32 = unsafe { :: std :: mem :: transmute ( OtherInfo ) } ; OtherInfo as u64 } ) ; __bindgen_bitfield_unit . set ( 25usize , 1u8 , { let Damage : u32 = unsafe { :: std :: mem :: transmute ( Damage ) } ; Damage as u64 } ) ; __bindgen_bitfield_unit . set ( 26usize , 1u8 , { let AddressValid : u32 = unsafe { :: std :: mem :: transmute ( AddressValid ) } ; AddressValid as u64 } ) ; __bindgen_bitfield_unit . set ( 27usize , 1u8 , { let MiscValid : u32 = unsafe { :: std :: mem :: transmute ( MiscValid ) } ; MiscValid as u64 } ) ; __bindgen_bitfield_unit . set ( 28usize , 1u8 , { let Enabled : u32 = unsafe { :: std :: mem :: transmute ( Enabled ) } ; Enabled as u64 } ) ; __bindgen_bitfield_unit . set ( 29usize , 1u8 , { let UnCorrected : u32 = unsafe { :: std :: mem :: transmute ( UnCorrected ) } ; UnCorrected as u64 } ) ; __bindgen_bitfield_unit . set ( 30usize , 1u8 , { let OverFlow : u32 = unsafe { :: std :: mem :: transmute ( OverFlow ) } ; OverFlow as u64 } ) ; __bindgen_bitfield_unit . set ( 31usize , 1u8 , { let Valid : u32 = unsafe { :: std :: mem :: transmute ( Valid ) } ; Valid as u64 } ) ; __bindgen_bitfield_unit } } pub type MCI_STATS = _MCI_STATS ; pub type PMCI_STATS = * mut _MCI_STATS ; # [ repr ( C ) ] pub struct _MCA_EXCEPTION { pub VersionNumber : ULONG , pub ExceptionType : MCA_EXCEPTION_TYPE , pub TimeStamp : LARGE_INTEGER , pub ProcessorNumber : ULONG , pub Reserved1 : ULONG , pub u : _MCA_EXCEPTION__bindgen_ty_1 , pub ExtCnt : ULONG , pub Reserved3 : ULONG , pub ExtReg : [ ULONGLONG ; 24usize ] , } # [ repr ( C ) ] pub struct _MCA_EXCEPTION__bindgen_ty_1 { pub Mca : __BindgenUnionField < _MCA_EXCEPTION__bindgen_ty_1__bindgen_ty_1 > , pub Mce : __BindgenUnionField < _MCA_EXCEPTION__bindgen_ty_1__bindgen_ty_2 > , pub bindgen_union_field : [ u64 ; 4usize ] , } # [ repr ( C ) ] pub struct _MCA_EXCEPTION__bindgen_ty_1__bindgen_ty_1 { pub BankNumber : UCHAR , pub Reserved2 : [ UCHAR ; 7usize ] , pub Status : MCI_STATS , pub Address : MCI_ADDR , pub Misc : ULONGLONG , } # [ repr ( C ) ] pub struct _MCA_EXCEPTION__bindgen_ty_1__bindgen_ty_2 { pub Address : ULONGLONG , pub Type : ULONGLONG , } pub type MCA_EXCEPTION = _MCA_EXCEPTION ; pub type PMCA_EXCEPTION = * mut _MCA_EXCEPTION ; pub type CMC_EXCEPTION = MCA_EXCEPTION ; pub type PCMC_EXCEPTION = * mut MCA_EXCEPTION ; pub type CPE_EXCEPTION = MCA_EXCEPTION ; pub type PCPE_EXCEPTION = * mut MCA_EXCEPTION ; extern "C" { # [ link_name = "\u{1}KeNumberProcessors" ] pub static mut KeNumberProcessors : CCHAR ; } # [ repr ( C ) ] pub struct _KSYSTEM_TIME { pub LowPart : ULONG , pub High1Time : LONG , pub High2Time : LONG , } pub type KSYSTEM_TIME = _KSYSTEM_TIME ; pub type PKSYSTEM_TIME = * mut _KSYSTEM_TIME ; pub type KPRIORITY = LONG ; pub type KSPIN_LOCK = ULONG_PTR ; pub type PKSPIN_LOCK = * mut KSPIN_LOCK ; pub const _KSPIN_LOCK_QUEUE_NUMBER_LockQueueUnusedSpare0 : _KSPIN_LOCK_QUEUE_NUMBER = 0 ; pub const _KSPIN_LOCK_QUEUE_NUMBER_LockQueueUnusedSpare1 : _KSPIN_LOCK_QUEUE_NUMBER = 1 ; pub const _KSPIN_LOCK_QUEUE_NUMBER_LockQueueUnusedSpare2 : _KSPIN_LOCK_QUEUE_NUMBER = 2 ; pub const _KSPIN_LOCK_QUEUE_NUMBER_LockQueueUnusedSpare3 : _KSPIN_LOCK_QUEUE_NUMBER = 3 ; pub const _KSPIN_LOCK_QUEUE_NUMBER_LockQueueVacbLock : _KSPIN_LOCK_QUEUE_NUMBER = 4 ; pub const _KSPIN_LOCK_QUEUE_NUMBER_LockQueueMasterLock : _KSPIN_LOCK_QUEUE_NUMBER = 5 ; pub const _KSPIN_LOCK_QUEUE_NUMBER_LockQueueNonPagedPoolLock : _KSPIN_LOCK_QUEUE_NUMBER = 6 ; pub const _KSPIN_LOCK_QUEUE_NUMBER_LockQueueIoCancelLock : _KSPIN_LOCK_QUEUE_NUMBER = 7 ; pub const _KSPIN_LOCK_QUEUE_NUMBER_LockQueueUnusedSpare8 : _KSPIN_LOCK_QUEUE_NUMBER = 8 ; pub const _KSPIN_LOCK_QUEUE_NUMBER_LockQueueIoVpbLock : _KSPIN_LOCK_QUEUE_NUMBER = 9 ; pub const _KSPIN_LOCK_QUEUE_NUMBER_LockQueueIoDatabaseLock : _KSPIN_LOCK_QUEUE_NUMBER = 10 ; pub const _KSPIN_LOCK_QUEUE_NUMBER_LockQueueIoCompletionLock : _KSPIN_LOCK_QUEUE_NUMBER = 11 ; pub const _KSPIN_LOCK_QUEUE_NUMBER_LockQueueNtfsStructLock : _KSPIN_LOCK_QUEUE_NUMBER = 12 ; pub const _KSPIN_LOCK_QUEUE_NUMBER_LockQueueAfdWorkQueueLock : _KSPIN_LOCK_QUEUE_NUMBER = 13 ; pub const _KSPIN_LOCK_QUEUE_NUMBER_LockQueueBcbLock : _KSPIN_LOCK_QUEUE_NUMBER = 14 ; pub const _KSPIN_LOCK_QUEUE_NUMBER_LockQueueUnusedSpare15 : _KSPIN_LOCK_QUEUE_NUMBER = 15 ; pub const _KSPIN_LOCK_QUEUE_NUMBER_LockQueueUnusedSpare16 : _KSPIN_LOCK_QUEUE_NUMBER = 16 ; pub const _KSPIN_LOCK_QUEUE_NUMBER_LockQueueMaximumLock : _KSPIN_LOCK_QUEUE_NUMBER = 17 ; pub type _KSPIN_LOCK_QUEUE_NUMBER = i32 ; pub use self :: _KSPIN_LOCK_QUEUE_NUMBER as KSPIN_LOCK_QUEUE_NUMBER ; pub type PKSPIN_LOCK_QUEUE_NUMBER = * mut _KSPIN_LOCK_QUEUE_NUMBER ; # [ repr ( C ) ] pub struct _KSPIN_LOCK_QUEUE { pub Next : * mut _KSPIN_LOCK_QUEUE , pub Lock : PKSPIN_LOCK , } pub type KSPIN_LOCK_QUEUE = _KSPIN_LOCK_QUEUE ; pub type PKSPIN_LOCK_QUEUE = * mut _KSPIN_LOCK_QUEUE ; # [ repr ( C ) ] pub struct _KLOCK_QUEUE_HANDLE { pub LockQueue : KSPIN_LOCK_QUEUE , pub OldIrql : KIRQL , } pub type KLOCK_QUEUE_HANDLE = _KLOCK_QUEUE_HANDLE ; pub type PKLOCK_QUEUE_HANDLE = * mut _KLOCK_QUEUE_HANDLE ; pub const _KPROFILE_SOURCE_ProfileTime : _KPROFILE_SOURCE = 0 ; pub const _KPROFILE_SOURCE_ProfileAlignmentFixup : _KPROFILE_SOURCE = 1 ; pub const _KPROFILE_SOURCE_ProfileTotalIssues : _KPROFILE_SOURCE = 2 ; pub const _KPROFILE_SOURCE_ProfilePipelineDry : _KPROFILE_SOURCE = 3 ; pub const _KPROFILE_SOURCE_ProfileLoadInstructions : _KPROFILE_SOURCE = 4 ; pub const _KPROFILE_SOURCE_ProfilePipelineFrozen : _KPROFILE_SOURCE = 5 ; pub const _KPROFILE_SOURCE_ProfileBranchInstructions : _KPROFILE_SOURCE = 6 ; pub const _KPROFILE_SOURCE_ProfileTotalNonissues : _KPROFILE_SOURCE = 7 ; pub const _KPROFILE_SOURCE_ProfileDcacheMisses : _KPROFILE_SOURCE = 8 ; pub const _KPROFILE_SOURCE_ProfileIcacheMisses : _KPROFILE_SOURCE = 9 ; pub const _KPROFILE_SOURCE_ProfileCacheMisses : _KPROFILE_SOURCE = 10 ; pub const _KPROFILE_SOURCE_ProfileBranchMispredictions : _KPROFILE_SOURCE = 11 ; pub const _KPROFILE_SOURCE_ProfileStoreInstructions : _KPROFILE_SOURCE = 12 ; pub const _KPROFILE_SOURCE_ProfileFpInstructions : _KPROFILE_SOURCE = 13 ; pub const _KPROFILE_SOURCE_ProfileIntegerInstructions : _KPROFILE_SOURCE = 14 ; pub const _KPROFILE_SOURCE_Profile2Issue : _KPROFILE_SOURCE = 15 ; pub const _KPROFILE_SOURCE_Profile3Issue : _KPROFILE_SOURCE = 16 ; pub const _KPROFILE_SOURCE_Profile4Issue : _KPROFILE_SOURCE = 17 ; pub const _KPROFILE_SOURCE_ProfileSpecialInstructions : _KPROFILE_SOURCE = 18 ; pub const _KPROFILE_SOURCE_ProfileTotalCycles : _KPROFILE_SOURCE = 19 ; pub const _KPROFILE_SOURCE_ProfileIcacheIssues : _KPROFILE_SOURCE = 20 ; pub const _KPROFILE_SOURCE_ProfileDcacheAccesses : _KPROFILE_SOURCE = 21 ; pub const _KPROFILE_SOURCE_ProfileMemoryBarrierCycles : _KPROFILE_SOURCE = 22 ; pub const _KPROFILE_SOURCE_ProfileLoadLinkedIssues : _KPROFILE_SOURCE = 23 ; pub const _KPROFILE_SOURCE_ProfileMaximum : _KPROFILE_SOURCE = 24 ; pub type _KPROFILE_SOURCE = i32 ; pub use self :: _KPROFILE_SOURCE as KPROFILE_SOURCE ; # [ repr ( C ) ] pub struct _DPC_WATCHDOG_GLOBAL_TRIAGE_BLOCK { pub Signature : ULONG , pub Revision : USHORT , pub Size : USHORT , pub DpcWatchdogProfileOffset : USHORT , pub DpcWatchdogProfileLength : ULONG , } pub type DPC_WATCHDOG_GLOBAL_TRIAGE_BLOCK = _DPC_WATCHDOG_GLOBAL_TRIAGE_BLOCK ; pub type PDPC_WATCHDOG_GLOBAL_TRIAGE_BLOCK = * mut _DPC_WATCHDOG_GLOBAL_TRIAGE_BLOCK ; # [ repr ( C ) ] pub struct _M128A { pub Low : ULONGLONG , pub High : LONGLONG , } pub type M128A = _M128A ; pub type PM128A = * mut _M128A ; # [ repr ( C ) ] pub struct _XSAVE_FORMAT { pub ControlWord : USHORT , pub StatusWord : USHORT , pub TagWord : UCHAR , pub Reserved1 : UCHAR , pub ErrorOpcode : USHORT , pub ErrorOffset : ULONG , pub ErrorSelector : USHORT , pub Reserved2 : USHORT , pub DataOffset : ULONG , pub DataSelector : USHORT , pub Reserved3 : USHORT , pub MxCsr : ULONG , pub MxCsr_Mask : ULONG , pub FloatRegisters : [ M128A ; 8usize ] , pub XmmRegisters : [ M128A ; 16usize ] , pub Reserved4 : [ UCHAR ; 96usize ] , } pub type XSAVE_FORMAT = _XSAVE_FORMAT ; pub type PXSAVE_FORMAT = * mut _XSAVE_FORMAT ; # [ repr ( C ) ] pub struct _XSAVE_AREA_HEADER { pub Mask : ULONG64 , pub CompactionMask : ULONG64 , pub Reserved2 : [ ULONG64 ; 6usize ] , } pub type XSAVE_AREA_HEADER = _XSAVE_AREA_HEADER ; pub type PXSAVE_AREA_HEADER = * mut _XSAVE_AREA_HEADER ; # [ repr ( C ) ] pub struct _XSAVE_AREA { pub LegacyState : XSAVE_FORMAT , pub Header : XSAVE_AREA_HEADER , } pub type XSAVE_AREA = _XSAVE_AREA ; pub type PXSAVE_AREA = * mut _XSAVE_AREA ; # [ repr ( C ) ] pub struct _XSTATE_CONTEXT { pub Mask : ULONG64 , pub Length : ULONG , pub Reserved1 : ULONG , pub Area : PXSAVE_AREA , pub Reserved2 : ULONG , pub Buffer : PVOID , pub Reserved3 : ULONG , } pub type XSTATE_CONTEXT = _XSTATE_CONTEXT ; pub type PXSTATE_CONTEXT = * mut _XSTATE_CONTEXT ; pub type __C_ASSERT__ = [ :: std :: os :: raw :: c_char ; 1usize ] ; pub type PACCESS_TOKEN = PVOID ; pub type PSECURITY_DESCRIPTOR = PVOID ; pub type PSID = PVOID ; pub type PCLAIMS_BLOB = PVOID ; pub type ACCESS_MASK = ULONG ; pub type PACCESS_MASK = * mut ACCESS_MASK ; # [ repr ( C ) ] pub struct _GENERIC_MAPPING { pub GenericRead : ACCESS_MASK , pub GenericWrite : ACCESS_MASK , pub GenericExecute : ACCESS_MASK , pub GenericAll : ACCESS_MASK , } pub type GENERIC_MAPPING = _GENERIC_MAPPING ; pub type PGENERIC_MAPPING = * mut GENERIC_MAPPING ; # [ repr ( C ) ] pub struct _LUID_AND_ATTRIBUTES { pub Luid : LUID , pub Attributes : ULONG , } pub type LUID_AND_ATTRIBUTES = _LUID_AND_ATTRIBUTES ; pub type PLUID_AND_ATTRIBUTES = * mut _LUID_AND_ATTRIBUTES ; pub type LUID_AND_ATTRIBUTES_ARRAY = [ LUID_AND_ATTRIBUTES ; 1usize ] ; pub type PLUID_AND_ATTRIBUTES_ARRAY = * mut LUID_AND_ATTRIBUTES_ARRAY ; # [ repr ( C ) ] pub struct _ACL { pub AclRevision : UCHAR , pub Sbz1 : UCHAR , pub AclSize : USHORT , pub AceCount : USHORT , pub Sbz2 : USHORT , } pub type ACL = _ACL ; pub type PACL = * mut ACL ; # [ repr ( C ) ] pub struct _PRIVILEGE_SET { pub PrivilegeCount : ULONG , pub Control : ULONG , pub Privilege : [ LUID_AND_ATTRIBUTES ; 1usize ] , } pub type PRIVILEGE_SET = _PRIVILEGE_SET ; pub type PPRIVILEGE_SET = * mut _PRIVILEGE_SET ; pub const _SECURITY_IMPERSONATION_LEVEL_SecurityAnonymous : _SECURITY_IMPERSONATION_LEVEL = 0 ; pub const _SECURITY_IMPERSONATION_LEVEL_SecurityIdentification : _SECURITY_IMPERSONATION_LEVEL = 1 ; pub const _SECURITY_IMPERSONATION_LEVEL_SecurityImpersonation : _SECURITY_IMPERSONATION_LEVEL = 2 ; pub const _SECURITY_IMPERSONATION_LEVEL_SecurityDelegation : _SECURITY_IMPERSONATION_LEVEL = 3 ; pub type _SECURITY_IMPERSONATION_LEVEL = i32 ; pub use self :: _SECURITY_IMPERSONATION_LEVEL as SECURITY_IMPERSONATION_LEVEL ; pub type PSECURITY_IMPERSONATION_LEVEL = * mut _SECURITY_IMPERSONATION_LEVEL ; pub type SECURITY_CONTEXT_TRACKING_MODE = BOOLEAN ; pub type PSECURITY_CONTEXT_TRACKING_MODE = * mut BOOLEAN ; # [ repr ( C ) ] pub struct _SECURITY_QUALITY_OF_SERVICE { pub Length : ULONG , pub ImpersonationLevel : SECURITY_IMPERSONATION_LEVEL , pub ContextTrackingMode : SECURITY_CONTEXT_TRACKING_MODE , pub EffectiveOnly : BOOLEAN , } pub type SECURITY_QUALITY_OF_SERVICE = _SECURITY_QUALITY_OF_SERVICE ; # [ repr ( C ) ] pub struct _SE_IMPERSONATION_STATE { pub Token : PACCESS_TOKEN , pub CopyOnOpen : BOOLEAN , pub EffectiveOnly : BOOLEAN , pub Level : SECURITY_IMPERSONATION_LEVEL , } pub type SE_IMPERSONATION_STATE = _SE_IMPERSONATION_STATE ; pub type PSE_IMPERSONATION_STATE = * mut _SE_IMPERSONATION_STATE ; pub type SECURITY_INFORMATION = ULONG ; pub type PSECURITY_INFORMATION = * mut ULONG ; pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeNone : _SE_ADT_PARAMETER_TYPE = 0 ; pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeString : _SE_ADT_PARAMETER_TYPE = 1 ; pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeFileSpec : _SE_ADT_PARAMETER_TYPE = 2 ; pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeUlong : _SE_ADT_PARAMETER_TYPE = 3 ; pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeSid : _SE_ADT_PARAMETER_TYPE = 4 ; pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeLogonId : _SE_ADT_PARAMETER_TYPE = 5 ; pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeNoLogonId : _SE_ADT_PARAMETER_TYPE = 6 ; pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeAccessMask : _SE_ADT_PARAMETER_TYPE = 7 ; pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypePrivs : _SE_ADT_PARAMETER_TYPE = 8 ; pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeObjectTypes : _SE_ADT_PARAMETER_TYPE = 9 ; pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeHexUlong : _SE_ADT_PARAMETER_TYPE = 10 ; pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypePtr : _SE_ADT_PARAMETER_TYPE = 11 ; pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeTime : _SE_ADT_PARAMETER_TYPE = 12 ; pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeGuid : _SE_ADT_PARAMETER_TYPE = 13 ; pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeLuid : _SE_ADT_PARAMETER_TYPE = 14 ; pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeHexInt64 : _SE_ADT_PARAMETER_TYPE = 15 ; pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeStringList : _SE_ADT_PARAMETER_TYPE = 16 ; pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeSidList : _SE_ADT_PARAMETER_TYPE = 17 ; pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeDuration : _SE_ADT_PARAMETER_TYPE = 18 ; pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeUserAccountControl : _SE_ADT_PARAMETER_TYPE = 19 ; pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeNoUac : _SE_ADT_PARAMETER_TYPE = 20 ; pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeMessage : _SE_ADT_PARAMETER_TYPE = 21 ; pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeDateTime : _SE_ADT_PARAMETER_TYPE = 22 ; pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeSockAddr : _SE_ADT_PARAMETER_TYPE = 23 ; pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeSD : _SE_ADT_PARAMETER_TYPE = 24 ; pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeLogonHours : _SE_ADT_PARAMETER_TYPE = 25 ; pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeLogonIdNoSid : _SE_ADT_PARAMETER_TYPE = 26 ; pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeUlongNoConv : _SE_ADT_PARAMETER_TYPE = 27 ; pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeSockAddrNoPort : _SE_ADT_PARAMETER_TYPE = 28 ; pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeAccessReason : _SE_ADT_PARAMETER_TYPE = 29 ; pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeStagingReason : _SE_ADT_PARAMETER_TYPE = 30 ; pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeResourceAttribute : _SE_ADT_PARAMETER_TYPE = 31 ; pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeClaims : _SE_ADT_PARAMETER_TYPE = 32 ; pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeLogonIdAsSid : _SE_ADT_PARAMETER_TYPE = 33 ; pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeMultiSzString : _SE_ADT_PARAMETER_TYPE = 34 ; pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeLogonIdEx : _SE_ADT_PARAMETER_TYPE = 35 ; pub type _SE_ADT_PARAMETER_TYPE = i32 ; pub use self :: _SE_ADT_PARAMETER_TYPE as SE_ADT_PARAMETER_TYPE ; pub type PSE_ADT_PARAMETER_TYPE = * mut _SE_ADT_PARAMETER_TYPE ; # [ repr ( C ) ] pub struct _SE_ADT_OBJECT_TYPE { pub ObjectType : GUID , pub Flags : USHORT , pub Level : USHORT , pub AccessMask : ACCESS_MASK , } pub type SE_ADT_OBJECT_TYPE = _SE_ADT_OBJECT_TYPE ; pub type PSE_ADT_OBJECT_TYPE = * mut _SE_ADT_OBJECT_TYPE ; # [ repr ( C ) ] pub struct _SE_ADT_PARAMETER_ARRAY_ENTRY { pub Type : SE_ADT_PARAMETER_TYPE , pub Length : ULONG , pub Data : [ ULONG_PTR ; 2usize ] , pub Address : PVOID , } pub type SE_ADT_PARAMETER_ARRAY_ENTRY = _SE_ADT_PARAMETER_ARRAY_ENTRY ; pub type PSE_ADT_PARAMETER_ARRAY_ENTRY = * mut _SE_ADT_PARAMETER_ARRAY_ENTRY ; # [ repr ( C ) ] pub struct _SE_ADT_ACCESS_REASON { pub AccessMask : ACCESS_MASK , pub AccessReasons : [ ULONG ; 32usize ] , pub ObjectTypeIndex : ULONG , pub AccessGranted : ULONG , pub SecurityDescriptor : PSECURITY_DESCRIPTOR , } pub type SE_ADT_ACCESS_REASON = _SE_ADT_ACCESS_REASON ; pub type PSE_ADT_ACCESS_REASON = * mut _SE_ADT_ACCESS_REASON ; # [ repr ( C ) ] pub struct _SE_ADT_CLAIMS { pub Length : ULONG , pub Claims : PCLAIMS_BLOB , } pub type SE_ADT_CLAIMS = _SE_ADT_CLAIMS ; pub type PSE_ADT_CLAIMS = * mut _SE_ADT_CLAIMS ; # [ repr ( C ) ] pub struct _SE_ADT_PARAMETER_ARRAY { pub CategoryId : ULONG , pub AuditId : ULONG , pub ParameterCount : ULONG , pub Length : ULONG , pub FlatSubCategoryId : USHORT , pub Type : USHORT , pub Flags : ULONG , pub Parameters : [ SE_ADT_PARAMETER_ARRAY_ENTRY ; 32usize ] , } pub type SE_ADT_PARAMETER_ARRAY = _SE_ADT_PARAMETER_ARRAY ; pub type PSE_ADT_PARAMETER_ARRAY = * mut _SE_ADT_PARAMETER_ARRAY ; # [ repr ( C ) ] pub struct _SE_ADT_PARAMETER_ARRAY_EX { pub CategoryId : ULONG , pub AuditId : ULONG , pub Version : ULONG , pub ParameterCount : ULONG , pub Length : ULONG , pub FlatSubCategoryId : USHORT , pub Type : USHORT , pub Flags : ULONG , pub Parameters : [ SE_ADT_PARAMETER_ARRAY_ENTRY ; 32usize ] , } pub type SE_ADT_PARAMETER_ARRAY_EX = _SE_ADT_PARAMETER_ARRAY_EX ; pub type PSE_ADT_PARAMETER_ARRAY_EX = * mut _SE_ADT_PARAMETER_ARRAY_EX ; # [ repr ( C ) ] pub struct _IO_STATUS_BLOCK { pub __bindgen_anon_1 : _IO_STATUS_BLOCK__bindgen_ty_1 , pub Information : ULONG_PTR , } # [ repr ( C ) ] pub struct _IO_STATUS_BLOCK__bindgen_ty_1 { pub Status : __BindgenUnionField < NTSTATUS > , pub Pointer : __BindgenUnionField < PVOID > , pub bindgen_union_field : u64 , } pub type IO_STATUS_BLOCK = _IO_STATUS_BLOCK ; pub type PIO_STATUS_BLOCK = * mut _IO_STATUS_BLOCK ; # [ repr ( C ) ] pub struct _IO_STATUS_BLOCK32 { pub Status : NTSTATUS , pub Information : ULONG , } pub type IO_STATUS_BLOCK32 = _IO_STATUS_BLOCK32 ; pub type PIO_STATUS_BLOCK32 = * mut _IO_STATUS_BLOCK32 ; pub type PIO_APC_ROUTINE = :: std :: option :: Option < unsafe extern "C" fn ( ApcContext : PVOID , IoStatusBlock : PIO_STATUS_BLOCK , Reserved : ULONG ) > ; pub const _IO_SESSION_EVENT_IoSessionEventIgnore : _IO_SESSION_EVENT = 0 ; pub const _IO_SESSION_EVENT_IoSessionEventCreated : _IO_SESSION_EVENT = 1 ; pub const _IO_SESSION_EVENT_IoSessionEventTerminated : _IO_SESSION_EVENT = 2 ; pub const _IO_SESSION_EVENT_IoSessionEventConnected : _IO_SESSION_EVENT = 3 ; pub const _IO_SESSION_EVENT_IoSessionEventDisconnected : _IO_SESSION_EVENT = 4 ; pub const _IO_SESSION_EVENT_IoSessionEventLogon : _IO_SESSION_EVENT = 5 ; pub const _IO_SESSION_EVENT_IoSessionEventLogoff : _IO_SESSION_EVENT = 6 ; pub const _IO_SESSION_EVENT_IoSessionEventMax : _IO_SESSION_EVENT = 7 ; pub type _IO_SESSION_EVENT = i32 ; pub use self :: _IO_SESSION_EVENT as IO_SESSION_EVENT ; pub type PIO_SESSION_EVENT = * mut _IO_SESSION_EVENT ; pub const _IO_SESSION_STATE_IoSessionStateCreated : _IO_SESSION_STATE = 1 ; pub const _IO_SESSION_STATE_IoSessionStateInitialized : _IO_SESSION_STATE = 2 ; pub const _IO_SESSION_STATE_IoSessionStateConnected : _IO_SESSION_STATE = 3 ; pub const _IO_SESSION_STATE_IoSessionStateDisconnected : _IO_SESSION_STATE = 4 ; pub const _IO_SESSION_STATE_IoSessionStateDisconnectedLoggedOn : _IO_SESSION_STATE = 5 ; pub const _IO_SESSION_STATE_IoSessionStateLoggedOn : _IO_SESSION_STATE = 6 ; pub const _IO_SESSION_STATE_IoSessionStateLoggedOff : _IO_SESSION_STATE = 7 ; pub const _IO_SESSION_STATE_IoSessionStateTerminated : _IO_SESSION_STATE = 8 ; pub const _IO_SESSION_STATE_IoSessionStateMax : _IO_SESSION_STATE = 9 ; pub type _IO_SESSION_STATE = i32 ; pub use self :: _IO_SESSION_STATE as IO_SESSION_STATE ; pub type PIO_SESSION_STATE = * mut _IO_SESSION_STATE ; # [ repr ( C ) ] pub struct _IO_SESSION_CONNECT_INFO { pub SessionId : ULONG , pub LocalSession : BOOLEAN , } pub type IO_SESSION_CONNECT_INFO = _IO_SESSION_CONNECT_INFO ; pub type PIO_SESSION_CONNECT_INFO = * mut _IO_SESSION_CONNECT_INFO ; pub const _FILE_INFORMATION_CLASS_FileDirectoryInformation : _FILE_INFORMATION_CLASS = 1 ; pub const _FILE_INFORMATION_CLASS_FileFullDirectoryInformation : _FILE_INFORMATION_CLASS = 2 ; pub const _FILE_INFORMATION_CLASS_FileBothDirectoryInformation : _FILE_INFORMATION_CLASS = 3 ; pub const _FILE_INFORMATION_CLASS_FileBasicInformation : _FILE_INFORMATION_CLASS = 4 ; pub const _FILE_INFORMATION_CLASS_FileStandardInformation : _FILE_INFORMATION_CLASS = 5 ; pub const _FILE_INFORMATION_CLASS_FileInternalInformation : _FILE_INFORMATION_CLASS = 6 ; pub const _FILE_INFORMATION_CLASS_FileEaInformation : _FILE_INFORMATION_CLASS = 7 ; pub const _FILE_INFORMATION_CLASS_FileAccessInformation : _FILE_INFORMATION_CLASS = 8 ; pub const _FILE_INFORMATION_CLASS_FileNameInformation : _FILE_INFORMATION_CLASS = 9 ; pub const _FILE_INFORMATION_CLASS_FileRenameInformation : _FILE_INFORMATION_CLASS = 10 ; pub const _FILE_INFORMATION_CLASS_FileLinkInformation : _FILE_INFORMATION_CLASS = 11 ; pub const _FILE_INFORMATION_CLASS_FileNamesInformation : _FILE_INFORMATION_CLASS = 12 ; pub const _FILE_INFORMATION_CLASS_FileDispositionInformation : _FILE_INFORMATION_CLASS = 13 ; pub const _FILE_INFORMATION_CLASS_FilePositionInformation : _FILE_INFORMATION_CLASS = 14 ; pub const _FILE_INFORMATION_CLASS_FileFullEaInformation : _FILE_INFORMATION_CLASS = 15 ; pub const _FILE_INFORMATION_CLASS_FileModeInformation : _FILE_INFORMATION_CLASS = 16 ; pub const _FILE_INFORMATION_CLASS_FileAlignmentInformation : _FILE_INFORMATION_CLASS = 17 ; pub const _FILE_INFORMATION_CLASS_FileAllInformation : _FILE_INFORMATION_CLASS = 18 ; pub const _FILE_INFORMATION_CLASS_FileAllocationInformation : _FILE_INFORMATION_CLASS = 19 ; pub const _FILE_INFORMATION_CLASS_FileEndOfFileInformation : _FILE_INFORMATION_CLASS = 20 ; pub const _FILE_INFORMATION_CLASS_FileAlternateNameInformation : _FILE_INFORMATION_CLASS = 21 ; pub const _FILE_INFORMATION_CLASS_FileStreamInformation : _FILE_INFORMATION_CLASS = 22 ; pub const _FILE_INFORMATION_CLASS_FilePipeInformation : _FILE_INFORMATION_CLASS = 23 ; pub const _FILE_INFORMATION_CLASS_FilePipeLocalInformation : _FILE_INFORMATION_CLASS = 24 ; pub const _FILE_INFORMATION_CLASS_FilePipeRemoteInformation : _FILE_INFORMATION_CLASS = 25 ; pub const _FILE_INFORMATION_CLASS_FileMailslotQueryInformation : _FILE_INFORMATION_CLASS = 26 ; pub const _FILE_INFORMATION_CLASS_FileMailslotSetInformation : _FILE_INFORMATION_CLASS = 27 ; pub const _FILE_INFORMATION_CLASS_FileCompressionInformation : _FILE_INFORMATION_CLASS = 28 ; pub const _FILE_INFORMATION_CLASS_FileObjectIdInformation : _FILE_INFORMATION_CLASS = 29 ; pub const _FILE_INFORMATION_CLASS_FileCompletionInformation : _FILE_INFORMATION_CLASS = 30 ; pub const _FILE_INFORMATION_CLASS_FileMoveClusterInformation : _FILE_INFORMATION_CLASS = 31 ; pub const _FILE_INFORMATION_CLASS_FileQuotaInformation : _FILE_INFORMATION_CLASS = 32 ; pub const _FILE_INFORMATION_CLASS_FileReparsePointInformation : _FILE_INFORMATION_CLASS = 33 ; pub const _FILE_INFORMATION_CLASS_FileNetworkOpenInformation : _FILE_INFORMATION_CLASS = 34 ; pub const _FILE_INFORMATION_CLASS_FileAttributeTagInformation : _FILE_INFORMATION_CLASS = 35 ; pub const _FILE_INFORMATION_CLASS_FileTrackingInformation : _FILE_INFORMATION_CLASS = 36 ; pub const _FILE_INFORMATION_CLASS_FileIdBothDirectoryInformation : _FILE_INFORMATION_CLASS = 37 ; pub const _FILE_INFORMATION_CLASS_FileIdFullDirectoryInformation : _FILE_INFORMATION_CLASS = 38 ; pub const _FILE_INFORMATION_CLASS_FileValidDataLengthInformation : _FILE_INFORMATION_CLASS = 39 ; pub const _FILE_INFORMATION_CLASS_FileShortNameInformation : _FILE_INFORMATION_CLASS = 40 ; pub const _FILE_INFORMATION_CLASS_FileIoCompletionNotificationInformation : _FILE_INFORMATION_CLASS = 41 ; pub const _FILE_INFORMATION_CLASS_FileIoStatusBlockRangeInformation : _FILE_INFORMATION_CLASS = 42 ; pub const _FILE_INFORMATION_CLASS_FileIoPriorityHintInformation : _FILE_INFORMATION_CLASS = 43 ; pub const _FILE_INFORMATION_CLASS_FileSfioReserveInformation : _FILE_INFORMATION_CLASS = 44 ; pub const _FILE_INFORMATION_CLASS_FileSfioVolumeInformation : _FILE_INFORMATION_CLASS = 45 ; pub const _FILE_INFORMATION_CLASS_FileHardLinkInformation : _FILE_INFORMATION_CLASS = 46 ; pub const _FILE_INFORMATION_CLASS_FileProcessIdsUsingFileInformation : _FILE_INFORMATION_CLASS = 47 ; pub const _FILE_INFORMATION_CLASS_FileNormalizedNameInformation : _FILE_INFORMATION_CLASS = 48 ; pub const _FILE_INFORMATION_CLASS_FileNetworkPhysicalNameInformation : _FILE_INFORMATION_CLASS = 49 ; pub const _FILE_INFORMATION_CLASS_FileIdGlobalTxDirectoryInformation : _FILE_INFORMATION_CLASS = 50 ; pub const _FILE_INFORMATION_CLASS_FileIsRemoteDeviceInformation : _FILE_INFORMATION_CLASS = 51 ; pub const _FILE_INFORMATION_CLASS_FileUnusedInformation : _FILE_INFORMATION_CLASS = 52 ; pub const _FILE_INFORMATION_CLASS_FileNumaNodeInformation : _FILE_INFORMATION_CLASS = 53 ; pub const _FILE_INFORMATION_CLASS_FileStandardLinkInformation : _FILE_INFORMATION_CLASS = 54 ; pub const _FILE_INFORMATION_CLASS_FileRemoteProtocolInformation : _FILE_INFORMATION_CLASS = 55 ; pub const _FILE_INFORMATION_CLASS_FileRenameInformationBypassAccessCheck : _FILE_INFORMATION_CLASS = 56 ; pub const _FILE_INFORMATION_CLASS_FileLinkInformationBypassAccessCheck : _FILE_INFORMATION_CLASS = 57 ; pub const _FILE_INFORMATION_CLASS_FileVolumeNameInformation : _FILE_INFORMATION_CLASS = 58 ; pub const _FILE_INFORMATION_CLASS_FileIdInformation : _FILE_INFORMATION_CLASS = 59 ; pub const _FILE_INFORMATION_CLASS_FileIdExtdDirectoryInformation : _FILE_INFORMATION_CLASS = 60 ; pub const _FILE_INFORMATION_CLASS_FileReplaceCompletionInformation : _FILE_INFORMATION_CLASS = 61 ; pub const _FILE_INFORMATION_CLASS_FileHardLinkFullIdInformation : _FILE_INFORMATION_CLASS = 62 ; pub const _FILE_INFORMATION_CLASS_FileIdExtdBothDirectoryInformation : _FILE_INFORMATION_CLASS = 63 ; pub const _FILE_INFORMATION_CLASS_FileDispositionInformationEx : _FILE_INFORMATION_CLASS = 64 ; pub const _FILE_INFORMATION_CLASS_FileRenameInformationEx : _FILE_INFORMATION_CLASS = 65 ; pub const _FILE_INFORMATION_CLASS_FileRenameInformationExBypassAccessCheck : _FILE_INFORMATION_CLASS = 66 ; pub const _FILE_INFORMATION_CLASS_FileDesiredStorageClassInformation : _FILE_INFORMATION_CLASS = 67 ; pub const _FILE_INFORMATION_CLASS_FileStatInformation : _FILE_INFORMATION_CLASS = 68 ; pub const _FILE_INFORMATION_CLASS_FileMemoryPartitionInformation : _FILE_INFORMATION_CLASS = 69 ; pub const _FILE_INFORMATION_CLASS_FileMaximumInformation : _FILE_INFORMATION_CLASS = 70 ; pub type _FILE_INFORMATION_CLASS = i32 ; pub use self :: _FILE_INFORMATION_CLASS as FILE_INFORMATION_CLASS ; pub type PFILE_INFORMATION_CLASS = * mut _FILE_INFORMATION_CLASS ; pub const _DIRECTORY_NOTIFY_INFORMATION_CLASS_DirectoryNotifyInformation : _DIRECTORY_NOTIFY_INFORMATION_CLASS = 1 ; pub const _DIRECTORY_NOTIFY_INFORMATION_CLASS_DirectoryNotifyExtendedInformation : _DIRECTORY_NOTIFY_INFORMATION_CLASS = 2 ; pub type _DIRECTORY_NOTIFY_INFORMATION_CLASS = i32 ; pub use self :: _DIRECTORY_NOTIFY_INFORMATION_CLASS as DIRECTORY_NOTIFY_INFORMATION_CLASS ; pub type PDIRECTORY_NOTIFY_INFORMATION_CLASS = * mut _DIRECTORY_NOTIFY_INFORMATION_CLASS ; # [ repr ( C ) ] pub struct _FILE_BASIC_INFORMATION { pub CreationTime : LARGE_INTEGER , pub LastAccessTime : LARGE_INTEGER , pub LastWriteTime : LARGE_INTEGER , pub ChangeTime : LARGE_INTEGER , pub FileAttributes : ULONG , } pub type FILE_BASIC_INFORMATION = _FILE_BASIC_INFORMATION ; pub type PFILE_BASIC_INFORMATION = * mut _FILE_BASIC_INFORMATION ; # [ repr ( C ) ] pub struct _FILE_STANDARD_INFORMATION { pub AllocationSize : LARGE_INTEGER , pub EndOfFile : LARGE_INTEGER , pub NumberOfLinks : ULONG , pub DeletePending : BOOLEAN , pub Directory : BOOLEAN , } pub type FILE_STANDARD_INFORMATION = _FILE_STANDARD_INFORMATION ; pub type PFILE_STANDARD_INFORMATION = * mut _FILE_STANDARD_INFORMATION ; # [ repr ( C ) ] pub struct _FILE_STANDARD_INFORMATION_EX { pub AllocationSize : LARGE_INTEGER , pub EndOfFile : LARGE_INTEGER , pub NumberOfLinks : ULONG , pub DeletePending : BOOLEAN , pub Directory : BOOLEAN , pub AlternateStream : BOOLEAN , pub MetadataAttribute : BOOLEAN , } pub type FILE_STANDARD_INFORMATION_EX = _FILE_STANDARD_INFORMATION_EX ; pub type PFILE_STANDARD_INFORMATION_EX = * mut _FILE_STANDARD_INFORMATION_EX ; # [ repr ( C ) ] pub struct _FILE_POSITION_INFORMATION { pub CurrentByteOffset : LARGE_INTEGER , } pub type FILE_POSITION_INFORMATION = _FILE_POSITION_INFORMATION ; pub type PFILE_POSITION_INFORMATION = * mut _FILE_POSITION_INFORMATION ; # [ repr ( C ) ] pub struct _FILE_NETWORK_OPEN_INFORMATION { pub CreationTime : LARGE_INTEGER , pub LastAccessTime : LARGE_INTEGER , pub LastWriteTime : LARGE_INTEGER , pub ChangeTime : LARGE_INTEGER , pub AllocationSize : LARGE_INTEGER , pub EndOfFile : LARGE_INTEGER , pub FileAttributes : ULONG , } pub type FILE_NETWORK_OPEN_INFORMATION = _FILE_NETWORK_OPEN_INFORMATION ; pub type PFILE_NETWORK_OPEN_INFORMATION = * mut _FILE_NETWORK_OPEN_INFORMATION ; # [ repr ( C ) ] pub struct _FILE_FULL_EA_INFORMATION { pub NextEntryOffset : ULONG , pub Flags : UCHAR , pub EaNameLength : UCHAR , pub EaValueLength : USHORT , pub EaName : [ CHAR ; 1usize ] , } pub type FILE_FULL_EA_INFORMATION = _FILE_FULL_EA_INFORMATION ; pub type PFILE_FULL_EA_INFORMATION = * mut _FILE_FULL_EA_INFORMATION ; # [ repr ( C ) ] pub struct _FILE_SFIO_RESERVE_INFORMATION { pub RequestsPerPeriod : ULONG , pub Period : ULONG , pub RetryFailures : BOOLEAN , pub Discardable : BOOLEAN , pub RequestSize : ULONG , pub NumOutstandingRequests : ULONG , } pub type FILE_SFIO_RESERVE_INFORMATION = _FILE_SFIO_RESERVE_INFORMATION ; pub type PFILE_SFIO_RESERVE_INFORMATION = * mut _FILE_SFIO_RESERVE_INFORMATION ; # [ repr ( C ) ] pub struct _FILE_SFIO_VOLUME_INFORMATION { pub MaximumRequestsPerPeriod : ULONG , pub MinimumPeriod : ULONG , pub MinimumTransferSize : ULONG , } pub type FILE_SFIO_VOLUME_INFORMATION = _FILE_SFIO_VOLUME_INFORMATION ; pub type PFILE_SFIO_VOLUME_INFORMATION = * mut _FILE_SFIO_VOLUME_INFORMATION ; pub const _IO_PRIORITY_HINT_IoPriorityVeryLow : _IO_PRIORITY_HINT = 0 ; pub const _IO_PRIORITY_HINT_IoPriorityLow : _IO_PRIORITY_HINT = 1 ; pub const _IO_PRIORITY_HINT_IoPriorityNormal : _IO_PRIORITY_HINT = 2 ; pub const _IO_PRIORITY_HINT_IoPriorityHigh : _IO_PRIORITY_HINT = 3 ; pub const _IO_PRIORITY_HINT_IoPriorityCritical : _IO_PRIORITY_HINT = 4 ; pub const _IO_PRIORITY_HINT_MaxIoPriorityTypes : _IO_PRIORITY_HINT = 5 ; pub type _IO_PRIORITY_HINT = i32 ; pub use self :: _IO_PRIORITY_HINT as IO_PRIORITY_HINT ; # [ repr ( C ) ] pub struct _FILE_IO_PRIORITY_HINT_INFORMATION { pub PriorityHint : IO_PRIORITY_HINT , } pub type FILE_IO_PRIORITY_HINT_INFORMATION = _FILE_IO_PRIORITY_HINT_INFORMATION ; pub type PFILE_IO_PRIORITY_HINT_INFORMATION = * mut _FILE_IO_PRIORITY_HINT_INFORMATION ; # [ repr ( C ) ] pub struct _FILE_IO_PRIORITY_HINT_INFORMATION_EX { pub PriorityHint : IO_PRIORITY_HINT , pub BoostOutstanding : BOOLEAN , } pub type FILE_IO_PRIORITY_HINT_INFORMATION_EX = _FILE_IO_PRIORITY_HINT_INFORMATION_EX ; pub type PFILE_IO_PRIORITY_HINT_INFORMATION_EX = * mut _FILE_IO_PRIORITY_HINT_INFORMATION_EX ; # [ repr ( C ) ] pub struct _FILE_IO_COMPLETION_NOTIFICATION_INFORMATION { pub Flags : ULONG , } pub type FILE_IO_COMPLETION_NOTIFICATION_INFORMATION = _FILE_IO_COMPLETION_NOTIFICATION_INFORMATION ; pub type PFILE_IO_COMPLETION_NOTIFICATION_INFORMATION = * mut _FILE_IO_COMPLETION_NOTIFICATION_INFORMATION ; # [ repr ( C ) ] pub struct _FILE_PROCESS_IDS_USING_FILE_INFORMATION { pub NumberOfProcessIdsInList : ULONG , pub ProcessIdList : [ ULONG_PTR ; 1usize ] , } pub type FILE_PROCESS_IDS_USING_FILE_INFORMATION = _FILE_PROCESS_IDS_USING_FILE_INFORMATION ; pub type PFILE_PROCESS_IDS_USING_FILE_INFORMATION = * mut _FILE_PROCESS_IDS_USING_FILE_INFORMATION ; # [ repr ( C ) ] pub struct _FILE_IS_REMOTE_DEVICE_INFORMATION { pub IsRemote : BOOLEAN , } pub type FILE_IS_REMOTE_DEVICE_INFORMATION = _FILE_IS_REMOTE_DEVICE_INFORMATION ; pub type PFILE_IS_REMOTE_DEVICE_INFORMATION = * mut _FILE_IS_REMOTE_DEVICE_INFORMATION ; # [ repr ( C ) ] pub struct _FILE_NUMA_NODE_INFORMATION { pub NodeNumber : USHORT , } pub type FILE_NUMA_NODE_INFORMATION = _FILE_NUMA_NODE_INFORMATION ; pub type PFILE_NUMA_NODE_INFORMATION = * mut _FILE_NUMA_NODE_INFORMATION ; # [ repr ( C ) ] pub struct _FILE_IOSTATUSBLOCK_RANGE_INFORMATION { pub IoStatusBlockRange : PUCHAR , pub Length : ULONG , } pub type FILE_IOSTATUSBLOCK_RANGE_INFORMATION = _FILE_IOSTATUSBLOCK_RANGE_INFORMATION ; pub type PFILE_IOSTATUSBLOCK_RANGE_INFORMATION = * mut _FILE_IOSTATUSBLOCK_RANGE_INFORMATION ; # [ repr ( C ) ] pub struct _FILE_MEMORY_PARTITION_INFORMATION { pub OwnerPartitionHandle : ULONG_PTR , pub Flags : _FILE_MEMORY_PARTITION_INFORMATION__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _FILE_MEMORY_PARTITION_INFORMATION__bindgen_ty_1 { pub __bindgen_anon_1 : __BindgenUnionField < _FILE_MEMORY_PARTITION_INFORMATION__bindgen_ty_1__bindgen_ty_1 > , pub AllFlags : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _FILE_MEMORY_PARTITION_INFORMATION__bindgen_ty_1__bindgen_ty_1 { pub NoCrossPartitionAccess : UCHAR , pub Spare : [ UCHAR ; 3usize ] , } pub type FILE_MEMORY_PARTITION_INFORMATION = _FILE_MEMORY_PARTITION_INFORMATION ; pub type PFILE_MEMORY_PARTITION_INFORMATION = * mut _FILE_MEMORY_PARTITION_INFORMATION ; pub const _FSINFOCLASS_FileFsVolumeInformation : _FSINFOCLASS = 1 ; pub const _FSINFOCLASS_FileFsLabelInformation : _FSINFOCLASS = 2 ; pub const _FSINFOCLASS_FileFsSizeInformation : _FSINFOCLASS = 3 ; pub const _FSINFOCLASS_FileFsDeviceInformation : _FSINFOCLASS = 4 ; pub const _FSINFOCLASS_FileFsAttributeInformation : _FSINFOCLASS = 5 ; pub const _FSINFOCLASS_FileFsControlInformation : _FSINFOCLASS = 6 ; pub const _FSINFOCLASS_FileFsFullSizeInformation : _FSINFOCLASS = 7 ; pub const _FSINFOCLASS_FileFsObjectIdInformation : _FSINFOCLASS = 8 ; pub const _FSINFOCLASS_FileFsDriverPathInformation : _FSINFOCLASS = 9 ; pub const _FSINFOCLASS_FileFsVolumeFlagsInformation : _FSINFOCLASS = 10 ; pub const _FSINFOCLASS_FileFsSectorSizeInformation : _FSINFOCLASS = 11 ; pub const _FSINFOCLASS_FileFsDataCopyInformation : _FSINFOCLASS = 12 ; pub const _FSINFOCLASS_FileFsMetadataSizeInformation : _FSINFOCLASS = 13 ; pub const _FSINFOCLASS_FileFsMaximumInformation : _FSINFOCLASS = 14 ; pub type _FSINFOCLASS = i32 ; pub use self :: _FSINFOCLASS as FS_INFORMATION_CLASS ; pub type PFS_INFORMATION_CLASS = * mut _FSINFOCLASS ; # [ repr ( C ) ] pub struct _FILE_FS_DEVICE_INFORMATION { pub DeviceType : ULONG , pub Characteristics : ULONG , } pub type FILE_FS_DEVICE_INFORMATION = _FILE_FS_DEVICE_INFORMATION ; pub type PFILE_FS_DEVICE_INFORMATION = * mut _FILE_FS_DEVICE_INFORMATION ; # [ repr ( C ) ] pub struct _FILE_SEGMENT_ELEMENT { pub Buffer : __BindgenUnionField < * mut :: std :: os :: raw :: c_void > , pub Alignment : __BindgenUnionField < ULONGLONG > , pub bindgen_union_field : u64 , } pub type FILE_SEGMENT_ELEMENT = _FILE_SEGMENT_ELEMENT ; pub type PFILE_SEGMENT_ELEMENT = * mut _FILE_SEGMENT_ELEMENT ; pub const _INTERFACE_TYPE_InterfaceTypeUndefined : _INTERFACE_TYPE = -1 ; pub const _INTERFACE_TYPE_Internal : _INTERFACE_TYPE = 0 ; pub const _INTERFACE_TYPE_Isa : _INTERFACE_TYPE = 1 ; pub const _INTERFACE_TYPE_Eisa : _INTERFACE_TYPE = 2 ; pub const _INTERFACE_TYPE_MicroChannel : _INTERFACE_TYPE = 3 ; pub const _INTERFACE_TYPE_TurboChannel : _INTERFACE_TYPE = 4 ; pub const _INTERFACE_TYPE_PCIBus : _INTERFACE_TYPE = 5 ; pub const _INTERFACE_TYPE_VMEBus : _INTERFACE_TYPE = 6 ; pub const _INTERFACE_TYPE_NuBus : _INTERFACE_TYPE = 7 ; pub const _INTERFACE_TYPE_PCMCIABus : _INTERFACE_TYPE = 8 ; pub const _INTERFACE_TYPE_CBus : _INTERFACE_TYPE = 9 ; pub const _INTERFACE_TYPE_MPIBus : _INTERFACE_TYPE = 10 ; pub const _INTERFACE_TYPE_MPSABus : _INTERFACE_TYPE = 11 ; pub const _INTERFACE_TYPE_ProcessorInternal : _INTERFACE_TYPE = 12 ; pub const _INTERFACE_TYPE_InternalPowerBus : _INTERFACE_TYPE = 13 ; pub const _INTERFACE_TYPE_PNPISABus : _INTERFACE_TYPE = 14 ; pub const _INTERFACE_TYPE_PNPBus : _INTERFACE_TYPE = 15 ; pub const _INTERFACE_TYPE_Vmcs : _INTERFACE_TYPE = 16 ; pub const _INTERFACE_TYPE_ACPIBus : _INTERFACE_TYPE = 17 ; pub const _INTERFACE_TYPE_MaximumInterfaceType : _INTERFACE_TYPE = 18 ; pub type _INTERFACE_TYPE = i32 ; pub use self :: _INTERFACE_TYPE as INTERFACE_TYPE ; pub type PINTERFACE_TYPE = * mut _INTERFACE_TYPE ; pub const _DMA_WIDTH_Width8Bits : _DMA_WIDTH = 0 ; pub const _DMA_WIDTH_Width16Bits : _DMA_WIDTH = 1 ; pub const _DMA_WIDTH_Width32Bits : _DMA_WIDTH = 2 ; pub const _DMA_WIDTH_Width64Bits : _DMA_WIDTH = 3 ; pub const _DMA_WIDTH_WidthNoWrap : _DMA_WIDTH = 4 ; pub const _DMA_WIDTH_MaximumDmaWidth : _DMA_WIDTH = 5 ; pub type _DMA_WIDTH = i32 ; pub use self :: _DMA_WIDTH as DMA_WIDTH ; pub type PDMA_WIDTH = * mut _DMA_WIDTH ; pub const _DMA_SPEED_Compatible : _DMA_SPEED = 0 ; pub const _DMA_SPEED_TypeA : _DMA_SPEED = 1 ; pub const _DMA_SPEED_TypeB : _DMA_SPEED = 2 ; pub const _DMA_SPEED_TypeC : _DMA_SPEED = 3 ; pub const _DMA_SPEED_TypeF : _DMA_SPEED = 4 ; pub const _DMA_SPEED_MaximumDmaSpeed : _DMA_SPEED = 5 ; pub type _DMA_SPEED = i32 ; pub use self :: _DMA_SPEED as DMA_SPEED ; pub type PDMA_SPEED = * mut _DMA_SPEED ; pub type PINTERFACE_REFERENCE = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID ) > ; pub type PINTERFACE_DEREFERENCE = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID ) > ; # [ repr ( C ) ] pub struct _IO_ERROR_LOG_PACKET { pub MajorFunctionCode : UCHAR , pub RetryCount : UCHAR , pub DumpDataSize : USHORT , pub NumberOfStrings : USHORT , pub StringOffset : USHORT , pub EventCategory : USHORT , pub ErrorCode : NTSTATUS , pub UniqueErrorValue : ULONG , pub FinalStatus : NTSTATUS , pub SequenceNumber : ULONG , pub IoControlCode : ULONG , pub DeviceOffset : LARGE_INTEGER , pub DumpData : [ ULONG ; 1usize ] , } pub type IO_ERROR_LOG_PACKET = _IO_ERROR_LOG_PACKET ; pub type PIO_ERROR_LOG_PACKET = * mut _IO_ERROR_LOG_PACKET ; # [ repr ( C ) ] pub struct _IO_ERROR_LOG_MESSAGE { pub Type : USHORT , pub Size : USHORT , pub DriverNameLength : USHORT , pub TimeStamp : LARGE_INTEGER , pub DriverNameOffset : ULONG , pub EntryData : IO_ERROR_LOG_PACKET , } pub type IO_ERROR_LOG_MESSAGE = _IO_ERROR_LOG_MESSAGE ; pub type PIO_ERROR_LOG_MESSAGE = * mut _IO_ERROR_LOG_MESSAGE ; # [ repr ( C ) ] pub struct _KEY_BASIC_INFORMATION { pub LastWriteTime : LARGE_INTEGER , pub TitleIndex : ULONG , pub NameLength : ULONG , pub Name : [ WCHAR ; 1usize ] , } pub type KEY_BASIC_INFORMATION = _KEY_BASIC_INFORMATION ; pub type PKEY_BASIC_INFORMATION = * mut _KEY_BASIC_INFORMATION ; # [ repr ( C ) ] pub struct _KEY_NODE_INFORMATION { pub LastWriteTime : LARGE_INTEGER , pub TitleIndex : ULONG , pub ClassOffset : ULONG , pub ClassLength : ULONG , pub NameLength : ULONG , pub Name : [ WCHAR ; 1usize ] , } pub type KEY_NODE_INFORMATION = _KEY_NODE_INFORMATION ; pub type PKEY_NODE_INFORMATION = * mut _KEY_NODE_INFORMATION ; # [ repr ( C ) ] pub struct _KEY_FULL_INFORMATION { pub LastWriteTime : LARGE_INTEGER , pub TitleIndex : ULONG , pub ClassOffset : ULONG , pub ClassLength : ULONG , pub SubKeys : ULONG , pub MaxNameLen : ULONG , pub MaxClassLen : ULONG , pub Values : ULONG , pub MaxValueNameLen : ULONG , pub MaxValueDataLen : ULONG , pub Class : [ WCHAR ; 1usize ] , } pub type KEY_FULL_INFORMATION = _KEY_FULL_INFORMATION ; pub type PKEY_FULL_INFORMATION = * mut _KEY_FULL_INFORMATION ; pub const _KEY_INFORMATION_CLASS_KeyBasicInformation : _KEY_INFORMATION_CLASS = 0 ; pub const _KEY_INFORMATION_CLASS_KeyNodeInformation : _KEY_INFORMATION_CLASS = 1 ; pub const _KEY_INFORMATION_CLASS_KeyFullInformation : _KEY_INFORMATION_CLASS = 2 ; pub const _KEY_INFORMATION_CLASS_KeyNameInformation : _KEY_INFORMATION_CLASS = 3 ; pub const _KEY_INFORMATION_CLASS_KeyCachedInformation : _KEY_INFORMATION_CLASS = 4 ; pub const _KEY_INFORMATION_CLASS_KeyFlagsInformation : _KEY_INFORMATION_CLASS = 5 ; pub const _KEY_INFORMATION_CLASS_KeyVirtualizationInformation : _KEY_INFORMATION_CLASS = 6 ; pub const _KEY_INFORMATION_CLASS_KeyHandleTagsInformation : _KEY_INFORMATION_CLASS = 7 ; pub const _KEY_INFORMATION_CLASS_KeyTrustInformation : _KEY_INFORMATION_CLASS = 8 ; pub const _KEY_INFORMATION_CLASS_KeyLayerInformation : _KEY_INFORMATION_CLASS = 9 ; pub const _KEY_INFORMATION_CLASS_MaxKeyInfoClass : _KEY_INFORMATION_CLASS = 10 ; pub type _KEY_INFORMATION_CLASS = i32 ; pub use self :: _KEY_INFORMATION_CLASS as KEY_INFORMATION_CLASS ; # [ repr ( C ) ] pub struct _KEY_WRITE_TIME_INFORMATION { pub LastWriteTime : LARGE_INTEGER , } pub type KEY_WRITE_TIME_INFORMATION = _KEY_WRITE_TIME_INFORMATION ; pub type PKEY_WRITE_TIME_INFORMATION = * mut _KEY_WRITE_TIME_INFORMATION ; # [ repr ( C ) ] pub struct _KEY_WOW64_FLAGS_INFORMATION { pub UserFlags : ULONG , } pub type KEY_WOW64_FLAGS_INFORMATION = _KEY_WOW64_FLAGS_INFORMATION ; pub type PKEY_WOW64_FLAGS_INFORMATION = * mut _KEY_WOW64_FLAGS_INFORMATION ; # [ repr ( C ) ] pub struct _KEY_CONTROL_FLAGS_INFORMATION { pub ControlFlags : ULONG , } pub type KEY_CONTROL_FLAGS_INFORMATION = _KEY_CONTROL_FLAGS_INFORMATION ; pub type PKEY_CONTROL_FLAGS_INFORMATION = * mut _KEY_CONTROL_FLAGS_INFORMATION ; # [ repr ( C ) ] pub struct _KEY_SET_VIRTUALIZATION_INFORMATION { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _KEY_SET_VIRTUALIZATION_INFORMATION { # [ inline ] pub fn VirtualTarget ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_VirtualTarget ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn VirtualStore ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_VirtualStore ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn VirtualSource ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_VirtualSource ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 29u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 29u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( VirtualTarget : ULONG , VirtualStore : ULONG , VirtualSource : ULONG , Reserved : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let VirtualTarget : u32 = unsafe { :: std :: mem :: transmute ( VirtualTarget ) } ; VirtualTarget as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let VirtualStore : u32 = unsafe { :: std :: mem :: transmute ( VirtualStore ) } ; VirtualStore as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let VirtualSource : u32 = unsafe { :: std :: mem :: transmute ( VirtualSource ) } ; VirtualSource as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 29u8 , { let Reserved : u32 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type KEY_SET_VIRTUALIZATION_INFORMATION = _KEY_SET_VIRTUALIZATION_INFORMATION ; pub type PKEY_SET_VIRTUALIZATION_INFORMATION = * mut _KEY_SET_VIRTUALIZATION_INFORMATION ; pub const _KEY_SET_INFORMATION_CLASS_KeyWriteTimeInformation : _KEY_SET_INFORMATION_CLASS = 0 ; pub const _KEY_SET_INFORMATION_CLASS_KeyWow64FlagsInformation : _KEY_SET_INFORMATION_CLASS = 1 ; pub const _KEY_SET_INFORMATION_CLASS_KeyControlFlagsInformation : _KEY_SET_INFORMATION_CLASS = 2 ; pub const _KEY_SET_INFORMATION_CLASS_KeySetVirtualizationInformation : _KEY_SET_INFORMATION_CLASS = 3 ; pub const _KEY_SET_INFORMATION_CLASS_KeySetDebugInformation : _KEY_SET_INFORMATION_CLASS = 4 ; pub const _KEY_SET_INFORMATION_CLASS_KeySetHandleTagsInformation : _KEY_SET_INFORMATION_CLASS = 5 ; pub const _KEY_SET_INFORMATION_CLASS_KeySetLayerInformation : _KEY_SET_INFORMATION_CLASS = 6 ; pub const _KEY_SET_INFORMATION_CLASS_MaxKeySetInfoClass : _KEY_SET_INFORMATION_CLASS = 7 ; pub type _KEY_SET_INFORMATION_CLASS = i32 ; pub use self :: _KEY_SET_INFORMATION_CLASS as KEY_SET_INFORMATION_CLASS ; # [ repr ( C ) ] pub struct _KEY_VALUE_BASIC_INFORMATION { pub TitleIndex : ULONG , pub Type : ULONG , pub NameLength : ULONG , pub Name : [ WCHAR ; 1usize ] , } pub type KEY_VALUE_BASIC_INFORMATION = _KEY_VALUE_BASIC_INFORMATION ; pub type PKEY_VALUE_BASIC_INFORMATION = * mut _KEY_VALUE_BASIC_INFORMATION ; # [ repr ( C ) ] pub struct _KEY_VALUE_FULL_INFORMATION { pub TitleIndex : ULONG , pub Type : ULONG , pub DataOffset : ULONG , pub DataLength : ULONG , pub NameLength : ULONG , pub Name : [ WCHAR ; 1usize ] , } pub type KEY_VALUE_FULL_INFORMATION = _KEY_VALUE_FULL_INFORMATION ; pub type PKEY_VALUE_FULL_INFORMATION = * mut _KEY_VALUE_FULL_INFORMATION ; # [ repr ( C ) ] pub struct _KEY_VALUE_PARTIAL_INFORMATION { pub TitleIndex : ULONG , pub Type : ULONG , pub DataLength : ULONG , pub Data : [ UCHAR ; 1usize ] , } pub type KEY_VALUE_PARTIAL_INFORMATION = _KEY_VALUE_PARTIAL_INFORMATION ; pub type PKEY_VALUE_PARTIAL_INFORMATION = * mut _KEY_VALUE_PARTIAL_INFORMATION ; # [ repr ( C ) ] pub struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 { pub Type : ULONG , pub DataLength : ULONG , pub Data : [ UCHAR ; 1usize ] , } pub type KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 = _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 ; pub type PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64 = * mut _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 ; # [ repr ( C ) ] pub struct _KEY_VALUE_LAYER_INFORMATION { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _KEY_VALUE_LAYER_INFORMATION { # [ inline ] pub fn IsTombstone ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_IsTombstone ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 31u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 31u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( IsTombstone : ULONG , Reserved : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let IsTombstone : u32 = unsafe { :: std :: mem :: transmute ( IsTombstone ) } ; IsTombstone as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 31u8 , { let Reserved : u32 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type KEY_VALUE_LAYER_INFORMATION = _KEY_VALUE_LAYER_INFORMATION ; pub type PKEY_VALUE_LAYER_INFORMATION = * mut _KEY_VALUE_LAYER_INFORMATION ; # [ repr ( C ) ] pub struct _KEY_VALUE_ENTRY { pub ValueName : PUNICODE_STRING , pub DataLength : ULONG , pub DataOffset : ULONG , pub Type : ULONG , } pub type KEY_VALUE_ENTRY = _KEY_VALUE_ENTRY ; pub type PKEY_VALUE_ENTRY = * mut _KEY_VALUE_ENTRY ; pub const _KEY_VALUE_INFORMATION_CLASS_KeyValueBasicInformation : _KEY_VALUE_INFORMATION_CLASS = 0 ; pub const _KEY_VALUE_INFORMATION_CLASS_KeyValueFullInformation : _KEY_VALUE_INFORMATION_CLASS = 1 ; pub const _KEY_VALUE_INFORMATION_CLASS_KeyValuePartialInformation : _KEY_VALUE_INFORMATION_CLASS = 2 ; pub const _KEY_VALUE_INFORMATION_CLASS_KeyValueFullInformationAlign64 : _KEY_VALUE_INFORMATION_CLASS = 3 ; pub const _KEY_VALUE_INFORMATION_CLASS_KeyValuePartialInformationAlign64 : _KEY_VALUE_INFORMATION_CLASS = 4 ; pub const _KEY_VALUE_INFORMATION_CLASS_KeyValueLayerInformation : _KEY_VALUE_INFORMATION_CLASS = 5 ; pub const _KEY_VALUE_INFORMATION_CLASS_MaxKeyValueInfoClass : _KEY_VALUE_INFORMATION_CLASS = 6 ; pub type _KEY_VALUE_INFORMATION_CLASS = i32 ; pub use self :: _KEY_VALUE_INFORMATION_CLASS as KEY_VALUE_INFORMATION_CLASS ; # [ repr ( C ) ] pub struct _KEY_TRUST_INFORMATION { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _KEY_TRUST_INFORMATION { # [ inline ] pub fn TrustedKey ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_TrustedKey ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 31u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 31u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( TrustedKey : ULONG , Reserved : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let TrustedKey : u32 = unsafe { :: std :: mem :: transmute ( TrustedKey ) } ; TrustedKey as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 31u8 , { let Reserved : u32 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type KEY_TRUST_INFORMATION = _KEY_TRUST_INFORMATION ; pub type PKEY_TRUST_INFORMATION = * mut _KEY_TRUST_INFORMATION ; # [ repr ( C ) ] pub struct _OBJECT_NAME_INFORMATION { pub Name : UNICODE_STRING , } pub type OBJECT_NAME_INFORMATION = _OBJECT_NAME_INFORMATION ; pub type POBJECT_NAME_INFORMATION = * mut _OBJECT_NAME_INFORMATION ; pub const _SECTION_INHERIT_ViewShare : _SECTION_INHERIT = 1 ; pub const _SECTION_INHERIT_ViewUnmap : _SECTION_INHERIT = 2 ; pub type _SECTION_INHERIT = i32 ; pub use self :: _SECTION_INHERIT as SECTION_INHERIT ; # [ repr ( C ) ] pub struct _CLIENT_ID { pub UniqueProcess : HANDLE , pub UniqueThread : HANDLE , } pub type CLIENT_ID = _CLIENT_ID ; pub type PCLIENT_ID = * mut CLIENT_ID ; extern "C" { # [ link_name = "\u{1}GUID_MAX_POWER_SAVINGS" ] pub static mut GUID_MAX_POWER_SAVINGS : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_MIN_POWER_SAVINGS" ] pub static mut GUID_MIN_POWER_SAVINGS : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_TYPICAL_POWER_SAVINGS" ] pub static mut GUID_TYPICAL_POWER_SAVINGS : GUID ; } extern "C" { # [ link_name = "\u{1}NO_SUBGROUP_GUID" ] pub static mut NO_SUBGROUP_GUID : GUID ; } extern "C" { # [ link_name = "\u{1}ALL_POWERSCHEMES_GUID" ] pub static mut ALL_POWERSCHEMES_GUID : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_POWERSCHEME_PERSONALITY" ] pub static mut GUID_POWERSCHEME_PERSONALITY : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_ACTIVE_POWERSCHEME" ] pub static mut GUID_ACTIVE_POWERSCHEME : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_IDLE_RESILIENCY_SUBGROUP" ] pub static mut GUID_IDLE_RESILIENCY_SUBGROUP : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_IDLE_RESILIENCY_PERIOD" ] pub static mut GUID_IDLE_RESILIENCY_PERIOD : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_DEEP_SLEEP_ENABLED" ] pub static mut GUID_DEEP_SLEEP_ENABLED : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_DEEP_SLEEP_PLATFORM_STATE" ] pub static mut GUID_DEEP_SLEEP_PLATFORM_STATE : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_DISK_COALESCING_POWERDOWN_TIMEOUT" ] pub static mut GUID_DISK_COALESCING_POWERDOWN_TIMEOUT : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_EXECUTION_REQUIRED_REQUEST_TIMEOUT" ] pub static mut GUID_EXECUTION_REQUIRED_REQUEST_TIMEOUT : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_VIDEO_SUBGROUP" ] pub static mut GUID_VIDEO_SUBGROUP : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_VIDEO_POWERDOWN_TIMEOUT" ] pub static mut GUID_VIDEO_POWERDOWN_TIMEOUT : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_VIDEO_ANNOYANCE_TIMEOUT" ] pub static mut GUID_VIDEO_ANNOYANCE_TIMEOUT : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE" ] pub static mut GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_VIDEO_DIM_TIMEOUT" ] pub static mut GUID_VIDEO_DIM_TIMEOUT : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_VIDEO_ADAPTIVE_POWERDOWN" ] pub static mut GUID_VIDEO_ADAPTIVE_POWERDOWN : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_MONITOR_POWER_ON" ] pub static mut GUID_MONITOR_POWER_ON : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS" ] pub static mut GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS" ] pub static mut GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS" ] pub static mut GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS" ] pub static mut GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_CONSOLE_DISPLAY_STATE" ] pub static mut GUID_CONSOLE_DISPLAY_STATE : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_ALLOW_DISPLAY_REQUIRED" ] pub static mut GUID_ALLOW_DISPLAY_REQUIRED : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_VIDEO_CONSOLE_LOCK_TIMEOUT" ] pub static mut GUID_VIDEO_CONSOLE_LOCK_TIMEOUT : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_ADAPTIVE_POWER_BEHAVIOR_SUBGROUP" ] pub static mut GUID_ADAPTIVE_POWER_BEHAVIOR_SUBGROUP : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_NON_ADAPTIVE_INPUT_TIMEOUT" ] pub static mut GUID_NON_ADAPTIVE_INPUT_TIMEOUT : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_ADAPTIVE_INPUT_CONTROLLER_STATE" ] pub static mut GUID_ADAPTIVE_INPUT_CONTROLLER_STATE : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_DISK_SUBGROUP" ] pub static mut GUID_DISK_SUBGROUP : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_DISK_MAX_POWER" ] pub static mut GUID_DISK_MAX_POWER : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_DISK_POWERDOWN_TIMEOUT" ] pub static mut GUID_DISK_POWERDOWN_TIMEOUT : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_DISK_IDLE_TIMEOUT" ] pub static mut GUID_DISK_IDLE_TIMEOUT : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_DISK_BURST_IGNORE_THRESHOLD" ] pub static mut GUID_DISK_BURST_IGNORE_THRESHOLD : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_DISK_ADAPTIVE_POWERDOWN" ] pub static mut GUID_DISK_ADAPTIVE_POWERDOWN : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_SLEEP_SUBGROUP" ] pub static mut GUID_SLEEP_SUBGROUP : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_SLEEP_IDLE_THRESHOLD" ] pub static mut GUID_SLEEP_IDLE_THRESHOLD : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_STANDBY_TIMEOUT" ] pub static mut GUID_STANDBY_TIMEOUT : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_UNATTEND_SLEEP_TIMEOUT" ] pub static mut GUID_UNATTEND_SLEEP_TIMEOUT : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_HIBERNATE_TIMEOUT" ] pub static mut GUID_HIBERNATE_TIMEOUT : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_HIBERNATE_FASTS4_POLICY" ] pub static mut GUID_HIBERNATE_FASTS4_POLICY : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_CRITICAL_POWER_TRANSITION" ] pub static mut GUID_CRITICAL_POWER_TRANSITION : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_SYSTEM_AWAYMODE" ] pub static mut GUID_SYSTEM_AWAYMODE : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_ALLOW_AWAYMODE" ] pub static mut GUID_ALLOW_AWAYMODE : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_USER_PRESENCE_PREDICTION" ] pub static mut GUID_USER_PRESENCE_PREDICTION : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_STANDBY_BUDGET_GRACE_PERIOD" ] pub static mut GUID_STANDBY_BUDGET_GRACE_PERIOD : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_STANDBY_BUDGET_PERCENT" ] pub static mut GUID_STANDBY_BUDGET_PERCENT : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_STANDBY_RESERVE_GRACE_PERIOD" ] pub static mut GUID_STANDBY_RESERVE_GRACE_PERIOD : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_STANDBY_RESERVE_TIME" ] pub static mut GUID_STANDBY_RESERVE_TIME : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_STANDBY_RESET_PERCENT" ] pub static mut GUID_STANDBY_RESET_PERCENT : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_ALLOW_STANDBY_STATES" ] pub static mut GUID_ALLOW_STANDBY_STATES : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_ALLOW_RTC_WAKE" ] pub static mut GUID_ALLOW_RTC_WAKE : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_LEGACY_RTC_MITIGATION" ] pub static mut GUID_LEGACY_RTC_MITIGATION : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_ALLOW_SYSTEM_REQUIRED" ] pub static mut GUID_ALLOW_SYSTEM_REQUIRED : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_POWER_SAVING_STATUS" ] pub static mut GUID_POWER_SAVING_STATUS : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_ENERGY_SAVER_SUBGROUP" ] pub static mut GUID_ENERGY_SAVER_SUBGROUP : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_ENERGY_SAVER_BATTERY_THRESHOLD" ] pub static mut GUID_ENERGY_SAVER_BATTERY_THRESHOLD : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_ENERGY_SAVER_BRIGHTNESS" ] pub static mut GUID_ENERGY_SAVER_BRIGHTNESS : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_ENERGY_SAVER_POLICY" ] pub static mut GUID_ENERGY_SAVER_POLICY : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_SYSTEM_BUTTON_SUBGROUP" ] pub static mut GUID_SYSTEM_BUTTON_SUBGROUP : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_POWERBUTTON_ACTION" ] pub static mut GUID_POWERBUTTON_ACTION : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_SLEEPBUTTON_ACTION" ] pub static mut GUID_SLEEPBUTTON_ACTION : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_USERINTERFACEBUTTON_ACTION" ] pub static mut GUID_USERINTERFACEBUTTON_ACTION : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_LIDCLOSE_ACTION" ] pub static mut GUID_LIDCLOSE_ACTION : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_LIDOPEN_POWERSTATE" ] pub static mut GUID_LIDOPEN_POWERSTATE : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_BATTERY_SUBGROUP" ] pub static mut GUID_BATTERY_SUBGROUP : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_BATTERY_DISCHARGE_ACTION_0" ] pub static mut GUID_BATTERY_DISCHARGE_ACTION_0 : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_BATTERY_DISCHARGE_LEVEL_0" ] pub static mut GUID_BATTERY_DISCHARGE_LEVEL_0 : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_BATTERY_DISCHARGE_FLAGS_0" ] pub static mut GUID_BATTERY_DISCHARGE_FLAGS_0 : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_BATTERY_DISCHARGE_ACTION_1" ] pub static mut GUID_BATTERY_DISCHARGE_ACTION_1 : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_BATTERY_DISCHARGE_LEVEL_1" ] pub static mut GUID_BATTERY_DISCHARGE_LEVEL_1 : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_BATTERY_DISCHARGE_FLAGS_1" ] pub static mut GUID_BATTERY_DISCHARGE_FLAGS_1 : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_BATTERY_DISCHARGE_ACTION_2" ] pub static mut GUID_BATTERY_DISCHARGE_ACTION_2 : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_BATTERY_DISCHARGE_LEVEL_2" ] pub static mut GUID_BATTERY_DISCHARGE_LEVEL_2 : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_BATTERY_DISCHARGE_FLAGS_2" ] pub static mut GUID_BATTERY_DISCHARGE_FLAGS_2 : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_BATTERY_DISCHARGE_ACTION_3" ] pub static mut GUID_BATTERY_DISCHARGE_ACTION_3 : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_BATTERY_DISCHARGE_LEVEL_3" ] pub static mut GUID_BATTERY_DISCHARGE_LEVEL_3 : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_BATTERY_DISCHARGE_FLAGS_3" ] pub static mut GUID_BATTERY_DISCHARGE_FLAGS_3 : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_SETTINGS_SUBGROUP" ] pub static mut GUID_PROCESSOR_SETTINGS_SUBGROUP : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_THROTTLE_POLICY" ] pub static mut GUID_PROCESSOR_THROTTLE_POLICY : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_THROTTLE_MAXIMUM" ] pub static mut GUID_PROCESSOR_THROTTLE_MAXIMUM : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_THROTTLE_MAXIMUM_1" ] pub static mut GUID_PROCESSOR_THROTTLE_MAXIMUM_1 : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_THROTTLE_MINIMUM" ] pub static mut GUID_PROCESSOR_THROTTLE_MINIMUM : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_THROTTLE_MINIMUM_1" ] pub static mut GUID_PROCESSOR_THROTTLE_MINIMUM_1 : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_FREQUENCY_LIMIT" ] pub static mut GUID_PROCESSOR_FREQUENCY_LIMIT : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_FREQUENCY_LIMIT_1" ] pub static mut GUID_PROCESSOR_FREQUENCY_LIMIT_1 : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_ALLOW_THROTTLING" ] pub static mut GUID_PROCESSOR_ALLOW_THROTTLING : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_IDLESTATE_POLICY" ] pub static mut GUID_PROCESSOR_IDLESTATE_POLICY : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_PERFSTATE_POLICY" ] pub static mut GUID_PROCESSOR_PERFSTATE_POLICY : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_PERF_INCREASE_THRESHOLD" ] pub static mut GUID_PROCESSOR_PERF_INCREASE_THRESHOLD : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_PERF_INCREASE_THRESHOLD_1" ] pub static mut GUID_PROCESSOR_PERF_INCREASE_THRESHOLD_1 : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_PERF_DECREASE_THRESHOLD" ] pub static mut GUID_PROCESSOR_PERF_DECREASE_THRESHOLD : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_PERF_DECREASE_THRESHOLD_1" ] pub static mut GUID_PROCESSOR_PERF_DECREASE_THRESHOLD_1 : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_PERF_INCREASE_POLICY" ] pub static mut GUID_PROCESSOR_PERF_INCREASE_POLICY : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_PERF_INCREASE_POLICY_1" ] pub static mut GUID_PROCESSOR_PERF_INCREASE_POLICY_1 : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_PERF_DECREASE_POLICY" ] pub static mut GUID_PROCESSOR_PERF_DECREASE_POLICY : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_PERF_DECREASE_POLICY_1" ] pub static mut GUID_PROCESSOR_PERF_DECREASE_POLICY_1 : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_PERF_INCREASE_TIME" ] pub static mut GUID_PROCESSOR_PERF_INCREASE_TIME : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_PERF_INCREASE_TIME_1" ] pub static mut GUID_PROCESSOR_PERF_INCREASE_TIME_1 : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_PERF_DECREASE_TIME" ] pub static mut GUID_PROCESSOR_PERF_DECREASE_TIME : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_PERF_DECREASE_TIME_1" ] pub static mut GUID_PROCESSOR_PERF_DECREASE_TIME_1 : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_PERF_TIME_CHECK" ] pub static mut GUID_PROCESSOR_PERF_TIME_CHECK : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_PERF_BOOST_POLICY" ] pub static mut GUID_PROCESSOR_PERF_BOOST_POLICY : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_PERF_BOOST_MODE" ] pub static mut GUID_PROCESSOR_PERF_BOOST_MODE : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_PERF_AUTONOMOUS_MODE" ] pub static mut GUID_PROCESSOR_PERF_AUTONOMOUS_MODE : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_PERF_ENERGY_PERFORMANCE_PREFERENCE" ] pub static mut GUID_PROCESSOR_PERF_ENERGY_PERFORMANCE_PREFERENCE : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_PERF_AUTONOMOUS_ACTIVITY_WINDOW" ] pub static mut GUID_PROCESSOR_PERF_AUTONOMOUS_ACTIVITY_WINDOW : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_DUTY_CYCLING" ] pub static mut GUID_PROCESSOR_DUTY_CYCLING : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_IDLE_ALLOW_SCALING" ] pub static mut GUID_PROCESSOR_IDLE_ALLOW_SCALING : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_IDLE_DISABLE" ] pub static mut GUID_PROCESSOR_IDLE_DISABLE : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_IDLE_STATE_MAXIMUM" ] pub static mut GUID_PROCESSOR_IDLE_STATE_MAXIMUM : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_IDLE_TIME_CHECK" ] pub static mut GUID_PROCESSOR_IDLE_TIME_CHECK : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_IDLE_DEMOTE_THRESHOLD" ] pub static mut GUID_PROCESSOR_IDLE_DEMOTE_THRESHOLD : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_IDLE_PROMOTE_THRESHOLD" ] pub static mut GUID_PROCESSOR_IDLE_PROMOTE_THRESHOLD : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_INCREASE_THRESHOLD" ] pub static mut GUID_PROCESSOR_CORE_PARKING_INCREASE_THRESHOLD : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_DECREASE_THRESHOLD" ] pub static mut GUID_PROCESSOR_CORE_PARKING_DECREASE_THRESHOLD : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_INCREASE_POLICY" ] pub static mut GUID_PROCESSOR_CORE_PARKING_INCREASE_POLICY : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_DECREASE_POLICY" ] pub static mut GUID_PROCESSOR_CORE_PARKING_DECREASE_POLICY : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_MAX_CORES" ] pub static mut GUID_PROCESSOR_CORE_PARKING_MAX_CORES : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_MAX_CORES_1" ] pub static mut GUID_PROCESSOR_CORE_PARKING_MAX_CORES_1 : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_MIN_CORES" ] pub static mut GUID_PROCESSOR_CORE_PARKING_MIN_CORES : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_MIN_CORES_1" ] pub static mut GUID_PROCESSOR_CORE_PARKING_MIN_CORES_1 : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_INCREASE_TIME" ] pub static mut GUID_PROCESSOR_CORE_PARKING_INCREASE_TIME : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_DECREASE_TIME" ] pub static mut GUID_PROCESSOR_CORE_PARKING_DECREASE_TIME : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_DECREASE_FACTOR" ] pub static mut GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_DECREASE_FACTOR : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_THRESHOLD" ] pub static mut GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_THRESHOLD : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_AFFINITY_WEIGHTING" ] pub static mut GUID_PROCESSOR_CORE_PARKING_AFFINITY_WEIGHTING : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_DECREASE_FACTOR" ] pub static mut GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_DECREASE_FACTOR : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_THRESHOLD" ] pub static mut GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_THRESHOLD : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_WEIGHTING" ] pub static mut GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_WEIGHTING : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_THRESHOLD" ] pub static mut GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_THRESHOLD : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_PARKING_CORE_OVERRIDE" ] pub static mut GUID_PROCESSOR_PARKING_CORE_OVERRIDE : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_PARKING_PERF_STATE" ] pub static mut GUID_PROCESSOR_PARKING_PERF_STATE : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_PARKING_PERF_STATE_1" ] pub static mut GUID_PROCESSOR_PARKING_PERF_STATE_1 : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_PARKING_CONCURRENCY_THRESHOLD" ] pub static mut GUID_PROCESSOR_PARKING_CONCURRENCY_THRESHOLD : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_PARKING_HEADROOM_THRESHOLD" ] pub static mut GUID_PROCESSOR_PARKING_HEADROOM_THRESHOLD : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_PARKING_DISTRIBUTION_THRESHOLD" ] pub static mut GUID_PROCESSOR_PARKING_DISTRIBUTION_THRESHOLD : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_PERF_HISTORY" ] pub static mut GUID_PROCESSOR_PERF_HISTORY : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_PERF_HISTORY_1" ] pub static mut GUID_PROCESSOR_PERF_HISTORY_1 : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_PERF_INCREASE_HISTORY" ] pub static mut GUID_PROCESSOR_PERF_INCREASE_HISTORY : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_PERF_DECREASE_HISTORY" ] pub static mut GUID_PROCESSOR_PERF_DECREASE_HISTORY : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_PERF_CORE_PARKING_HISTORY" ] pub static mut GUID_PROCESSOR_PERF_CORE_PARKING_HISTORY : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_PERF_LATENCY_HINT" ] pub static mut GUID_PROCESSOR_PERF_LATENCY_HINT : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_PERF_LATENCY_HINT_PERF" ] pub static mut GUID_PROCESSOR_PERF_LATENCY_HINT_PERF : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_PERF_LATENCY_HINT_PERF_1" ] pub static mut GUID_PROCESSOR_PERF_LATENCY_HINT_PERF_1 : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK" ] pub static mut GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK_1" ] pub static mut GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK_1 : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_DISTRIBUTE_UTILITY" ] pub static mut GUID_PROCESSOR_DISTRIBUTE_UTILITY : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_HETEROGENEOUS_POLICY" ] pub static mut GUID_PROCESSOR_HETEROGENEOUS_POLICY : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_HETERO_DECREASE_TIME" ] pub static mut GUID_PROCESSOR_HETERO_DECREASE_TIME : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_HETERO_INCREASE_TIME" ] pub static mut GUID_PROCESSOR_HETERO_INCREASE_TIME : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_HETERO_DECREASE_THRESHOLD" ] pub static mut GUID_PROCESSOR_HETERO_DECREASE_THRESHOLD : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_HETERO_INCREASE_THRESHOLD" ] pub static mut GUID_PROCESSOR_HETERO_INCREASE_THRESHOLD : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_CLASS0_FLOOR_PERF" ] pub static mut GUID_PROCESSOR_CLASS0_FLOOR_PERF : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_CLASS1_INITIAL_PERF" ] pub static mut GUID_PROCESSOR_CLASS1_INITIAL_PERF : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_THREAD_SCHEDULING_POLICY" ] pub static mut GUID_PROCESSOR_THREAD_SCHEDULING_POLICY : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PROCESSOR_SHORT_THREAD_SCHEDULING_POLICY" ] pub static mut GUID_PROCESSOR_SHORT_THREAD_SCHEDULING_POLICY : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_SYSTEM_COOLING_POLICY" ] pub static mut GUID_SYSTEM_COOLING_POLICY : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_LOCK_CONSOLE_ON_WAKE" ] pub static mut GUID_LOCK_CONSOLE_ON_WAKE : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_DEVICE_IDLE_POLICY" ] pub static mut GUID_DEVICE_IDLE_POLICY : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_CONNECTIVITY_IN_STANDBY" ] pub static mut GUID_CONNECTIVITY_IN_STANDBY : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_DISCONNECTED_STANDBY_MODE" ] pub static mut GUID_DISCONNECTED_STANDBY_MODE : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_ACDC_POWER_SOURCE" ] pub static mut GUID_ACDC_POWER_SOURCE : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_LIDSWITCH_STATE_CHANGE" ] pub static mut GUID_LIDSWITCH_STATE_CHANGE : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_BATTERY_PERCENTAGE_REMAINING" ] pub static mut GUID_BATTERY_PERCENTAGE_REMAINING : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_BATTERY_COUNT" ] pub static mut GUID_BATTERY_COUNT : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_GLOBAL_USER_PRESENCE" ] pub static mut GUID_GLOBAL_USER_PRESENCE : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_SESSION_DISPLAY_STATUS" ] pub static mut GUID_SESSION_DISPLAY_STATUS : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_SESSION_USER_PRESENCE" ] pub static mut GUID_SESSION_USER_PRESENCE : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_IDLE_BACKGROUND_TASK" ] pub static mut GUID_IDLE_BACKGROUND_TASK : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_BACKGROUND_TASK_NOTIFICATION" ] pub static mut GUID_BACKGROUND_TASK_NOTIFICATION : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_APPLAUNCH_BUTTON" ] pub static mut GUID_APPLAUNCH_BUTTON : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PCIEXPRESS_SETTINGS_SUBGROUP" ] pub static mut GUID_PCIEXPRESS_SETTINGS_SUBGROUP : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_PCIEXPRESS_ASPM_POLICY" ] pub static mut GUID_PCIEXPRESS_ASPM_POLICY : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_ENABLE_SWITCH_FORCED_SHUTDOWN" ] pub static mut GUID_ENABLE_SWITCH_FORCED_SHUTDOWN : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_INTSTEER_SUBGROUP" ] pub static mut GUID_INTSTEER_SUBGROUP : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_INTSTEER_MODE" ] pub static mut GUID_INTSTEER_MODE : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_INTSTEER_LOAD_PER_PROC_TRIGGER" ] pub static mut GUID_INTSTEER_LOAD_PER_PROC_TRIGGER : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_INTSTEER_TIME_UNPARK_TRIGGER" ] pub static mut GUID_INTSTEER_TIME_UNPARK_TRIGGER : GUID ; } extern "C" { # [ link_name = "\u{1}GUID_MIXED_REALITY_MODE" ] pub static mut GUID_MIXED_REALITY_MODE : GUID ; } pub const _SYSTEM_POWER_STATE_PowerSystemUnspecified : _SYSTEM_POWER_STATE = 0 ; pub const _SYSTEM_POWER_STATE_PowerSystemWorking : _SYSTEM_POWER_STATE = 1 ; pub const _SYSTEM_POWER_STATE_PowerSystemSleeping1 : _SYSTEM_POWER_STATE = 2 ; pub const _SYSTEM_POWER_STATE_PowerSystemSleeping2 : _SYSTEM_POWER_STATE = 3 ; pub const _SYSTEM_POWER_STATE_PowerSystemSleeping3 : _SYSTEM_POWER_STATE = 4 ; pub const _SYSTEM_POWER_STATE_PowerSystemHibernate : _SYSTEM_POWER_STATE = 5 ; pub const _SYSTEM_POWER_STATE_PowerSystemShutdown : _SYSTEM_POWER_STATE = 6 ; pub const _SYSTEM_POWER_STATE_PowerSystemMaximum : _SYSTEM_POWER_STATE = 7 ; pub type _SYSTEM_POWER_STATE = i32 ; pub use self :: _SYSTEM_POWER_STATE as SYSTEM_POWER_STATE ; pub type PSYSTEM_POWER_STATE = * mut _SYSTEM_POWER_STATE ; pub const POWER_ACTION_PowerActionNone : POWER_ACTION = 0 ; pub const POWER_ACTION_PowerActionReserved : POWER_ACTION = 1 ; pub const POWER_ACTION_PowerActionSleep : POWER_ACTION = 2 ; pub const POWER_ACTION_PowerActionHibernate : POWER_ACTION = 3 ; pub const POWER_ACTION_PowerActionShutdown : POWER_ACTION = 4 ; pub const POWER_ACTION_PowerActionShutdownReset : POWER_ACTION = 5 ; pub const POWER_ACTION_PowerActionShutdownOff : POWER_ACTION = 6 ; pub const POWER_ACTION_PowerActionWarmEject : POWER_ACTION = 7 ; pub const POWER_ACTION_PowerActionDisplayOff : POWER_ACTION = 8 ; pub type POWER_ACTION = i32 ; pub type PPOWER_ACTION = * mut POWER_ACTION ; pub const _DEVICE_POWER_STATE_PowerDeviceUnspecified : _DEVICE_POWER_STATE = 0 ; pub const _DEVICE_POWER_STATE_PowerDeviceD0 : _DEVICE_POWER_STATE = 1 ; pub const _DEVICE_POWER_STATE_PowerDeviceD1 : _DEVICE_POWER_STATE = 2 ; pub const _DEVICE_POWER_STATE_PowerDeviceD2 : _DEVICE_POWER_STATE = 3 ; pub const _DEVICE_POWER_STATE_PowerDeviceD3 : _DEVICE_POWER_STATE = 4 ; pub const _DEVICE_POWER_STATE_PowerDeviceMaximum : _DEVICE_POWER_STATE = 5 ; pub type _DEVICE_POWER_STATE = i32 ; pub use self :: _DEVICE_POWER_STATE as DEVICE_POWER_STATE ; pub type PDEVICE_POWER_STATE = * mut _DEVICE_POWER_STATE ; pub const _MONITOR_DISPLAY_STATE_PowerMonitorOff : _MONITOR_DISPLAY_STATE = 0 ; pub const _MONITOR_DISPLAY_STATE_PowerMonitorOn : _MONITOR_DISPLAY_STATE = 1 ; pub const _MONITOR_DISPLAY_STATE_PowerMonitorDim : _MONITOR_DISPLAY_STATE = 2 ; pub type _MONITOR_DISPLAY_STATE = i32 ; pub use self :: _MONITOR_DISPLAY_STATE as MONITOR_DISPLAY_STATE ; pub type PMONITOR_DISPLAY_STATE = * mut _MONITOR_DISPLAY_STATE ; pub const _USER_ACTIVITY_PRESENCE_PowerUserPresent : _USER_ACTIVITY_PRESENCE = 0 ; pub const _USER_ACTIVITY_PRESENCE_PowerUserNotPresent : _USER_ACTIVITY_PRESENCE = 1 ; pub const _USER_ACTIVITY_PRESENCE_PowerUserInactive : _USER_ACTIVITY_PRESENCE = 2 ; pub const _USER_ACTIVITY_PRESENCE_PowerUserMaximum : _USER_ACTIVITY_PRESENCE = 3 ; pub const _USER_ACTIVITY_PRESENCE_PowerUserInvalid : _USER_ACTIVITY_PRESENCE = 3 ; pub type _USER_ACTIVITY_PRESENCE = i32 ; pub use self :: _USER_ACTIVITY_PRESENCE as USER_ACTIVITY_PRESENCE ; pub type PUSER_ACTIVITY_PRESENCE = * mut _USER_ACTIVITY_PRESENCE ; # [ repr ( C ) ] pub struct _POWER_STATE { pub SystemState : __BindgenUnionField < SYSTEM_POWER_STATE > , pub DeviceState : __BindgenUnionField < DEVICE_POWER_STATE > , pub bindgen_union_field : u32 , } pub type POWER_STATE = _POWER_STATE ; pub type PPOWER_STATE = * mut _POWER_STATE ; pub const _POWER_STATE_TYPE_SystemPowerState : _POWER_STATE_TYPE = 0 ; pub const _POWER_STATE_TYPE_DevicePowerState : _POWER_STATE_TYPE = 1 ; pub type _POWER_STATE_TYPE = i32 ; pub use self :: _POWER_STATE_TYPE as POWER_STATE_TYPE ; pub type PPOWER_STATE_TYPE = * mut _POWER_STATE_TYPE ; # [ repr ( C ) ] pub struct _SYSTEM_POWER_STATE_CONTEXT { pub __bindgen_anon_1 : _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1 { pub __bindgen_anon_1 : __BindgenUnionField < _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1 > , pub ContextAsUlong : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn Reserved1 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved1 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn TargetSystemState ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_TargetSystemState ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 4u8 , val as u64 ) } } # [ inline ] pub fn EffectiveSystemState ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_EffectiveSystemState ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 4u8 , val as u64 ) } } # [ inline ] pub fn CurrentSystemState ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_CurrentSystemState ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 4u8 , val as u64 ) } } # [ inline ] pub fn IgnoreHibernationPath ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 20usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_IgnoreHibernationPath ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 20usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PseudoTransition ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 21usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_PseudoTransition ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 21usize , 1u8 , val as u64 ) } } # [ inline ] pub fn KernelSoftReboot ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 22usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_KernelSoftReboot ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 22usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved2 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 23usize , 9u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved2 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 23usize , 9u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Reserved1 : ULONG , TargetSystemState : ULONG , EffectiveSystemState : ULONG , CurrentSystemState : ULONG , IgnoreHibernationPath : ULONG , PseudoTransition : ULONG , KernelSoftReboot : ULONG , Reserved2 : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let Reserved1 : u32 = unsafe { :: std :: mem :: transmute ( Reserved1 ) } ; Reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 4u8 , { let TargetSystemState : u32 = unsafe { :: std :: mem :: transmute ( TargetSystemState ) } ; TargetSystemState as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 4u8 , { let EffectiveSystemState : u32 = unsafe { :: std :: mem :: transmute ( EffectiveSystemState ) } ; EffectiveSystemState as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 4u8 , { let CurrentSystemState : u32 = unsafe { :: std :: mem :: transmute ( CurrentSystemState ) } ; CurrentSystemState as u64 } ) ; __bindgen_bitfield_unit . set ( 20usize , 1u8 , { let IgnoreHibernationPath : u32 = unsafe { :: std :: mem :: transmute ( IgnoreHibernationPath ) } ; IgnoreHibernationPath as u64 } ) ; __bindgen_bitfield_unit . set ( 21usize , 1u8 , { let PseudoTransition : u32 = unsafe { :: std :: mem :: transmute ( PseudoTransition ) } ; PseudoTransition as u64 } ) ; __bindgen_bitfield_unit . set ( 22usize , 1u8 , { let KernelSoftReboot : u32 = unsafe { :: std :: mem :: transmute ( KernelSoftReboot ) } ; KernelSoftReboot as u64 } ) ; __bindgen_bitfield_unit . set ( 23usize , 9u8 , { let Reserved2 : u32 = unsafe { :: std :: mem :: transmute ( Reserved2 ) } ; Reserved2 as u64 } ) ; __bindgen_bitfield_unit } } pub type SYSTEM_POWER_STATE_CONTEXT = _SYSTEM_POWER_STATE_CONTEXT ; pub type PSYSTEM_POWER_STATE_CONTEXT = * mut _SYSTEM_POWER_STATE_CONTEXT ; # [ repr ( C ) ] pub struct _COUNTED_REASON_CONTEXT { pub Version : ULONG , pub Flags : ULONG , pub __bindgen_anon_1 : _COUNTED_REASON_CONTEXT__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _COUNTED_REASON_CONTEXT__bindgen_ty_1 { pub __bindgen_anon_1 : __BindgenUnionField < _COUNTED_REASON_CONTEXT__bindgen_ty_1__bindgen_ty_1 > , pub SimpleString : __BindgenUnionField < UNICODE_STRING > , pub bindgen_union_field : [ u64 ; 4usize ] , } # [ repr ( C ) ] pub struct _COUNTED_REASON_CONTEXT__bindgen_ty_1__bindgen_ty_1 { pub ResourceFileName : UNICODE_STRING , pub ResourceReasonId : USHORT , pub StringCount : ULONG , pub ReasonStrings : PUNICODE_STRING , } pub type COUNTED_REASON_CONTEXT = _COUNTED_REASON_CONTEXT ; pub type PCOUNTED_REASON_CONTEXT = * mut _COUNTED_REASON_CONTEXT ; pub type EXECUTION_STATE = ULONG ; pub type PEXECUTION_STATE = * mut ULONG ; pub const LATENCY_TIME_LT_DONT_CARE : LATENCY_TIME = 0 ; pub const LATENCY_TIME_LT_LOWEST_LATENCY : LATENCY_TIME = 1 ; pub type LATENCY_TIME = i32 ; pub const _POWER_REQUEST_TYPE_PowerRequestDisplayRequired : _POWER_REQUEST_TYPE = 0 ; pub const _POWER_REQUEST_TYPE_PowerRequestSystemRequired : _POWER_REQUEST_TYPE = 1 ; pub const _POWER_REQUEST_TYPE_PowerRequestAwayModeRequired : _POWER_REQUEST_TYPE = 2 ; pub const _POWER_REQUEST_TYPE_PowerRequestExecutionRequired : _POWER_REQUEST_TYPE = 3 ; pub type _POWER_REQUEST_TYPE = i32 ; pub use self :: _POWER_REQUEST_TYPE as POWER_REQUEST_TYPE ; pub type PPOWER_REQUEST_TYPE = * mut _POWER_REQUEST_TYPE ; # [ repr ( C ) ] pub struct CM_Power_Data_s { pub PD_Size : ULONG , pub PD_MostRecentPowerState : DEVICE_POWER_STATE , pub PD_Capabilities : ULONG , pub PD_D1Latency : ULONG , pub PD_D2Latency : ULONG , pub PD_D3Latency : ULONG , pub PD_PowerStateMapping : [ DEVICE_POWER_STATE ; 7usize ] , pub PD_DeepestSystemWake : SYSTEM_POWER_STATE , } pub type CM_POWER_DATA = CM_Power_Data_s ; pub type PCM_POWER_DATA = * mut CM_Power_Data_s ; pub const POWER_INFORMATION_LEVEL_SystemPowerPolicyAc : POWER_INFORMATION_LEVEL = 0 ; pub const POWER_INFORMATION_LEVEL_SystemPowerPolicyDc : POWER_INFORMATION_LEVEL = 1 ; pub const POWER_INFORMATION_LEVEL_VerifySystemPolicyAc : POWER_INFORMATION_LEVEL = 2 ; pub const POWER_INFORMATION_LEVEL_VerifySystemPolicyDc : POWER_INFORMATION_LEVEL = 3 ; pub const POWER_INFORMATION_LEVEL_SystemPowerCapabilities : POWER_INFORMATION_LEVEL = 4 ; pub const POWER_INFORMATION_LEVEL_SystemBatteryState : POWER_INFORMATION_LEVEL = 5 ; pub const POWER_INFORMATION_LEVEL_SystemPowerStateHandler : POWER_INFORMATION_LEVEL = 6 ; pub const POWER_INFORMATION_LEVEL_ProcessorStateHandler : POWER_INFORMATION_LEVEL = 7 ; pub const POWER_INFORMATION_LEVEL_SystemPowerPolicyCurrent : POWER_INFORMATION_LEVEL = 8 ; pub const POWER_INFORMATION_LEVEL_AdministratorPowerPolicy : POWER_INFORMATION_LEVEL = 9 ; pub const POWER_INFORMATION_LEVEL_SystemReserveHiberFile : POWER_INFORMATION_LEVEL = 10 ; pub const POWER_INFORMATION_LEVEL_ProcessorInformation : POWER_INFORMATION_LEVEL = 11 ; pub const POWER_INFORMATION_LEVEL_SystemPowerInformation : POWER_INFORMATION_LEVEL = 12 ; pub const POWER_INFORMATION_LEVEL_ProcessorStateHandler2 : POWER_INFORMATION_LEVEL = 13 ; pub const POWER_INFORMATION_LEVEL_LastWakeTime : POWER_INFORMATION_LEVEL = 14 ; pub const POWER_INFORMATION_LEVEL_LastSleepTime : POWER_INFORMATION_LEVEL = 15 ; pub const POWER_INFORMATION_LEVEL_SystemExecutionState : POWER_INFORMATION_LEVEL = 16 ; pub const POWER_INFORMATION_LEVEL_SystemPowerStateNotifyHandler : POWER_INFORMATION_LEVEL = 17 ; pub const POWER_INFORMATION_LEVEL_ProcessorPowerPolicyAc : POWER_INFORMATION_LEVEL = 18 ; pub const POWER_INFORMATION_LEVEL_ProcessorPowerPolicyDc : POWER_INFORMATION_LEVEL = 19 ; pub const POWER_INFORMATION_LEVEL_VerifyProcessorPowerPolicyAc : POWER_INFORMATION_LEVEL = 20 ; pub const POWER_INFORMATION_LEVEL_VerifyProcessorPowerPolicyDc : POWER_INFORMATION_LEVEL = 21 ; pub const POWER_INFORMATION_LEVEL_ProcessorPowerPolicyCurrent : POWER_INFORMATION_LEVEL = 22 ; pub const POWER_INFORMATION_LEVEL_SystemPowerStateLogging : POWER_INFORMATION_LEVEL = 23 ; pub const POWER_INFORMATION_LEVEL_SystemPowerLoggingEntry : POWER_INFORMATION_LEVEL = 24 ; pub const POWER_INFORMATION_LEVEL_SetPowerSettingValue : POWER_INFORMATION_LEVEL = 25 ; pub const POWER_INFORMATION_LEVEL_NotifyUserPowerSetting : POWER_INFORMATION_LEVEL = 26 ; pub const POWER_INFORMATION_LEVEL_PowerInformationLevelUnused0 : POWER_INFORMATION_LEVEL = 27 ; pub const POWER_INFORMATION_LEVEL_SystemMonitorHiberBootPowerOff : POWER_INFORMATION_LEVEL = 28 ; pub const POWER_INFORMATION_LEVEL_SystemVideoState : POWER_INFORMATION_LEVEL = 29 ; pub const POWER_INFORMATION_LEVEL_TraceApplicationPowerMessage : POWER_INFORMATION_LEVEL = 30 ; pub const POWER_INFORMATION_LEVEL_TraceApplicationPowerMessageEnd : POWER_INFORMATION_LEVEL = 31 ; pub const POWER_INFORMATION_LEVEL_ProcessorPerfStates : POWER_INFORMATION_LEVEL = 32 ; pub const POWER_INFORMATION_LEVEL_ProcessorIdleStates : POWER_INFORMATION_LEVEL = 33 ; pub const POWER_INFORMATION_LEVEL_ProcessorCap : POWER_INFORMATION_LEVEL = 34 ; pub const POWER_INFORMATION_LEVEL_SystemWakeSource : POWER_INFORMATION_LEVEL = 35 ; pub const POWER_INFORMATION_LEVEL_SystemHiberFileInformation : POWER_INFORMATION_LEVEL = 36 ; pub const POWER_INFORMATION_LEVEL_TraceServicePowerMessage : POWER_INFORMATION_LEVEL = 37 ; pub const POWER_INFORMATION_LEVEL_ProcessorLoad : POWER_INFORMATION_LEVEL = 38 ; pub const POWER_INFORMATION_LEVEL_PowerShutdownNotification : POWER_INFORMATION_LEVEL = 39 ; pub const POWER_INFORMATION_LEVEL_MonitorCapabilities : POWER_INFORMATION_LEVEL = 40 ; pub const POWER_INFORMATION_LEVEL_SessionPowerInit : POWER_INFORMATION_LEVEL = 41 ; pub const POWER_INFORMATION_LEVEL_SessionDisplayState : POWER_INFORMATION_LEVEL = 42 ; pub const POWER_INFORMATION_LEVEL_PowerRequestCreate : POWER_INFORMATION_LEVEL = 43 ; pub const POWER_INFORMATION_LEVEL_PowerRequestAction : POWER_INFORMATION_LEVEL = 44 ; pub const POWER_INFORMATION_LEVEL_GetPowerRequestList : POWER_INFORMATION_LEVEL = 45 ; pub const POWER_INFORMATION_LEVEL_ProcessorInformationEx : POWER_INFORMATION_LEVEL = 46 ; pub const POWER_INFORMATION_LEVEL_NotifyUserModeLegacyPowerEvent : POWER_INFORMATION_LEVEL = 47 ; pub const POWER_INFORMATION_LEVEL_GroupPark : POWER_INFORMATION_LEVEL = 48 ; pub const POWER_INFORMATION_LEVEL_ProcessorIdleDomains : POWER_INFORMATION_LEVEL = 49 ; pub const POWER_INFORMATION_LEVEL_WakeTimerList : POWER_INFORMATION_LEVEL = 50 ; pub const POWER_INFORMATION_LEVEL_SystemHiberFileSize : POWER_INFORMATION_LEVEL = 51 ; pub const POWER_INFORMATION_LEVEL_ProcessorIdleStatesHv : POWER_INFORMATION_LEVEL = 52 ; pub const POWER_INFORMATION_LEVEL_ProcessorPerfStatesHv : POWER_INFORMATION_LEVEL = 53 ; pub const POWER_INFORMATION_LEVEL_ProcessorPerfCapHv : POWER_INFORMATION_LEVEL = 54 ; pub const POWER_INFORMATION_LEVEL_ProcessorSetIdle : POWER_INFORMATION_LEVEL = 55 ; pub const POWER_INFORMATION_LEVEL_LogicalProcessorIdling : POWER_INFORMATION_LEVEL = 56 ; pub const POWER_INFORMATION_LEVEL_UserPresence : POWER_INFORMATION_LEVEL = 57 ; pub const POWER_INFORMATION_LEVEL_PowerSettingNotificationName : POWER_INFORMATION_LEVEL = 58 ; pub const POWER_INFORMATION_LEVEL_GetPowerSettingValue : POWER_INFORMATION_LEVEL = 59 ; pub const POWER_INFORMATION_LEVEL_IdleResiliency : POWER_INFORMATION_LEVEL = 60 ; pub const POWER_INFORMATION_LEVEL_SessionRITState : POWER_INFORMATION_LEVEL = 61 ; pub const POWER_INFORMATION_LEVEL_SessionConnectNotification : POWER_INFORMATION_LEVEL = 62 ; pub const POWER_INFORMATION_LEVEL_SessionPowerCleanup : POWER_INFORMATION_LEVEL = 63 ; pub const POWER_INFORMATION_LEVEL_SessionLockState : POWER_INFORMATION_LEVEL = 64 ; pub const POWER_INFORMATION_LEVEL_SystemHiberbootState : POWER_INFORMATION_LEVEL = 65 ; pub const POWER_INFORMATION_LEVEL_PlatformInformation : POWER_INFORMATION_LEVEL = 66 ; pub const POWER_INFORMATION_LEVEL_PdcInvocation : POWER_INFORMATION_LEVEL = 67 ; pub const POWER_INFORMATION_LEVEL_MonitorInvocation : POWER_INFORMATION_LEVEL = 68 ; pub const POWER_INFORMATION_LEVEL_FirmwareTableInformationRegistered : POWER_INFORMATION_LEVEL = 69 ; pub const POWER_INFORMATION_LEVEL_SetShutdownSelectedTime : POWER_INFORMATION_LEVEL = 70 ; pub const POWER_INFORMATION_LEVEL_SuspendResumeInvocation : POWER_INFORMATION_LEVEL = 71 ; pub const POWER_INFORMATION_LEVEL_PlmPowerRequestCreate : POWER_INFORMATION_LEVEL = 72 ; pub const POWER_INFORMATION_LEVEL_ScreenOff : POWER_INFORMATION_LEVEL = 73 ; pub const POWER_INFORMATION_LEVEL_CsDeviceNotification : POWER_INFORMATION_LEVEL = 74 ; pub const POWER_INFORMATION_LEVEL_PlatformRole : POWER_INFORMATION_LEVEL = 75 ; pub const POWER_INFORMATION_LEVEL_LastResumePerformance : POWER_INFORMATION_LEVEL = 76 ; pub const POWER_INFORMATION_LEVEL_DisplayBurst : POWER_INFORMATION_LEVEL = 77 ; pub const POWER_INFORMATION_LEVEL_ExitLatencySamplingPercentage : POWER_INFORMATION_LEVEL = 78 ; pub const POWER_INFORMATION_LEVEL_RegisterSpmPowerSettings : POWER_INFORMATION_LEVEL = 79 ; pub const POWER_INFORMATION_LEVEL_PlatformIdleStates : POWER_INFORMATION_LEVEL = 80 ; pub const POWER_INFORMATION_LEVEL_ProcessorIdleVeto : POWER_INFORMATION_LEVEL = 81 ; pub const POWER_INFORMATION_LEVEL_PlatformIdleVeto : POWER_INFORMATION_LEVEL = 82 ; pub const POWER_INFORMATION_LEVEL_SystemBatteryStatePrecise : POWER_INFORMATION_LEVEL = 83 ; pub const POWER_INFORMATION_LEVEL_ThermalEvent : POWER_INFORMATION_LEVEL = 84 ; pub const POWER_INFORMATION_LEVEL_PowerRequestActionInternal : POWER_INFORMATION_LEVEL = 85 ; pub const POWER_INFORMATION_LEVEL_BatteryDeviceState : POWER_INFORMATION_LEVEL = 86 ; pub const POWER_INFORMATION_LEVEL_PowerInformationInternal : POWER_INFORMATION_LEVEL = 87 ; pub const POWER_INFORMATION_LEVEL_ThermalStandby : POWER_INFORMATION_LEVEL = 88 ; pub const POWER_INFORMATION_LEVEL_SystemHiberFileType : POWER_INFORMATION_LEVEL = 89 ; pub const POWER_INFORMATION_LEVEL_PhysicalPowerButtonPress : POWER_INFORMATION_LEVEL = 90 ; pub const POWER_INFORMATION_LEVEL_QueryPotentialDripsConstraint : POWER_INFORMATION_LEVEL = 91 ; pub const POWER_INFORMATION_LEVEL_EnergyTrackerCreate : POWER_INFORMATION_LEVEL = 92 ; pub const POWER_INFORMATION_LEVEL_EnergyTrackerQuery : POWER_INFORMATION_LEVEL = 93 ; pub const POWER_INFORMATION_LEVEL_UpdateBlackBoxRecorder : POWER_INFORMATION_LEVEL = 94 ; pub const POWER_INFORMATION_LEVEL_PowerInformationLevelMaximum : POWER_INFORMATION_LEVEL = 95 ; pub type POWER_INFORMATION_LEVEL = i32 ; pub const POWER_USER_PRESENCE_TYPE_UserNotPresent : POWER_USER_PRESENCE_TYPE = 0 ; pub const POWER_USER_PRESENCE_TYPE_UserPresent : POWER_USER_PRESENCE_TYPE = 1 ; pub const POWER_USER_PRESENCE_TYPE_UserUnknown : POWER_USER_PRESENCE_TYPE = 255 ; pub type POWER_USER_PRESENCE_TYPE = i32 ; pub type PPOWER_USER_PRESENCE_TYPE = * mut POWER_USER_PRESENCE_TYPE ; # [ repr ( C ) ] pub struct _POWER_USER_PRESENCE { pub UserPresence : POWER_USER_PRESENCE_TYPE , } pub type POWER_USER_PRESENCE = _POWER_USER_PRESENCE ; pub type PPOWER_USER_PRESENCE = * mut _POWER_USER_PRESENCE ; # [ repr ( C ) ] pub struct _POWER_SESSION_CONNECT { pub Connected : BOOLEAN , pub Console : BOOLEAN , } pub type POWER_SESSION_CONNECT = _POWER_SESSION_CONNECT ; pub type PPOWER_SESSION_CONNECT = * mut _POWER_SESSION_CONNECT ; # [ repr ( C ) ] pub struct _POWER_SESSION_TIMEOUTS { pub InputTimeout : ULONG , pub DisplayTimeout : ULONG , } pub type POWER_SESSION_TIMEOUTS = _POWER_SESSION_TIMEOUTS ; pub type PPOWER_SESSION_TIMEOUTS = * mut _POWER_SESSION_TIMEOUTS ; # [ repr ( C ) ] pub struct _POWER_SESSION_RIT_STATE { pub Active : BOOLEAN , pub LastInputTime : ULONG , } pub type POWER_SESSION_RIT_STATE = _POWER_SESSION_RIT_STATE ; pub type PPOWER_SESSION_RIT_STATE = * mut _POWER_SESSION_RIT_STATE ; # [ repr ( C ) ] pub struct _POWER_SESSION_WINLOGON { pub SessionId : ULONG , pub Console : BOOLEAN , pub Locked : BOOLEAN , } pub type POWER_SESSION_WINLOGON = _POWER_SESSION_WINLOGON ; pub type PPOWER_SESSION_WINLOGON = * mut _POWER_SESSION_WINLOGON ; # [ repr ( C ) ] pub struct _POWER_IDLE_RESILIENCY { pub CoalescingTimeout : ULONG , pub IdleResiliencyPeriod : ULONG , } pub type POWER_IDLE_RESILIENCY = _POWER_IDLE_RESILIENCY ; pub type PPOWER_IDLE_RESILIENCY = * mut _POWER_IDLE_RESILIENCY ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUnknown : POWER_MONITOR_REQUEST_REASON = 0 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPowerButton : POWER_MONITOR_REQUEST_REASON = 1 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonRemoteConnection : POWER_MONITOR_REQUEST_REASON = 2 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonScMonitorpower : POWER_MONITOR_REQUEST_REASON = 3 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInput : POWER_MONITOR_REQUEST_REASON = 4 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonAcDcDisplayBurst : POWER_MONITOR_REQUEST_REASON = 5 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserDisplayBurst : POWER_MONITOR_REQUEST_REASON = 6 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPoSetSystemState : POWER_MONITOR_REQUEST_REASON = 7 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonSetThreadExecutionState : POWER_MONITOR_REQUEST_REASON = 8 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonFullWake : POWER_MONITOR_REQUEST_REASON = 9 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonSessionUnlock : POWER_MONITOR_REQUEST_REASON = 10 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonScreenOffRequest : POWER_MONITOR_REQUEST_REASON = 11 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonIdleTimeout : POWER_MONITOR_REQUEST_REASON = 12 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPolicyChange : POWER_MONITOR_REQUEST_REASON = 13 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonSleepButton : POWER_MONITOR_REQUEST_REASON = 14 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonLid : POWER_MONITOR_REQUEST_REASON = 15 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonBatteryCountChange : POWER_MONITOR_REQUEST_REASON = 16 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonGracePeriod : POWER_MONITOR_REQUEST_REASON = 17 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPnP : POWER_MONITOR_REQUEST_REASON = 18 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonDP : POWER_MONITOR_REQUEST_REASON = 19 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonSxTransition : POWER_MONITOR_REQUEST_REASON = 20 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonSystemIdle : POWER_MONITOR_REQUEST_REASON = 21 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonNearProximity : POWER_MONITOR_REQUEST_REASON = 22 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonThermalStandby : POWER_MONITOR_REQUEST_REASON = 23 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonResumePdc : POWER_MONITOR_REQUEST_REASON = 24 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonResumeS4 : POWER_MONITOR_REQUEST_REASON = 25 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonTerminal : POWER_MONITOR_REQUEST_REASON = 26 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPdcSignal : POWER_MONITOR_REQUEST_REASON = 27 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonAcDcDisplayBurstSuppressed : POWER_MONITOR_REQUEST_REASON = 28 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonSystemStateEntered : POWER_MONITOR_REQUEST_REASON = 29 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonWinrt : POWER_MONITOR_REQUEST_REASON = 30 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputKeyboard : POWER_MONITOR_REQUEST_REASON = 31 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputMouse : POWER_MONITOR_REQUEST_REASON = 32 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputTouch : POWER_MONITOR_REQUEST_REASON = 33 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputPen : POWER_MONITOR_REQUEST_REASON = 34 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputAccelerometer : POWER_MONITOR_REQUEST_REASON = 35 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputHid : POWER_MONITOR_REQUEST_REASON = 36 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputPoUserPresent : POWER_MONITOR_REQUEST_REASON = 37 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputSessionSwitch : POWER_MONITOR_REQUEST_REASON = 38 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputInitialization : POWER_MONITOR_REQUEST_REASON = 39 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPdcSignalWindowsMobilePwrNotif : POWER_MONITOR_REQUEST_REASON = 40 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPdcSignalWindowsMobileShell : POWER_MONITOR_REQUEST_REASON = 41 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPdcSignalHeyCortana : POWER_MONITOR_REQUEST_REASON = 42 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPdcSignalHolographicShell : POWER_MONITOR_REQUEST_REASON = 43 ; pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonMax : POWER_MONITOR_REQUEST_REASON = 44 ; pub type POWER_MONITOR_REQUEST_REASON = i32 ; pub const _POWER_MONITOR_REQUEST_TYPE_MonitorRequestTypeOff : _POWER_MONITOR_REQUEST_TYPE = 0 ; pub const _POWER_MONITOR_REQUEST_TYPE_MonitorRequestTypeOnAndPresent : _POWER_MONITOR_REQUEST_TYPE = 1 ; pub const _POWER_MONITOR_REQUEST_TYPE_MonitorRequestTypeToggleOn : _POWER_MONITOR_REQUEST_TYPE = 2 ; pub type _POWER_MONITOR_REQUEST_TYPE = i32 ; pub use self :: _POWER_MONITOR_REQUEST_TYPE as POWER_MONITOR_REQUEST_TYPE ; # [ repr ( C ) ] pub struct _POWER_MONITOR_INVOCATION { pub Console : BOOLEAN , pub RequestReason : POWER_MONITOR_REQUEST_REASON , } pub type POWER_MONITOR_INVOCATION = _POWER_MONITOR_INVOCATION ; pub type PPOWER_MONITOR_INVOCATION = * mut _POWER_MONITOR_INVOCATION ; # [ repr ( C ) ] pub struct _RESUME_PERFORMANCE { pub PostTimeMs : ULONG , pub TotalResumeTimeMs : ULONGLONG , pub ResumeCompleteTimestamp : ULONGLONG , } pub type RESUME_PERFORMANCE = _RESUME_PERFORMANCE ; pub type PRESUME_PERFORMANCE = * mut _RESUME_PERFORMANCE ; pub const SYSTEM_POWER_CONDITION_PoAc : SYSTEM_POWER_CONDITION = 0 ; pub const SYSTEM_POWER_CONDITION_PoDc : SYSTEM_POWER_CONDITION = 1 ; pub const SYSTEM_POWER_CONDITION_PoHot : SYSTEM_POWER_CONDITION = 2 ; pub const SYSTEM_POWER_CONDITION_PoConditionMaximum : SYSTEM_POWER_CONDITION = 3 ; pub type SYSTEM_POWER_CONDITION = i32 ; # [ repr ( C ) ] pub struct SET_POWER_SETTING_VALUE { pub Version : ULONG , pub Guid : GUID , pub PowerCondition : SYSTEM_POWER_CONDITION , pub DataLength : ULONG , pub Data : [ UCHAR ; 1usize ] , } pub type PSET_POWER_SETTING_VALUE = * mut SET_POWER_SETTING_VALUE ; # [ repr ( C ) ] pub struct NOTIFY_USER_POWER_SETTING { pub Guid : GUID , } pub type PNOTIFY_USER_POWER_SETTING = * mut NOTIFY_USER_POWER_SETTING ; # [ repr ( C ) ] pub struct _APPLICATIONLAUNCH_SETTING_VALUE { pub ActivationTime : LARGE_INTEGER , pub Flags : ULONG , pub ButtonInstanceID : ULONG , } pub type APPLICATIONLAUNCH_SETTING_VALUE = _APPLICATIONLAUNCH_SETTING_VALUE ; pub type PAPPLICATIONLAUNCH_SETTING_VALUE = * mut _APPLICATIONLAUNCH_SETTING_VALUE ; pub const _POWER_PLATFORM_ROLE_PlatformRoleUnspecified : _POWER_PLATFORM_ROLE = 0 ; pub const _POWER_PLATFORM_ROLE_PlatformRoleDesktop : _POWER_PLATFORM_ROLE = 1 ; pub const _POWER_PLATFORM_ROLE_PlatformRoleMobile : _POWER_PLATFORM_ROLE = 2 ; pub const _POWER_PLATFORM_ROLE_PlatformRoleWorkstation : _POWER_PLATFORM_ROLE = 3 ; pub const _POWER_PLATFORM_ROLE_PlatformRoleEnterpriseServer : _POWER_PLATFORM_ROLE = 4 ; pub const _POWER_PLATFORM_ROLE_PlatformRoleSOHOServer : _POWER_PLATFORM_ROLE = 5 ; pub const _POWER_PLATFORM_ROLE_PlatformRoleAppliancePC : _POWER_PLATFORM_ROLE = 6 ; pub const _POWER_PLATFORM_ROLE_PlatformRolePerformanceServer : _POWER_PLATFORM_ROLE = 7 ; pub const _POWER_PLATFORM_ROLE_PlatformRoleSlate : _POWER_PLATFORM_ROLE = 8 ; pub const _POWER_PLATFORM_ROLE_PlatformRoleMaximum : _POWER_PLATFORM_ROLE = 9 ; pub type _POWER_PLATFORM_ROLE = i32 ; pub use self :: _POWER_PLATFORM_ROLE as POWER_PLATFORM_ROLE ; pub type PPOWER_PLATFORM_ROLE = * mut _POWER_PLATFORM_ROLE ; # [ repr ( C ) ] pub struct _POWER_PLATFORM_INFORMATION { pub AoAc : BOOLEAN , } pub type POWER_PLATFORM_INFORMATION = _POWER_PLATFORM_INFORMATION ; pub type PPOWER_PLATFORM_INFORMATION = * mut _POWER_PLATFORM_INFORMATION ; # [ repr ( C ) ] pub struct BATTERY_REPORTING_SCALE { pub Granularity : ULONG , pub Capacity : ULONG , } pub type PBATTERY_REPORTING_SCALE = * mut BATTERY_REPORTING_SCALE ; extern "C" { pub fn NtPowerInformation ( InformationLevel : POWER_INFORMATION_LEVEL , InputBuffer : PVOID , InputBufferLength : ULONG , OutputBuffer : PVOID , OutputBufferLength : ULONG ) -> NTSTATUS ; } pub const _CM_SERVICE_NODE_TYPE_DriverType : _CM_SERVICE_NODE_TYPE = 1 ; pub const _CM_SERVICE_NODE_TYPE_FileSystemType : _CM_SERVICE_NODE_TYPE = 2 ; pub const _CM_SERVICE_NODE_TYPE_Win32ServiceOwnProcess : _CM_SERVICE_NODE_TYPE = 16 ; pub const _CM_SERVICE_NODE_TYPE_Win32ServiceShareProcess : _CM_SERVICE_NODE_TYPE = 32 ; pub const _CM_SERVICE_NODE_TYPE_AdapterType : _CM_SERVICE_NODE_TYPE = 4 ; pub const _CM_SERVICE_NODE_TYPE_RecognizerType : _CM_SERVICE_NODE_TYPE = 8 ; pub type _CM_SERVICE_NODE_TYPE = i32 ; pub use self :: _CM_SERVICE_NODE_TYPE as SERVICE_NODE_TYPE ; pub const _CM_SERVICE_LOAD_TYPE_BootLoad : _CM_SERVICE_LOAD_TYPE = 0 ; pub const _CM_SERVICE_LOAD_TYPE_SystemLoad : _CM_SERVICE_LOAD_TYPE = 1 ; pub const _CM_SERVICE_LOAD_TYPE_AutoLoad : _CM_SERVICE_LOAD_TYPE = 2 ; pub const _CM_SERVICE_LOAD_TYPE_DemandLoad : _CM_SERVICE_LOAD_TYPE = 3 ; pub const _CM_SERVICE_LOAD_TYPE_DisableLoad : _CM_SERVICE_LOAD_TYPE = 4 ; pub type _CM_SERVICE_LOAD_TYPE = i32 ; pub use self :: _CM_SERVICE_LOAD_TYPE as SERVICE_LOAD_TYPE ; pub const _CM_ERROR_CONTROL_TYPE_IgnoreError : _CM_ERROR_CONTROL_TYPE = 0 ; pub const _CM_ERROR_CONTROL_TYPE_NormalError : _CM_ERROR_CONTROL_TYPE = 1 ; pub const _CM_ERROR_CONTROL_TYPE_SevereError : _CM_ERROR_CONTROL_TYPE = 2 ; pub const _CM_ERROR_CONTROL_TYPE_CriticalError : _CM_ERROR_CONTROL_TYPE = 3 ; pub type _CM_ERROR_CONTROL_TYPE = i32 ; pub use self :: _CM_ERROR_CONTROL_TYPE as SERVICE_ERROR_TYPE ; pub type CM_RESOURCE_TYPE = :: std :: os :: raw :: c_int ; pub const _CM_SHARE_DISPOSITION_CmResourceShareUndetermined : _CM_SHARE_DISPOSITION = 0 ; pub const _CM_SHARE_DISPOSITION_CmResourceShareDeviceExclusive : _CM_SHARE_DISPOSITION = 1 ; pub const _CM_SHARE_DISPOSITION_CmResourceShareDriverExclusive : _CM_SHARE_DISPOSITION = 2 ; pub const _CM_SHARE_DISPOSITION_CmResourceShareShared : _CM_SHARE_DISPOSITION = 3 ; pub type _CM_SHARE_DISPOSITION = i32 ; pub use self :: _CM_SHARE_DISPOSITION as CM_SHARE_DISPOSITION ; # [ repr ( C ) ] pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR { pub Type : UCHAR , pub ShareDisposition : UCHAR , pub Flags : USHORT , pub u : _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1 { pub Generic : __BindgenUnionField < _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 > , pub Port : __BindgenUnionField < _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 > , pub Interrupt : __BindgenUnionField < _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3 > , pub MessageInterrupt : __BindgenUnionField < _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4 > , pub Memory : __BindgenUnionField < _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5 > , pub Dma : __BindgenUnionField < _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6 > , pub DmaV3 : __BindgenUnionField < _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7 > , pub DevicePrivate : __BindgenUnionField < _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8 > , pub BusNumber : __BindgenUnionField < _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9 > , pub DeviceSpecificData : __BindgenUnionField < _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10 > , pub Memory40 : __BindgenUnionField < _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11 > , pub Memory48 : __BindgenUnionField < _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12 > , pub Memory64 : __BindgenUnionField < _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13 > , pub Connection : __BindgenUnionField < _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14 > , pub bindgen_union_field : [ u32 ; 4usize ] , } # [ repr ( C ) ] pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 { pub _bindgen_opaque_blob : [ u32 ; 3usize ] , } # [ repr ( C ) ] pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 { pub _bindgen_opaque_blob : [ u32 ; 3usize ] , } # [ repr ( C ) ] pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3 { pub _bindgen_opaque_blob : [ u32 ; 4usize ] , } # [ repr ( C ) ] pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4 { pub __bindgen_anon_1 : _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 { pub Raw : __BindgenUnionField < _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 > , pub Translated : __BindgenUnionField < _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2 > , pub bindgen_union_field : [ u32 ; 4usize ] , } # [ repr ( C ) ] pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 { pub _bindgen_opaque_blob : [ u32 ; 4usize ] , } # [ repr ( C ) ] pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2 { pub _bindgen_opaque_blob : [ u32 ; 4usize ] , } # [ repr ( C ) ] pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5 { pub _bindgen_opaque_blob : [ u32 ; 3usize ] , } # [ repr ( C ) ] pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6 { pub Channel : ULONG , pub Port : ULONG , pub Reserved1 : ULONG , } # [ repr ( C ) ] pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7 { pub Channel : ULONG , pub RequestLine : ULONG , pub TransferWidth : UCHAR , pub Reserved1 : UCHAR , pub Reserved2 : UCHAR , pub Reserved3 : UCHAR , } # [ repr ( C ) ] pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8 { pub Data : [ ULONG ; 3usize ] , } # [ repr ( C ) ] pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9 { pub Start : ULONG , pub Length : ULONG , pub Reserved : ULONG , } # [ repr ( C ) ] pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10 { pub DataSize : ULONG , pub Reserved1 : ULONG , pub Reserved2 : ULONG , } # [ repr ( C ) ] pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11 { pub _bindgen_opaque_blob : [ u32 ; 3usize ] , } # [ repr ( C ) ] pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12 { pub _bindgen_opaque_blob : [ u32 ; 3usize ] , } # [ repr ( C ) ] pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13 { pub _bindgen_opaque_blob : [ u32 ; 3usize ] , } # [ repr ( C ) ] pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14 { pub Class : UCHAR , pub Type : UCHAR , pub Reserved1 : UCHAR , pub Reserved2 : UCHAR , pub IdLowPart : ULONG , pub IdHighPart : ULONG , } pub type CM_PARTIAL_RESOURCE_DESCRIPTOR = _CM_PARTIAL_RESOURCE_DESCRIPTOR ; pub type PCM_PARTIAL_RESOURCE_DESCRIPTOR = * mut _CM_PARTIAL_RESOURCE_DESCRIPTOR ; # [ repr ( C ) ] pub struct _CM_PARTIAL_RESOURCE_LIST { pub Version : USHORT , pub Revision : USHORT , pub Count : ULONG , pub PartialDescriptors : [ CM_PARTIAL_RESOURCE_DESCRIPTOR ; 1usize ] , } pub type CM_PARTIAL_RESOURCE_LIST = _CM_PARTIAL_RESOURCE_LIST ; pub type PCM_PARTIAL_RESOURCE_LIST = * mut _CM_PARTIAL_RESOURCE_LIST ; # [ repr ( C ) ] pub struct _CM_FULL_RESOURCE_DESCRIPTOR { pub InterfaceType : INTERFACE_TYPE , pub BusNumber : ULONG , pub PartialResourceList : CM_PARTIAL_RESOURCE_LIST , } pub type CM_FULL_RESOURCE_DESCRIPTOR = _CM_FULL_RESOURCE_DESCRIPTOR ; pub type PCM_FULL_RESOURCE_DESCRIPTOR = * mut _CM_FULL_RESOURCE_DESCRIPTOR ; # [ repr ( C ) ] pub struct _CM_RESOURCE_LIST { pub Count : ULONG , pub List : [ CM_FULL_RESOURCE_DESCRIPTOR ; 1usize ] , } pub type CM_RESOURCE_LIST = _CM_RESOURCE_LIST ; pub type PCM_RESOURCE_LIST = * mut _CM_RESOURCE_LIST ; # [ repr ( C ) ] pub struct _DEVICE_FLAGS { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub __bindgen_padding_0 : [ u8 ; 3usize ] , pub __bindgen_align : [ u32 ; 0usize ] , } impl _DEVICE_FLAGS { # [ inline ] pub fn Failed ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Failed ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ReadOnly ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ReadOnly ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Removable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Removable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ConsoleIn ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ConsoleIn ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ConsoleOut ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ConsoleOut ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Input ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Input ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Output ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Output ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Failed : ULONG , ReadOnly : ULONG , Removable : ULONG , ConsoleIn : ULONG , ConsoleOut : ULONG , Input : ULONG , Output : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let Failed : u32 = unsafe { :: std :: mem :: transmute ( Failed ) } ; Failed as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let ReadOnly : u32 = unsafe { :: std :: mem :: transmute ( ReadOnly ) } ; ReadOnly as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let Removable : u32 = unsafe { :: std :: mem :: transmute ( Removable ) } ; Removable as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let ConsoleIn : u32 = unsafe { :: std :: mem :: transmute ( ConsoleIn ) } ; ConsoleIn as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let ConsoleOut : u32 = unsafe { :: std :: mem :: transmute ( ConsoleOut ) } ; ConsoleOut as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let Input : u32 = unsafe { :: std :: mem :: transmute ( Input ) } ; Input as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let Output : u32 = unsafe { :: std :: mem :: transmute ( Output ) } ; Output as u64 } ) ; __bindgen_bitfield_unit } } pub type DEVICE_FLAGS = _DEVICE_FLAGS ; pub type PDEVICE_FLAGS = * mut _DEVICE_FLAGS ; # [ repr ( C ) ] pub struct _CM_COMPONENT_INFORMATION { pub Flags : DEVICE_FLAGS , pub Version : ULONG , pub Key : ULONG , pub AffinityMask : KAFFINITY , } pub type CM_COMPONENT_INFORMATION = _CM_COMPONENT_INFORMATION ; pub type PCM_COMPONENT_INFORMATION = * mut _CM_COMPONENT_INFORMATION ; # [ repr ( C ) ] pub struct _CM_ROM_BLOCK { pub Address : ULONG , pub Size : ULONG , } pub type CM_ROM_BLOCK = _CM_ROM_BLOCK ; pub type PCM_ROM_BLOCK = * mut _CM_ROM_BLOCK ; # [ repr ( C , packed ) ] pub struct _CM_INT13_DRIVE_PARAMETER { pub DriveSelect : USHORT , pub MaxCylinders : ULONG , pub SectorsPerTrack : USHORT , pub MaxHeads : USHORT , pub NumberDrives : USHORT , } pub type CM_INT13_DRIVE_PARAMETER = _CM_INT13_DRIVE_PARAMETER ; pub type PCM_INT13_DRIVE_PARAMETER = * mut _CM_INT13_DRIVE_PARAMETER ; # [ repr ( C , packed ) ] pub struct _CM_MCA_POS_DATA { pub AdapterId : USHORT , pub PosData1 : UCHAR , pub PosData2 : UCHAR , pub PosData3 : UCHAR , pub PosData4 : UCHAR , } pub type CM_MCA_POS_DATA = _CM_MCA_POS_DATA ; pub type PCM_MCA_POS_DATA = * mut _CM_MCA_POS_DATA ; # [ repr ( C , packed ) ] pub struct _EISA_MEMORY_TYPE { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl _EISA_MEMORY_TYPE { # [ inline ] pub fn ReadWrite ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_ReadWrite ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Cached ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_Cached ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved0 ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_Reserved0 ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Type ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_Type ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 2u8 , val as u64 ) } } # [ inline ] pub fn Shared ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_Shared ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved1 ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_Reserved1 ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MoreEntries ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_MoreEntries ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ReadWrite : UCHAR , Cached : UCHAR , Reserved0 : UCHAR , Type : UCHAR , Shared : UCHAR , Reserved1 : UCHAR , MoreEntries : UCHAR ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let ReadWrite : u8 = unsafe { :: std :: mem :: transmute ( ReadWrite ) } ; ReadWrite as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let Cached : u8 = unsafe { :: std :: mem :: transmute ( Cached ) } ; Cached as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let Reserved0 : u8 = unsafe { :: std :: mem :: transmute ( Reserved0 ) } ; Reserved0 as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 2u8 , { let Type : u8 = unsafe { :: std :: mem :: transmute ( Type ) } ; Type as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let Shared : u8 = unsafe { :: std :: mem :: transmute ( Shared ) } ; Shared as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let Reserved1 : u8 = unsafe { :: std :: mem :: transmute ( Reserved1 ) } ; Reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let MoreEntries : u8 = unsafe { :: std :: mem :: transmute ( MoreEntries ) } ; MoreEntries as u64 } ) ; __bindgen_bitfield_unit } } pub type EISA_MEMORY_TYPE = _EISA_MEMORY_TYPE ; pub type PEISA_MEMORY_TYPE = * mut _EISA_MEMORY_TYPE ; # [ repr ( C , packed ) ] pub struct _EISA_MEMORY_CONFIGURATION { pub ConfigurationByte : EISA_MEMORY_TYPE , pub DataSize : UCHAR , pub AddressLowWord : USHORT , pub AddressHighByte : UCHAR , pub MemorySize : USHORT , } pub type EISA_MEMORY_CONFIGURATION = _EISA_MEMORY_CONFIGURATION ; pub type PEISA_MEMORY_CONFIGURATION = * mut _EISA_MEMORY_CONFIGURATION ; # [ repr ( C , packed ) ] pub struct _EISA_IRQ_DESCRIPTOR { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl _EISA_IRQ_DESCRIPTOR { # [ inline ] pub fn Interrupt ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_Interrupt ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn LevelTriggered ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_LevelTriggered ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Shared ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_Shared ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MoreEntries ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_MoreEntries ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Interrupt : UCHAR , Reserved : UCHAR , LevelTriggered : UCHAR , Shared : UCHAR , MoreEntries : UCHAR ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let Interrupt : u8 = unsafe { :: std :: mem :: transmute ( Interrupt ) } ; Interrupt as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let Reserved : u8 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let LevelTriggered : u8 = unsafe { :: std :: mem :: transmute ( LevelTriggered ) } ; LevelTriggered as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let Shared : u8 = unsafe { :: std :: mem :: transmute ( Shared ) } ; Shared as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let MoreEntries : u8 = unsafe { :: std :: mem :: transmute ( MoreEntries ) } ; MoreEntries as u64 } ) ; __bindgen_bitfield_unit } } pub type EISA_IRQ_DESCRIPTOR = _EISA_IRQ_DESCRIPTOR ; pub type PEISA_IRQ_DESCRIPTOR = * mut _EISA_IRQ_DESCRIPTOR ; # [ repr ( C ) ] pub struct _EISA_IRQ_CONFIGURATION { pub ConfigurationByte : EISA_IRQ_DESCRIPTOR , pub Reserved : UCHAR , } pub type EISA_IRQ_CONFIGURATION = _EISA_IRQ_CONFIGURATION ; pub type PEISA_IRQ_CONFIGURATION = * mut _EISA_IRQ_CONFIGURATION ; # [ repr ( C , packed ) ] pub struct _DMA_CONFIGURATION_BYTE0 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl _DMA_CONFIGURATION_BYTE0 { # [ inline ] pub fn Channel ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_Channel ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 3u8 , val as u64 ) } } # [ inline ] pub fn Shared ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_Shared ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MoreEntries ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_MoreEntries ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Channel : UCHAR , Reserved : UCHAR , Shared : UCHAR , MoreEntries : UCHAR ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let Channel : u8 = unsafe { :: std :: mem :: transmute ( Channel ) } ; Channel as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 3u8 , { let Reserved : u8 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let Shared : u8 = unsafe { :: std :: mem :: transmute ( Shared ) } ; Shared as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let MoreEntries : u8 = unsafe { :: std :: mem :: transmute ( MoreEntries ) } ; MoreEntries as u64 } ) ; __bindgen_bitfield_unit } } pub type DMA_CONFIGURATION_BYTE0 = _DMA_CONFIGURATION_BYTE0 ; # [ repr ( C , packed ) ] pub struct _DMA_CONFIGURATION_BYTE1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl _DMA_CONFIGURATION_BYTE1 { # [ inline ] pub fn Reserved0 ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_Reserved0 ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 2u8 , val as u64 ) } } # [ inline ] pub fn TransferSize ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_TransferSize ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 2u8 , val as u64 ) } } # [ inline ] pub fn Timing ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_Timing ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 2u8 , val as u64 ) } } # [ inline ] pub fn Reserved1 ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_Reserved1 ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 2u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Reserved0 : UCHAR , TransferSize : UCHAR , Timing : UCHAR , Reserved1 : UCHAR ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 2u8 , { let Reserved0 : u8 = unsafe { :: std :: mem :: transmute ( Reserved0 ) } ; Reserved0 as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 2u8 , { let TransferSize : u8 = unsafe { :: std :: mem :: transmute ( TransferSize ) } ; TransferSize as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 2u8 , { let Timing : u8 = unsafe { :: std :: mem :: transmute ( Timing ) } ; Timing as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 2u8 , { let Reserved1 : u8 = unsafe { :: std :: mem :: transmute ( Reserved1 ) } ; Reserved1 as u64 } ) ; __bindgen_bitfield_unit } } pub type DMA_CONFIGURATION_BYTE1 = _DMA_CONFIGURATION_BYTE1 ; # [ repr ( C ) ] pub struct _EISA_DMA_CONFIGURATION { pub ConfigurationByte0 : DMA_CONFIGURATION_BYTE0 , pub ConfigurationByte1 : DMA_CONFIGURATION_BYTE1 , } pub type EISA_DMA_CONFIGURATION = _EISA_DMA_CONFIGURATION ; pub type PEISA_DMA_CONFIGURATION = * mut _EISA_DMA_CONFIGURATION ; # [ repr ( C , packed ) ] pub struct _EISA_PORT_DESCRIPTOR { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl _EISA_PORT_DESCRIPTOR { # [ inline ] pub fn NumberPorts ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_NumberPorts ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 5u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Shared ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_Shared ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MoreEntries ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_MoreEntries ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( NumberPorts : UCHAR , Reserved : UCHAR , Shared : UCHAR , MoreEntries : UCHAR ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 5u8 , { let NumberPorts : u8 = unsafe { :: std :: mem :: transmute ( NumberPorts ) } ; NumberPorts as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let Reserved : u8 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let Shared : u8 = unsafe { :: std :: mem :: transmute ( Shared ) } ; Shared as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let MoreEntries : u8 = unsafe { :: std :: mem :: transmute ( MoreEntries ) } ; MoreEntries as u64 } ) ; __bindgen_bitfield_unit } } pub type EISA_PORT_DESCRIPTOR = _EISA_PORT_DESCRIPTOR ; pub type PEISA_PORT_DESCRIPTOR = * mut _EISA_PORT_DESCRIPTOR ; # [ repr ( C , packed ) ] pub struct _EISA_PORT_CONFIGURATION { pub Configuration : EISA_PORT_DESCRIPTOR , pub PortAddress : USHORT , } pub type EISA_PORT_CONFIGURATION = _EISA_PORT_CONFIGURATION ; pub type PEISA_PORT_CONFIGURATION = * mut _EISA_PORT_CONFIGURATION ; # [ repr ( C , packed ) ] pub struct _CM_EISA_SLOT_INFORMATION { pub ReturnCode : UCHAR , pub ReturnFlags : UCHAR , pub MajorRevision : UCHAR , pub MinorRevision : UCHAR , pub Checksum : USHORT , pub NumberFunctions : UCHAR , pub FunctionInformation : UCHAR , pub CompressedId : ULONG , } pub type CM_EISA_SLOT_INFORMATION = _CM_EISA_SLOT_INFORMATION ; pub type PCM_EISA_SLOT_INFORMATION = * mut _CM_EISA_SLOT_INFORMATION ; # [ repr ( C , packed ) ] pub struct _CM_EISA_FUNCTION_INFORMATION { pub CompressedId : ULONG , pub IdSlotFlags1 : UCHAR , pub IdSlotFlags2 : UCHAR , pub MinorRevision : UCHAR , pub MajorRevision : UCHAR , pub Selections : [ UCHAR ; 26usize ] , pub FunctionFlags : UCHAR , pub TypeString : [ UCHAR ; 80usize ] , pub EisaMemory : [ EISA_MEMORY_CONFIGURATION ; 9usize ] , pub EisaIrq : [ EISA_IRQ_CONFIGURATION ; 7usize ] , pub EisaDma : [ EISA_DMA_CONFIGURATION ; 4usize ] , pub EisaPort : [ EISA_PORT_CONFIGURATION ; 20usize ] , pub InitializationData : [ UCHAR ; 60usize ] , } pub type CM_EISA_FUNCTION_INFORMATION = _CM_EISA_FUNCTION_INFORMATION ; pub type PCM_EISA_FUNCTION_INFORMATION = * mut _CM_EISA_FUNCTION_INFORMATION ; # [ repr ( C , packed ) ] pub struct _CM_PNP_BIOS_DEVICE_NODE { pub Size : USHORT , pub Node : UCHAR , pub ProductId : ULONG , pub DeviceType : [ UCHAR ; 3usize ] , pub DeviceAttributes : USHORT , } pub type CM_PNP_BIOS_DEVICE_NODE = _CM_PNP_BIOS_DEVICE_NODE ; pub type PCM_PNP_BIOS_DEVICE_NODE = * mut _CM_PNP_BIOS_DEVICE_NODE ; # [ repr ( C , packed ) ] pub struct _CM_PNP_BIOS_INSTALLATION_CHECK { pub Signature : [ UCHAR ; 4usize ] , pub Revision : UCHAR , pub Length : UCHAR , pub ControlField : USHORT , pub Checksum : UCHAR , pub EventFlagAddress : ULONG , pub RealModeEntryOffset : USHORT , pub RealModeEntrySegment : USHORT , pub ProtectedModeEntryOffset : USHORT , pub ProtectedModeCodeBaseAddress : ULONG , pub OemDeviceId : ULONG , pub RealModeDataBaseAddress : USHORT , pub ProtectedModeDataBaseAddress : ULONG , } pub type CM_PNP_BIOS_INSTALLATION_CHECK = _CM_PNP_BIOS_INSTALLATION_CHECK ; pub type PCM_PNP_BIOS_INSTALLATION_CHECK = * mut _CM_PNP_BIOS_INSTALLATION_CHECK ; # [ repr ( C ) ] pub struct _CM_SCSI_DEVICE_DATA { pub Version : USHORT , pub Revision : USHORT , pub HostIdentifier : UCHAR , } pub type CM_SCSI_DEVICE_DATA = _CM_SCSI_DEVICE_DATA ; pub type PCM_SCSI_DEVICE_DATA = * mut _CM_SCSI_DEVICE_DATA ; # [ repr ( C ) ] pub struct _CM_VIDEO_DEVICE_DATA { pub Version : USHORT , pub Revision : USHORT , pub VideoClock : ULONG , } pub type CM_VIDEO_DEVICE_DATA = _CM_VIDEO_DEVICE_DATA ; pub type PCM_VIDEO_DEVICE_DATA = * mut _CM_VIDEO_DEVICE_DATA ; # [ repr ( C ) ] pub struct _CM_SONIC_DEVICE_DATA { pub Version : USHORT , pub Revision : USHORT , pub DataConfigurationRegister : USHORT , pub EthernetAddress : [ UCHAR ; 8usize ] , } pub type CM_SONIC_DEVICE_DATA = _CM_SONIC_DEVICE_DATA ; pub type PCM_SONIC_DEVICE_DATA = * mut _CM_SONIC_DEVICE_DATA ; # [ repr ( C ) ] pub struct _CM_SERIAL_DEVICE_DATA { pub Version : USHORT , pub Revision : USHORT , pub BaudClock : ULONG , } pub type CM_SERIAL_DEVICE_DATA = _CM_SERIAL_DEVICE_DATA ; pub type PCM_SERIAL_DEVICE_DATA = * mut _CM_SERIAL_DEVICE_DATA ; # [ repr ( C ) ] pub struct _CM_MONITOR_DEVICE_DATA { pub Version : USHORT , pub Revision : USHORT , pub HorizontalScreenSize : USHORT , pub VerticalScreenSize : USHORT , pub HorizontalResolution : USHORT , pub VerticalResolution : USHORT , pub HorizontalDisplayTimeLow : USHORT , pub HorizontalDisplayTime : USHORT , pub HorizontalDisplayTimeHigh : USHORT , pub HorizontalBackPorchLow : USHORT , pub HorizontalBackPorch : USHORT , pub HorizontalBackPorchHigh : USHORT , pub HorizontalFrontPorchLow : USHORT , pub HorizontalFrontPorch : USHORT , pub HorizontalFrontPorchHigh : USHORT , pub HorizontalSyncLow : USHORT , pub HorizontalSync : USHORT , pub HorizontalSyncHigh : USHORT , pub VerticalBackPorchLow : USHORT , pub VerticalBackPorch : USHORT , pub VerticalBackPorchHigh : USHORT , pub VerticalFrontPorchLow : USHORT , pub VerticalFrontPorch : USHORT , pub VerticalFrontPorchHigh : USHORT , pub VerticalSyncLow : USHORT , pub VerticalSync : USHORT , pub VerticalSyncHigh : USHORT , } pub type CM_MONITOR_DEVICE_DATA = _CM_MONITOR_DEVICE_DATA ; pub type PCM_MONITOR_DEVICE_DATA = * mut _CM_MONITOR_DEVICE_DATA ; # [ repr ( C ) ] pub struct _CM_FLOPPY_DEVICE_DATA { pub Version : USHORT , pub Revision : USHORT , pub Size : [ CHAR ; 8usize ] , pub MaxDensity : ULONG , pub MountDensity : ULONG , pub StepRateHeadUnloadTime : UCHAR , pub HeadLoadTime : UCHAR , pub MotorOffTime : UCHAR , pub SectorLengthCode : UCHAR , pub SectorPerTrack : UCHAR , pub ReadWriteGapLength : UCHAR , pub DataTransferLength : UCHAR , pub FormatGapLength : UCHAR , pub FormatFillCharacter : UCHAR , pub HeadSettleTime : UCHAR , pub MotorSettleTime : UCHAR , pub MaximumTrackValue : UCHAR , pub DataTransferRate : UCHAR , } pub type CM_FLOPPY_DEVICE_DATA = _CM_FLOPPY_DEVICE_DATA ; pub type PCM_FLOPPY_DEVICE_DATA = * mut _CM_FLOPPY_DEVICE_DATA ; # [ repr ( C ) ] pub struct _CM_KEYBOARD_DEVICE_DATA { pub Version : USHORT , pub Revision : USHORT , pub Type : UCHAR , pub Subtype : UCHAR , pub KeyboardFlags : USHORT , } pub type CM_KEYBOARD_DEVICE_DATA = _CM_KEYBOARD_DEVICE_DATA ; pub type PCM_KEYBOARD_DEVICE_DATA = * mut _CM_KEYBOARD_DEVICE_DATA ; # [ repr ( C ) ] pub struct _CM_DISK_GEOMETRY_DEVICE_DATA { pub BytesPerSector : ULONG , pub NumberOfCylinders : ULONG , pub SectorsPerTrack : ULONG , pub NumberOfHeads : ULONG , } pub type CM_DISK_GEOMETRY_DEVICE_DATA = _CM_DISK_GEOMETRY_DEVICE_DATA ; pub type PCM_DISK_GEOMETRY_DEVICE_DATA = * mut _CM_DISK_GEOMETRY_DEVICE_DATA ; pub const _IRQ_DEVICE_POLICY_IrqPolicyMachineDefault : _IRQ_DEVICE_POLICY = 0 ; pub const _IRQ_DEVICE_POLICY_IrqPolicyAllCloseProcessors : _IRQ_DEVICE_POLICY = 1 ; pub const _IRQ_DEVICE_POLICY_IrqPolicyOneCloseProcessor : _IRQ_DEVICE_POLICY = 2 ; pub const _IRQ_DEVICE_POLICY_IrqPolicyAllProcessorsInMachine : _IRQ_DEVICE_POLICY = 3 ; pub const _IRQ_DEVICE_POLICY_IrqPolicySpecifiedProcessors : _IRQ_DEVICE_POLICY = 4 ; pub const _IRQ_DEVICE_POLICY_IrqPolicySpreadMessagesAcrossAllProcessors : _IRQ_DEVICE_POLICY = 5 ; pub const _IRQ_DEVICE_POLICY_IrqPolicyAllProcessorsInMachineWhenSteered : _IRQ_DEVICE_POLICY = 6 ; pub type _IRQ_DEVICE_POLICY = i32 ; pub use self :: _IRQ_DEVICE_POLICY as IRQ_DEVICE_POLICY ; pub type PIRQ_DEVICE_POLICY = * mut _IRQ_DEVICE_POLICY ; pub const _IRQ_PRIORITY_IrqPriorityUndefined : _IRQ_PRIORITY = 0 ; pub const _IRQ_PRIORITY_IrqPriorityLow : _IRQ_PRIORITY = 1 ; pub const _IRQ_PRIORITY_IrqPriorityNormal : _IRQ_PRIORITY = 2 ; pub const _IRQ_PRIORITY_IrqPriorityHigh : _IRQ_PRIORITY = 3 ; pub type _IRQ_PRIORITY = i32 ; pub use self :: _IRQ_PRIORITY as IRQ_PRIORITY ; pub type PIRQ_PRIORITY = * mut _IRQ_PRIORITY ; pub const _IRQ_GROUP_POLICY_GroupAffinityAllGroupZero : _IRQ_GROUP_POLICY = 0 ; pub const _IRQ_GROUP_POLICY_GroupAffinityDontCare : _IRQ_GROUP_POLICY = 1 ; pub type _IRQ_GROUP_POLICY = i32 ; pub use self :: _IRQ_GROUP_POLICY as IRQ_GROUP_POLICY ; pub type PIRQ_GROUP_POLICY = * mut _IRQ_GROUP_POLICY ; # [ repr ( C ) ] pub struct _IO_RESOURCE_DESCRIPTOR { pub Option : UCHAR , pub Type : UCHAR , pub ShareDisposition : UCHAR , pub Spare1 : UCHAR , pub Flags : USHORT , pub Spare2 : USHORT , pub u : _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1 { pub Port : __BindgenUnionField < _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 > , pub Memory : __BindgenUnionField < _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 > , pub Interrupt : __BindgenUnionField < _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3 > , pub Dma : __BindgenUnionField < _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4 > , pub DmaV3 : __BindgenUnionField < _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5 > , pub Generic : __BindgenUnionField < _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6 > , pub DevicePrivate : __BindgenUnionField < _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7 > , pub BusNumber : __BindgenUnionField < _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8 > , pub ConfigData : __BindgenUnionField < _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9 > , pub Memory40 : __BindgenUnionField < _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10 > , pub Memory48 : __BindgenUnionField < _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11 > , pub Memory64 : __BindgenUnionField < _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12 > , pub Connection : __BindgenUnionField < _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13 > , pub bindgen_union_field : [ u64 ; 3usize ] , } # [ repr ( C ) ] pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 { pub Length : ULONG , pub Alignment : ULONG , pub MinimumAddress : PHYSICAL_ADDRESS , pub MaximumAddress : PHYSICAL_ADDRESS , } # [ repr ( C ) ] pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 { pub Length : ULONG , pub Alignment : ULONG , pub MinimumAddress : PHYSICAL_ADDRESS , pub MaximumAddress : PHYSICAL_ADDRESS , } # [ repr ( C ) ] pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3 { pub MinimumVector : ULONG , pub MaximumVector : ULONG , pub AffinityPolicy : IRQ_DEVICE_POLICY , pub PriorityPolicy : IRQ_PRIORITY , pub TargetedProcessors : KAFFINITY , } # [ repr ( C ) ] pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4 { pub MinimumChannel : ULONG , pub MaximumChannel : ULONG , } # [ repr ( C ) ] pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5 { pub RequestLine : ULONG , pub Reserved : ULONG , pub Channel : ULONG , pub TransferWidth : ULONG , } # [ repr ( C ) ] pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6 { pub Length : ULONG , pub Alignment : ULONG , pub MinimumAddress : PHYSICAL_ADDRESS , pub MaximumAddress : PHYSICAL_ADDRESS , } # [ repr ( C ) ] pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7 { pub Data : [ ULONG ; 3usize ] , } # [ repr ( C ) ] pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8 { pub Length : ULONG , pub MinBusNumber : ULONG , pub MaxBusNumber : ULONG , pub Reserved : ULONG , } # [ repr ( C ) ] pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9 { pub Priority : ULONG , pub Reserved1 : ULONG , pub Reserved2 : ULONG , } # [ repr ( C ) ] pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10 { pub Length40 : ULONG , pub Alignment40 : ULONG , pub MinimumAddress : PHYSICAL_ADDRESS , pub MaximumAddress : PHYSICAL_ADDRESS , } # [ repr ( C ) ] pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11 { pub Length48 : ULONG , pub Alignment48 : ULONG , pub MinimumAddress : PHYSICAL_ADDRESS , pub MaximumAddress : PHYSICAL_ADDRESS , } # [ repr ( C ) ] pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12 { pub Length64 : ULONG , pub Alignment64 : ULONG , pub MinimumAddress : PHYSICAL_ADDRESS , pub MaximumAddress : PHYSICAL_ADDRESS , } # [ repr ( C ) ] pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13 { pub Class : UCHAR , pub Type : UCHAR , pub Reserved1 : UCHAR , pub Reserved2 : UCHAR , pub IdLowPart : ULONG , pub IdHighPart : ULONG , } pub type IO_RESOURCE_DESCRIPTOR = _IO_RESOURCE_DESCRIPTOR ; pub type PIO_RESOURCE_DESCRIPTOR = * mut _IO_RESOURCE_DESCRIPTOR ; # [ repr ( C ) ] pub struct _IO_RESOURCE_LIST { pub Version : USHORT , pub Revision : USHORT , pub Count : ULONG , pub Descriptors : [ IO_RESOURCE_DESCRIPTOR ; 1usize ] , } pub type IO_RESOURCE_LIST = _IO_RESOURCE_LIST ; pub type PIO_RESOURCE_LIST = * mut _IO_RESOURCE_LIST ; # [ repr ( C ) ] pub struct _IO_RESOURCE_REQUIREMENTS_LIST { pub ListSize : ULONG , pub InterfaceType : INTERFACE_TYPE , pub BusNumber : ULONG , pub SlotNumber : ULONG , pub Reserved : [ ULONG ; 3usize ] , pub AlternativeLists : ULONG , pub List : [ IO_RESOURCE_LIST ; 1usize ] , } pub type IO_RESOURCE_REQUIREMENTS_LIST = _IO_RESOURCE_REQUIREMENTS_LIST ; pub type PIO_RESOURCE_REQUIREMENTS_LIST = * mut _IO_RESOURCE_REQUIREMENTS_LIST ; # [ repr ( C ) ] pub struct _SLIST_ENTRY { pub Next : * mut _SLIST_ENTRY , pub __bindgen_padding_0 : u64 , } pub type SLIST_ENTRY = _SLIST_ENTRY ; pub type PSLIST_ENTRY = * mut _SLIST_ENTRY ; # [ repr ( C ) ] pub struct _SLIST_HEADER { pub Alignment : __BindgenUnionField < ULONGLONG > , pub __bindgen_anon_1 : __BindgenUnionField < _SLIST_HEADER__bindgen_ty_1 > , pub bindgen_union_field : [ u8 ; 32usize ] , } # [ repr ( C ) ] pub struct _SLIST_HEADER__bindgen_ty_1 { pub Next : SLIST_ENTRY , pub Depth : USHORT , pub CpuId : USHORT , pub __bindgen_padding_0 : [ u32 ; 3usize ] , } pub type SLIST_HEADER = _SLIST_HEADER ; pub type PSLIST_HEADER = * mut _SLIST_HEADER ; extern "C" { pub fn RtlAssert ( VoidFailedAssertion : PVOID , VoidFileName : PVOID , LineNumber : ULONG , MutableMessage : PSTR ) ; } extern "C" { pub fn __fastfail ( Code : :: std :: os :: raw :: c_uint ) ; } extern "C" { pub fn RtlIntegerToUnicodeString ( Value : ULONG , Base : ULONG , String : PUNICODE_STRING ) -> NTSTATUS ; } extern "C" { pub fn RtlInt64ToUnicodeString ( Value : ULONGLONG , Base : ULONG , String : PUNICODE_STRING ) -> NTSTATUS ; } extern "C" { pub fn RtlUnicodeStringToInteger ( String : PCUNICODE_STRING , Base : ULONG , Value : PULONG ) -> NTSTATUS ; } extern "C" { pub fn RtlUnicodeStringToInt64 ( String : PCUNICODE_STRING , Base : ULONG , Number : PLONG64 , EndPointer : * mut PWSTR ) -> NTSTATUS ; } extern "C" { # [ link_name = "\u{1}NlsMbCodePageTag" ] pub static mut NlsMbCodePageTag : * mut :: std :: os :: raw :: c_uchar ; } extern "C" { # [ link_name = "\u{1}NlsMbOemCodePageTag" ] pub static mut NlsMbOemCodePageTag : * mut :: std :: os :: raw :: c_uchar ; } extern "C" { pub fn RtlInitString ( DestinationString : PSTRING , SourceString : PCSZ ) ; } extern "C" { pub fn RtlInitAnsiString ( DestinationString : PANSI_STRING , SourceString : PCSZ ) ; } extern "C" { pub fn RtlInitUnicodeString ( DestinationString : PUNICODE_STRING , SourceString : PCWSTR ) ; } pub type PRTL_QUERY_REGISTRY_ROUTINE = :: std :: option :: Option < unsafe extern "C" fn ( ) -> NTSTATUS > ; # [ repr ( C ) ] pub struct _RTL_QUERY_REGISTRY_TABLE { pub QueryRoutine : PRTL_QUERY_REGISTRY_ROUTINE , pub Flags : ULONG , pub Name : PWSTR , pub EntryContext : PVOID , pub DefaultType : ULONG , pub DefaultData : PVOID , pub DefaultLength : ULONG , } pub type RTL_QUERY_REGISTRY_TABLE = _RTL_QUERY_REGISTRY_TABLE ; pub type PRTL_QUERY_REGISTRY_TABLE = * mut _RTL_QUERY_REGISTRY_TABLE ; extern "C" { pub fn RtlQueryRegistryValues ( RelativeTo : ULONG , Path : PCWSTR , QueryTable : PRTL_QUERY_REGISTRY_TABLE , Context : PVOID , Environment : PVOID ) -> NTSTATUS ; } extern "C" { pub fn MmGetSystemRoutineAddress ( SystemRoutineName : PUNICODE_STRING ) -> PVOID ; } extern "C" { pub fn RtlWriteRegistryValue ( RelativeTo : ULONG , Path : PCWSTR , ValueName : PCWSTR , ValueType : ULONG , ValueData : PVOID , ValueLength : ULONG ) -> NTSTATUS ; } extern "C" { pub fn RtlDeleteRegistryValue ( RelativeTo : ULONG , Path : PCWSTR , ValueName : PCWSTR ) -> NTSTATUS ; } extern "C" { pub fn RtlCreateRegistryKey ( RelativeTo : ULONG , Path : PWSTR ) -> NTSTATUS ; } extern "C" { pub fn RtlCheckRegistryKey ( RelativeTo : ULONG , Path : PWSTR ) -> NTSTATUS ; } extern "C" { pub fn RtlInitAnsiStringEx ( DestinationString : PANSI_STRING , SourceString : PCSZ ) -> NTSTATUS ; } extern "C" { pub fn RtlInitStringEx ( DestinationString : PSTRING , SourceString : PCSZ ) -> NTSTATUS ; } extern "C" { pub fn RtlAnsiStringToUnicodeString ( DestinationString : PUNICODE_STRING , SourceString : PCANSI_STRING , AllocateDestinationString : BOOLEAN ) -> NTSTATUS ; } extern "C" { pub fn RtlUnicodeStringToAnsiString ( DestinationString : PANSI_STRING , SourceString : PCUNICODE_STRING , AllocateDestinationString : BOOLEAN ) -> NTSTATUS ; } extern "C" { pub fn RtlCompareUnicodeStrings ( String1 : PCWCH , String1Length : SIZE_T , String2 : PCWCH , String2Length : SIZE_T , CaseInSensitive : BOOLEAN ) -> LONG ; } extern "C" { pub fn RtlCompareUnicodeString ( String1 : PCUNICODE_STRING , String2 : PCUNICODE_STRING , CaseInSensitive : BOOLEAN ) -> LONG ; } extern "C" { pub fn RtlEqualUnicodeString ( String1 : PCUNICODE_STRING , String2 : PCUNICODE_STRING , CaseInSensitive : BOOLEAN ) -> BOOLEAN ; } extern "C" { pub fn RtlHashUnicodeString ( String : PCUNICODE_STRING , CaseInSensitive : BOOLEAN , HashAlgorithm : ULONG , HashValue : PULONG ) -> NTSTATUS ; } extern "C" { pub fn RtlCopyUnicodeString ( DestinationString : PUNICODE_STRING , SourceString : PCUNICODE_STRING ) ; } extern "C" { pub fn RtlAppendUnicodeStringToString ( Destination : PUNICODE_STRING , Source : PCUNICODE_STRING ) -> NTSTATUS ; } extern "C" { pub fn RtlAppendUnicodeToString ( Destination : PUNICODE_STRING , Source : PCWSTR ) -> NTSTATUS ; } extern "C" { pub fn RtlUpcaseUnicodeChar ( SourceCharacter : WCHAR ) -> WCHAR ; } extern "C" { pub fn RtlDowncaseUnicodeChar ( SourceCharacter : WCHAR ) -> WCHAR ; } extern "C" { pub fn RtlFreeUnicodeString ( UnicodeString : PUNICODE_STRING ) ; } extern "C" { pub fn RtlFreeAnsiString ( AnsiString : PANSI_STRING ) ; } extern "C" { pub fn RtlxUnicodeStringToAnsiSize ( UnicodeString : PCUNICODE_STRING ) -> ULONG ; } extern "C" { pub fn RtlxAnsiStringToUnicodeSize ( AnsiString : PCANSI_STRING ) -> ULONG ; } extern "C" { pub fn RtlUnicodeToUTF8N ( UTF8StringDestination : PCHAR , UTF8StringMaxByteCount : ULONG , UTF8StringActualByteCount : PULONG , UnicodeStringSource : PCWCH , UnicodeStringByteCount : ULONG ) -> NTSTATUS ; } extern "C" { pub fn RtlUTF8ToUnicodeN ( UnicodeStringDestination : PWSTR , UnicodeStringMaxByteCount : ULONG , UnicodeStringActualByteCount : PULONG , UTF8StringSource : PCCH , UTF8StringByteCount : ULONG ) -> NTSTATUS ; } extern "C" { pub fn RtlStringFromGUID ( Guid : * const GUID , GuidString : PUNICODE_STRING ) -> NTSTATUS ; } extern "C" { pub fn RtlGUIDFromString ( GuidString : PCUNICODE_STRING , Guid : * mut GUID ) -> NTSTATUS ; } extern "C" { pub fn RtlGenerateClass5Guid ( NamespaceGuid : * const GUID , Buffer : PVOID , BufferSize : ULONG , Guid : * mut GUID ) -> NTSTATUS ; } extern "C" { pub fn RtlCopyMemoryNonTemporal ( Destination : * mut :: std :: os :: raw :: c_void , Source : * const :: std :: os :: raw :: c_void , Length : SIZE_T ) ; } extern "C" { pub fn RtlPrefetchMemoryNonTemporal ( Source : PVOID , Length : SIZE_T ) ; } extern "C" { pub fn DbgBreakPointWithStatus ( Status : ULONG ) ; } extern "C" { pub fn DbgPrint ( Format : PCSTR , ... ) -> ULONG ; } extern "C" { pub fn DbgPrintEx ( ComponentId : ULONG , Level : ULONG , Format : PCSTR , ... ) -> ULONG ; } extern "C" { pub fn vDbgPrintEx ( ComponentId : ULONG , Level : ULONG , Format : PCCH , arglist : va_list ) -> ULONG ; } extern "C" { pub fn vDbgPrintExWithPrefix ( Prefix : PCCH , ComponentId : ULONG , Level : ULONG , Format : PCCH , arglist : va_list ) -> ULONG ; } extern "C" { pub fn DbgPrintReturnControlC ( Format : PCCH , ... ) -> ULONG ; } extern "C" { pub fn DbgQueryDebugFilterState ( ComponentId : ULONG , Level : ULONG ) -> NTSTATUS ; } extern "C" { pub fn DbgSetDebugFilterState ( ComponentId : ULONG , Level : ULONG , State : BOOLEAN ) -> NTSTATUS ; } pub type PDEBUG_PRINT_CALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( Output : PSTRING , ComponentId : ULONG , Level : ULONG ) > ; extern "C" { pub fn DbgSetDebugPrintCallback ( DebugPrintCallback : PDEBUG_PRINT_CALLBACK , Enable : BOOLEAN ) -> NTSTATUS ; } extern "C" { pub fn RtlExtendedMagicDivide ( Dividend : LARGE_INTEGER , MagicDivisor : LARGE_INTEGER , ShiftCount : CCHAR ) -> LARGE_INTEGER ; } extern "C" { pub fn RtlExtendedLargeIntegerDivide ( Dividend : LARGE_INTEGER , Divisor : ULONG , Remainder : PULONG ) -> LARGE_INTEGER ; } extern "C" { pub fn RtlExtendedIntegerMultiply ( Multiplicand : LARGE_INTEGER , Multiplier : LONG ) -> LARGE_INTEGER ; } # [ repr ( C ) ] pub struct _TIME_FIELDS { pub Year : CSHORT , pub Month : CSHORT , pub Day : CSHORT , pub Hour : CSHORT , pub Minute : CSHORT , pub Second : CSHORT , pub Milliseconds : CSHORT , pub Weekday : CSHORT , } pub type TIME_FIELDS = _TIME_FIELDS ; pub type PTIME_FIELDS = * mut TIME_FIELDS ; extern "C" { pub fn RtlTimeToTimeFields ( Time : PLARGE_INTEGER , TimeFields : PTIME_FIELDS ) ; } extern "C" { pub fn RtlTimeFieldsToTime ( TimeFields : PTIME_FIELDS , Time : PLARGE_INTEGER ) -> BOOLEAN ; } # [ repr ( C ) ] pub struct _RTL_BITMAP { pub SizeOfBitMap : ULONG , pub Buffer : PULONG , } pub type RTL_BITMAP = _RTL_BITMAP ; pub type PRTL_BITMAP = * mut RTL_BITMAP ; extern "C" { pub fn RtlInitializeBitMap ( BitMapHeader : PRTL_BITMAP , BitMapBuffer : PULONG , SizeOfBitMap : ULONG ) ; } extern "C" { pub fn RtlClearBit ( BitMapHeader : PRTL_BITMAP , BitNumber : ULONG ) ; } extern "C" { pub fn RtlSetBit ( BitMapHeader : PRTL_BITMAP , BitNumber : ULONG ) ; } extern "C" { pub fn RtlTestBit ( BitMapHeader : PRTL_BITMAP , BitNumber : ULONG ) -> BOOLEAN ; } extern "C" { pub fn RtlClearAllBits ( BitMapHeader : PRTL_BITMAP ) ; } extern "C" { pub fn RtlSetAllBits ( BitMapHeader : PRTL_BITMAP ) ; } extern "C" { pub fn RtlFindClearBits ( BitMapHeader : PRTL_BITMAP , NumberToFind : ULONG , HintIndex : ULONG ) -> ULONG ; } extern "C" { pub fn RtlFindSetBits ( BitMapHeader : PRTL_BITMAP , NumberToFind : ULONG , HintIndex : ULONG ) -> ULONG ; } extern "C" { pub fn RtlFindClearBitsAndSet ( BitMapHeader : PRTL_BITMAP , NumberToFind : ULONG , HintIndex : ULONG ) -> ULONG ; } extern "C" { pub fn RtlFindSetBitsAndClear ( BitMapHeader : PRTL_BITMAP , NumberToFind : ULONG , HintIndex : ULONG ) -> ULONG ; } extern "C" { pub fn RtlClearBits ( BitMapHeader : PRTL_BITMAP , StartingIndex : ULONG , NumberToClear : ULONG ) ; } extern "C" { pub fn RtlSetBits ( BitMapHeader : PRTL_BITMAP , StartingIndex : ULONG , NumberToSet : ULONG ) ; } # [ repr ( C ) ] pub struct _RTL_BITMAP_RUN { pub StartingIndex : ULONG , pub NumberOfBits : ULONG , } pub type RTL_BITMAP_RUN = _RTL_BITMAP_RUN ; pub type PRTL_BITMAP_RUN = * mut RTL_BITMAP_RUN ; extern "C" { pub fn RtlFindClearRuns ( BitMapHeader : PRTL_BITMAP , RunArray : PRTL_BITMAP_RUN , SizeOfRunArray : ULONG , LocateLongestRuns : BOOLEAN ) -> ULONG ; } extern "C" { pub fn RtlFindLongestRunClear ( BitMapHeader : PRTL_BITMAP , StartingIndex : PULONG ) -> ULONG ; } extern "C" { pub fn RtlFindFirstRunClear ( BitMapHeader : PRTL_BITMAP , StartingIndex : PULONG ) -> ULONG ; } extern "C" { pub fn RtlNumberOfClearBitsInRange ( BitMapHeader : PRTL_BITMAP , StartingIndex : ULONG , Length : ULONG ) -> ULONG ; } extern "C" { pub fn RtlNumberOfSetBitsInRange ( BitMapHeader : PRTL_BITMAP , StartingIndex : ULONG , Length : ULONG ) -> ULONG ; } extern "C" { pub fn RtlNumberOfClearBits ( BitMapHeader : PRTL_BITMAP ) -> ULONG ; } extern "C" { pub fn RtlNumberOfSetBits ( BitMapHeader : PRTL_BITMAP ) -> ULONG ; } extern "C" { pub fn RtlAreBitsClear ( BitMapHeader : PRTL_BITMAP , StartingIndex : ULONG , Length : ULONG ) -> BOOLEAN ; } extern "C" { pub fn RtlAreBitsSet ( BitMapHeader : PRTL_BITMAP , StartingIndex : ULONG , Length : ULONG ) -> BOOLEAN ; } extern "C" { pub fn RtlFindNextForwardRunClear ( BitMapHeader : PRTL_BITMAP , FromIndex : ULONG , StartingRunIndex : PULONG ) -> ULONG ; } extern "C" { pub fn RtlFindLastBackwardRunClear ( BitMapHeader : PRTL_BITMAP , FromIndex : ULONG , StartingRunIndex : PULONG ) -> ULONG ; } extern "C" { pub fn RtlFindLeastSignificantBit ( Set : ULONGLONG ) -> CCHAR ; } extern "C" { pub fn RtlFindMostSignificantBit ( Set : ULONGLONG ) -> CCHAR ; } extern "C" { pub fn RtlNumberOfSetBitsUlongPtr ( Target : ULONG_PTR ) -> ULONG ; } extern "C" { pub fn RtlCopyBitMap ( Source : PRTL_BITMAP , Destination : PRTL_BITMAP , TargetBit : ULONG ) ; } extern "C" { pub fn RtlExtractBitMap ( Source : PRTL_BITMAP , Destination : PRTL_BITMAP , TargetBit : ULONG , NumberOfBits : ULONG ) ; } extern "C" { pub fn RtlCreateSecurityDescriptor ( SecurityDescriptor : PSECURITY_DESCRIPTOR , Revision : ULONG ) -> NTSTATUS ; } extern "C" { pub fn RtlValidSecurityDescriptor ( SecurityDescriptor : PSECURITY_DESCRIPTOR ) -> BOOLEAN ; } extern "C" { pub fn RtlLengthSecurityDescriptor ( SecurityDescriptor : PSECURITY_DESCRIPTOR ) -> ULONG ; } extern "C" { pub fn RtlValidRelativeSecurityDescriptor ( SecurityDescriptorInput : PSECURITY_DESCRIPTOR , SecurityDescriptorLength : ULONG , RequiredInformation : SECURITY_INFORMATION ) -> BOOLEAN ; } extern "C" { pub fn RtlSetDaclSecurityDescriptor ( SecurityDescriptor : PSECURITY_DESCRIPTOR , DaclPresent : BOOLEAN , Dacl : PACL , DaclDefaulted : BOOLEAN ) -> NTSTATUS ; } extern "C" { pub fn _byteswap_ushort ( arg1 : :: std :: os :: raw :: c_ushort ) -> :: std :: os :: raw :: c_ushort ; } extern "C" { pub fn _byteswap_ulong ( arg1 : :: std :: os :: raw :: c_ulong ) -> :: std :: os :: raw :: c_ulong ; } extern "C" { pub fn _byteswap_uint64 ( arg1 : :: std :: os :: raw :: c_ulonglong ) -> :: std :: os :: raw :: c_ulonglong ; } # [ repr ( C ) ] pub struct _OSVERSIONINFOA { pub dwOSVersionInfoSize : ULONG , pub dwMajorVersion : ULONG , pub dwMinorVersion : ULONG , pub dwBuildNumber : ULONG , pub dwPlatformId : ULONG , pub szCSDVersion : [ CHAR ; 128usize ] , } pub type OSVERSIONINFOA = _OSVERSIONINFOA ; pub type POSVERSIONINFOA = * mut _OSVERSIONINFOA ; pub type LPOSVERSIONINFOA = * mut _OSVERSIONINFOA ; # [ repr ( C ) ] pub struct _OSVERSIONINFOW { pub dwOSVersionInfoSize : ULONG , pub dwMajorVersion : ULONG , pub dwMinorVersion : ULONG , pub dwBuildNumber : ULONG , pub dwPlatformId : ULONG , pub szCSDVersion : [ WCHAR ; 128usize ] , } pub type OSVERSIONINFOW = _OSVERSIONINFOW ; pub type POSVERSIONINFOW = * mut _OSVERSIONINFOW ; pub type LPOSVERSIONINFOW = * mut _OSVERSIONINFOW ; pub type RTL_OSVERSIONINFOW = _OSVERSIONINFOW ; pub type PRTL_OSVERSIONINFOW = * mut _OSVERSIONINFOW ; pub type OSVERSIONINFO = OSVERSIONINFOA ; pub type POSVERSIONINFO = POSVERSIONINFOA ; pub type LPOSVERSIONINFO = LPOSVERSIONINFOA ; # [ repr ( C ) ] pub struct _OSVERSIONINFOEXA { pub dwOSVersionInfoSize : ULONG , pub dwMajorVersion : ULONG , pub dwMinorVersion : ULONG , pub dwBuildNumber : ULONG , pub dwPlatformId : ULONG , pub szCSDVersion : [ CHAR ; 128usize ] , pub wServicePackMajor : USHORT , pub wServicePackMinor : USHORT , pub wSuiteMask : USHORT , pub wProductType : UCHAR , pub wReserved : UCHAR , } pub type OSVERSIONINFOEXA = _OSVERSIONINFOEXA ; pub type POSVERSIONINFOEXA = * mut _OSVERSIONINFOEXA ; pub type LPOSVERSIONINFOEXA = * mut _OSVERSIONINFOEXA ; # [ repr ( C ) ] pub struct _OSVERSIONINFOEXW { pub dwOSVersionInfoSize : ULONG , pub dwMajorVersion : ULONG , pub dwMinorVersion : ULONG , pub dwBuildNumber : ULONG , pub dwPlatformId : ULONG , pub szCSDVersion : [ WCHAR ; 128usize ] , pub wServicePackMajor : USHORT , pub wServicePackMinor : USHORT , pub wSuiteMask : USHORT , pub wProductType : UCHAR , pub wReserved : UCHAR , } pub type OSVERSIONINFOEXW = _OSVERSIONINFOEXW ; pub type POSVERSIONINFOEXW = * mut _OSVERSIONINFOEXW ; pub type LPOSVERSIONINFOEXW = * mut _OSVERSIONINFOEXW ; pub type RTL_OSVERSIONINFOEXW = _OSVERSIONINFOEXW ; pub type PRTL_OSVERSIONINFOEXW = * mut _OSVERSIONINFOEXW ; pub type OSVERSIONINFOEX = OSVERSIONINFOEXA ; pub type POSVERSIONINFOEX = POSVERSIONINFOEXA ; pub type LPOSVERSIONINFOEX = LPOSVERSIONINFOEXA ; extern "C" { pub fn VerSetConditionMask ( ConditionMask : ULONGLONG , TypeMask : ULONG , Condition : UCHAR ) -> ULONGLONG ; } extern "C" { pub fn RtlGetVersion ( lpVersionInformation : PRTL_OSVERSIONINFOW ) -> NTSTATUS ; } extern "C" { pub fn RtlVerifyVersionInfo ( VersionInfo : PRTL_OSVERSIONINFOEXW , TypeMask : ULONG , ConditionMask : ULONGLONG ) -> NTSTATUS ; } pub type PFN_RTL_IS_NTDDI_VERSION_AVAILABLE = :: std :: option :: Option < unsafe extern "C" fn ( Version : ULONG ) -> BOOLEAN > ; pub type PFN_RTL_IS_SERVICE_PACK_VERSION_INSTALLED = :: std :: option :: Option < unsafe extern "C" fn ( Version : ULONG ) -> BOOLEAN > ; extern "C" { pub fn RtlIsNtDdiVersionAvailable ( Version : ULONG ) -> BOOLEAN ; } extern "C" { pub fn RtlIsServicePackVersionInstalled ( Version : ULONG ) -> BOOLEAN ; } pub const _DPFLTR_TYPE_DPFLTR_SYSTEM_ID : _DPFLTR_TYPE = 0 ; pub const _DPFLTR_TYPE_DPFLTR_SMSS_ID : _DPFLTR_TYPE = 1 ; pub const _DPFLTR_TYPE_DPFLTR_SETUP_ID : _DPFLTR_TYPE = 2 ; pub const _DPFLTR_TYPE_DPFLTR_NTFS_ID : _DPFLTR_TYPE = 3 ; pub const _DPFLTR_TYPE_DPFLTR_FSTUB_ID : _DPFLTR_TYPE = 4 ; pub const _DPFLTR_TYPE_DPFLTR_CRASHDUMP_ID : _DPFLTR_TYPE = 5 ; pub const _DPFLTR_TYPE_DPFLTR_CDAUDIO_ID : _DPFLTR_TYPE = 6 ; pub const _DPFLTR_TYPE_DPFLTR_CDROM_ID : _DPFLTR_TYPE = 7 ; pub const _DPFLTR_TYPE_DPFLTR_CLASSPNP_ID : _DPFLTR_TYPE = 8 ; pub const _DPFLTR_TYPE_DPFLTR_DISK_ID : _DPFLTR_TYPE = 9 ; pub const _DPFLTR_TYPE_DPFLTR_REDBOOK_ID : _DPFLTR_TYPE = 10 ; pub const _DPFLTR_TYPE_DPFLTR_STORPROP_ID : _DPFLTR_TYPE = 11 ; pub const _DPFLTR_TYPE_DPFLTR_SCSIPORT_ID : _DPFLTR_TYPE = 12 ; pub const _DPFLTR_TYPE_DPFLTR_SCSIMINIPORT_ID : _DPFLTR_TYPE = 13 ; pub const _DPFLTR_TYPE_DPFLTR_CONFIG_ID : _DPFLTR_TYPE = 14 ; pub const _DPFLTR_TYPE_DPFLTR_I8042PRT_ID : _DPFLTR_TYPE = 15 ; pub const _DPFLTR_TYPE_DPFLTR_SERMOUSE_ID : _DPFLTR_TYPE = 16 ; pub const _DPFLTR_TYPE_DPFLTR_LSERMOUS_ID : _DPFLTR_TYPE = 17 ; pub const _DPFLTR_TYPE_DPFLTR_KBDHID_ID : _DPFLTR_TYPE = 18 ; pub const _DPFLTR_TYPE_DPFLTR_MOUHID_ID : _DPFLTR_TYPE = 19 ; pub const _DPFLTR_TYPE_DPFLTR_KBDCLASS_ID : _DPFLTR_TYPE = 20 ; pub const _DPFLTR_TYPE_DPFLTR_MOUCLASS_ID : _DPFLTR_TYPE = 21 ; pub const _DPFLTR_TYPE_DPFLTR_TWOTRACK_ID : _DPFLTR_TYPE = 22 ; pub const _DPFLTR_TYPE_DPFLTR_WMILIB_ID : _DPFLTR_TYPE = 23 ; pub const _DPFLTR_TYPE_DPFLTR_ACPI_ID : _DPFLTR_TYPE = 24 ; pub const _DPFLTR_TYPE_DPFLTR_AMLI_ID : _DPFLTR_TYPE = 25 ; pub const _DPFLTR_TYPE_DPFLTR_HALIA64_ID : _DPFLTR_TYPE = 26 ; pub const _DPFLTR_TYPE_DPFLTR_VIDEO_ID : _DPFLTR_TYPE = 27 ; pub const _DPFLTR_TYPE_DPFLTR_SVCHOST_ID : _DPFLTR_TYPE = 28 ; pub const _DPFLTR_TYPE_DPFLTR_VIDEOPRT_ID : _DPFLTR_TYPE = 29 ; pub const _DPFLTR_TYPE_DPFLTR_TCPIP_ID : _DPFLTR_TYPE = 30 ; pub const _DPFLTR_TYPE_DPFLTR_DMSYNTH_ID : _DPFLTR_TYPE = 31 ; pub const _DPFLTR_TYPE_DPFLTR_NTOSPNP_ID : _DPFLTR_TYPE = 32 ; pub const _DPFLTR_TYPE_DPFLTR_FASTFAT_ID : _DPFLTR_TYPE = 33 ; pub const _DPFLTR_TYPE_DPFLTR_SAMSS_ID : _DPFLTR_TYPE = 34 ; pub const _DPFLTR_TYPE_DPFLTR_PNPMGR_ID : _DPFLTR_TYPE = 35 ; pub const _DPFLTR_TYPE_DPFLTR_NETAPI_ID : _DPFLTR_TYPE = 36 ; pub const _DPFLTR_TYPE_DPFLTR_SCSERVER_ID : _DPFLTR_TYPE = 37 ; pub const _DPFLTR_TYPE_DPFLTR_SCCLIENT_ID : _DPFLTR_TYPE = 38 ; pub const _DPFLTR_TYPE_DPFLTR_SERIAL_ID : _DPFLTR_TYPE = 39 ; pub const _DPFLTR_TYPE_DPFLTR_SERENUM_ID : _DPFLTR_TYPE = 40 ; pub const _DPFLTR_TYPE_DPFLTR_UHCD_ID : _DPFLTR_TYPE = 41 ; pub const _DPFLTR_TYPE_DPFLTR_RPCPROXY_ID : _DPFLTR_TYPE = 42 ; pub const _DPFLTR_TYPE_DPFLTR_AUTOCHK_ID : _DPFLTR_TYPE = 43 ; pub const _DPFLTR_TYPE_DPFLTR_DCOMSS_ID : _DPFLTR_TYPE = 44 ; pub const _DPFLTR_TYPE_DPFLTR_UNIMODEM_ID : _DPFLTR_TYPE = 45 ; pub const _DPFLTR_TYPE_DPFLTR_SIS_ID : _DPFLTR_TYPE = 46 ; pub const _DPFLTR_TYPE_DPFLTR_FLTMGR_ID : _DPFLTR_TYPE = 47 ; pub const _DPFLTR_TYPE_DPFLTR_WMICORE_ID : _DPFLTR_TYPE = 48 ; pub const _DPFLTR_TYPE_DPFLTR_BURNENG_ID : _DPFLTR_TYPE = 49 ; pub const _DPFLTR_TYPE_DPFLTR_IMAPI_ID : _DPFLTR_TYPE = 50 ; pub const _DPFLTR_TYPE_DPFLTR_SXS_ID : _DPFLTR_TYPE = 51 ; pub const _DPFLTR_TYPE_DPFLTR_FUSION_ID : _DPFLTR_TYPE = 52 ; pub const _DPFLTR_TYPE_DPFLTR_IDLETASK_ID : _DPFLTR_TYPE = 53 ; pub const _DPFLTR_TYPE_DPFLTR_SOFTPCI_ID : _DPFLTR_TYPE = 54 ; pub const _DPFLTR_TYPE_DPFLTR_TAPE_ID : _DPFLTR_TYPE = 55 ; pub const _DPFLTR_TYPE_DPFLTR_MCHGR_ID : _DPFLTR_TYPE = 56 ; pub const _DPFLTR_TYPE_DPFLTR_IDEP_ID : _DPFLTR_TYPE = 57 ; pub const _DPFLTR_TYPE_DPFLTR_PCIIDE_ID : _DPFLTR_TYPE = 58 ; pub const _DPFLTR_TYPE_DPFLTR_FLOPPY_ID : _DPFLTR_TYPE = 59 ; pub const _DPFLTR_TYPE_DPFLTR_FDC_ID : _DPFLTR_TYPE = 60 ; pub const _DPFLTR_TYPE_DPFLTR_TERMSRV_ID : _DPFLTR_TYPE = 61 ; pub const _DPFLTR_TYPE_DPFLTR_W32TIME_ID : _DPFLTR_TYPE = 62 ; pub const _DPFLTR_TYPE_DPFLTR_PREFETCHER_ID : _DPFLTR_TYPE = 63 ; pub const _DPFLTR_TYPE_DPFLTR_RSFILTER_ID : _DPFLTR_TYPE = 64 ; pub const _DPFLTR_TYPE_DPFLTR_FCPORT_ID : _DPFLTR_TYPE = 65 ; pub const _DPFLTR_TYPE_DPFLTR_PCI_ID : _DPFLTR_TYPE = 66 ; pub const _DPFLTR_TYPE_DPFLTR_DMIO_ID : _DPFLTR_TYPE = 67 ; pub const _DPFLTR_TYPE_DPFLTR_DMCONFIG_ID : _DPFLTR_TYPE = 68 ; pub const _DPFLTR_TYPE_DPFLTR_DMADMIN_ID : _DPFLTR_TYPE = 69 ; pub const _DPFLTR_TYPE_DPFLTR_WSOCKTRANSPORT_ID : _DPFLTR_TYPE = 70 ; pub const _DPFLTR_TYPE_DPFLTR_VSS_ID : _DPFLTR_TYPE = 71 ; pub const _DPFLTR_TYPE_DPFLTR_PNPMEM_ID : _DPFLTR_TYPE = 72 ; pub const _DPFLTR_TYPE_DPFLTR_PROCESSOR_ID : _DPFLTR_TYPE = 73 ; pub const _DPFLTR_TYPE_DPFLTR_DMSERVER_ID : _DPFLTR_TYPE = 74 ; pub const _DPFLTR_TYPE_DPFLTR_SR_ID : _DPFLTR_TYPE = 75 ; pub const _DPFLTR_TYPE_DPFLTR_INFINIBAND_ID : _DPFLTR_TYPE = 76 ; pub const _DPFLTR_TYPE_DPFLTR_IHVDRIVER_ID : _DPFLTR_TYPE = 77 ; pub const _DPFLTR_TYPE_DPFLTR_IHVVIDEO_ID : _DPFLTR_TYPE = 78 ; pub const _DPFLTR_TYPE_DPFLTR_IHVAUDIO_ID : _DPFLTR_TYPE = 79 ; pub const _DPFLTR_TYPE_DPFLTR_IHVNETWORK_ID : _DPFLTR_TYPE = 80 ; pub const _DPFLTR_TYPE_DPFLTR_IHVSTREAMING_ID : _DPFLTR_TYPE = 81 ; pub const _DPFLTR_TYPE_DPFLTR_IHVBUS_ID : _DPFLTR_TYPE = 82 ; pub const _DPFLTR_TYPE_DPFLTR_HPS_ID : _DPFLTR_TYPE = 83 ; pub const _DPFLTR_TYPE_DPFLTR_RTLTHREADPOOL_ID : _DPFLTR_TYPE = 84 ; pub const _DPFLTR_TYPE_DPFLTR_LDR_ID : _DPFLTR_TYPE = 85 ; pub const _DPFLTR_TYPE_DPFLTR_TCPIP6_ID : _DPFLTR_TYPE = 86 ; pub const _DPFLTR_TYPE_DPFLTR_ISAPNP_ID : _DPFLTR_TYPE = 87 ; pub const _DPFLTR_TYPE_DPFLTR_SHPC_ID : _DPFLTR_TYPE = 88 ; pub const _DPFLTR_TYPE_DPFLTR_STORPORT_ID : _DPFLTR_TYPE = 89 ; pub const _DPFLTR_TYPE_DPFLTR_STORMINIPORT_ID : _DPFLTR_TYPE = 90 ; pub const _DPFLTR_TYPE_DPFLTR_PRINTSPOOLER_ID : _DPFLTR_TYPE = 91 ; pub const _DPFLTR_TYPE_DPFLTR_VSSDYNDISK_ID : _DPFLTR_TYPE = 92 ; pub const _DPFLTR_TYPE_DPFLTR_VERIFIER_ID : _DPFLTR_TYPE = 93 ; pub const _DPFLTR_TYPE_DPFLTR_VDS_ID : _DPFLTR_TYPE = 94 ; pub const _DPFLTR_TYPE_DPFLTR_VDSBAS_ID : _DPFLTR_TYPE = 95 ; pub const _DPFLTR_TYPE_DPFLTR_VDSDYN_ID : _DPFLTR_TYPE = 96 ; pub const _DPFLTR_TYPE_DPFLTR_VDSDYNDR_ID : _DPFLTR_TYPE = 97 ; pub const _DPFLTR_TYPE_DPFLTR_VDSLDR_ID : _DPFLTR_TYPE = 98 ; pub const _DPFLTR_TYPE_DPFLTR_VDSUTIL_ID : _DPFLTR_TYPE = 99 ; pub const _DPFLTR_TYPE_DPFLTR_DFRGIFC_ID : _DPFLTR_TYPE = 100 ; pub const _DPFLTR_TYPE_DPFLTR_DEFAULT_ID : _DPFLTR_TYPE = 101 ; pub const _DPFLTR_TYPE_DPFLTR_MM_ID : _DPFLTR_TYPE = 102 ; pub const _DPFLTR_TYPE_DPFLTR_DFSC_ID : _DPFLTR_TYPE = 103 ; pub const _DPFLTR_TYPE_DPFLTR_WOW64_ID : _DPFLTR_TYPE = 104 ; pub const _DPFLTR_TYPE_DPFLTR_ALPC_ID : _DPFLTR_TYPE = 105 ; pub const _DPFLTR_TYPE_DPFLTR_WDI_ID : _DPFLTR_TYPE = 106 ; pub const _DPFLTR_TYPE_DPFLTR_PERFLIB_ID : _DPFLTR_TYPE = 107 ; pub const _DPFLTR_TYPE_DPFLTR_KTM_ID : _DPFLTR_TYPE = 108 ; pub const _DPFLTR_TYPE_DPFLTR_IOSTRESS_ID : _DPFLTR_TYPE = 109 ; pub const _DPFLTR_TYPE_DPFLTR_HEAP_ID : _DPFLTR_TYPE = 110 ; pub const _DPFLTR_TYPE_DPFLTR_WHEA_ID : _DPFLTR_TYPE = 111 ; pub const _DPFLTR_TYPE_DPFLTR_USERGDI_ID : _DPFLTR_TYPE = 112 ; pub const _DPFLTR_TYPE_DPFLTR_MMCSS_ID : _DPFLTR_TYPE = 113 ; pub const _DPFLTR_TYPE_DPFLTR_TPM_ID : _DPFLTR_TYPE = 114 ; pub const _DPFLTR_TYPE_DPFLTR_THREADORDER_ID : _DPFLTR_TYPE = 115 ; pub const _DPFLTR_TYPE_DPFLTR_ENVIRON_ID : _DPFLTR_TYPE = 116 ; pub const _DPFLTR_TYPE_DPFLTR_EMS_ID : _DPFLTR_TYPE = 117 ; pub const _DPFLTR_TYPE_DPFLTR_WDT_ID : _DPFLTR_TYPE = 118 ; pub const _DPFLTR_TYPE_DPFLTR_FVEVOL_ID : _DPFLTR_TYPE = 119 ; pub const _DPFLTR_TYPE_DPFLTR_NDIS_ID : _DPFLTR_TYPE = 120 ; pub const _DPFLTR_TYPE_DPFLTR_NVCTRACE_ID : _DPFLTR_TYPE = 121 ; pub const _DPFLTR_TYPE_DPFLTR_LUAFV_ID : _DPFLTR_TYPE = 122 ; pub const _DPFLTR_TYPE_DPFLTR_APPCOMPAT_ID : _DPFLTR_TYPE = 123 ; pub const _DPFLTR_TYPE_DPFLTR_USBSTOR_ID : _DPFLTR_TYPE = 124 ; pub const _DPFLTR_TYPE_DPFLTR_SBP2PORT_ID : _DPFLTR_TYPE = 125 ; pub const _DPFLTR_TYPE_DPFLTR_COVERAGE_ID : _DPFLTR_TYPE = 126 ; pub const _DPFLTR_TYPE_DPFLTR_CACHEMGR_ID : _DPFLTR_TYPE = 127 ; pub const _DPFLTR_TYPE_DPFLTR_MOUNTMGR_ID : _DPFLTR_TYPE = 128 ; pub const _DPFLTR_TYPE_DPFLTR_CFR_ID : _DPFLTR_TYPE = 129 ; pub const _DPFLTR_TYPE_DPFLTR_TXF_ID : _DPFLTR_TYPE = 130 ; pub const _DPFLTR_TYPE_DPFLTR_KSECDD_ID : _DPFLTR_TYPE = 131 ; pub const _DPFLTR_TYPE_DPFLTR_FLTREGRESS_ID : _DPFLTR_TYPE = 132 ; pub const _DPFLTR_TYPE_DPFLTR_MPIO_ID : _DPFLTR_TYPE = 133 ; pub const _DPFLTR_TYPE_DPFLTR_MSDSM_ID : _DPFLTR_TYPE = 134 ; pub const _DPFLTR_TYPE_DPFLTR_UDFS_ID : _DPFLTR_TYPE = 135 ; pub const _DPFLTR_TYPE_DPFLTR_PSHED_ID : _DPFLTR_TYPE = 136 ; pub const _DPFLTR_TYPE_DPFLTR_STORVSP_ID : _DPFLTR_TYPE = 137 ; pub const _DPFLTR_TYPE_DPFLTR_LSASS_ID : _DPFLTR_TYPE = 138 ; pub const _DPFLTR_TYPE_DPFLTR_SSPICLI_ID : _DPFLTR_TYPE = 139 ; pub const _DPFLTR_TYPE_DPFLTR_CNG_ID : _DPFLTR_TYPE = 140 ; pub const _DPFLTR_TYPE_DPFLTR_EXFAT_ID : _DPFLTR_TYPE = 141 ; pub const _DPFLTR_TYPE_DPFLTR_FILETRACE_ID : _DPFLTR_TYPE = 142 ; pub const _DPFLTR_TYPE_DPFLTR_XSAVE_ID : _DPFLTR_TYPE = 143 ; pub const _DPFLTR_TYPE_DPFLTR_SE_ID : _DPFLTR_TYPE = 144 ; pub const _DPFLTR_TYPE_DPFLTR_DRIVEEXTENDER_ID : _DPFLTR_TYPE = 145 ; pub const _DPFLTR_TYPE_DPFLTR_POWER_ID : _DPFLTR_TYPE = 146 ; pub const _DPFLTR_TYPE_DPFLTR_CRASHDUMPXHCI_ID : _DPFLTR_TYPE = 147 ; pub const _DPFLTR_TYPE_DPFLTR_GPIO_ID : _DPFLTR_TYPE = 148 ; pub const _DPFLTR_TYPE_DPFLTR_REFS_ID : _DPFLTR_TYPE = 149 ; pub const _DPFLTR_TYPE_DPFLTR_WER_ID : _DPFLTR_TYPE = 150 ; pub const _DPFLTR_TYPE_DPFLTR_CAPIMG_ID : _DPFLTR_TYPE = 151 ; pub const _DPFLTR_TYPE_DPFLTR_VPCI_ID : _DPFLTR_TYPE = 152 ; pub const _DPFLTR_TYPE_DPFLTR_STORAGECLASSMEMORY_ID : _DPFLTR_TYPE = 153 ; pub const _DPFLTR_TYPE_DPFLTR_FSLIB_ID : _DPFLTR_TYPE = 154 ; pub const _DPFLTR_TYPE_DPFLTR_ENDOFTABLE_ID : _DPFLTR_TYPE = 155 ; pub type _DPFLTR_TYPE = i32 ; pub use self :: _DPFLTR_TYPE as DPFLTR_TYPE ; extern "C" { pub fn RtlIoEncodeMemIoResource ( Descriptor : PIO_RESOURCE_DESCRIPTOR , Type : UCHAR , Length : ULONGLONG , Alignment : ULONGLONG , MinimumAddress : ULONGLONG , MaximumAddress : ULONGLONG ) -> NTSTATUS ; } extern "C" { pub fn RtlCmEncodeMemIoResource ( Descriptor : PCM_PARTIAL_RESOURCE_DESCRIPTOR , Type : UCHAR , Length : ULONGLONG , Start : ULONGLONG ) -> NTSTATUS ; } extern "C" { pub fn RtlIoDecodeMemIoResource ( Descriptor : PIO_RESOURCE_DESCRIPTOR , Alignment : PULONGLONG , MinimumAddress : PULONGLONG , MaximumAddress : PULONGLONG ) -> ULONGLONG ; } extern "C" { pub fn RtlCmDecodeMemIoResource ( Descriptor : PCM_PARTIAL_RESOURCE_DESCRIPTOR , Start : PULONGLONG ) -> ULONGLONG ; } extern "C" { pub fn RtlFindClosestEncodableLength ( SourceLength : ULONGLONG , TargetLength : PULONGLONG ) -> NTSTATUS ; } extern "C" { pub fn RtlIsUntrustedObject ( Handle : HANDLE , Object : PVOID , UntrustedObject : PBOOLEAN ) -> NTSTATUS ; } extern "C" { pub fn RtlQueryValidationRunlevel ( ComponentName : PCUNICODE_STRING ) -> ULONG ; } extern "C" { pub fn RtlCrc32 ( Buffer : * const :: std :: os :: raw :: c_void , Size : usize , InitialCrc : ULONG ) -> ULONG ; } extern "C" { pub fn RtlCrc64 ( Buffer : * const :: std :: os :: raw :: c_void , Size : usize , InitialCrc : ULONGLONG ) -> ULONGLONG ; } pub const _OS_DEPLOYEMENT_STATE_VALUES_OS_DEPLOYMENT_STANDARD : _OS_DEPLOYEMENT_STATE_VALUES = 1 ; pub const _OS_DEPLOYEMENT_STATE_VALUES_OS_DEPLOYMENT_COMPACT : _OS_DEPLOYEMENT_STATE_VALUES = 2 ; pub type _OS_DEPLOYEMENT_STATE_VALUES = i32 ; pub use self :: _OS_DEPLOYEMENT_STATE_VALUES as OS_DEPLOYEMENT_STATE_VALUES ; extern "C" { pub fn RtlOsDeploymentState ( Flags : ULONG ) -> OS_DEPLOYEMENT_STATE_VALUES ; } pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeNone : _IMAGE_POLICY_ENTRY_TYPE = 0 ; pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeBool : _IMAGE_POLICY_ENTRY_TYPE = 1 ; pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeInt8 : _IMAGE_POLICY_ENTRY_TYPE = 2 ; pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeUInt8 : _IMAGE_POLICY_ENTRY_TYPE = 3 ; pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeInt16 : _IMAGE_POLICY_ENTRY_TYPE = 4 ; pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeUInt16 : _IMAGE_POLICY_ENTRY_TYPE = 5 ; pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeInt32 : _IMAGE_POLICY_ENTRY_TYPE = 6 ; pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeUInt32 : _IMAGE_POLICY_ENTRY_TYPE = 7 ; pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeInt64 : _IMAGE_POLICY_ENTRY_TYPE = 8 ; pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeUInt64 : _IMAGE_POLICY_ENTRY_TYPE = 9 ; pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeAnsiString : _IMAGE_POLICY_ENTRY_TYPE = 10 ; pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeUnicodeString : _IMAGE_POLICY_ENTRY_TYPE = 11 ; pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeMaximum : _IMAGE_POLICY_ENTRY_TYPE = 12 ; pub type _IMAGE_POLICY_ENTRY_TYPE = i32 ; pub use self :: _IMAGE_POLICY_ENTRY_TYPE as IMAGE_POLICY_ENTRY_TYPE ; pub const _IMAGE_POLICY_ID_ImagePolicyIdNone : _IMAGE_POLICY_ID = 0 ; pub const _IMAGE_POLICY_ID_ImagePolicyIdEtw : _IMAGE_POLICY_ID = 1 ; pub const _IMAGE_POLICY_ID_ImagePolicyIdDebug : _IMAGE_POLICY_ID = 2 ; pub const _IMAGE_POLICY_ID_ImagePolicyIdCrashDump : _IMAGE_POLICY_ID = 3 ; pub const _IMAGE_POLICY_ID_ImagePolicyIdCrashDumpKey : _IMAGE_POLICY_ID = 4 ; pub const _IMAGE_POLICY_ID_ImagePolicyIdCrashDumpKeyGuid : _IMAGE_POLICY_ID = 5 ; pub const _IMAGE_POLICY_ID_ImagePolicyIdParentSd : _IMAGE_POLICY_ID = 6 ; pub const _IMAGE_POLICY_ID_ImagePolicyIdParentSdRev : _IMAGE_POLICY_ID = 7 ; pub const _IMAGE_POLICY_ID_ImagePolicyIdSvn : _IMAGE_POLICY_ID = 8 ; pub const _IMAGE_POLICY_ID_ImagePolicyIdDeviceId : _IMAGE_POLICY_ID = 9 ; pub const _IMAGE_POLICY_ID_ImagePolicyIdCapability : _IMAGE_POLICY_ID = 10 ; pub const _IMAGE_POLICY_ID_ImagePolicyIdScenarioId : _IMAGE_POLICY_ID = 11 ; pub const _IMAGE_POLICY_ID_ImagePolicyIdMaximum : _IMAGE_POLICY_ID = 12 ; pub type _IMAGE_POLICY_ID = i32 ; pub use self :: _IMAGE_POLICY_ID as IMAGE_POLICY_ID ; # [ repr ( C ) ] pub struct _IMAGE_POLICY_ENTRY { pub Type : IMAGE_POLICY_ENTRY_TYPE , pub PolicyId : IMAGE_POLICY_ID , pub u : _IMAGE_POLICY_ENTRY__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _IMAGE_POLICY_ENTRY__bindgen_ty_1 { pub None : __BindgenUnionField < * const :: std :: os :: raw :: c_void > , pub BoolValue : __BindgenUnionField < BOOLEAN > , pub Int8Value : __BindgenUnionField < INT8 > , pub UInt8Value : __BindgenUnionField < UINT8 > , pub Int16Value : __BindgenUnionField < INT16 > , pub UInt16Value : __BindgenUnionField < UINT16 > , pub Int32Value : __BindgenUnionField < INT32 > , pub UInt32Value : __BindgenUnionField < UINT32 > , pub Int64Value : __BindgenUnionField < INT64 > , pub UInt64Value : __BindgenUnionField < UINT64 > , pub AnsiStringValue : __BindgenUnionField < PCSTR > , pub UnicodeStringValue : __BindgenUnionField < PCWSTR > , pub bindgen_union_field : u64 , } pub type IMAGE_POLICY_ENTRY = _IMAGE_POLICY_ENTRY ; pub type PCIMAGE_POLICY_ENTRY = * const IMAGE_POLICY_ENTRY ; # [ repr ( C ) ] pub struct _IMAGE_POLICY_METADATA { pub Version : UCHAR , pub Reserved0 : [ UCHAR ; 7usize ] , pub ApplicationId : ULONGLONG , pub Policies : __IncompleteArrayField < IMAGE_POLICY_ENTRY > , } pub type IMAGE_POLICY_METADATA = _IMAGE_POLICY_METADATA ; pub type PCIMAGE_POLICY_METADATA = * const IMAGE_POLICY_METADATA ; extern "C" { pub fn RtlCompareMemory ( Source1 : * const :: std :: os :: raw :: c_void , Source2 : * const :: std :: os :: raw :: c_void , Length : SIZE_T ) -> SIZE_T ; } pub type UOW = GUID ; pub type PUOW = * mut GUID ; pub type CRM_PROTOCOL_ID = GUID ; pub type PCRM_PROTOCOL_ID = * mut GUID ; pub type NOTIFICATION_MASK = ULONG ; # [ repr ( C ) ] pub struct _TRANSACTION_NOTIFICATION { pub TransactionKey : PVOID , pub TransactionNotification : ULONG , pub TmVirtualClock : LARGE_INTEGER , pub ArgumentLength : ULONG , } pub type TRANSACTION_NOTIFICATION = _TRANSACTION_NOTIFICATION ; pub type PTRANSACTION_NOTIFICATION = * mut _TRANSACTION_NOTIFICATION ; # [ repr ( C ) ] pub struct _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT { pub EnlistmentId : GUID , pub UOW : UOW , } pub type TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT = _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT ; pub type PTRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT = * mut _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT ; # [ repr ( C ) ] pub struct _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT { pub TmIdentity : GUID , pub Flags : ULONG , } pub type TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT = _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT ; pub type PTRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT = * mut _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT ; pub type SAVEPOINT_ID = ULONG ; pub type PSAVEPOINT_ID = * mut ULONG ; # [ repr ( C ) ] pub struct _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT { pub SavepointId : SAVEPOINT_ID , } pub type TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT = _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT ; pub type PTRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT = * mut _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT ; # [ repr ( C ) ] pub struct _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT { pub PropagationCookie : ULONG , pub UOW : GUID , pub TmIdentity : GUID , pub BufferLength : ULONG , } pub type TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT = _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT ; pub type PTRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT = * mut _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT ; # [ repr ( C ) ] pub struct _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT { pub MarshalCookie : ULONG , pub UOW : GUID , } pub type TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT = _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT ; pub type PTRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT = * mut _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT ; pub type TRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT = TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT ; pub type PTRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT = * mut TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT ; # [ repr ( C ) ] pub struct _KCRM_MARSHAL_HEADER { pub VersionMajor : ULONG , pub VersionMinor : ULONG , pub NumProtocols : ULONG , pub Unused : ULONG , } pub type KCRM_MARSHAL_HEADER = _KCRM_MARSHAL_HEADER ; pub type PKCRM_MARSHAL_HEADER = * mut _KCRM_MARSHAL_HEADER ; pub type PRKCRM_MARSHAL_HEADER = * mut _KCRM_MARSHAL_HEADER ; # [ repr ( C ) ] pub struct _KCRM_TRANSACTION_BLOB { pub UOW : UOW , pub TmIdentity : GUID , pub IsolationLevel : ULONG , pub IsolationFlags : ULONG , pub Timeout : ULONG , pub Description : [ WCHAR ; 64usize ] , } pub type KCRM_TRANSACTION_BLOB = _KCRM_TRANSACTION_BLOB ; pub type PKCRM_TRANSACTION_BLOB = * mut _KCRM_TRANSACTION_BLOB ; pub type PRKCRM_TRANSACTION_BLOB = * mut _KCRM_TRANSACTION_BLOB ; # [ repr ( C ) ] pub struct _KCRM_PROTOCOL_BLOB { pub ProtocolId : CRM_PROTOCOL_ID , pub StaticInfoLength : ULONG , pub TransactionIdInfoLength : ULONG , pub Unused1 : ULONG , pub Unused2 : ULONG , } pub type KCRM_PROTOCOL_BLOB = _KCRM_PROTOCOL_BLOB ; pub type PKCRM_PROTOCOL_BLOB = * mut _KCRM_PROTOCOL_BLOB ; pub type PRKCRM_PROTOCOL_BLOB = * mut _KCRM_PROTOCOL_BLOB ; pub const _TRANSACTION_OUTCOME_TransactionOutcomeUndetermined : _TRANSACTION_OUTCOME = 1 ; pub const _TRANSACTION_OUTCOME_TransactionOutcomeCommitted : _TRANSACTION_OUTCOME = 2 ; pub const _TRANSACTION_OUTCOME_TransactionOutcomeAborted : _TRANSACTION_OUTCOME = 3 ; pub type _TRANSACTION_OUTCOME = i32 ; pub use self :: _TRANSACTION_OUTCOME as TRANSACTION_OUTCOME ; pub const _TRANSACTION_STATE_TransactionStateNormal : _TRANSACTION_STATE = 1 ; pub const _TRANSACTION_STATE_TransactionStateIndoubt : _TRANSACTION_STATE = 2 ; pub const _TRANSACTION_STATE_TransactionStateCommittedNotify : _TRANSACTION_STATE = 3 ; pub type _TRANSACTION_STATE = i32 ; pub use self :: _TRANSACTION_STATE as TRANSACTION_STATE ; # [ repr ( C ) ] pub struct _TRANSACTION_BASIC_INFORMATION { pub TransactionId : GUID , pub State : ULONG , pub Outcome : ULONG , } pub type TRANSACTION_BASIC_INFORMATION = _TRANSACTION_BASIC_INFORMATION ; pub type PTRANSACTION_BASIC_INFORMATION = * mut _TRANSACTION_BASIC_INFORMATION ; # [ repr ( C ) ] pub struct _TRANSACTIONMANAGER_BASIC_INFORMATION { pub TmIdentity : GUID , pub VirtualClock : LARGE_INTEGER , } pub type TRANSACTIONMANAGER_BASIC_INFORMATION = _TRANSACTIONMANAGER_BASIC_INFORMATION ; pub type PTRANSACTIONMANAGER_BASIC_INFORMATION = * mut _TRANSACTIONMANAGER_BASIC_INFORMATION ; # [ repr ( C ) ] pub struct _TRANSACTIONMANAGER_LOG_INFORMATION { pub LogIdentity : GUID , } pub type TRANSACTIONMANAGER_LOG_INFORMATION = _TRANSACTIONMANAGER_LOG_INFORMATION ; pub type PTRANSACTIONMANAGER_LOG_INFORMATION = * mut _TRANSACTIONMANAGER_LOG_INFORMATION ; # [ repr ( C ) ] pub struct _TRANSACTIONMANAGER_LOGPATH_INFORMATION { pub LogPathLength : ULONG , pub LogPath : [ WCHAR ; 1usize ] , } pub type TRANSACTIONMANAGER_LOGPATH_INFORMATION = _TRANSACTIONMANAGER_LOGPATH_INFORMATION ; pub type PTRANSACTIONMANAGER_LOGPATH_INFORMATION = * mut _TRANSACTIONMANAGER_LOGPATH_INFORMATION ; # [ repr ( C ) ] pub struct _TRANSACTIONMANAGER_RECOVERY_INFORMATION { pub LastRecoveredLsn : ULONGLONG , } pub type TRANSACTIONMANAGER_RECOVERY_INFORMATION = _TRANSACTIONMANAGER_RECOVERY_INFORMATION ; pub type PTRANSACTIONMANAGER_RECOVERY_INFORMATION = * mut _TRANSACTIONMANAGER_RECOVERY_INFORMATION ; # [ repr ( C ) ] pub struct _TRANSACTION_PROPERTIES_INFORMATION { pub IsolationLevel : ULONG , pub IsolationFlags : ULONG , pub Timeout : LARGE_INTEGER , pub Outcome : ULONG , pub DescriptionLength : ULONG , pub Description : [ WCHAR ; 1usize ] , } pub type TRANSACTION_PROPERTIES_INFORMATION = _TRANSACTION_PROPERTIES_INFORMATION ; pub type PTRANSACTION_PROPERTIES_INFORMATION = * mut _TRANSACTION_PROPERTIES_INFORMATION ; # [ repr ( C ) ] pub struct _TRANSACTION_BIND_INFORMATION { pub TmHandle : HANDLE , } pub type TRANSACTION_BIND_INFORMATION = _TRANSACTION_BIND_INFORMATION ; pub type PTRANSACTION_BIND_INFORMATION = * mut _TRANSACTION_BIND_INFORMATION ; # [ repr ( C ) ] pub struct _TRANSACTION_ENLISTMENT_PAIR { pub EnlistmentId : GUID , pub ResourceManagerId : GUID , } pub type TRANSACTION_ENLISTMENT_PAIR = _TRANSACTION_ENLISTMENT_PAIR ; pub type PTRANSACTION_ENLISTMENT_PAIR = * mut _TRANSACTION_ENLISTMENT_PAIR ; # [ repr ( C ) ] pub struct _TRANSACTION_ENLISTMENTS_INFORMATION { pub NumberOfEnlistments : ULONG , pub EnlistmentPair : [ TRANSACTION_ENLISTMENT_PAIR ; 1usize ] , } pub type TRANSACTION_ENLISTMENTS_INFORMATION = _TRANSACTION_ENLISTMENTS_INFORMATION ; pub type PTRANSACTION_ENLISTMENTS_INFORMATION = * mut _TRANSACTION_ENLISTMENTS_INFORMATION ; # [ repr ( C ) ] pub struct _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION { pub SuperiorEnlistmentPair : TRANSACTION_ENLISTMENT_PAIR , } pub type TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION = _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION ; pub type PTRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION = * mut _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION ; # [ repr ( C ) ] pub struct _RESOURCEMANAGER_BASIC_INFORMATION { pub ResourceManagerId : GUID , pub DescriptionLength : ULONG , pub Description : [ WCHAR ; 1usize ] , } pub type RESOURCEMANAGER_BASIC_INFORMATION = _RESOURCEMANAGER_BASIC_INFORMATION ; pub type PRESOURCEMANAGER_BASIC_INFORMATION = * mut _RESOURCEMANAGER_BASIC_INFORMATION ; # [ repr ( C ) ] pub struct _RESOURCEMANAGER_COMPLETION_INFORMATION { pub IoCompletionPortHandle : HANDLE , pub CompletionKey : ULONG_PTR , } pub type RESOURCEMANAGER_COMPLETION_INFORMATION = _RESOURCEMANAGER_COMPLETION_INFORMATION ; pub type PRESOURCEMANAGER_COMPLETION_INFORMATION = * mut _RESOURCEMANAGER_COMPLETION_INFORMATION ; pub const _TRANSACTION_INFORMATION_CLASS_TransactionBasicInformation : _TRANSACTION_INFORMATION_CLASS = 0 ; pub const _TRANSACTION_INFORMATION_CLASS_TransactionPropertiesInformation : _TRANSACTION_INFORMATION_CLASS = 1 ; pub const _TRANSACTION_INFORMATION_CLASS_TransactionEnlistmentInformation : _TRANSACTION_INFORMATION_CLASS = 2 ; pub const _TRANSACTION_INFORMATION_CLASS_TransactionSuperiorEnlistmentInformation : _TRANSACTION_INFORMATION_CLASS = 3 ; pub type _TRANSACTION_INFORMATION_CLASS = i32 ; pub use self :: _TRANSACTION_INFORMATION_CLASS as TRANSACTION_INFORMATION_CLASS ; pub const _TRANSACTIONMANAGER_INFORMATION_CLASS_TransactionManagerBasicInformation : _TRANSACTIONMANAGER_INFORMATION_CLASS = 0 ; pub const _TRANSACTIONMANAGER_INFORMATION_CLASS_TransactionManagerLogInformation : _TRANSACTIONMANAGER_INFORMATION_CLASS = 1 ; pub const _TRANSACTIONMANAGER_INFORMATION_CLASS_TransactionManagerLogPathInformation : _TRANSACTIONMANAGER_INFORMATION_CLASS = 2 ; pub const _TRANSACTIONMANAGER_INFORMATION_CLASS_TransactionManagerRecoveryInformation : _TRANSACTIONMANAGER_INFORMATION_CLASS = 4 ; pub type _TRANSACTIONMANAGER_INFORMATION_CLASS = i32 ; pub use self :: _TRANSACTIONMANAGER_INFORMATION_CLASS as TRANSACTIONMANAGER_INFORMATION_CLASS ; pub const _RESOURCEMANAGER_INFORMATION_CLASS_ResourceManagerBasicInformation : _RESOURCEMANAGER_INFORMATION_CLASS = 0 ; pub const _RESOURCEMANAGER_INFORMATION_CLASS_ResourceManagerCompletionInformation : _RESOURCEMANAGER_INFORMATION_CLASS = 1 ; pub type _RESOURCEMANAGER_INFORMATION_CLASS = i32 ; pub use self :: _RESOURCEMANAGER_INFORMATION_CLASS as RESOURCEMANAGER_INFORMATION_CLASS ; # [ repr ( C ) ] pub struct _ENLISTMENT_BASIC_INFORMATION { pub EnlistmentId : GUID , pub TransactionId : GUID , pub ResourceManagerId : GUID , } pub type ENLISTMENT_BASIC_INFORMATION = _ENLISTMENT_BASIC_INFORMATION ; pub type PENLISTMENT_BASIC_INFORMATION = * mut _ENLISTMENT_BASIC_INFORMATION ; # [ repr ( C ) ] pub struct _ENLISTMENT_CRM_INFORMATION { pub CrmTransactionManagerId : GUID , pub CrmResourceManagerId : GUID , pub CrmEnlistmentId : GUID , } pub type ENLISTMENT_CRM_INFORMATION = _ENLISTMENT_CRM_INFORMATION ; pub type PENLISTMENT_CRM_INFORMATION = * mut _ENLISTMENT_CRM_INFORMATION ; pub const _ENLISTMENT_INFORMATION_CLASS_EnlistmentBasicInformation : _ENLISTMENT_INFORMATION_CLASS = 0 ; pub const _ENLISTMENT_INFORMATION_CLASS_EnlistmentRecoveryInformation : _ENLISTMENT_INFORMATION_CLASS = 1 ; pub const _ENLISTMENT_INFORMATION_CLASS_EnlistmentCrmInformation : _ENLISTMENT_INFORMATION_CLASS = 2 ; pub type _ENLISTMENT_INFORMATION_CLASS = i32 ; pub use self :: _ENLISTMENT_INFORMATION_CLASS as ENLISTMENT_INFORMATION_CLASS ; # [ repr ( C ) ] pub struct _TRANSACTION_LIST_ENTRY { pub UOW : UOW , } pub type TRANSACTION_LIST_ENTRY = _TRANSACTION_LIST_ENTRY ; pub type PTRANSACTION_LIST_ENTRY = * mut _TRANSACTION_LIST_ENTRY ; # [ repr ( C ) ] pub struct _TRANSACTION_LIST_INFORMATION { pub NumberOfTransactions : ULONG , pub TransactionInformation : [ TRANSACTION_LIST_ENTRY ; 1usize ] , } pub type TRANSACTION_LIST_INFORMATION = _TRANSACTION_LIST_INFORMATION ; pub type PTRANSACTION_LIST_INFORMATION = * mut _TRANSACTION_LIST_INFORMATION ; pub const _KTMOBJECT_TYPE_KTMOBJECT_TRANSACTION : _KTMOBJECT_TYPE = 0 ; pub const _KTMOBJECT_TYPE_KTMOBJECT_TRANSACTION_MANAGER : _KTMOBJECT_TYPE = 1 ; pub const _KTMOBJECT_TYPE_KTMOBJECT_RESOURCE_MANAGER : _KTMOBJECT_TYPE = 2 ; pub const _KTMOBJECT_TYPE_KTMOBJECT_ENLISTMENT : _KTMOBJECT_TYPE = 3 ; pub const _KTMOBJECT_TYPE_KTMOBJECT_INVALID : _KTMOBJECT_TYPE = 4 ; pub type _KTMOBJECT_TYPE = i32 ; pub use self :: _KTMOBJECT_TYPE as KTMOBJECT_TYPE ; pub type PKTMOBJECT_TYPE = * mut _KTMOBJECT_TYPE ; # [ repr ( C ) ] pub struct _KTMOBJECT_CURSOR { pub LastQuery : GUID , pub ObjectIdCount : ULONG , pub ObjectIds : [ GUID ; 1usize ] , } pub type KTMOBJECT_CURSOR = _KTMOBJECT_CURSOR ; pub type PKTMOBJECT_CURSOR = * mut _KTMOBJECT_CURSOR ; extern "C" { pub fn NtCreateTransactionManager ( TmHandle : PHANDLE , DesiredAccess : ACCESS_MASK , ObjectAttributes : POBJECT_ATTRIBUTES , LogFileName : PUNICODE_STRING , CreateOptions : ULONG , CommitStrength : ULONG ) -> NTSTATUS ; } extern "C" { pub fn NtOpenTransactionManager ( TmHandle : PHANDLE , DesiredAccess : ACCESS_MASK , ObjectAttributes : POBJECT_ATTRIBUTES , LogFileName : PUNICODE_STRING , TmIdentity : LPGUID , OpenOptions : ULONG ) -> NTSTATUS ; } extern "C" { pub fn NtRenameTransactionManager ( LogFileName : PUNICODE_STRING , ExistingTransactionManagerGuid : LPGUID ) -> NTSTATUS ; } extern "C" { pub fn NtRollforwardTransactionManager ( TransactionManagerHandle : HANDLE , TmVirtualClock : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn NtRecoverTransactionManager ( TransactionManagerHandle : HANDLE ) -> NTSTATUS ; } extern "C" { pub fn NtQueryInformationTransactionManager ( TransactionManagerHandle : HANDLE , TransactionManagerInformationClass : TRANSACTIONMANAGER_INFORMATION_CLASS , TransactionManagerInformation : PVOID , TransactionManagerInformationLength : ULONG , ReturnLength : PULONG ) -> NTSTATUS ; } extern "C" { pub fn NtSetInformationTransactionManager ( TmHandle : HANDLE , TransactionManagerInformationClass : TRANSACTIONMANAGER_INFORMATION_CLASS , TransactionManagerInformation : PVOID , TransactionManagerInformationLength : ULONG ) -> NTSTATUS ; } extern "C" { pub fn NtEnumerateTransactionObject ( RootObjectHandle : HANDLE , QueryType : KTMOBJECT_TYPE , ObjectCursor : PKTMOBJECT_CURSOR , ObjectCursorLength : ULONG , ReturnLength : PULONG ) -> NTSTATUS ; } pub type PFN_NT_CREATE_TRANSACTION = :: std :: option :: Option < unsafe extern "C" fn ( TransactionHandle : PHANDLE , DesiredAccess : ACCESS_MASK , ObjectAttributes : POBJECT_ATTRIBUTES , Uow : LPGUID , TmHandle : HANDLE , CreateOptions : ULONG , IsolationLevel : ULONG , IsolationFlags : ULONG , Timeout : PLARGE_INTEGER , Description : PUNICODE_STRING ) -> NTSTATUS > ; extern "C" { pub fn NtCreateTransaction ( TransactionHandle : PHANDLE , DesiredAccess : ACCESS_MASK , ObjectAttributes : POBJECT_ATTRIBUTES , Uow : LPGUID , TmHandle : HANDLE , CreateOptions : ULONG , IsolationLevel : ULONG , IsolationFlags : ULONG , Timeout : PLARGE_INTEGER , Description : PUNICODE_STRING ) -> NTSTATUS ; } pub type PFN_NT_OPEN_TRANSACTION = :: std :: option :: Option < unsafe extern "C" fn ( TransactionHandle : PHANDLE , DesiredAccess : ACCESS_MASK , ObjectAttributes : POBJECT_ATTRIBUTES , Uow : LPGUID , TmHandle : HANDLE ) -> NTSTATUS > ; extern "C" { pub fn NtOpenTransaction ( TransactionHandle : PHANDLE , DesiredAccess : ACCESS_MASK , ObjectAttributes : POBJECT_ATTRIBUTES , Uow : LPGUID , TmHandle : HANDLE ) -> NTSTATUS ; } pub type PFN_NT_QUERY_INFORMATION_TRANSACTION = :: std :: option :: Option < unsafe extern "C" fn ( TransactionHandle : HANDLE , TransactionInformationClass : TRANSACTION_INFORMATION_CLASS , TransactionInformation : PVOID , TransactionInformationLength : ULONG , ReturnLength : PULONG ) -> NTSTATUS > ; extern "C" { pub fn NtQueryInformationTransaction ( TransactionHandle : HANDLE , TransactionInformationClass : TRANSACTION_INFORMATION_CLASS , TransactionInformation : PVOID , TransactionInformationLength : ULONG , ReturnLength : PULONG ) -> NTSTATUS ; } pub type PFN_NT_SET_INFORMATION_TRANSACTION = :: std :: option :: Option < unsafe extern "C" fn ( TransactionHandle : HANDLE , TransactionInformationClass : TRANSACTION_INFORMATION_CLASS , TransactionInformation : PVOID , TransactionInformationLength : ULONG ) -> NTSTATUS > ; extern "C" { pub fn NtSetInformationTransaction ( TransactionHandle : HANDLE , TransactionInformationClass : TRANSACTION_INFORMATION_CLASS , TransactionInformation : PVOID , TransactionInformationLength : ULONG ) -> NTSTATUS ; } pub type PFN_NT_COMMIT_TRANSACTION = :: std :: option :: Option < unsafe extern "C" fn ( TransactionHandle : HANDLE , Wait : BOOLEAN ) -> NTSTATUS > ; extern "C" { pub fn NtCommitTransaction ( TransactionHandle : HANDLE , Wait : BOOLEAN ) -> NTSTATUS ; } pub type PFN_NT_ROLLBACK_TRANSACTION = :: std :: option :: Option < unsafe extern "C" fn ( TransactionHandle : HANDLE , Wait : BOOLEAN ) -> NTSTATUS > ; extern "C" { pub fn NtRollbackTransaction ( TransactionHandle : HANDLE , Wait : BOOLEAN ) -> NTSTATUS ; } extern "C" { pub fn NtCreateEnlistment ( EnlistmentHandle : PHANDLE , DesiredAccess : ACCESS_MASK , ResourceManagerHandle : HANDLE , TransactionHandle : HANDLE , ObjectAttributes : POBJECT_ATTRIBUTES , CreateOptions : ULONG , NotificationMask : NOTIFICATION_MASK , EnlistmentKey : PVOID ) -> NTSTATUS ; } extern "C" { pub fn NtOpenEnlistment ( EnlistmentHandle : PHANDLE , DesiredAccess : ACCESS_MASK , ResourceManagerHandle : HANDLE , EnlistmentGuid : LPGUID , ObjectAttributes : POBJECT_ATTRIBUTES ) -> NTSTATUS ; } extern "C" { pub fn NtQueryInformationEnlistment ( EnlistmentHandle : HANDLE , EnlistmentInformationClass : ENLISTMENT_INFORMATION_CLASS , EnlistmentInformation : PVOID , EnlistmentInformationLength : ULONG , ReturnLength : PULONG ) -> NTSTATUS ; } extern "C" { pub fn NtSetInformationEnlistment ( EnlistmentHandle : HANDLE , EnlistmentInformationClass : ENLISTMENT_INFORMATION_CLASS , EnlistmentInformation : PVOID , EnlistmentInformationLength : ULONG ) -> NTSTATUS ; } extern "C" { pub fn NtRecoverEnlistment ( EnlistmentHandle : HANDLE , EnlistmentKey : PVOID ) -> NTSTATUS ; } extern "C" { pub fn NtPrePrepareEnlistment ( EnlistmentHandle : HANDLE , TmVirtualClock : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn NtPrepareEnlistment ( EnlistmentHandle : HANDLE , TmVirtualClock : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn NtCommitEnlistment ( EnlistmentHandle : HANDLE , TmVirtualClock : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn NtRollbackEnlistment ( EnlistmentHandle : HANDLE , TmVirtualClock : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn NtPrePrepareComplete ( EnlistmentHandle : HANDLE , TmVirtualClock : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn NtPrepareComplete ( EnlistmentHandle : HANDLE , TmVirtualClock : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn NtCommitComplete ( EnlistmentHandle : HANDLE , TmVirtualClock : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn NtReadOnlyEnlistment ( EnlistmentHandle : HANDLE , TmVirtualClock : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn NtRollbackComplete ( EnlistmentHandle : HANDLE , TmVirtualClock : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn NtSinglePhaseReject ( EnlistmentHandle : HANDLE , TmVirtualClock : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn NtCreateResourceManager ( ResourceManagerHandle : PHANDLE , DesiredAccess : ACCESS_MASK , TmHandle : HANDLE , RmGuid : LPGUID , ObjectAttributes : POBJECT_ATTRIBUTES , CreateOptions : ULONG , Description : PUNICODE_STRING ) -> NTSTATUS ; } extern "C" { pub fn NtOpenResourceManager ( ResourceManagerHandle : PHANDLE , DesiredAccess : ACCESS_MASK , TmHandle : HANDLE , ResourceManagerGuid : LPGUID , ObjectAttributes : POBJECT_ATTRIBUTES ) -> NTSTATUS ; } extern "C" { pub fn NtRecoverResourceManager ( ResourceManagerHandle : HANDLE ) -> NTSTATUS ; } extern "C" { pub fn NtGetNotificationResourceManager ( ResourceManagerHandle : HANDLE , TransactionNotification : PTRANSACTION_NOTIFICATION , NotificationLength : ULONG , Timeout : PLARGE_INTEGER , ReturnLength : PULONG , Asynchronous : ULONG , AsynchronousContext : ULONG_PTR ) -> NTSTATUS ; } extern "C" { pub fn NtQueryInformationResourceManager ( ResourceManagerHandle : HANDLE , ResourceManagerInformationClass : RESOURCEMANAGER_INFORMATION_CLASS , ResourceManagerInformation : PVOID , ResourceManagerInformationLength : ULONG , ReturnLength : PULONG ) -> NTSTATUS ; } extern "C" { pub fn NtSetInformationResourceManager ( ResourceManagerHandle : HANDLE , ResourceManagerInformationClass : RESOURCEMANAGER_INFORMATION_CLASS , ResourceManagerInformation : PVOID , ResourceManagerInformationLength : ULONG ) -> NTSTATUS ; } extern "C" { pub fn NtRegisterProtocolAddressInformation ( ResourceManager : HANDLE , ProtocolId : PCRM_PROTOCOL_ID , ProtocolInformationSize : ULONG , ProtocolInformation : PVOID , CreateOptions : ULONG ) -> NTSTATUS ; } extern "C" { pub fn NtPropagationComplete ( ResourceManagerHandle : HANDLE , RequestCookie : ULONG , BufferLength : ULONG , Buffer : PVOID ) -> NTSTATUS ; } extern "C" { pub fn NtPropagationFailed ( ResourceManagerHandle : HANDLE , RequestCookie : ULONG , PropStatus : NTSTATUS ) -> NTSTATUS ; } extern "C" { # [ link_name = "\u{1}NtGlobalFlag" ] pub static mut NtGlobalFlag : ULONG ; } pub use self :: _POOL_TYPE as POOL_TYPE ; pub type ALLOCATE_FUNCTION = :: std :: option :: Option < unsafe extern "C" fn ( PoolType : POOL_TYPE , NumberOfBytes : SIZE_T , Tag : ULONG ) -> PVOID > ; pub type PALLOCATE_FUNCTION = ALLOCATE_FUNCTION ; pub type FREE_FUNCTION = :: std :: option :: Option < unsafe extern "C" fn ( Buffer : PVOID ) > ; pub type PFREE_FUNCTION = FREE_FUNCTION ; pub type PLOOKASIDE_LIST_EX = * mut _LOOKASIDE_LIST_EX ; pub type ALLOCATE_FUNCTION_EX = :: std :: option :: Option < unsafe extern "C" fn ( PoolType : POOL_TYPE , NumberOfBytes : SIZE_T , Tag : ULONG , Lookaside : PLOOKASIDE_LIST_EX ) -> PVOID > ; pub type PALLOCATE_FUNCTION_EX = ALLOCATE_FUNCTION_EX ; pub type FREE_FUNCTION_EX = :: std :: option :: Option < unsafe extern "C" fn ( Buffer : PVOID , Lookaside : PLOOKASIDE_LIST_EX ) > ; pub type PFREE_FUNCTION_EX = FREE_FUNCTION_EX ; # [ repr ( C ) ] pub struct _GENERAL_LOOKASIDE { pub __bindgen_anon_1 : _GENERAL_LOOKASIDE__bindgen_ty_1 , pub Depth : USHORT , pub MaximumDepth : USHORT , pub TotalAllocates : ULONG , pub __bindgen_anon_2 : _GENERAL_LOOKASIDE__bindgen_ty_2 , pub TotalFrees : ULONG , pub __bindgen_anon_3 : _GENERAL_LOOKASIDE__bindgen_ty_3 , pub Type : POOL_TYPE , pub Tag : ULONG , pub Size : ULONG , pub __bindgen_anon_4 : _GENERAL_LOOKASIDE__bindgen_ty_4 , pub __bindgen_anon_5 : _GENERAL_LOOKASIDE__bindgen_ty_5 , pub ListEntry : LIST_ENTRY , pub LastTotalAllocates : ULONG , pub __bindgen_anon_6 : _GENERAL_LOOKASIDE__bindgen_ty_6 , pub Future : [ ULONG ; 2usize ] , pub __bindgen_padding_0 : [ u64 ; 2usize ] , } # [ repr ( C ) ] pub struct _GENERAL_LOOKASIDE__bindgen_ty_1 { pub ListHead : __BindgenUnionField < SLIST_HEADER > , pub SingleListHead : __BindgenUnionField < SINGLE_LIST_ENTRY > , pub bindgen_union_field : [ u8 ; 32usize ] , } # [ repr ( C ) ] pub struct _GENERAL_LOOKASIDE__bindgen_ty_2 { pub AllocateMisses : __BindgenUnionField < ULONG > , pub AllocateHits : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _GENERAL_LOOKASIDE__bindgen_ty_3 { pub FreeMisses : __BindgenUnionField < ULONG > , pub FreeHits : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _GENERAL_LOOKASIDE__bindgen_ty_4 { pub AllocateEx : __BindgenUnionField < PALLOCATE_FUNCTION_EX > , pub Allocate : __BindgenUnionField < PALLOCATE_FUNCTION > , pub bindgen_union_field : u64 , } # [ repr ( C ) ] pub struct _GENERAL_LOOKASIDE__bindgen_ty_5 { pub FreeEx : __BindgenUnionField < PFREE_FUNCTION_EX > , pub Free : __BindgenUnionField < PFREE_FUNCTION > , pub bindgen_union_field : u64 , } # [ repr ( C ) ] pub struct _GENERAL_LOOKASIDE__bindgen_ty_6 { pub LastAllocateMisses : __BindgenUnionField < ULONG > , pub LastAllocateHits : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } pub type GENERAL_LOOKASIDE = _GENERAL_LOOKASIDE ; pub type PGENERAL_LOOKASIDE = * mut GENERAL_LOOKASIDE ; # [ repr ( C ) ] pub struct _GENERAL_LOOKASIDE_POOL { pub __bindgen_anon_1 : _GENERAL_LOOKASIDE_POOL__bindgen_ty_1 , pub Depth : USHORT , pub MaximumDepth : USHORT , pub TotalAllocates : ULONG , pub __bindgen_anon_2 : _GENERAL_LOOKASIDE_POOL__bindgen_ty_2 , pub TotalFrees : ULONG , pub __bindgen_anon_3 : _GENERAL_LOOKASIDE_POOL__bindgen_ty_3 , pub Type : POOL_TYPE , pub Tag : ULONG , pub Size : ULONG , pub __bindgen_anon_4 : _GENERAL_LOOKASIDE_POOL__bindgen_ty_4 , pub __bindgen_anon_5 : _GENERAL_LOOKASIDE_POOL__bindgen_ty_5 , pub ListEntry : LIST_ENTRY , pub LastTotalAllocates : ULONG , pub __bindgen_anon_6 : _GENERAL_LOOKASIDE_POOL__bindgen_ty_6 , pub Future : [ ULONG ; 2usize ] , } # [ repr ( C ) ] pub struct _GENERAL_LOOKASIDE_POOL__bindgen_ty_1 { pub ListHead : __BindgenUnionField < SLIST_HEADER > , pub SingleListHead : __BindgenUnionField < SINGLE_LIST_ENTRY > , pub bindgen_union_field : [ u8 ; 32usize ] , } # [ repr ( C ) ] pub struct _GENERAL_LOOKASIDE_POOL__bindgen_ty_2 { pub AllocateMisses : __BindgenUnionField < ULONG > , pub AllocateHits : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _GENERAL_LOOKASIDE_POOL__bindgen_ty_3 { pub FreeMisses : __BindgenUnionField < ULONG > , pub FreeHits : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _GENERAL_LOOKASIDE_POOL__bindgen_ty_4 { pub AllocateEx : __BindgenUnionField < PALLOCATE_FUNCTION_EX > , pub Allocate : __BindgenUnionField < PALLOCATE_FUNCTION > , pub bindgen_union_field : u64 , } # [ repr ( C ) ] pub struct _GENERAL_LOOKASIDE_POOL__bindgen_ty_5 { pub FreeEx : __BindgenUnionField < PFREE_FUNCTION_EX > , pub Free : __BindgenUnionField < PFREE_FUNCTION > , pub bindgen_union_field : u64 , } # [ repr ( C ) ] pub struct _GENERAL_LOOKASIDE_POOL__bindgen_ty_6 { pub LastAllocateMisses : __BindgenUnionField < ULONG > , pub LastAllocateHits : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } pub type GENERAL_LOOKASIDE_POOL = _GENERAL_LOOKASIDE_POOL ; pub type PGENERAL_LOOKASIDE_POOL = * mut _GENERAL_LOOKASIDE_POOL ; pub type KPROCESSOR_MODE = CCHAR ; pub const _MODE_KernelMode : _MODE = 0 ; pub const _MODE_UserMode : _MODE = 1 ; pub const _MODE_MaximumMode : _MODE = 2 ; pub type _MODE = i32 ; pub use self :: _MODE as MODE ; pub type KSYNCHRONIZE_ROUTINE = :: std :: option :: Option < unsafe extern "C" fn ( SynchronizeContext : PVOID ) -> BOOLEAN > ; pub type PKSYNCHRONIZE_ROUTINE = KSYNCHRONIZE_ROUTINE ; # [ repr ( C ) ] pub struct _KAPC { pub Type : UCHAR , pub SpareByte0 : UCHAR , pub Size : UCHAR , pub SpareByte1 : UCHAR , pub SpareLong0 : ULONG , pub Thread : * mut _KTHREAD , pub ApcListEntry : LIST_ENTRY , pub Reserved : [ PVOID ; 3usize ] , pub NormalContext : PVOID , pub SystemArgument1 : PVOID , pub SystemArgument2 : PVOID , pub ApcStateIndex : CCHAR , pub ApcMode : KPROCESSOR_MODE , pub Inserted : BOOLEAN , } pub type KAPC = _KAPC ; pub type PKAPC = * mut _KAPC ; pub type PRKAPC = * mut _KAPC ; pub type KDEFERRED_ROUTINE = :: std :: option :: Option < unsafe extern "C" fn ( Dpc : * mut _KDPC , DeferredContext : PVOID , SystemArgument1 : PVOID , SystemArgument2 : PVOID ) > ; pub type PKDEFERRED_ROUTINE = KDEFERRED_ROUTINE ; pub const _KDPC_IMPORTANCE_LowImportance : _KDPC_IMPORTANCE = 0 ; pub const _KDPC_IMPORTANCE_MediumImportance : _KDPC_IMPORTANCE = 1 ; pub const _KDPC_IMPORTANCE_HighImportance : _KDPC_IMPORTANCE = 2 ; pub const _KDPC_IMPORTANCE_MediumHighImportance : _KDPC_IMPORTANCE = 3 ; pub type _KDPC_IMPORTANCE = i32 ; pub use self :: _KDPC_IMPORTANCE as KDPC_IMPORTANCE ; # [ repr ( C ) ] pub struct _KDPC { pub __bindgen_anon_1 : _KDPC__bindgen_ty_1 , pub DpcListEntry : SINGLE_LIST_ENTRY , pub ProcessorHistory : KAFFINITY , pub DeferredRoutine : PKDEFERRED_ROUTINE , pub DeferredContext : PVOID , pub SystemArgument1 : PVOID , pub SystemArgument2 : PVOID , pub DpcData : PVOID , } # [ repr ( C ) ] pub struct _KDPC__bindgen_ty_1 { pub TargetInfoAsUlong : __BindgenUnionField < ULONG > , pub __bindgen_anon_1 : __BindgenUnionField < _KDPC__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _KDPC__bindgen_ty_1__bindgen_ty_1 { pub Type : UCHAR , pub Importance : UCHAR , pub Number : USHORT , } pub type KDPC = _KDPC ; pub type PKDPC = * mut _KDPC ; pub type PRKDPC = * mut _KDPC ; # [ repr ( C ) ] pub struct _MDL { pub Next : * mut _MDL , pub Size : CSHORT , pub MdlFlags : CSHORT , pub Process : * mut _EPROCESS , pub MappedSystemVa : PVOID , pub StartVa : PVOID , pub ByteCount : ULONG , pub ByteOffset : ULONG , } pub type MDL = _MDL ; pub type PMDL = * mut _MDL ; pub type PMDLX = * mut MDL ; # [ repr ( C ) ] pub struct _DISPATCHER_HEADER { pub __bindgen_anon_1 : _DISPATCHER_HEADER__bindgen_ty_1 , pub SignalState : LONG , pub WaitListHead : LIST_ENTRY , } # [ repr ( C ) ] pub struct _DISPATCHER_HEADER__bindgen_ty_1 { pub __bindgen_anon_1 : __BindgenUnionField < _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1 > , pub __bindgen_anon_2 : __BindgenUnionField < _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2 > , pub __bindgen_anon_3 : __BindgenUnionField < _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3 > , pub __bindgen_anon_4 : __BindgenUnionField < _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4 > , pub __bindgen_anon_5 : __BindgenUnionField < _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5 > , pub __bindgen_anon_6 : __BindgenUnionField < _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6 > , pub __bindgen_anon_7 : __BindgenUnionField < _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1 { pub Lock : __BindgenUnionField < LONG > , pub LockNV : __BindgenUnionField < LONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2 { pub Type : UCHAR , pub Signalling : UCHAR , pub Size : UCHAR , pub Reserved1 : UCHAR , } # [ repr ( C ) ] pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3 { pub TimerType : UCHAR , pub __bindgen_anon_1 : _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 , pub Hand : UCHAR , pub __bindgen_anon_2 : _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2 , } # [ repr ( C ) ] pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 { pub TimerControlFlags : __BindgenUnionField < UCHAR > , pub __bindgen_anon_1 : __BindgenUnionField < _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : u8 , } # [ repr ( C , packed ) ] pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn Absolute ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_Absolute ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Wake ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_Wake ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn EncodedTolerableDelay ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_EncodedTolerableDelay ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 6u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Absolute : UCHAR , Wake : UCHAR , EncodedTolerableDelay : UCHAR ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let Absolute : u8 = unsafe { :: std :: mem :: transmute ( Absolute ) } ; Absolute as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let Wake : u8 = unsafe { :: std :: mem :: transmute ( Wake ) } ; Wake as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 6u8 , { let EncodedTolerableDelay : u8 = unsafe { :: std :: mem :: transmute ( EncodedTolerableDelay ) } ; EncodedTolerableDelay as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2 { pub TimerMiscFlags : __BindgenUnionField < UCHAR > , pub __bindgen_anon_1 : __BindgenUnionField < _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1 > , pub bindgen_union_field : u8 , } # [ repr ( C , packed ) ] pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1 { # [ inline ] pub fn Index ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_Index ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Processor ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_Processor ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 5u8 , val as u64 ) } } # [ inline ] pub fn Inserted ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_Inserted ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Expired ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_Expired ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Index : UCHAR , Processor : UCHAR , Inserted : UCHAR , Expired : UCHAR ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let Index : u8 = unsafe { :: std :: mem :: transmute ( Index ) } ; Index as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 5u8 , { let Processor : u8 = unsafe { :: std :: mem :: transmute ( Processor ) } ; Processor as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let Inserted : u8 = unsafe { :: std :: mem :: transmute ( Inserted ) } ; Inserted as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let Expired : u8 = unsafe { :: std :: mem :: transmute ( Expired ) } ; Expired as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4 { pub Timer2Type : UCHAR , pub __bindgen_anon_1 : _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 , pub Timer2ComponentId : UCHAR , pub Timer2RelativeId : UCHAR , } # [ repr ( C ) ] pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 { pub Timer2Flags : __BindgenUnionField < UCHAR > , pub __bindgen_anon_1 : __BindgenUnionField < _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : u8 , } # [ repr ( C , packed ) ] pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn Timer2Inserted ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_Timer2Inserted ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Timer2Expiring ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_Timer2Expiring ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Timer2CancelPending ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_Timer2CancelPending ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Timer2SetPending ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_Timer2SetPending ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Timer2Running ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_Timer2Running ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Timer2Disabled ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_Timer2Disabled ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Timer2ReservedFlags ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_Timer2ReservedFlags ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 2u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Timer2Inserted : UCHAR , Timer2Expiring : UCHAR , Timer2CancelPending : UCHAR , Timer2SetPending : UCHAR , Timer2Running : UCHAR , Timer2Disabled : UCHAR , Timer2ReservedFlags : UCHAR ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let Timer2Inserted : u8 = unsafe { :: std :: mem :: transmute ( Timer2Inserted ) } ; Timer2Inserted as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let Timer2Expiring : u8 = unsafe { :: std :: mem :: transmute ( Timer2Expiring ) } ; Timer2Expiring as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let Timer2CancelPending : u8 = unsafe { :: std :: mem :: transmute ( Timer2CancelPending ) } ; Timer2CancelPending as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let Timer2SetPending : u8 = unsafe { :: std :: mem :: transmute ( Timer2SetPending ) } ; Timer2SetPending as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let Timer2Running : u8 = unsafe { :: std :: mem :: transmute ( Timer2Running ) } ; Timer2Running as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let Timer2Disabled : u8 = unsafe { :: std :: mem :: transmute ( Timer2Disabled ) } ; Timer2Disabled as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 2u8 , { let Timer2ReservedFlags : u8 = unsafe { :: std :: mem :: transmute ( Timer2ReservedFlags ) } ; Timer2ReservedFlags as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5 { pub QueueType : UCHAR , pub __bindgen_anon_1 : _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 , pub QueueSize : UCHAR , pub QueueReserved : UCHAR , } # [ repr ( C ) ] pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 { pub QueueControlFlags : __BindgenUnionField < UCHAR > , pub __bindgen_anon_1 : __BindgenUnionField < _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : u8 , } # [ repr ( C , packed ) ] pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn Abandoned ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_Abandoned ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn DisableIncrement ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_DisableIncrement ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn QueueReservedControlFlags ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_QueueReservedControlFlags ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 6u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Abandoned : UCHAR , DisableIncrement : UCHAR , QueueReservedControlFlags : UCHAR ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let Abandoned : u8 = unsafe { :: std :: mem :: transmute ( Abandoned ) } ; Abandoned as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let DisableIncrement : u8 = unsafe { :: std :: mem :: transmute ( DisableIncrement ) } ; DisableIncrement as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 6u8 , { let QueueReservedControlFlags : u8 = unsafe { :: std :: mem :: transmute ( QueueReservedControlFlags ) } ; QueueReservedControlFlags as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6 { pub ThreadType : UCHAR , pub ThreadReserved : UCHAR , pub __bindgen_anon_1 : _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1 , pub __bindgen_anon_2 : _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2 , } # [ repr ( C ) ] pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1 { pub ThreadControlFlags : __BindgenUnionField < UCHAR > , pub __bindgen_anon_1 : __BindgenUnionField < _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : u8 , } # [ repr ( C , packed ) ] pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn CycleProfiling ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_CycleProfiling ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn CounterProfiling ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_CounterProfiling ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn GroupScheduling ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_GroupScheduling ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AffinitySet ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_AffinitySet ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Tagged ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_Tagged ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn EnergyProfiling ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_EnergyProfiling ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Instrumented ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_Instrumented ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ThreadReservedControlFlags ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_ThreadReservedControlFlags ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( CycleProfiling : UCHAR , CounterProfiling : UCHAR , GroupScheduling : UCHAR , AffinitySet : UCHAR , Tagged : UCHAR , EnergyProfiling : UCHAR , Instrumented : UCHAR , ThreadReservedControlFlags : UCHAR ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let CycleProfiling : u8 = unsafe { :: std :: mem :: transmute ( CycleProfiling ) } ; CycleProfiling as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let CounterProfiling : u8 = unsafe { :: std :: mem :: transmute ( CounterProfiling ) } ; CounterProfiling as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let GroupScheduling : u8 = unsafe { :: std :: mem :: transmute ( GroupScheduling ) } ; GroupScheduling as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let AffinitySet : u8 = unsafe { :: std :: mem :: transmute ( AffinitySet ) } ; AffinitySet as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let Tagged : u8 = unsafe { :: std :: mem :: transmute ( Tagged ) } ; Tagged as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let EnergyProfiling : u8 = unsafe { :: std :: mem :: transmute ( EnergyProfiling ) } ; EnergyProfiling as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let Instrumented : u8 = unsafe { :: std :: mem :: transmute ( Instrumented ) } ; Instrumented as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let ThreadReservedControlFlags : u8 = unsafe { :: std :: mem :: transmute ( ThreadReservedControlFlags ) } ; ThreadReservedControlFlags as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2 { pub DebugActive : __BindgenUnionField < UCHAR > , pub bindgen_union_field : u8 , } # [ repr ( C ) ] pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7 { pub MutantType : UCHAR , pub MutantSize : UCHAR , pub DpcActive : BOOLEAN , pub MutantReserved : UCHAR , } pub type DISPATCHER_HEADER = _DISPATCHER_HEADER ; pub type PDISPATCHER_HEADER = * mut _DISPATCHER_HEADER ; # [ repr ( C ) ] pub struct _KEVENT { pub Header : DISPATCHER_HEADER , } pub type KEVENT = _KEVENT ; pub type PKEVENT = * mut _KEVENT ; pub type PRKEVENT = * mut _KEVENT ; # [ repr ( C ) ] pub struct _KGATE { pub Header : DISPATCHER_HEADER , } pub type KGATE = _KGATE ; pub type PKGATE = * mut _KGATE ; # [ repr ( C ) ] pub struct _KTIMER { pub Header : DISPATCHER_HEADER , pub DueTime : ULARGE_INTEGER , pub TimerListEntry : LIST_ENTRY , pub Dpc : * mut _KDPC , pub Period : ULONG , } pub type KTIMER = _KTIMER ; pub type PKTIMER = * mut _KTIMER ; pub type PRKTIMER = * mut _KTIMER ; pub const _LOCK_OPERATION_IoReadAccess : _LOCK_OPERATION = 0 ; pub const _LOCK_OPERATION_IoWriteAccess : _LOCK_OPERATION = 1 ; pub const _LOCK_OPERATION_IoModifyAccess : _LOCK_OPERATION = 2 ; pub type _LOCK_OPERATION = i32 ; pub use self :: _LOCK_OPERATION as LOCK_OPERATION ; # [ repr ( C ) ] pub struct _FAST_MUTEX { pub Count : LONG , pub Owner : PVOID , pub Contention : ULONG , pub Event : KEVENT , pub OldIrql : ULONG , } pub type FAST_MUTEX = _FAST_MUTEX ; pub type PFAST_MUTEX = * mut _FAST_MUTEX ; pub type KGUARDED_MUTEX = _FAST_MUTEX ; pub type PKGUARDED_MUTEX = * mut _FAST_MUTEX ; pub type PFN_COUNT = ULONG ; pub type SPFN_NUMBER = LONG ; pub type PSPFN_NUMBER = * mut LONG ; pub type PFN_NUMBER = ULONG ; pub type PPFN_NUMBER = * mut ULONG ; extern "C" { pub fn KfLowerIrql ( NewIrql : KIRQL ) ; } extern "C" { pub fn KfRaiseIrql ( NewIrql : KIRQL ) -> KIRQL ; } extern "C" { pub fn KeRaiseIrqlToDpcLevel ( ) -> KIRQL ; } extern "C" { pub fn READ_REGISTER_UCHAR ( Register : * mut UCHAR ) -> UCHAR ; } extern "C" { pub fn READ_REGISTER_USHORT ( Register : * mut USHORT ) -> USHORT ; } extern "C" { pub fn READ_REGISTER_ULONG ( Register : * mut ULONG ) -> ULONG ; } extern "C" { pub fn READ_REGISTER_BUFFER_UCHAR ( Register : * mut UCHAR , Buffer : PUCHAR , Count : ULONG ) ; } extern "C" { pub fn READ_REGISTER_BUFFER_USHORT ( Register : * mut USHORT , Buffer : PUSHORT , Count : ULONG ) ; } extern "C" { pub fn READ_REGISTER_BUFFER_ULONG ( Register : * mut ULONG , Buffer : PULONG , Count : ULONG ) ; } extern "C" { pub fn WRITE_REGISTER_UCHAR ( Register : * mut UCHAR , Value : UCHAR ) ; } extern "C" { pub fn WRITE_REGISTER_USHORT ( Register : * mut USHORT , Value : USHORT ) ; } extern "C" { pub fn WRITE_REGISTER_ULONG ( Register : * mut ULONG , Value : ULONG ) ; } extern "C" { pub fn WRITE_REGISTER_BUFFER_UCHAR ( Register : * mut UCHAR , Buffer : PUCHAR , Count : ULONG ) ; } extern "C" { pub fn WRITE_REGISTER_BUFFER_USHORT ( Register : * mut USHORT , Buffer : PUSHORT , Count : ULONG ) ; } extern "C" { pub fn WRITE_REGISTER_BUFFER_ULONG ( Register : * mut ULONG , Buffer : PULONG , Count : ULONG ) ; } extern "C" { pub fn READ_PORT_UCHAR ( Port : PUCHAR ) -> UCHAR ; } extern "C" { pub fn READ_PORT_USHORT ( Port : PUSHORT ) -> USHORT ; } extern "C" { pub fn READ_PORT_ULONG ( Port : PULONG ) -> ULONG ; } extern "C" { pub fn READ_PORT_BUFFER_UCHAR ( Port : PUCHAR , Buffer : PUCHAR , Count : ULONG ) ; } extern "C" { pub fn READ_PORT_BUFFER_USHORT ( Port : PUSHORT , Buffer : PUSHORT , Count : ULONG ) ; } extern "C" { pub fn READ_PORT_BUFFER_ULONG ( Port : PULONG , Buffer : PULONG , Count : ULONG ) ; } extern "C" { pub fn WRITE_PORT_UCHAR ( Port : PUCHAR , Value : UCHAR ) ; } extern "C" { pub fn WRITE_PORT_USHORT ( Port : PUSHORT , Value : USHORT ) ; } extern "C" { pub fn WRITE_PORT_ULONG ( Port : PULONG , Value : ULONG ) ; } extern "C" { pub fn WRITE_PORT_BUFFER_UCHAR ( Port : PUCHAR , Buffer : PUCHAR , Count : ULONG ) ; } extern "C" { pub fn WRITE_PORT_BUFFER_USHORT ( Port : PUSHORT , Buffer : PUSHORT , Count : ULONG ) ; } extern "C" { pub fn WRITE_PORT_BUFFER_ULONG ( Port : PULONG , Buffer : PULONG , Count : ULONG ) ; } extern "C" { pub fn KeFlushIoBuffers ( Mdl : PMDL , ReadOperation : BOOLEAN , DmaOperation : BOOLEAN ) ; } # [ repr ( C ) ] pub struct _KFLOATING_SAVE { pub ControlWord : ULONG , pub StatusWord : ULONG , pub ErrorOffset : ULONG , pub ErrorSelector : ULONG , pub DataOffset : ULONG , pub DataSelector : ULONG , pub Spare0 : ULONG , pub Spare1 : ULONG , } pub type KFLOATING_SAVE = _KFLOATING_SAVE ; pub type PKFLOATING_SAVE = * mut _KFLOATING_SAVE ; # [ repr ( C ) ] pub struct _AMD_L1_CACHE_INFO { pub Ulong : __BindgenUnionField < ULONG > , pub __bindgen_anon_1 : __BindgenUnionField < _AMD_L1_CACHE_INFO__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _AMD_L1_CACHE_INFO__bindgen_ty_1 { pub LineSize : UCHAR , pub LinesPerTag : UCHAR , pub Associativity : UCHAR , pub Size : UCHAR , } pub type AMD_L1_CACHE_INFO = _AMD_L1_CACHE_INFO ; pub type PAMD_L1_CACHE_INFO = * mut _AMD_L1_CACHE_INFO ; # [ repr ( C ) ] pub struct _AMD_L2_CACHE_INFO { pub Ulong : __BindgenUnionField < ULONG > , pub __bindgen_anon_1 : __BindgenUnionField < _AMD_L2_CACHE_INFO__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _AMD_L2_CACHE_INFO__bindgen_ty_1 { pub LineSize : UCHAR , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub Size : USHORT , } impl _AMD_L2_CACHE_INFO__bindgen_ty_1 { # [ inline ] pub fn LinesPerTag ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_LinesPerTag ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn Associativity ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_Associativity ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( LinesPerTag : UCHAR , Associativity : UCHAR ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let LinesPerTag : u8 = unsafe { :: std :: mem :: transmute ( LinesPerTag ) } ; LinesPerTag as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let Associativity : u8 = unsafe { :: std :: mem :: transmute ( Associativity ) } ; Associativity as u64 } ) ; __bindgen_bitfield_unit } } pub type AMD_L2_CACHE_INFO = _AMD_L2_CACHE_INFO ; pub type PAMD_L2_CACHE_INFO = * mut _AMD_L2_CACHE_INFO ; # [ repr ( C ) ] pub struct _AMD_L3_CACHE_INFO { pub Ulong : __BindgenUnionField < ULONG > , pub __bindgen_anon_1 : __BindgenUnionField < _AMD_L3_CACHE_INFO__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _AMD_L3_CACHE_INFO__bindgen_ty_1 { pub LineSize : UCHAR , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl _AMD_L3_CACHE_INFO__bindgen_ty_1 { # [ inline ] pub fn LinesPerTag ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_LinesPerTag ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn Associativity ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_Associativity ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 2u8 ) as u16 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 2u8 , val as u64 ) } } # [ inline ] pub fn Size ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 14u8 ) as u16 ) } } # [ inline ] pub fn set_Size ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 14u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( LinesPerTag : UCHAR , Associativity : UCHAR , Reserved : USHORT , Size : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let LinesPerTag : u8 = unsafe { :: std :: mem :: transmute ( LinesPerTag ) } ; LinesPerTag as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let Associativity : u8 = unsafe { :: std :: mem :: transmute ( Associativity ) } ; Associativity as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 2u8 , { let Reserved : u16 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 14u8 , { let Size : u16 = unsafe { :: std :: mem :: transmute ( Size ) } ; Size as u64 } ) ; __bindgen_bitfield_unit } } pub type AMD_L3_CACHE_INFO = _AMD_L3_CACHE_INFO ; pub type PAMD_L3_CACHE_INFO = * mut _AMD_L3_CACHE_INFO ; pub const _INTEL_CACHE_TYPE_IntelCacheNull : _INTEL_CACHE_TYPE = 0 ; pub const _INTEL_CACHE_TYPE_IntelCacheData : _INTEL_CACHE_TYPE = 1 ; pub const _INTEL_CACHE_TYPE_IntelCacheInstruction : _INTEL_CACHE_TYPE = 2 ; pub const _INTEL_CACHE_TYPE_IntelCacheUnified : _INTEL_CACHE_TYPE = 3 ; pub const _INTEL_CACHE_TYPE_IntelCacheRam : _INTEL_CACHE_TYPE = 4 ; pub const _INTEL_CACHE_TYPE_IntelCacheTrace : _INTEL_CACHE_TYPE = 5 ; pub type _INTEL_CACHE_TYPE = i32 ; pub use self :: _INTEL_CACHE_TYPE as INTEL_CACHE_TYPE ; # [ repr ( C ) ] pub struct INTEL_CACHE_INFO_EAX { pub Ulong : __BindgenUnionField < ULONG > , pub __bindgen_anon_1 : __BindgenUnionField < INTEL_CACHE_INFO_EAX__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct INTEL_CACHE_INFO_EAX__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl INTEL_CACHE_INFO_EAX__bindgen_ty_1 { # [ inline ] pub fn Type ( & self ) -> INTEL_CACHE_TYPE { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_Type ( & mut self , val : INTEL_CACHE_TYPE ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 5u8 , val as u64 ) } } # [ inline ] pub fn Level ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_Level ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn SelfInitializing ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_SelfInitializing ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn FullyAssociative ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_FullyAssociative ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 4u8 , val as u64 ) } } # [ inline ] pub fn ThreadsSharing ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 12u8 ) as u32 ) } } # [ inline ] pub fn set_ThreadsSharing ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 12u8 , val as u64 ) } } # [ inline ] pub fn ProcessorCores ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 26usize , 6u8 ) as u32 ) } } # [ inline ] pub fn set_ProcessorCores ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 26usize , 6u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Type : INTEL_CACHE_TYPE , Level : ULONG , SelfInitializing : ULONG , FullyAssociative : ULONG , Reserved : ULONG , ThreadsSharing : ULONG , ProcessorCores : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 5u8 , { let Type : u32 = unsafe { :: std :: mem :: transmute ( Type ) } ; Type as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let Level : u32 = unsafe { :: std :: mem :: transmute ( Level ) } ; Level as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let SelfInitializing : u32 = unsafe { :: std :: mem :: transmute ( SelfInitializing ) } ; SelfInitializing as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let FullyAssociative : u32 = unsafe { :: std :: mem :: transmute ( FullyAssociative ) } ; FullyAssociative as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 4u8 , { let Reserved : u32 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 12u8 , { let ThreadsSharing : u32 = unsafe { :: std :: mem :: transmute ( ThreadsSharing ) } ; ThreadsSharing as u64 } ) ; __bindgen_bitfield_unit . set ( 26usize , 6u8 , { let ProcessorCores : u32 = unsafe { :: std :: mem :: transmute ( ProcessorCores ) } ; ProcessorCores as u64 } ) ; __bindgen_bitfield_unit } } pub type PINTEL_CACHE_INFO_EAX = * mut INTEL_CACHE_INFO_EAX ; # [ repr ( C ) ] pub struct INTEL_CACHE_INFO_EBX { pub Ulong : __BindgenUnionField < ULONG > , pub __bindgen_anon_1 : __BindgenUnionField < INTEL_CACHE_INFO_EBX__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct INTEL_CACHE_INFO_EBX__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl INTEL_CACHE_INFO_EBX__bindgen_ty_1 { # [ inline ] pub fn LineSize ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 12u8 ) as u32 ) } } # [ inline ] pub fn set_LineSize ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 12u8 , val as u64 ) } } # [ inline ] pub fn Partitions ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 10u8 ) as u32 ) } } # [ inline ] pub fn set_Partitions ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 10u8 , val as u64 ) } } # [ inline ] pub fn Associativity ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 22usize , 10u8 ) as u32 ) } } # [ inline ] pub fn set_Associativity ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 22usize , 10u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( LineSize : ULONG , Partitions : ULONG , Associativity : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 12u8 , { let LineSize : u32 = unsafe { :: std :: mem :: transmute ( LineSize ) } ; LineSize as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 10u8 , { let Partitions : u32 = unsafe { :: std :: mem :: transmute ( Partitions ) } ; Partitions as u64 } ) ; __bindgen_bitfield_unit . set ( 22usize , 10u8 , { let Associativity : u32 = unsafe { :: std :: mem :: transmute ( Associativity ) } ; Associativity as u64 } ) ; __bindgen_bitfield_unit } } pub type PINTEL_CACHE_INFO_EBX = * mut INTEL_CACHE_INFO_EBX ; extern "C" { pub fn _mm_clflush ( Address : * const :: std :: os :: raw :: c_void ) ; } extern "C" { pub fn __invlpg ( Page : PVOID ) ; } extern "C" { pub fn __wbinvd ( ) ; } extern "C" { pub fn __readcr3 ( ) -> ULONG ; } extern "C" { pub fn __writecr3 ( Data : UINT32 ) ; } extern "C" { pub fn __readeflags ( ) -> UINT32 ; } extern "C" { pub fn _ReadWriteBarrier ( ) ; } extern "C" { pub fn KeSaveFloatingPointState ( FloatSave : PKFLOATING_SAVE ) -> NTSTATUS ; } extern "C" { pub fn KeRestoreFloatingPointState ( FloatSave : PKFLOATING_SAVE ) -> NTSTATUS ; } extern "C" { pub fn __inbyte ( Port : USHORT ) -> UCHAR ; } extern "C" { pub fn __inword ( Port : USHORT ) -> USHORT ; } extern "C" { pub fn __indword ( Port : USHORT ) -> ULONG ; } extern "C" { pub fn __outbyte ( Port : USHORT , Data : UCHAR ) ; } extern "C" { pub fn __outword ( Port : USHORT , Data : USHORT ) ; } extern "C" { pub fn __outdword ( Port : USHORT , Data : ULONG ) ; } extern "C" { pub fn __inbytestring ( Port : USHORT , Buffer : PUCHAR , Count : ULONG ) ; } extern "C" { pub fn __inwordstring ( Port : USHORT , Buffer : PUSHORT , Count : ULONG ) ; } extern "C" { pub fn __indwordstring ( Port : USHORT , Buffer : PULONG , Count : ULONG ) ; } extern "C" { pub fn __outbytestring ( Port : USHORT , Buffer : PUCHAR , Count : ULONG ) ; } extern "C" { pub fn __outwordstring ( Port : USHORT , Buffer : PUSHORT , Count : ULONG ) ; } extern "C" { pub fn __outdwordstring ( Port : USHORT , Buffer : PULONG , Count : ULONG ) ; } pub const _FIRMWARE_TYPE_FirmwareTypeUnknown : _FIRMWARE_TYPE = 0 ; pub const _FIRMWARE_TYPE_FirmwareTypeBios : _FIRMWARE_TYPE = 1 ; pub const _FIRMWARE_TYPE_FirmwareTypeUefi : _FIRMWARE_TYPE = 2 ; pub const _FIRMWARE_TYPE_FirmwareTypeMax : _FIRMWARE_TYPE = 3 ; pub type _FIRMWARE_TYPE = i32 ; pub use self :: _FIRMWARE_TYPE as FIRMWARE_TYPE ; pub type PFIRMWARE_TYPE = * mut _FIRMWARE_TYPE ; pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationProcessorCore : _LOGICAL_PROCESSOR_RELATIONSHIP = 0 ; pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationNumaNode : _LOGICAL_PROCESSOR_RELATIONSHIP = 1 ; pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationCache : _LOGICAL_PROCESSOR_RELATIONSHIP = 2 ; pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationProcessorPackage : _LOGICAL_PROCESSOR_RELATIONSHIP = 3 ; pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationGroup : _LOGICAL_PROCESSOR_RELATIONSHIP = 4 ; pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationAll : _LOGICAL_PROCESSOR_RELATIONSHIP = 65535 ; pub type _LOGICAL_PROCESSOR_RELATIONSHIP = i32 ; pub use self :: _LOGICAL_PROCESSOR_RELATIONSHIP as LOGICAL_PROCESSOR_RELATIONSHIP ; pub const _PROCESSOR_CACHE_TYPE_CacheUnified : _PROCESSOR_CACHE_TYPE = 0 ; pub const _PROCESSOR_CACHE_TYPE_CacheInstruction : _PROCESSOR_CACHE_TYPE = 1 ; pub const _PROCESSOR_CACHE_TYPE_CacheData : _PROCESSOR_CACHE_TYPE = 2 ; pub const _PROCESSOR_CACHE_TYPE_CacheTrace : _PROCESSOR_CACHE_TYPE = 3 ; pub type _PROCESSOR_CACHE_TYPE = i32 ; pub use self :: _PROCESSOR_CACHE_TYPE as PROCESSOR_CACHE_TYPE ; # [ repr ( C ) ] pub struct _CACHE_DESCRIPTOR { pub Level : UCHAR , pub Associativity : UCHAR , pub LineSize : USHORT , pub Size : ULONG , pub Type : PROCESSOR_CACHE_TYPE , } pub type CACHE_DESCRIPTOR = _CACHE_DESCRIPTOR ; pub type PCACHE_DESCRIPTOR = * mut _CACHE_DESCRIPTOR ; # [ repr ( C ) ] pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION { pub ProcessorMask : ULONG_PTR , pub Relationship : LOGICAL_PROCESSOR_RELATIONSHIP , pub __bindgen_anon_1 : _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1 { pub ProcessorCore : __BindgenUnionField < _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1 > , pub NumaNode : __BindgenUnionField < _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2 > , pub Cache : __BindgenUnionField < CACHE_DESCRIPTOR > , pub Reserved : __BindgenUnionField < [ ULONGLONG ; 2usize ] > , pub bindgen_union_field : [ u64 ; 2usize ] , } # [ repr ( C ) ] pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1 { pub Flags : UCHAR , } # [ repr ( C ) ] pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2 { pub NodeNumber : ULONG , } pub type SYSTEM_LOGICAL_PROCESSOR_INFORMATION = _SYSTEM_LOGICAL_PROCESSOR_INFORMATION ; pub type PSYSTEM_LOGICAL_PROCESSOR_INFORMATION = * mut _SYSTEM_LOGICAL_PROCESSOR_INFORMATION ; # [ repr ( C ) ] pub struct _PROCESSOR_RELATIONSHIP { pub Flags : UCHAR , pub EfficiencyClass : UCHAR , pub Reserved : [ UCHAR ; 20usize ] , pub GroupCount : USHORT , pub GroupMask : [ GROUP_AFFINITY ; 1usize ] , } pub type PROCESSOR_RELATIONSHIP = _PROCESSOR_RELATIONSHIP ; pub type PPROCESSOR_RELATIONSHIP = * mut _PROCESSOR_RELATIONSHIP ; # [ repr ( C ) ] pub struct _NUMA_NODE_RELATIONSHIP { pub NodeNumber : ULONG , pub Reserved : [ UCHAR ; 20usize ] , pub GroupMask : GROUP_AFFINITY , } pub type NUMA_NODE_RELATIONSHIP = _NUMA_NODE_RELATIONSHIP ; pub type PNUMA_NODE_RELATIONSHIP = * mut _NUMA_NODE_RELATIONSHIP ; # [ repr ( C ) ] pub struct _CACHE_RELATIONSHIP { pub Level : UCHAR , pub Associativity : UCHAR , pub LineSize : USHORT , pub CacheSize : ULONG , pub Type : PROCESSOR_CACHE_TYPE , pub Reserved : [ UCHAR ; 20usize ] , pub GroupMask : GROUP_AFFINITY , } pub type CACHE_RELATIONSHIP = _CACHE_RELATIONSHIP ; pub type PCACHE_RELATIONSHIP = * mut _CACHE_RELATIONSHIP ; # [ repr ( C ) ] pub struct _PROCESSOR_GROUP_INFO { pub MaximumProcessorCount : UCHAR , pub ActiveProcessorCount : UCHAR , pub Reserved : [ UCHAR ; 38usize ] , pub ActiveProcessorMask : KAFFINITY , } pub type PROCESSOR_GROUP_INFO = _PROCESSOR_GROUP_INFO ; pub type PPROCESSOR_GROUP_INFO = * mut _PROCESSOR_GROUP_INFO ; # [ repr ( C ) ] pub struct _GROUP_RELATIONSHIP { pub MaximumGroupCount : USHORT , pub ActiveGroupCount : USHORT , pub Reserved : [ UCHAR ; 20usize ] , pub GroupInfo : [ PROCESSOR_GROUP_INFO ; 1usize ] , } pub type GROUP_RELATIONSHIP = _GROUP_RELATIONSHIP ; pub type PGROUP_RELATIONSHIP = * mut _GROUP_RELATIONSHIP ; # [ repr ( C ) ] pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX { pub Relationship : LOGICAL_PROCESSOR_RELATIONSHIP , pub Size : ULONG , pub __bindgen_anon_1 : _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1 { pub Processor : __BindgenUnionField < PROCESSOR_RELATIONSHIP > , pub NumaNode : __BindgenUnionField < NUMA_NODE_RELATIONSHIP > , pub Cache : __BindgenUnionField < CACHE_RELATIONSHIP > , pub Group : __BindgenUnionField < GROUP_RELATIONSHIP > , pub bindgen_union_field : [ u64 ; 9usize ] , } pub type SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX = _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX ; pub type PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX = * mut _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX ; pub const _CPU_SET_INFORMATION_TYPE_CpuSetInformation : _CPU_SET_INFORMATION_TYPE = 0 ; pub type _CPU_SET_INFORMATION_TYPE = i32 ; pub use self :: _CPU_SET_INFORMATION_TYPE as CPU_SET_INFORMATION_TYPE ; pub type PCPU_SET_INFORMATION_TYPE = * mut _CPU_SET_INFORMATION_TYPE ; # [ repr ( C ) ] pub struct _SYSTEM_CPU_SET_INFORMATION { pub Size : ULONG , pub Type : CPU_SET_INFORMATION_TYPE , pub __bindgen_anon_1 : _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1 { pub CpuSet : __BindgenUnionField < _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : [ u64 ; 3usize ] , } # [ repr ( C ) ] pub struct _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1 { pub Id : ULONG , pub Group : USHORT , pub LogicalProcessorIndex : UCHAR , pub CoreIndex : UCHAR , pub LastLevelCacheIndex : UCHAR , pub NumaNodeIndex : UCHAR , pub EfficiencyClass : UCHAR , pub __bindgen_anon_1 : _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , pub Reserved : ULONG , pub AllocationTag : ULONG64 , } # [ repr ( C ) ] pub struct _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 { pub AllFlags : __BindgenUnionField < UCHAR > , pub __bindgen_anon_1 : __BindgenUnionField < _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : u8 , } # [ repr ( C , packed ) ] pub struct _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn Parked ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_Parked ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Allocated ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_Allocated ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AllocatedToTargetProcess ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_AllocatedToTargetProcess ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn RealTime ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_RealTime ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ReservedFlags ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_ReservedFlags ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Parked : UCHAR , Allocated : UCHAR , AllocatedToTargetProcess : UCHAR , RealTime : UCHAR , ReservedFlags : UCHAR ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let Parked : u8 = unsafe { :: std :: mem :: transmute ( Parked ) } ; Parked as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let Allocated : u8 = unsafe { :: std :: mem :: transmute ( Allocated ) } ; Allocated as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let AllocatedToTargetProcess : u8 = unsafe { :: std :: mem :: transmute ( AllocatedToTargetProcess ) } ; AllocatedToTargetProcess as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let RealTime : u8 = unsafe { :: std :: mem :: transmute ( RealTime ) } ; RealTime as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let ReservedFlags : u8 = unsafe { :: std :: mem :: transmute ( ReservedFlags ) } ; ReservedFlags as u64 } ) ; __bindgen_bitfield_unit } } pub type SYSTEM_CPU_SET_INFORMATION = _SYSTEM_CPU_SET_INFORMATION ; pub type PSYSTEM_CPU_SET_INFORMATION = * mut _SYSTEM_CPU_SET_INFORMATION ; pub const _ALTERNATIVE_ARCHITECTURE_TYPE_StandardDesign : _ALTERNATIVE_ARCHITECTURE_TYPE = 0 ; pub const _ALTERNATIVE_ARCHITECTURE_TYPE_NEC98x86 : _ALTERNATIVE_ARCHITECTURE_TYPE = 1 ; pub const _ALTERNATIVE_ARCHITECTURE_TYPE_EndAlternatives : _ALTERNATIVE_ARCHITECTURE_TYPE = 2 ; pub type _ALTERNATIVE_ARCHITECTURE_TYPE = i32 ; pub use self :: _ALTERNATIVE_ARCHITECTURE_TYPE as ALTERNATIVE_ARCHITECTURE_TYPE ; # [ repr ( C ) ] pub struct _EXCEPTION_RECORD { pub ExceptionCode : NTSTATUS , pub ExceptionFlags : ULONG , pub ExceptionRecord : * mut _EXCEPTION_RECORD , pub ExceptionAddress : PVOID , pub NumberParameters : ULONG , pub ExceptionInformation : [ ULONG_PTR ; 15usize ] , } pub type EXCEPTION_RECORD = _EXCEPTION_RECORD ; pub type PEXCEPTION_RECORD = * mut EXCEPTION_RECORD ; # [ repr ( C ) ] pub struct _EXCEPTION_RECORD32 { pub ExceptionCode : NTSTATUS , pub ExceptionFlags : ULONG , pub ExceptionRecord : ULONG , pub ExceptionAddress : ULONG , pub NumberParameters : ULONG , pub ExceptionInformation : [ ULONG ; 15usize ] , } pub type EXCEPTION_RECORD32 = _EXCEPTION_RECORD32 ; pub type PEXCEPTION_RECORD32 = * mut _EXCEPTION_RECORD32 ; # [ repr ( C ) ] pub struct _EXCEPTION_RECORD64 { pub ExceptionCode : NTSTATUS , pub ExceptionFlags : ULONG , pub ExceptionRecord : ULONG64 , pub ExceptionAddress : ULONG64 , pub NumberParameters : ULONG , pub __unusedAlignment : ULONG , pub ExceptionInformation : [ ULONG64 ; 15usize ] , } pub type EXCEPTION_RECORD64 = _EXCEPTION_RECORD64 ; pub type PEXCEPTION_RECORD64 = * mut _EXCEPTION_RECORD64 ; # [ repr ( C ) ] pub struct _EXCEPTION_POINTERS { pub ExceptionRecord : PEXCEPTION_RECORD , pub ContextRecord : PCONTEXT , } pub type EXCEPTION_POINTERS = _EXCEPTION_POINTERS ; pub type PEXCEPTION_POINTERS = * mut _EXCEPTION_POINTERS ; pub const _KINTERRUPT_MODE_LevelSensitive : _KINTERRUPT_MODE = 0 ; pub const _KINTERRUPT_MODE_Latched : _KINTERRUPT_MODE = 1 ; pub type _KINTERRUPT_MODE = i32 ; pub use self :: _KINTERRUPT_MODE as KINTERRUPT_MODE ; pub const _KINTERRUPT_POLARITY_InterruptPolarityUnknown : _KINTERRUPT_POLARITY = 0 ; pub const _KINTERRUPT_POLARITY_InterruptActiveHigh : _KINTERRUPT_POLARITY = 1 ; pub const _KINTERRUPT_POLARITY_InterruptRisingEdge : _KINTERRUPT_POLARITY = 1 ; pub const _KINTERRUPT_POLARITY_InterruptActiveLow : _KINTERRUPT_POLARITY = 2 ; pub const _KINTERRUPT_POLARITY_InterruptFallingEdge : _KINTERRUPT_POLARITY = 2 ; pub const _KINTERRUPT_POLARITY_InterruptActiveBoth : _KINTERRUPT_POLARITY = 3 ; pub const _KINTERRUPT_POLARITY_InterruptActiveBothTriggerLow : _KINTERRUPT_POLARITY = 3 ; pub const _KINTERRUPT_POLARITY_InterruptActiveBothTriggerHigh : _KINTERRUPT_POLARITY = 4 ; pub type _KINTERRUPT_POLARITY = i32 ; pub use self :: _KINTERRUPT_POLARITY as KINTERRUPT_POLARITY ; pub type PKINTERRUPT_POLARITY = * mut _KINTERRUPT_POLARITY ; pub const _KWAIT_REASON_Executive : _KWAIT_REASON = 0 ; pub const _KWAIT_REASON_FreePage : _KWAIT_REASON = 1 ; pub const _KWAIT_REASON_PageIn : _KWAIT_REASON = 2 ; pub const _KWAIT_REASON_PoolAllocation : _KWAIT_REASON = 3 ; pub const _KWAIT_REASON_DelayExecution : _KWAIT_REASON = 4 ; pub const _KWAIT_REASON_Suspended : _KWAIT_REASON = 5 ; pub const _KWAIT_REASON_UserRequest : _KWAIT_REASON = 6 ; pub const _KWAIT_REASON_WrExecutive : _KWAIT_REASON = 7 ; pub const _KWAIT_REASON_WrFreePage : _KWAIT_REASON = 8 ; pub const _KWAIT_REASON_WrPageIn : _KWAIT_REASON = 9 ; pub const _KWAIT_REASON_WrPoolAllocation : _KWAIT_REASON = 10 ; pub const _KWAIT_REASON_WrDelayExecution : _KWAIT_REASON = 11 ; pub const _KWAIT_REASON_WrSuspended : _KWAIT_REASON = 12 ; pub const _KWAIT_REASON_WrUserRequest : _KWAIT_REASON = 13 ; pub const _KWAIT_REASON_WrSpare0 : _KWAIT_REASON = 14 ; pub const _KWAIT_REASON_WrQueue : _KWAIT_REASON = 15 ; pub const _KWAIT_REASON_WrLpcReceive : _KWAIT_REASON = 16 ; pub const _KWAIT_REASON_WrLpcReply : _KWAIT_REASON = 17 ; pub const _KWAIT_REASON_WrVirtualMemory : _KWAIT_REASON = 18 ; pub const _KWAIT_REASON_WrPageOut : _KWAIT_REASON = 19 ; pub const _KWAIT_REASON_WrRendezvous : _KWAIT_REASON = 20 ; pub const _KWAIT_REASON_WrKeyedEvent : _KWAIT_REASON = 21 ; pub const _KWAIT_REASON_WrTerminated : _KWAIT_REASON = 22 ; pub const _KWAIT_REASON_WrProcessInSwap : _KWAIT_REASON = 23 ; pub const _KWAIT_REASON_WrCpuRateControl : _KWAIT_REASON = 24 ; pub const _KWAIT_REASON_WrCalloutStack : _KWAIT_REASON = 25 ; pub const _KWAIT_REASON_WrKernel : _KWAIT_REASON = 26 ; pub const _KWAIT_REASON_WrResource : _KWAIT_REASON = 27 ; pub const _KWAIT_REASON_WrPushLock : _KWAIT_REASON = 28 ; pub const _KWAIT_REASON_WrMutex : _KWAIT_REASON = 29 ; pub const _KWAIT_REASON_WrQuantumEnd : _KWAIT_REASON = 30 ; pub const _KWAIT_REASON_WrDispatchInt : _KWAIT_REASON = 31 ; pub const _KWAIT_REASON_WrPreempted : _KWAIT_REASON = 32 ; pub const _KWAIT_REASON_WrYieldExecution : _KWAIT_REASON = 33 ; pub const _KWAIT_REASON_WrFastMutex : _KWAIT_REASON = 34 ; pub const _KWAIT_REASON_WrGuardedMutex : _KWAIT_REASON = 35 ; pub const _KWAIT_REASON_WrRundown : _KWAIT_REASON = 36 ; pub const _KWAIT_REASON_WrAlertByThreadId : _KWAIT_REASON = 37 ; pub const _KWAIT_REASON_WrDeferredPreempt : _KWAIT_REASON = 38 ; pub const _KWAIT_REASON_WrPhysicalFault : _KWAIT_REASON = 39 ; pub const _KWAIT_REASON_MaximumWaitReason : _KWAIT_REASON = 40 ; pub type _KWAIT_REASON = i32 ; pub use self :: _KWAIT_REASON as KWAIT_REASON ; # [ repr ( C ) ] pub struct _KWAIT_BLOCK { pub WaitListEntry : LIST_ENTRY , pub WaitType : UCHAR , pub BlockState : UCHAR , pub WaitKey : USHORT , pub SpareLong : LONG , pub __bindgen_anon_1 : _KWAIT_BLOCK__bindgen_ty_1 , pub Object : PVOID , pub SparePtr : PVOID , } # [ repr ( C ) ] pub struct _KWAIT_BLOCK__bindgen_ty_1 { pub Thread : __BindgenUnionField < * mut _KTHREAD > , pub NotificationQueue : __BindgenUnionField < * mut _KQUEUE > , pub bindgen_union_field : u64 , } pub type KWAIT_BLOCK = _KWAIT_BLOCK ; pub type PKWAIT_BLOCK = * mut _KWAIT_BLOCK ; pub type PRKWAIT_BLOCK = * mut _KWAIT_BLOCK ; pub type KSTART_ROUTINE = :: std :: option :: Option < unsafe extern "C" fn ( StartContext : PVOID ) > ; pub type PKSTART_ROUTINE = KSTART_ROUTINE ; # [ repr ( C ) ] pub struct _KDEVICE_QUEUE { pub Type : CSHORT , pub Size : CSHORT , pub DeviceListHead : LIST_ENTRY , pub Lock : KSPIN_LOCK , pub Busy : BOOLEAN , } pub type KDEVICE_QUEUE = _KDEVICE_QUEUE ; pub type PKDEVICE_QUEUE = * mut _KDEVICE_QUEUE ; pub type PRKDEVICE_QUEUE = * mut _KDEVICE_QUEUE ; # [ repr ( C ) ] pub struct _KDEVICE_QUEUE_ENTRY { pub DeviceListEntry : LIST_ENTRY , pub SortKey : ULONG , pub Inserted : BOOLEAN , } pub type KDEVICE_QUEUE_ENTRY = _KDEVICE_QUEUE_ENTRY ; pub type PKDEVICE_QUEUE_ENTRY = * mut _KDEVICE_QUEUE_ENTRY ; pub type PRKDEVICE_QUEUE_ENTRY = * mut _KDEVICE_QUEUE_ENTRY ; pub type KSERVICE_ROUTINE = :: std :: option :: Option < unsafe extern "C" fn ( Interrupt : * mut _KINTERRUPT , ServiceContext : PVOID ) -> BOOLEAN > ; pub type PKSERVICE_ROUTINE = KSERVICE_ROUTINE ; pub type KMESSAGE_SERVICE_ROUTINE = :: std :: option :: Option < unsafe extern "C" fn ( Interrupt : * mut _KINTERRUPT , ServiceContext : PVOID , MessageID : ULONG ) -> BOOLEAN > ; pub type PKMESSAGE_SERVICE_ROUTINE = KMESSAGE_SERVICE_ROUTINE ; # [ repr ( C ) ] pub struct _KMUTANT { pub Header : DISPATCHER_HEADER , pub MutantListEntry : LIST_ENTRY , pub OwnerThread : * mut _KTHREAD , pub Abandoned : BOOLEAN , pub ApcDisable : UCHAR , } pub type KMUTANT = _KMUTANT ; pub type PKMUTANT = * mut _KMUTANT ; pub type PRKMUTANT = * mut _KMUTANT ; pub type KMUTEX = _KMUTANT ; pub type PKMUTEX = * mut _KMUTANT ; pub type PRKMUTEX = * mut _KMUTANT ; # [ repr ( C ) ] pub struct _KSEMAPHORE { pub Header : DISPATCHER_HEADER , pub Limit : LONG , } pub type KSEMAPHORE = _KSEMAPHORE ; pub type PKSEMAPHORE = * mut _KSEMAPHORE ; pub type PRKSEMAPHORE = * mut _KSEMAPHORE ; extern "C" { pub fn KeInitializeDpc ( Dpc : PRKDPC , DeferredRoutine : PKDEFERRED_ROUTINE , DeferredContext : PVOID ) ; } extern "C" { pub fn KeInitializeThreadedDpc ( Dpc : PRKDPC , DeferredRoutine : PKDEFERRED_ROUTINE , DeferredContext : PVOID ) ; } extern "C" { pub fn KeInsertQueueDpc ( Dpc : PRKDPC , SystemArgument1 : PVOID , SystemArgument2 : PVOID ) -> BOOLEAN ; } extern "C" { pub fn KeRemoveQueueDpc ( Dpc : PRKDPC ) -> BOOLEAN ; } extern "C" { pub fn KeRemoveQueueDpcEx ( Dpc : PRKDPC , WaitIfActive : BOOLEAN ) -> BOOLEAN ; } extern "C" { pub fn KeInitializeCrashDumpHeader ( DumpType : ULONG , Flags : ULONG , Buffer : PVOID , BufferSize : ULONG , BufferNeeded : PULONG ) -> NTSTATUS ; } extern "C" { pub fn KeSetImportanceDpc ( Dpc : PRKDPC , Importance : KDPC_IMPORTANCE ) ; } extern "C" { pub fn KeSetTargetProcessorDpc ( Dpc : PRKDPC , Number : CCHAR ) ; } extern "C" { pub fn KeFlushQueuedDpcs ( ) ; } extern "C" { pub fn KeInitializeDeviceQueue ( DeviceQueue : PKDEVICE_QUEUE ) ; } extern "C" { pub fn KeInsertDeviceQueue ( DeviceQueue : PKDEVICE_QUEUE , DeviceQueueEntry : PKDEVICE_QUEUE_ENTRY ) -> BOOLEAN ; } extern "C" { pub fn KeInsertByKeyDeviceQueue ( DeviceQueue : PKDEVICE_QUEUE , DeviceQueueEntry : PKDEVICE_QUEUE_ENTRY , SortKey : ULONG ) -> BOOLEAN ; } extern "C" { pub fn KeRemoveDeviceQueue ( DeviceQueue : PKDEVICE_QUEUE ) -> PKDEVICE_QUEUE_ENTRY ; } extern "C" { pub fn KeRemoveByKeyDeviceQueue ( DeviceQueue : PKDEVICE_QUEUE , SortKey : ULONG ) -> PKDEVICE_QUEUE_ENTRY ; } extern "C" { pub fn KeRemoveByKeyDeviceQueueIfBusy ( DeviceQueue : PKDEVICE_QUEUE , SortKey : ULONG ) -> PKDEVICE_QUEUE_ENTRY ; } extern "C" { pub fn KeRemoveEntryDeviceQueue ( DeviceQueue : PKDEVICE_QUEUE , DeviceQueueEntry : PKDEVICE_QUEUE_ENTRY ) -> BOOLEAN ; } extern "C" { pub fn KeSynchronizeExecution ( Interrupt : PKINTERRUPT , SynchronizeRoutine : PKSYNCHRONIZE_ROUTINE , SynchronizeContext : PVOID ) -> BOOLEAN ; } extern "C" { pub fn KeAcquireInterruptSpinLock ( Interrupt : PKINTERRUPT ) -> KIRQL ; } extern "C" { pub fn KeReleaseInterruptSpinLock ( Interrupt : PKINTERRUPT , OldIrql : KIRQL ) ; } extern "C" { pub fn KeInitializeEvent ( Event : PRKEVENT , Type : EVENT_TYPE , State : BOOLEAN ) ; } extern "C" { pub fn KeClearEvent ( Event : PRKEVENT ) ; } extern "C" { pub fn KeReadStateEvent ( Event : PRKEVENT ) -> LONG ; } extern "C" { pub fn KeResetEvent ( Event : PRKEVENT ) -> LONG ; } extern "C" { pub fn KeSetEvent ( Event : PRKEVENT , Increment : KPRIORITY , Wait : BOOLEAN ) -> LONG ; } extern "C" { pub fn KeInitializeMutex ( Mutex : PRKMUTEX , Level : ULONG ) ; } extern "C" { pub fn KeReadStateMutex ( Mutex : PRKMUTEX ) -> LONG ; } extern "C" { pub fn KeReleaseMutex ( Mutex : PRKMUTEX , Wait : BOOLEAN ) -> LONG ; } extern "C" { pub fn KeInitializeSemaphore ( Semaphore : PRKSEMAPHORE , Count : LONG , Limit : LONG ) ; } extern "C" { pub fn KeReadStateSemaphore ( Semaphore : PRKSEMAPHORE ) -> LONG ; } extern "C" { pub fn KeReleaseSemaphore ( Semaphore : PRKSEMAPHORE , Increment : KPRIORITY , Adjustment : LONG , Wait : BOOLEAN ) -> LONG ; } extern "C" { pub fn KeDelayExecutionThread ( WaitMode : KPROCESSOR_MODE , Alertable : BOOLEAN , Interval : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn KeQueryPriorityThread ( Thread : PKTHREAD ) -> KPRIORITY ; } extern "C" { pub fn KeQueryRuntimeThread ( Thread : PKTHREAD , UserTime : PULONG ) -> ULONG ; } extern "C" { pub fn KeQueryTotalCycleTimeThread ( Thread : PKTHREAD , CycleTimeStamp : PULONG64 ) -> ULONG64 ; } extern "C" { pub fn KeSetTargetProcessorDpcEx ( Dpc : PKDPC , ProcNumber : PPROCESSOR_NUMBER ) -> NTSTATUS ; } extern "C" { pub fn KeRevertToUserAffinityThread ( ) ; } extern "C" { pub fn KeSetSystemAffinityThread ( Affinity : KAFFINITY ) ; } extern "C" { pub fn KeRevertToUserAffinityThreadEx ( Affinity : KAFFINITY ) ; } extern "C" { pub fn KeSetSystemGroupAffinityThread ( Affinity : PGROUP_AFFINITY , PreviousAffinity : PGROUP_AFFINITY ) ; } extern "C" { pub fn KeRevertToUserGroupAffinityThread ( PreviousAffinity : PGROUP_AFFINITY ) ; } extern "C" { pub fn KeSetSystemAffinityThreadEx ( Affinity : KAFFINITY ) -> KAFFINITY ; } extern "C" { pub fn KeSetPriorityThread ( Thread : PKTHREAD , Priority : KPRIORITY ) -> KPRIORITY ; } extern "C" { pub fn KeEnterCriticalRegion ( ) ; } extern "C" { pub fn KeLeaveCriticalRegion ( ) ; } extern "C" { pub fn KeEnterGuardedRegion ( ) ; } extern "C" { pub fn KeLeaveGuardedRegion ( ) ; } extern "C" { pub fn KeAreApcsDisabled ( ) -> BOOLEAN ; } extern "C" { pub fn KeInitializeTimer ( Timer : PKTIMER ) ; } extern "C" { pub fn KeInitializeTimerEx ( Timer : PKTIMER , Type : TIMER_TYPE ) ; } extern "C" { pub fn KeCancelTimer ( arg1 : PKTIMER ) -> BOOLEAN ; } extern "C" { pub fn KeReadStateTimer ( Timer : PKTIMER ) -> BOOLEAN ; } extern "C" { pub fn KeSetTimer ( Timer : PKTIMER , DueTime : LARGE_INTEGER , Dpc : PKDPC ) -> BOOLEAN ; } extern "C" { pub fn KeSetTimerEx ( Timer : PKTIMER , DueTime : LARGE_INTEGER , Period : LONG , Dpc : PKDPC ) -> BOOLEAN ; } extern "C" { pub fn KeSetCoalescableTimer ( Timer : PKTIMER , DueTime : LARGE_INTEGER , Period : ULONG , TolerableDelay : ULONG , Dpc : PKDPC ) -> BOOLEAN ; } extern "C" { pub fn KeWaitForMultipleObjects ( Count : ULONG , Object : * mut PVOID , WaitType : WAIT_TYPE , WaitReason : KWAIT_REASON , WaitMode : KPROCESSOR_MODE , Alertable : BOOLEAN , Timeout : PLARGE_INTEGER , WaitBlockArray : PKWAIT_BLOCK ) -> NTSTATUS ; } extern "C" { pub fn KeWaitForSingleObject ( Object : PVOID , WaitReason : KWAIT_REASON , WaitMode : KPROCESSOR_MODE , Alertable : BOOLEAN , Timeout : PLARGE_INTEGER ) -> NTSTATUS ; } pub type KIPI_BROADCAST_WORKER = :: std :: option :: Option < unsafe extern "C" fn ( Argument : ULONG_PTR ) -> ULONG_PTR > ; pub type PKIPI_BROADCAST_WORKER = KIPI_BROADCAST_WORKER ; extern "C" { pub fn KeIpiGenericCall ( BroadcastFunction : PKIPI_BROADCAST_WORKER , Context : ULONG_PTR ) -> ULONG_PTR ; } extern "C" { pub fn KeInitializeSpinLock ( SpinLock : PKSPIN_LOCK ) ; } extern "C" { pub fn KeTestSpinLock ( SpinLock : PKSPIN_LOCK ) -> BOOLEAN ; } extern "C" { pub fn KeTryToAcquireSpinLockAtDpcLevel ( SpinLock : PKSPIN_LOCK ) -> BOOLEAN ; } extern "C" { pub fn KefAcquireSpinLockAtDpcLevel ( SpinLock : PKSPIN_LOCK ) ; } extern "C" { pub fn KefReleaseSpinLockFromDpcLevel ( SpinLock : PKSPIN_LOCK ) ; } extern "C" { pub fn KfAcquireSpinLock ( SpinLock : PKSPIN_LOCK ) -> KIRQL ; } extern "C" { pub fn KfReleaseSpinLock ( SpinLock : PKSPIN_LOCK , NewIrql : KIRQL ) ; } extern "C" { pub fn KeAcquireSpinLockForDpc ( SpinLock : PKSPIN_LOCK ) -> KIRQL ; } extern "C" { pub fn KeReleaseSpinLockForDpc ( SpinLock : PKSPIN_LOCK , OldIrql : KIRQL ) ; } extern "C" { pub fn KeAcquireInStackQueuedSpinLock ( SpinLock : PKSPIN_LOCK , LockHandle : PKLOCK_QUEUE_HANDLE ) ; } extern "C" { pub fn KeReleaseInStackQueuedSpinLock ( LockHandle : PKLOCK_QUEUE_HANDLE ) ; } extern "C" { pub fn KeAcquireInStackQueuedSpinLockAtDpcLevel ( SpinLock : PKSPIN_LOCK , LockHandle : PKLOCK_QUEUE_HANDLE ) ; } extern "C" { pub fn KeReleaseInStackQueuedSpinLockFromDpcLevel ( LockHandle : PKLOCK_QUEUE_HANDLE ) ; } extern "C" { pub fn KeAcquireInStackQueuedSpinLockForDpc ( SpinLock : PKSPIN_LOCK , LockHandle : PKLOCK_QUEUE_HANDLE ) ; } extern "C" { pub fn KeReleaseInStackQueuedSpinLockForDpc ( LockHandle : PKLOCK_QUEUE_HANDLE ) ; } # [ repr ( C ) ] pub struct _KDPC_WATCHDOG_INFORMATION { pub DpcTimeLimit : ULONG , pub DpcTimeCount : ULONG , pub DpcWatchdogLimit : ULONG , pub DpcWatchdogCount : ULONG , pub Reserved : ULONG , } pub type KDPC_WATCHDOG_INFORMATION = _KDPC_WATCHDOG_INFORMATION ; pub type PKDPC_WATCHDOG_INFORMATION = * mut _KDPC_WATCHDOG_INFORMATION ; extern "C" { pub fn KeQueryDpcWatchdogInformation ( WatchdogInformation : PKDPC_WATCHDOG_INFORMATION ) -> NTSTATUS ; } pub const _KBUGCHECK_BUFFER_DUMP_STATE_BufferEmpty : _KBUGCHECK_BUFFER_DUMP_STATE = 0 ; pub const _KBUGCHECK_BUFFER_DUMP_STATE_BufferInserted : _KBUGCHECK_BUFFER_DUMP_STATE = 1 ; pub const _KBUGCHECK_BUFFER_DUMP_STATE_BufferStarted : _KBUGCHECK_BUFFER_DUMP_STATE = 2 ; pub const _KBUGCHECK_BUFFER_DUMP_STATE_BufferFinished : _KBUGCHECK_BUFFER_DUMP_STATE = 3 ; pub const _KBUGCHECK_BUFFER_DUMP_STATE_BufferIncomplete : _KBUGCHECK_BUFFER_DUMP_STATE = 4 ; pub type _KBUGCHECK_BUFFER_DUMP_STATE = i32 ; pub use self :: _KBUGCHECK_BUFFER_DUMP_STATE as KBUGCHECK_BUFFER_DUMP_STATE ; pub type KBUGCHECK_CALLBACK_ROUTINE = :: std :: option :: Option < unsafe extern "C" fn ( Buffer : PVOID , Length : ULONG ) > ; pub type PKBUGCHECK_CALLBACK_ROUTINE = KBUGCHECK_CALLBACK_ROUTINE ; # [ repr ( C ) ] pub struct _KBUGCHECK_CALLBACK_RECORD { pub Entry : LIST_ENTRY , pub CallbackRoutine : PKBUGCHECK_CALLBACK_ROUTINE , pub Buffer : PVOID , pub Length : ULONG , pub Component : PUCHAR , pub Checksum : ULONG_PTR , pub State : UCHAR , } pub type KBUGCHECK_CALLBACK_RECORD = _KBUGCHECK_CALLBACK_RECORD ; pub type PKBUGCHECK_CALLBACK_RECORD = * mut _KBUGCHECK_CALLBACK_RECORD ; extern "C" { pub fn KeDeregisterBugCheckCallback ( CallbackRecord : PKBUGCHECK_CALLBACK_RECORD ) -> BOOLEAN ; } extern "C" { pub fn KeRegisterBugCheckCallback ( CallbackRecord : PKBUGCHECK_CALLBACK_RECORD , CallbackRoutine : PKBUGCHECK_CALLBACK_ROUTINE , Buffer : PVOID , Length : ULONG , Component : PUCHAR ) -> BOOLEAN ; } pub const _KBUGCHECK_CALLBACK_REASON_KbCallbackInvalid : _KBUGCHECK_CALLBACK_REASON = 0 ; pub const _KBUGCHECK_CALLBACK_REASON_KbCallbackReserved1 : _KBUGCHECK_CALLBACK_REASON = 1 ; pub const _KBUGCHECK_CALLBACK_REASON_KbCallbackSecondaryDumpData : _KBUGCHECK_CALLBACK_REASON = 2 ; pub const _KBUGCHECK_CALLBACK_REASON_KbCallbackDumpIo : _KBUGCHECK_CALLBACK_REASON = 3 ; pub const _KBUGCHECK_CALLBACK_REASON_KbCallbackAddPages : _KBUGCHECK_CALLBACK_REASON = 4 ; pub const _KBUGCHECK_CALLBACK_REASON_KbCallbackSecondaryMultiPartDumpData : _KBUGCHECK_CALLBACK_REASON = 5 ; pub const _KBUGCHECK_CALLBACK_REASON_KbCallbackRemovePages : _KBUGCHECK_CALLBACK_REASON = 6 ; pub type _KBUGCHECK_CALLBACK_REASON = i32 ; pub use self :: _KBUGCHECK_CALLBACK_REASON as KBUGCHECK_CALLBACK_REASON ; # [ repr ( C ) ] pub struct _KBUGCHECK_REASON_CALLBACK_RECORD { _unused : [ u8 ; 0 ] , } pub type KBUGCHECK_REASON_CALLBACK_ROUTINE = :: std :: option :: Option < unsafe extern "C" fn ( Reason : KBUGCHECK_CALLBACK_REASON , Record : * mut _KBUGCHECK_REASON_CALLBACK_RECORD , ReasonSpecificData : PVOID , ReasonSpecificDataLength : ULONG ) > ; pub type PKBUGCHECK_REASON_CALLBACK_ROUTINE = KBUGCHECK_REASON_CALLBACK_ROUTINE ; extern "C" { pub fn BugCheckSecondaryMultiPartDumpDataCallback ( Reason : KBUGCHECK_CALLBACK_REASON , Record : * mut _KBUGCHECK_REASON_CALLBACK_RECORD , ReasonSpecificData : PVOID , ReasonSpecificDataLength : ULONG ) ; } pub type KBUGCHECK_REASON_CALLBACK_RECORD = _KBUGCHECK_REASON_CALLBACK_RECORD ; pub type PKBUGCHECK_REASON_CALLBACK_RECORD = * mut _KBUGCHECK_REASON_CALLBACK_RECORD ; # [ repr ( C ) ] pub struct _KBUGCHECK_SECONDARY_DUMP_DATA { pub InBuffer : PVOID , pub InBufferLength : ULONG , pub MaximumAllowed : ULONG , pub Guid : GUID , pub OutBuffer : PVOID , pub OutBufferLength : ULONG , } pub type KBUGCHECK_SECONDARY_DUMP_DATA = _KBUGCHECK_SECONDARY_DUMP_DATA ; pub type PKBUGCHECK_SECONDARY_DUMP_DATA = * mut _KBUGCHECK_SECONDARY_DUMP_DATA ; # [ repr ( C ) ] pub struct _KBUGCHECK_SECONDARY_DUMP_DATA_EX { pub InBuffer : PVOID , pub InBufferLength : ULONG , pub MaximumAllowed : ULONG , pub Guid : GUID , pub OutBuffer : PVOID , pub OutBufferLength : ULONG , pub Context : PVOID , pub Flags : ULONG , pub DumpType : ULONG , pub BugCheckCode : ULONG , pub BugCheckParameter1 : ULONG_PTR , pub BugCheckParameter2 : ULONG_PTR , pub BugCheckParameter3 : ULONG_PTR , pub BugCheckParameter4 : ULONG_PTR , } pub type KBUGCHECK_SECONDARY_DUMP_DATA_EX = _KBUGCHECK_SECONDARY_DUMP_DATA_EX ; pub type PKBUGCHECK_SECONDARY_DUMP_DATA_EX = * mut _KBUGCHECK_SECONDARY_DUMP_DATA_EX ; pub const _KBUGCHECK_DUMP_IO_TYPE_KbDumpIoInvalid : _KBUGCHECK_DUMP_IO_TYPE = 0 ; pub const _KBUGCHECK_DUMP_IO_TYPE_KbDumpIoHeader : _KBUGCHECK_DUMP_IO_TYPE = 1 ; pub const _KBUGCHECK_DUMP_IO_TYPE_KbDumpIoBody : _KBUGCHECK_DUMP_IO_TYPE = 2 ; pub const _KBUGCHECK_DUMP_IO_TYPE_KbDumpIoSecondaryData : _KBUGCHECK_DUMP_IO_TYPE = 3 ; pub const _KBUGCHECK_DUMP_IO_TYPE_KbDumpIoComplete : _KBUGCHECK_DUMP_IO_TYPE = 4 ; pub type _KBUGCHECK_DUMP_IO_TYPE = i32 ; pub use self :: _KBUGCHECK_DUMP_IO_TYPE as KBUGCHECK_DUMP_IO_TYPE ; # [ repr ( C ) ] pub struct _KBUGCHECK_DUMP_IO { pub Offset : ULONG64 , pub Buffer : PVOID , pub BufferLength : ULONG , pub Type : KBUGCHECK_DUMP_IO_TYPE , } pub type KBUGCHECK_DUMP_IO = _KBUGCHECK_DUMP_IO ; pub type PKBUGCHECK_DUMP_IO = * mut _KBUGCHECK_DUMP_IO ; # [ repr ( C ) ] pub struct _KBUGCHECK_ADD_PAGES { pub Context : PVOID , pub Flags : ULONG , pub BugCheckCode : ULONG , pub Address : ULONG_PTR , pub Count : ULONG_PTR , } pub type KBUGCHECK_ADD_PAGES = _KBUGCHECK_ADD_PAGES ; pub type PKBUGCHECK_ADD_PAGES = * mut _KBUGCHECK_ADD_PAGES ; # [ repr ( C ) ] pub struct _KBUGCHECK_REMOVE_PAGES { pub Context : PVOID , pub Flags : ULONG , pub BugCheckCode : ULONG , pub Address : ULONG_PTR , pub Count : ULONG_PTR , } pub type KBUGCHECK_REMOVE_PAGES = _KBUGCHECK_REMOVE_PAGES ; pub type PKBUGCHECK_REMOVE_PAGES = * mut _KBUGCHECK_REMOVE_PAGES ; extern "C" { pub fn KeDeregisterBugCheckReasonCallback ( CallbackRecord : PKBUGCHECK_REASON_CALLBACK_RECORD ) -> BOOLEAN ; } extern "C" { pub fn KeRegisterBugCheckReasonCallback ( CallbackRecord : PKBUGCHECK_REASON_CALLBACK_RECORD , CallbackRoutine : PKBUGCHECK_REASON_CALLBACK_ROUTINE , Reason : KBUGCHECK_CALLBACK_REASON , Component : PUCHAR ) -> BOOLEAN ; } pub type NMI_CALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , Handled : BOOLEAN ) -> BOOLEAN > ; pub type PNMI_CALLBACK = NMI_CALLBACK ; extern "C" { pub fn KeRegisterNmiCallback ( CallbackRoutine : PNMI_CALLBACK , Context : PVOID ) -> PVOID ; } extern "C" { pub fn KeDeregisterNmiCallback ( Handle : PVOID ) -> NTSTATUS ; } pub const _BOUND_CALLBACK_STATUS_BoundExceptionContinueSearch : _BOUND_CALLBACK_STATUS = 0 ; pub const _BOUND_CALLBACK_STATUS_BoundExceptionHandled : _BOUND_CALLBACK_STATUS = 1 ; pub const _BOUND_CALLBACK_STATUS_BoundExceptionError : _BOUND_CALLBACK_STATUS = 2 ; pub const _BOUND_CALLBACK_STATUS_BoundExceptionMaximum : _BOUND_CALLBACK_STATUS = 3 ; pub type _BOUND_CALLBACK_STATUS = i32 ; pub use self :: _BOUND_CALLBACK_STATUS as BOUND_CALLBACK_STATUS ; pub type PBOUND_CALLBACK_STATUS = * mut _BOUND_CALLBACK_STATUS ; pub type BOUND_CALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( ) -> BOUND_CALLBACK_STATUS > ; pub type PBOUND_CALLBACK = BOUND_CALLBACK ; extern "C" { pub fn KeRegisterBoundCallback ( CallbackRoutine : PBOUND_CALLBACK ) -> PVOID ; } extern "C" { pub fn KeDeregisterBoundCallback ( Handle : PVOID ) -> NTSTATUS ; } extern "C" { pub fn KeBugCheckEx ( BugCheckCode : ULONG , BugCheckParameter1 : ULONG_PTR , BugCheckParameter2 : ULONG_PTR , BugCheckParameter3 : ULONG_PTR , BugCheckParameter4 : ULONG_PTR ) ; } extern "C" { pub fn KeQueryInterruptTime ( ) -> ULONGLONG ; } extern "C" { pub fn KeQuerySystemTime ( CurrentTime : PLARGE_INTEGER ) ; } extern "C" { pub fn KeQuerySystemTimePrecise ( CurrentTime : PLARGE_INTEGER ) ; } extern "C" { pub fn KeQueryInterruptTimePrecise ( QpcTimeStamp : PULONG64 ) -> ULONG64 ; } extern "C" { pub fn KeQueryUnbiasedInterruptTimePrecise ( QpcTimeStamp : PULONG64 ) -> ULONG64 ; } extern "C" { pub fn KeQueryTimeIncrement ( ) -> ULONG ; } extern "C" { pub fn KeQueryUnbiasedInterruptTime ( ) -> ULONGLONG ; } extern "C" { pub fn KeGetRecommendedSharedDataAlignment ( ) -> ULONG ; } extern "C" { pub fn KeQueryActiveProcessors ( ) -> KAFFINITY ; } extern "C" { pub fn KeQueryActiveProcessorCount ( ActiveProcessors : PKAFFINITY ) -> ULONG ; } extern "C" { pub fn KeQueryActiveProcessorCountEx ( GroupNumber : USHORT ) -> ULONG ; } extern "C" { pub fn KeQueryMaximumProcessorCount ( ) -> ULONG ; } extern "C" { pub fn KeQueryMaximumProcessorCountEx ( GroupNumber : USHORT ) -> ULONG ; } extern "C" { pub fn KeQueryActiveGroupCount ( ) -> USHORT ; } extern "C" { pub fn KeQueryMaximumGroupCount ( ) -> USHORT ; } extern "C" { pub fn KeQueryGroupAffinity ( GroupNumber : USHORT ) -> KAFFINITY ; } extern "C" { pub fn KeGetCurrentProcessorNumberEx ( ProcNumber : PPROCESSOR_NUMBER ) -> ULONG ; } extern "C" { pub fn KeQueryNodeActiveAffinity ( NodeNumber : USHORT , Affinity : PGROUP_AFFINITY , Count : PUSHORT ) ; } extern "C" { pub fn KeQueryNodeMaximumProcessorCount ( NodeNumber : USHORT ) -> USHORT ; } extern "C" { pub fn KeQueryHighestNodeNumber ( ) -> USHORT ; } extern "C" { pub fn KeGetCurrentNodeNumber ( ) -> USHORT ; } extern "C" { pub fn KeQueryLogicalProcessorRelationship ( ProcessorNumber : PPROCESSOR_NUMBER , RelationshipType : LOGICAL_PROCESSOR_RELATIONSHIP , Information : PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX , Length : PULONG ) -> NTSTATUS ; } extern "C" { pub fn KeShouldYieldProcessor ( ) -> LOGICAL ; } extern "C" { # [ link_name = "\u{1}KeTickCount" ] pub static mut KeTickCount : KSYSTEM_TIME ; } pub const _MEMORY_CACHING_TYPE_ORIG_MmFrameBufferCached : _MEMORY_CACHING_TYPE_ORIG = 2 ; pub type _MEMORY_CACHING_TYPE_ORIG = i32 ; pub use self :: _MEMORY_CACHING_TYPE_ORIG as MEMORY_CACHING_TYPE_ORIG ; pub const _MEMORY_CACHING_TYPE_MmNonCached : _MEMORY_CACHING_TYPE = 0 ; pub const _MEMORY_CACHING_TYPE_MmCached : _MEMORY_CACHING_TYPE = 1 ; pub const _MEMORY_CACHING_TYPE_MmWriteCombined : _MEMORY_CACHING_TYPE = 2 ; pub const _MEMORY_CACHING_TYPE_MmHardwareCoherentCached : _MEMORY_CACHING_TYPE = 3 ; pub const _MEMORY_CACHING_TYPE_MmNonCachedUnordered : _MEMORY_CACHING_TYPE = 4 ; pub const _MEMORY_CACHING_TYPE_MmUSWCCached : _MEMORY_CACHING_TYPE = 5 ; pub const _MEMORY_CACHING_TYPE_MmMaximumCacheType : _MEMORY_CACHING_TYPE = 6 ; pub const _MEMORY_CACHING_TYPE_MmNotMapped : _MEMORY_CACHING_TYPE = -1 ; pub type _MEMORY_CACHING_TYPE = i32 ; pub use self :: _MEMORY_CACHING_TYPE as MEMORY_CACHING_TYPE ; extern "C" { pub fn KeAreAllApcsDisabled ( ) -> BOOLEAN ; } extern "C" { pub fn KeInitializeGuardedMutex ( Mutex : PKGUARDED_MUTEX ) ; } extern "C" { pub fn KeAcquireGuardedMutex ( Mutex : PKGUARDED_MUTEX ) ; } extern "C" { pub fn KeReleaseGuardedMutex ( Mutex : PKGUARDED_MUTEX ) ; } extern "C" { pub fn KeTryToAcquireGuardedMutex ( Mutex : PKGUARDED_MUTEX ) -> BOOLEAN ; } extern "C" { pub fn KeAcquireGuardedMutexUnsafe ( FastMutex : PKGUARDED_MUTEX ) ; } extern "C" { pub fn KeReleaseGuardedMutexUnsafe ( FastMutex : PKGUARDED_MUTEX ) ; } pub const KE_PROCESSOR_CHANGE_NOTIFY_STATE_KeProcessorAddStartNotify : KE_PROCESSOR_CHANGE_NOTIFY_STATE = 0 ; pub const KE_PROCESSOR_CHANGE_NOTIFY_STATE_KeProcessorAddCompleteNotify : KE_PROCESSOR_CHANGE_NOTIFY_STATE = 1 ; pub const KE_PROCESSOR_CHANGE_NOTIFY_STATE_KeProcessorAddFailureNotify : KE_PROCESSOR_CHANGE_NOTIFY_STATE = 2 ; pub type KE_PROCESSOR_CHANGE_NOTIFY_STATE = i32 ; # [ repr ( C ) ] pub struct _KE_PROCESSOR_CHANGE_NOTIFY_CONTEXT { pub State : KE_PROCESSOR_CHANGE_NOTIFY_STATE , pub NtNumber : ULONG , pub Status : NTSTATUS , pub ProcNumber : PROCESSOR_NUMBER , } pub type KE_PROCESSOR_CHANGE_NOTIFY_CONTEXT = _KE_PROCESSOR_CHANGE_NOTIFY_CONTEXT ; pub type PKE_PROCESSOR_CHANGE_NOTIFY_CONTEXT = * mut _KE_PROCESSOR_CHANGE_NOTIFY_CONTEXT ; pub type PROCESSOR_CALLBACK_FUNCTION = :: std :: option :: Option < unsafe extern "C" fn ( CallbackContext : PVOID , ChangeContext : PKE_PROCESSOR_CHANGE_NOTIFY_CONTEXT , OperationStatus : PNTSTATUS ) > ; pub type PPROCESSOR_CALLBACK_FUNCTION = PROCESSOR_CALLBACK_FUNCTION ; extern "C" { pub fn KeRegisterProcessorChangeCallback ( CallbackFunction : PPROCESSOR_CALLBACK_FUNCTION , CallbackContext : PVOID , Flags : ULONG ) -> PVOID ; } extern "C" { pub fn KeDeregisterProcessorChangeCallback ( CallbackHandle : PVOID ) ; } extern "C" { pub fn KeGetProcessorNumberFromIndex ( ProcIndex : ULONG , ProcNumber : PPROCESSOR_NUMBER ) -> NTSTATUS ; } extern "C" { pub fn KeGetProcessorIndexFromNumber ( ProcNumber : PPROCESSOR_NUMBER ) -> ULONG ; } # [ repr ( C ) ] pub struct _XSTATE_SAVE { pub __bindgen_anon_1 : _XSTATE_SAVE__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _XSTATE_SAVE__bindgen_ty_1 { pub __bindgen_anon_1 : __BindgenUnionField < _XSTATE_SAVE__bindgen_ty_1__bindgen_ty_1 > , pub XStateContext : __BindgenUnionField < XSTATE_CONTEXT > , pub bindgen_union_field : [ u64 ; 7usize ] , } # [ repr ( C ) ] pub struct _XSTATE_SAVE__bindgen_ty_1__bindgen_ty_1 { pub Reserved1 : LONG64 , pub Reserved2 : ULONG , pub Prev : * mut _XSTATE_SAVE , pub Reserved3 : PXSAVE_AREA , pub Thread : * mut _KTHREAD , pub Reserved4 : PVOID , pub Level : UCHAR , } pub type XSTATE_SAVE = _XSTATE_SAVE ; pub type PXSTATE_SAVE = * mut _XSTATE_SAVE ; extern "C" { pub fn KeSaveExtendedProcessorState ( Mask : ULONG64 , XStateSave : PXSTATE_SAVE ) -> NTSTATUS ; } extern "C" { pub fn KeRestoreExtendedProcessorState ( XStateSave : PXSTATE_SAVE ) ; } # [ repr ( C ) ] pub struct _EXT_SET_PARAMETERS_V0 { pub Version : ULONG , pub Reserved : ULONG , pub NoWakeTolerance : LONGLONG , } pub type EXT_SET_PARAMETERS = _EXT_SET_PARAMETERS_V0 ; pub type PEXT_SET_PARAMETERS = * mut _EXT_SET_PARAMETERS_V0 ; pub type KT2_SET_PARAMETERS = EXT_SET_PARAMETERS ; pub type PKT2_SET_PARAMETERS = * mut EXT_SET_PARAMETERS ; extern "C" { pub fn KeConvertAuxiliaryCounterToPerformanceCounter ( AuxiliaryCounterValue : ULONG64 , PerformanceCounterValue : PULONG64 , ConversionError : PULONG64 ) -> NTSTATUS ; } extern "C" { pub fn KeConvertPerformanceCounterToAuxiliaryCounter ( PerformanceCounterValue : ULONG64 , AuxiliaryCounterValue : PULONG64 , ConversionError : PULONG64 ) -> NTSTATUS ; } extern "C" { pub fn KeQueryAuxiliaryCounterFrequency ( AuxiliaryCounterFrequency : PULONG64 ) -> NTSTATUS ; } # [ repr ( C ) ] pub struct _KWAIT_CHAIN { pub Head : PVOID , } pub type KWAIT_CHAIN = _KWAIT_CHAIN ; pub type PKWAIT_CHAIN = * mut _KWAIT_CHAIN ; extern "C" { # [ link_name = "\u{1}KdDebuggerNotPresent" ] pub static mut KdDebuggerNotPresent : PBOOLEAN ; } extern "C" { # [ link_name = "\u{1}KdDebuggerEnabled" ] pub static mut KdDebuggerEnabled : PBOOLEAN ; } extern "C" { pub fn KdDisableDebugger ( ) -> NTSTATUS ; } extern "C" { pub fn KdEnableDebugger ( ) -> NTSTATUS ; } extern "C" { pub fn KdRefreshDebuggerNotPresent ( ) -> BOOLEAN ; } pub const _KD_OPTION_KD_OPTION_SET_BLOCK_ENABLE : _KD_OPTION = 0 ; pub type _KD_OPTION = i32 ; pub use self :: _KD_OPTION as KD_OPTION ; extern "C" { pub fn KdChangeOption ( Option : KD_OPTION , InBufferBytes : ULONG , InBuffer : PVOID , OutBufferBytes : ULONG , OutBuffer : PVOID , OutBufferNeeded : PULONG ) -> NTSTATUS ; } pub const _POOL_TYPE_NonPagedPool : _POOL_TYPE = 0 ; pub const _POOL_TYPE_NonPagedPoolExecute : _POOL_TYPE = 0 ; pub const _POOL_TYPE_PagedPool : _POOL_TYPE = 1 ; pub const _POOL_TYPE_NonPagedPoolMustSucceed : _POOL_TYPE = 2 ; pub const _POOL_TYPE_DontUseThisType : _POOL_TYPE = 3 ; pub const _POOL_TYPE_NonPagedPoolCacheAligned : _POOL_TYPE = 4 ; pub const _POOL_TYPE_PagedPoolCacheAligned : _POOL_TYPE = 5 ; pub const _POOL_TYPE_NonPagedPoolCacheAlignedMustS : _POOL_TYPE = 6 ; pub const _POOL_TYPE_MaxPoolType : _POOL_TYPE = 7 ; pub const _POOL_TYPE_NonPagedPoolBase : _POOL_TYPE = 0 ; pub const _POOL_TYPE_NonPagedPoolBaseMustSucceed : _POOL_TYPE = 2 ; pub const _POOL_TYPE_NonPagedPoolBaseCacheAligned : _POOL_TYPE = 4 ; pub const _POOL_TYPE_NonPagedPoolBaseCacheAlignedMustS : _POOL_TYPE = 6 ; pub const _POOL_TYPE_NonPagedPoolSession : _POOL_TYPE = 32 ; pub const _POOL_TYPE_PagedPoolSession : _POOL_TYPE = 33 ; pub const _POOL_TYPE_NonPagedPoolMustSucceedSession : _POOL_TYPE = 34 ; pub const _POOL_TYPE_DontUseThisTypeSession : _POOL_TYPE = 35 ; pub const _POOL_TYPE_NonPagedPoolCacheAlignedSession : _POOL_TYPE = 36 ; pub const _POOL_TYPE_PagedPoolCacheAlignedSession : _POOL_TYPE = 37 ; pub const _POOL_TYPE_NonPagedPoolCacheAlignedMustSSession : _POOL_TYPE = 38 ; pub const _POOL_TYPE_NonPagedPoolNx : _POOL_TYPE = 512 ; pub const _POOL_TYPE_NonPagedPoolNxCacheAligned : _POOL_TYPE = 516 ; pub const _POOL_TYPE_NonPagedPoolSessionNx : _POOL_TYPE = 544 ; pub type _POOL_TYPE = i32 ; extern "C" { pub fn ExAllocatePool ( PoolType : POOL_TYPE , NumberOfBytes : SIZE_T ) -> PVOID ; } extern "C" { pub fn ExAllocatePoolWithQuota ( PoolType : POOL_TYPE , NumberOfBytes : SIZE_T ) -> PVOID ; } extern "C" { pub fn ExAllocatePoolWithTag ( PoolType : POOL_TYPE , NumberOfBytes : SIZE_T , Tag : ULONG ) -> PVOID ; } pub const _EX_POOL_PRIORITY_LowPoolPriority : _EX_POOL_PRIORITY = 0 ; pub const _EX_POOL_PRIORITY_LowPoolPrioritySpecialPoolOverrun : _EX_POOL_PRIORITY = 8 ; pub const _EX_POOL_PRIORITY_LowPoolPrioritySpecialPoolUnderrun : _EX_POOL_PRIORITY = 9 ; pub const _EX_POOL_PRIORITY_NormalPoolPriority : _EX_POOL_PRIORITY = 16 ; pub const _EX_POOL_PRIORITY_NormalPoolPrioritySpecialPoolOverrun : _EX_POOL_PRIORITY = 24 ; pub const _EX_POOL_PRIORITY_NormalPoolPrioritySpecialPoolUnderrun : _EX_POOL_PRIORITY = 25 ; pub const _EX_POOL_PRIORITY_HighPoolPriority : _EX_POOL_PRIORITY = 32 ; pub const _EX_POOL_PRIORITY_HighPoolPrioritySpecialPoolOverrun : _EX_POOL_PRIORITY = 40 ; pub const _EX_POOL_PRIORITY_HighPoolPrioritySpecialPoolUnderrun : _EX_POOL_PRIORITY = 41 ; pub type _EX_POOL_PRIORITY = i32 ; pub use self :: _EX_POOL_PRIORITY as EX_POOL_PRIORITY ; extern "C" { pub fn ExAllocatePoolWithTagPriority ( PoolType : POOL_TYPE , NumberOfBytes : SIZE_T , Tag : ULONG , Priority : EX_POOL_PRIORITY ) -> PVOID ; } extern "C" { pub fn ExAllocatePoolWithQuotaTag ( PoolType : POOL_TYPE , NumberOfBytes : SIZE_T , Tag : ULONG ) -> PVOID ; } extern "C" { pub fn ExFreePool ( P : PVOID ) ; } extern "C" { pub fn ExFreePoolWithTag ( P : PVOID , Tag : ULONG ) ; } extern "C" { pub fn ExAcquireFastMutexUnsafe ( FastMutex : PFAST_MUTEX ) ; } extern "C" { pub fn ExReleaseFastMutexUnsafe ( FastMutex : PFAST_MUTEX ) ; } extern "C" { pub fn ExAcquireFastMutex ( FastMutex : PFAST_MUTEX ) ; } extern "C" { pub fn ExReleaseFastMutex ( FastMutex : PFAST_MUTEX ) ; } extern "C" { pub fn ExTryToAcquireFastMutex ( FastMutex : PFAST_MUTEX ) -> BOOLEAN ; } extern "C" { pub fn _InterlockedAddLargeStatistic ( Addend : * mut :: std :: os :: raw :: c_longlong , Increment : :: std :: os :: raw :: c_long ) -> :: std :: os :: raw :: c_long ; } extern "C" { pub fn ExInterlockedAddLargeInteger ( Addend : PLARGE_INTEGER , Increment : LARGE_INTEGER , Lock : PKSPIN_LOCK ) -> LARGE_INTEGER ; } extern "C" { pub fn ExfInterlockedAddUlong ( Addend : PULONG , Increment : ULONG , Lock : PKSPIN_LOCK ) -> ULONG ; } extern "C" { pub fn ExfInterlockedCompareExchange64 ( Destination : * mut LONGLONG , ExChange : PLONGLONG , Comperand : PLONGLONG ) -> LONGLONG ; } extern "C" { pub fn ExfInterlockedInsertHeadList ( ListHead : PLIST_ENTRY , ListEntry : PLIST_ENTRY , Lock : PKSPIN_LOCK ) -> PLIST_ENTRY ; } extern "C" { pub fn ExfInterlockedInsertTailList ( ListHead : PLIST_ENTRY , ListEntry : PLIST_ENTRY , Lock : PKSPIN_LOCK ) -> PLIST_ENTRY ; } extern "C" { pub fn ExfInterlockedRemoveHeadList ( ListHead : PLIST_ENTRY , Lock : PKSPIN_LOCK ) -> PLIST_ENTRY ; } extern "C" { pub fn ExfInterlockedPopEntryList ( ListHead : PSINGLE_LIST_ENTRY , Lock : PKSPIN_LOCK ) -> PSINGLE_LIST_ENTRY ; } extern "C" { pub fn ExfInterlockedPushEntryList ( ListHead : PSINGLE_LIST_ENTRY , ListEntry : PSINGLE_LIST_ENTRY , Lock : PKSPIN_LOCK ) -> PSINGLE_LIST_ENTRY ; } extern "C" { pub fn InitializeSListHead ( SListHead : PSLIST_HEADER ) ; } extern "C" { pub fn FirstEntrySList ( SListHead : PSLIST_HEADER ) -> PSLIST_ENTRY ; } extern "C" { pub fn ExInterlockedFlushSList ( ListHead : PSLIST_HEADER ) -> PSLIST_ENTRY ; } extern "C" { pub fn InterlockedPopEntrySList ( ListHead : PSLIST_HEADER ) -> PSLIST_ENTRY ; } extern "C" { pub fn InterlockedPushEntrySList ( ListHead : PSLIST_HEADER , ListEntry : PSLIST_ENTRY ) -> PSLIST_ENTRY ; } # [ repr ( C ) ] pub struct _LOOKASIDE_LIST_EX { pub L : GENERAL_LOOKASIDE_POOL , } pub type LOOKASIDE_LIST_EX = _LOOKASIDE_LIST_EX ; extern "C" { pub fn ExInitializeLookasideListEx ( Lookaside : PLOOKASIDE_LIST_EX , Allocate : PALLOCATE_FUNCTION_EX , Free : PFREE_FUNCTION_EX , PoolType : POOL_TYPE , Flags : ULONG , Size : SIZE_T , Tag : ULONG , Depth : USHORT ) -> NTSTATUS ; } extern "C" { pub fn ExDeleteLookasideListEx ( Lookaside : PLOOKASIDE_LIST_EX ) ; } extern "C" { pub fn ExFlushLookasideListEx ( Lookaside : PLOOKASIDE_LIST_EX ) ; } # [ repr ( C ) ] pub struct _NPAGED_LOOKASIDE_LIST { pub L : GENERAL_LOOKASIDE , pub Lock__ObsoleteButDoNotDelete : KSPIN_LOCK , pub __bindgen_padding_0 : [ u64 ; 7usize ] , } pub type NPAGED_LOOKASIDE_LIST = _NPAGED_LOOKASIDE_LIST ; pub type PNPAGED_LOOKASIDE_LIST = * mut _NPAGED_LOOKASIDE_LIST ; extern "C" { pub fn ExInitializeNPagedLookasideList ( Lookaside : PNPAGED_LOOKASIDE_LIST , Allocate : PALLOCATE_FUNCTION , Free : PFREE_FUNCTION , Flags : ULONG , Size : SIZE_T , Tag : ULONG , Depth : USHORT ) ; } extern "C" { pub fn ExDeleteNPagedLookasideList ( Lookaside : PNPAGED_LOOKASIDE_LIST ) ; } # [ repr ( C ) ] pub struct _PAGED_LOOKASIDE_LIST { pub L : GENERAL_LOOKASIDE , pub Lock__ObsoleteButDoNotDelete : FAST_MUTEX , pub __bindgen_padding_0 : u64 , } pub type PAGED_LOOKASIDE_LIST = _PAGED_LOOKASIDE_LIST ; pub type PPAGED_LOOKASIDE_LIST = * mut _PAGED_LOOKASIDE_LIST ; extern "C" { pub fn ExInitializePagedLookasideList ( Lookaside : PPAGED_LOOKASIDE_LIST , Allocate : PALLOCATE_FUNCTION , Free : PFREE_FUNCTION , Flags : ULONG , Size : SIZE_T , Tag : ULONG , Depth : USHORT ) ; } extern "C" { pub fn ExDeletePagedLookasideList ( Lookaside : PPAGED_LOOKASIDE_LIST ) ; } extern "C" { pub fn ProbeForRead ( Address : * mut :: std :: os :: raw :: c_void , Length : SIZE_T , Alignment : ULONG ) ; } extern "C" { pub fn ExRaiseStatus ( Status : NTSTATUS ) ; } extern "C" { pub fn ProbeForWrite ( Address : * mut :: std :: os :: raw :: c_void , Length : SIZE_T , Alignment : ULONG ) ; } pub const _WORK_QUEUE_TYPE_CriticalWorkQueue : _WORK_QUEUE_TYPE = 0 ; pub const _WORK_QUEUE_TYPE_DelayedWorkQueue : _WORK_QUEUE_TYPE = 1 ; pub const _WORK_QUEUE_TYPE_HyperCriticalWorkQueue : _WORK_QUEUE_TYPE = 2 ; pub const _WORK_QUEUE_TYPE_NormalWorkQueue : _WORK_QUEUE_TYPE = 3 ; pub const _WORK_QUEUE_TYPE_BackgroundWorkQueue : _WORK_QUEUE_TYPE = 4 ; pub const _WORK_QUEUE_TYPE_RealTimeWorkQueue : _WORK_QUEUE_TYPE = 5 ; pub const _WORK_QUEUE_TYPE_SuperCriticalWorkQueue : _WORK_QUEUE_TYPE = 6 ; pub const _WORK_QUEUE_TYPE_MaximumWorkQueue : _WORK_QUEUE_TYPE = 7 ; pub const _WORK_QUEUE_TYPE_CustomPriorityWorkQueue : _WORK_QUEUE_TYPE = 32 ; pub type _WORK_QUEUE_TYPE = i32 ; pub use self :: _WORK_QUEUE_TYPE as WORK_QUEUE_TYPE ; pub type WORKER_THREAD_ROUTINE = :: std :: option :: Option < unsafe extern "C" fn ( Parameter : PVOID ) > ; pub type PWORKER_THREAD_ROUTINE = WORKER_THREAD_ROUTINE ; # [ repr ( C ) ] pub struct _WORK_QUEUE_ITEM { pub List : LIST_ENTRY , pub WorkerRoutine : PWORKER_THREAD_ROUTINE , pub Parameter : PVOID , } pub type WORK_QUEUE_ITEM = _WORK_QUEUE_ITEM ; pub type PWORK_QUEUE_ITEM = * mut _WORK_QUEUE_ITEM ; extern "C" { pub fn ExQueueWorkItem ( WorkItem : PWORK_QUEUE_ITEM , QueueType : WORK_QUEUE_TYPE ) ; } extern "C" { pub fn ExIsProcessorFeaturePresent ( ProcessorFeature : ULONG ) -> BOOLEAN ; } pub type ERESOURCE_THREAD = ULONG_PTR ; pub type PERESOURCE_THREAD = * mut ERESOURCE_THREAD ; # [ repr ( C ) ] pub struct _OWNER_ENTRY { pub OwnerThread : ERESOURCE_THREAD , pub __bindgen_anon_1 : _OWNER_ENTRY__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _OWNER_ENTRY__bindgen_ty_1 { pub __bindgen_anon_1 : __BindgenUnionField < _OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1 > , pub TableSize : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn IoPriorityBoosted ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_IoPriorityBoosted ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn OwnerReferenced ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_OwnerReferenced ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn IoQoSPriorityBoosted ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_IoQoSPriorityBoosted ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn OwnerCount ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 29u8 ) as u32 ) } } # [ inline ] pub fn set_OwnerCount ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 29u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( IoPriorityBoosted : ULONG , OwnerReferenced : ULONG , IoQoSPriorityBoosted : ULONG , OwnerCount : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let IoPriorityBoosted : u32 = unsafe { :: std :: mem :: transmute ( IoPriorityBoosted ) } ; IoPriorityBoosted as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let OwnerReferenced : u32 = unsafe { :: std :: mem :: transmute ( OwnerReferenced ) } ; OwnerReferenced as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let IoQoSPriorityBoosted : u32 = unsafe { :: std :: mem :: transmute ( IoQoSPriorityBoosted ) } ; IoQoSPriorityBoosted as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 29u8 , { let OwnerCount : u32 = unsafe { :: std :: mem :: transmute ( OwnerCount ) } ; OwnerCount as u64 } ) ; __bindgen_bitfield_unit } } pub type OWNER_ENTRY = _OWNER_ENTRY ; pub type POWNER_ENTRY = * mut _OWNER_ENTRY ; # [ repr ( C ) ] pub struct _ERESOURCE { pub SystemResourcesList : LIST_ENTRY , pub OwnerTable : POWNER_ENTRY , pub ActiveCount : SHORT , pub __bindgen_anon_1 : _ERESOURCE__bindgen_ty_1 , pub SharedWaiters : PVOID , pub ExclusiveWaiters : PVOID , pub OwnerEntry : OWNER_ENTRY , pub ActiveEntries : ULONG , pub ContentionCount : ULONG , pub NumberOfSharedWaiters : ULONG , pub NumberOfExclusiveWaiters : ULONG , pub Reserved2 : PVOID , pub __bindgen_anon_2 : _ERESOURCE__bindgen_ty_2 , pub SpinLock : KSPIN_LOCK , } # [ repr ( C ) ] pub struct _ERESOURCE__bindgen_ty_1 { pub Flag : __BindgenUnionField < USHORT > , pub __bindgen_anon_1 : __BindgenUnionField < _ERESOURCE__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : u16 , } # [ repr ( C ) ] pub struct _ERESOURCE__bindgen_ty_1__bindgen_ty_1 { pub ReservedLowFlags : UCHAR , pub WaiterPriority : UCHAR , } # [ repr ( C ) ] pub struct _ERESOURCE__bindgen_ty_2 { pub Address : __BindgenUnionField < PVOID > , pub CreatorBackTraceIndex : __BindgenUnionField < ULONG_PTR > , pub bindgen_union_field : u64 , } pub type ERESOURCE = _ERESOURCE ; pub type PERESOURCE = * mut _ERESOURCE ; # [ repr ( C ) ] pub struct _RESOURCE_HASH_ENTRY { pub ListEntry : LIST_ENTRY , pub Address : PVOID , pub ContentionCount : ULONG , pub Number : ULONG , } pub type RESOURCE_HASH_ENTRY = _RESOURCE_HASH_ENTRY ; pub type PRESOURCE_HASH_ENTRY = * mut _RESOURCE_HASH_ENTRY ; # [ repr ( C ) ] pub struct _RESOURCE_PERFORMANCE_DATA { pub ActiveResourceCount : ULONG , pub TotalResourceCount : ULONG , pub ExclusiveAcquire : ULONG , pub SharedFirstLevel : ULONG , pub SharedSecondLevel : ULONG , pub StarveFirstLevel : ULONG , pub StarveSecondLevel : ULONG , pub WaitForExclusive : ULONG , pub OwnerTableExpands : ULONG , pub MaximumTableExpand : ULONG , pub HashTable : [ LIST_ENTRY ; 64usize ] , } pub type RESOURCE_PERFORMANCE_DATA = _RESOURCE_PERFORMANCE_DATA ; pub type PRESOURCE_PERFORMANCE_DATA = * mut _RESOURCE_PERFORMANCE_DATA ; extern "C" { pub fn ExInitializeResourceLite ( Resource : PERESOURCE ) -> NTSTATUS ; } extern "C" { pub fn ExReinitializeResourceLite ( Resource : PERESOURCE ) -> NTSTATUS ; } extern "C" { pub fn ExAcquireResourceSharedLite ( Resource : PERESOURCE , Wait : BOOLEAN ) -> BOOLEAN ; } extern "C" { pub fn ExEnterCriticalRegionAndAcquireResourceShared ( Resource : PERESOURCE ) -> PVOID ; } extern "C" { pub fn ExAcquireResourceExclusiveLite ( Resource : PERESOURCE , Wait : BOOLEAN ) -> BOOLEAN ; } extern "C" { pub fn ExEnterCriticalRegionAndAcquireResourceExclusive ( Resource : PERESOURCE ) -> PVOID ; } extern "C" { pub fn ExAcquireSharedStarveExclusive ( Resource : PERESOURCE , Wait : BOOLEAN ) -> BOOLEAN ; } extern "C" { pub fn ExAcquireSharedWaitForExclusive ( Resource : PERESOURCE , Wait : BOOLEAN ) -> BOOLEAN ; } extern "C" { pub fn ExEnterCriticalRegionAndAcquireSharedWaitForExclusive ( Resource : PERESOURCE ) -> PVOID ; } extern "C" { pub fn ExReleaseResourceLite ( Resource : PERESOURCE ) ; } extern "C" { pub fn ExReleaseResourceAndLeaveCriticalRegion ( Resource : PERESOURCE ) ; } extern "C" { pub fn ExReleaseResourceForThreadLite ( Resource : PERESOURCE , ResourceThreadId : ERESOURCE_THREAD ) ; } extern "C" { pub fn ExSetResourceOwnerPointer ( Resource : PERESOURCE , OwnerPointer : PVOID ) ; } extern "C" { pub fn ExSetResourceOwnerPointerEx ( Resource : PERESOURCE , OwnerPointer : PVOID , Flags : ULONG ) ; } extern "C" { pub fn ExConvertExclusiveToSharedLite ( Resource : PERESOURCE ) ; } extern "C" { pub fn ExDeleteResourceLite ( Resource : PERESOURCE ) -> NTSTATUS ; } extern "C" { pub fn ExGetExclusiveWaiterCount ( Resource : PERESOURCE ) -> ULONG ; } extern "C" { pub fn ExGetSharedWaiterCount ( Resource : PERESOURCE ) -> ULONG ; } extern "C" { pub fn ExIsResourceAcquiredExclusiveLite ( Resource : PERESOURCE ) -> BOOLEAN ; } extern "C" { pub fn ExIsResourceAcquiredSharedLite ( Resource : PERESOURCE ) -> ULONG ; } # [ repr ( C ) ] pub struct _EX_RUNDOWN_REF { pub __bindgen_anon_1 : _EX_RUNDOWN_REF__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _EX_RUNDOWN_REF__bindgen_ty_1 { pub Count : __BindgenUnionField < ULONG_PTR > , pub Ptr : __BindgenUnionField < PVOID > , pub bindgen_union_field : u64 , } pub type EX_RUNDOWN_REF = _EX_RUNDOWN_REF ; pub type PEX_RUNDOWN_REF = * mut _EX_RUNDOWN_REF ; # [ repr ( C ) ] pub struct _EX_RUNDOWN_REF_CACHE_AWARE { _unused : [ u8 ; 0 ] , } pub type PEX_RUNDOWN_REF_CACHE_AWARE = * mut _EX_RUNDOWN_REF_CACHE_AWARE ; extern "C" { pub fn ExGetPreviousMode ( ) -> KPROCESSOR_MODE ; } extern "C" { pub fn ExSetTimerResolution ( DesiredTime : ULONG , SetResolution : BOOLEAN ) -> ULONG ; } extern "C" { pub fn ExQueryTimerResolution ( MaximumTime : PULONG , MinimumTime : PULONG , CurrentTime : PULONG ) ; } extern "C" { pub fn ExSystemTimeToLocalTime ( SystemTime : PLARGE_INTEGER , LocalTime : PLARGE_INTEGER ) ; } extern "C" { pub fn ExLocalTimeToSystemTime ( LocalTime : PLARGE_INTEGER , SystemTime : PLARGE_INTEGER ) ; } # [ repr ( C ) ] pub struct _EX_TIMER { _unused : [ u8 ; 0 ] , } pub type PEX_TIMER = * mut _EX_TIMER ; pub type EXT_CALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( Timer : PEX_TIMER , Context : PVOID ) > ; pub type PEXT_CALLBACK = EXT_CALLBACK ; pub type EXT_DELETE_CALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID ) > ; pub type PEXT_DELETE_CALLBACK = EXT_DELETE_CALLBACK ; pub type PEXT_CANCEL_PARAMETERS = PVOID ; # [ repr ( C ) ] pub struct _EXT_DELETE_PARAMETERS { pub Version : ULONG , pub Reserved : ULONG , pub DeleteCallback : PEXT_DELETE_CALLBACK , pub DeleteContext : PVOID , } pub type EXT_DELETE_PARAMETERS = _EXT_DELETE_PARAMETERS ; pub type PEXT_DELETE_PARAMETERS = * mut _EXT_DELETE_PARAMETERS ; extern "C" { pub fn ExAllocateTimer ( Callback : PEXT_CALLBACK , CallbackContext : PVOID , Attributes : ULONG ) -> PEX_TIMER ; } extern "C" { pub fn ExSetTimer ( Timer : PEX_TIMER , DueTime : LONGLONG , Period : LONGLONG , Parameters : PEXT_SET_PARAMETERS ) -> BOOLEAN ; } extern "C" { pub fn ExCancelTimer ( Timer : PEX_TIMER , Parameters : PEXT_CANCEL_PARAMETERS ) -> BOOLEAN ; } extern "C" { pub fn ExDeleteTimer ( Timer : PEX_TIMER , Cancel : BOOLEAN , Wait : BOOLEAN , Parameters : PEXT_DELETE_PARAMETERS ) -> BOOLEAN ; } pub type CALLBACK_FUNCTION = :: std :: option :: Option < unsafe extern "C" fn ( CallbackContext : PVOID , Argument1 : PVOID , Argument2 : PVOID ) > ; pub type PCALLBACK_FUNCTION = CALLBACK_FUNCTION ; extern "C" { pub fn ExCreateCallback ( CallbackObject : * mut PCALLBACK_OBJECT , ObjectAttributes : POBJECT_ATTRIBUTES , Create : BOOLEAN , AllowMultipleCallbacks : BOOLEAN ) -> NTSTATUS ; } extern "C" { pub fn ExRegisterCallback ( CallbackObject : PCALLBACK_OBJECT , CallbackFunction : PCALLBACK_FUNCTION , CallbackContext : PVOID ) -> PVOID ; } extern "C" { pub fn ExUnregisterCallback ( CallbackRegistration : PVOID ) ; } extern "C" { pub fn ExNotifyCallback ( CallbackObject : PVOID , Argument1 : PVOID , Argument2 : PVOID ) ; } extern "C" { pub fn ExVerifySuite ( SuiteType : SUITE_TYPE ) -> BOOLEAN ; } extern "C" { pub fn ExInitializeRundownProtection ( RunRef : PEX_RUNDOWN_REF ) ; } extern "C" { pub fn ExReInitializeRundownProtection ( RunRef : PEX_RUNDOWN_REF ) ; } extern "C" { pub fn ExAcquireRundownProtection ( RunRef : PEX_RUNDOWN_REF ) -> BOOLEAN ; } extern "C" { pub fn ExAcquireRundownProtectionEx ( RunRef : PEX_RUNDOWN_REF , Count : ULONG ) -> BOOLEAN ; } extern "C" { pub fn ExReleaseRundownProtection ( RunRef : PEX_RUNDOWN_REF ) ; } extern "C" { pub fn ExReleaseRundownProtectionEx ( RunRef : PEX_RUNDOWN_REF , Count : ULONG ) ; } extern "C" { pub fn ExRundownCompleted ( RunRef : PEX_RUNDOWN_REF ) ; } extern "C" { pub fn ExWaitForRundownProtectionRelease ( RunRef : PEX_RUNDOWN_REF ) ; } extern "C" { pub fn ExAllocateCacheAwareRundownProtection ( PoolType : POOL_TYPE , PoolTag : ULONG ) -> PEX_RUNDOWN_REF_CACHE_AWARE ; } extern "C" { pub fn ExSizeOfRundownProtectionCacheAware ( ) -> SIZE_T ; } extern "C" { pub fn ExInitializeRundownProtectionCacheAware ( RunRefCacheAware : PEX_RUNDOWN_REF_CACHE_AWARE , RunRefSize : SIZE_T ) ; } extern "C" { pub fn ExFreeCacheAwareRundownProtection ( RunRefCacheAware : PEX_RUNDOWN_REF_CACHE_AWARE ) ; } extern "C" { pub fn ExAcquireRundownProtectionCacheAware ( RunRefCacheAware : PEX_RUNDOWN_REF_CACHE_AWARE ) -> BOOLEAN ; } extern "C" { pub fn ExReleaseRundownProtectionCacheAware ( RunRefCacheAware : PEX_RUNDOWN_REF_CACHE_AWARE ) ; } extern "C" { pub fn ExAcquireRundownProtectionCacheAwareEx ( RunRefCacheAware : PEX_RUNDOWN_REF_CACHE_AWARE , Count : ULONG ) -> BOOLEAN ; } extern "C" { pub fn ExReleaseRundownProtectionCacheAwareEx ( RunRef : PEX_RUNDOWN_REF_CACHE_AWARE , Count : ULONG ) ; } extern "C" { pub fn ExWaitForRundownProtectionReleaseCacheAware ( RunRef : PEX_RUNDOWN_REF_CACHE_AWARE ) ; } extern "C" { pub fn ExReInitializeRundownProtectionCacheAware ( RunRefCacheAware : PEX_RUNDOWN_REF_CACHE_AWARE ) ; } extern "C" { pub fn ExRundownCompletedCacheAware ( RunRefCacheAware : PEX_RUNDOWN_REF_CACHE_AWARE ) ; } extern "C" { pub fn ExInitializeRundownProtectionCacheAwareEx ( RunRefCacheAware : PEX_RUNDOWN_REF_CACHE_AWARE , Flags : ULONG ) ; } extern "C" { pub fn ExCleanupRundownProtectionCacheAware ( RunRefCacheAware : PEX_RUNDOWN_REF_CACHE_AWARE ) ; } pub type EX_SPIN_LOCK = LONG ; pub type PEX_SPIN_LOCK = * mut LONG ; extern "C" { pub fn ExAcquireSpinLockSharedAtDpcLevel ( SpinLock : PEX_SPIN_LOCK ) ; } extern "C" { pub fn ExAcquireSpinLockShared ( SpinLock : PEX_SPIN_LOCK ) -> KIRQL ; } extern "C" { pub fn ExReleaseSpinLockSharedFromDpcLevel ( SpinLock : PEX_SPIN_LOCK ) ; } extern "C" { pub fn ExReleaseSpinLockShared ( SpinLock : PEX_SPIN_LOCK , OldIrql : KIRQL ) ; } extern "C" { pub fn ExTryConvertSharedSpinLockExclusive ( SpinLock : PEX_SPIN_LOCK ) -> LOGICAL ; } extern "C" { pub fn ExAcquireSpinLockExclusiveAtDpcLevel ( SpinLock : PEX_SPIN_LOCK ) ; } extern "C" { pub fn ExAcquireSpinLockExclusive ( SpinLock : PEX_SPIN_LOCK ) -> KIRQL ; } extern "C" { pub fn ExReleaseSpinLockExclusiveFromDpcLevel ( SpinLock : PEX_SPIN_LOCK ) ; } extern "C" { pub fn ExReleaseSpinLockExclusive ( SpinLock : PEX_SPIN_LOCK , OldIrql : KIRQL ) ; } extern "C" { pub fn ExTryAcquireSpinLockSharedAtDpcLevel ( SpinLock : PEX_SPIN_LOCK ) -> LOGICAL ; } extern "C" { pub fn ExTryAcquireSpinLockExclusiveAtDpcLevel ( SpinLock : PEX_SPIN_LOCK ) -> LOGICAL ; } pub type EX_CALLBACK_FUNCTION = :: std :: option :: Option < unsafe extern "C" fn ( CallbackContext : PVOID , Argument1 : PVOID , Argument2 : PVOID ) -> NTSTATUS > ; pub type PEX_CALLBACK_FUNCTION = EX_CALLBACK_FUNCTION ; extern "C" { pub fn ExGetFirmwareEnvironmentVariable ( VariableName : PUNICODE_STRING , VendorGuid : LPGUID , Value : PVOID , ValueLength : PULONG , Attributes : PULONG ) -> NTSTATUS ; } extern "C" { pub fn ExSetFirmwareEnvironmentVariable ( VariableName : PUNICODE_STRING , VendorGuid : LPGUID , Value : PVOID , ValueLength : ULONG , Attributes : ULONG ) -> NTSTATUS ; } extern "C" { pub fn ExIsManufacturingModeEnabled ( ) -> BOOLEAN ; } extern "C" { pub fn ExIsSoftBoot ( ) -> BOOLEAN ; } extern "C" { pub fn ExGetFirmwareType ( ) -> FIRMWARE_TYPE ; } extern "C" { pub fn ExEnumerateSystemFirmwareTables ( FirmwareTableProviderSignature : ULONG , FirmwareTableBuffer : PVOID , BufferLength : ULONG , ReturnLength : PULONG ) -> NTSTATUS ; } extern "C" { pub fn ExGetSystemFirmwareTable ( FirmwareTableProviderSignature : ULONG , FirmwareTableID : ULONG , FirmwareTableBuffer : PVOID , BufferLength : ULONG , ReturnLength : PULONG ) -> NTSTATUS ; } pub const _REG_NOTIFY_CLASS_RegNtDeleteKey : _REG_NOTIFY_CLASS = 0 ; pub const _REG_NOTIFY_CLASS_RegNtPreDeleteKey : _REG_NOTIFY_CLASS = 0 ; pub const _REG_NOTIFY_CLASS_RegNtSetValueKey : _REG_NOTIFY_CLASS = 1 ; pub const _REG_NOTIFY_CLASS_RegNtPreSetValueKey : _REG_NOTIFY_CLASS = 1 ; pub const _REG_NOTIFY_CLASS_RegNtDeleteValueKey : _REG_NOTIFY_CLASS = 2 ; pub const _REG_NOTIFY_CLASS_RegNtPreDeleteValueKey : _REG_NOTIFY_CLASS = 2 ; pub const _REG_NOTIFY_CLASS_RegNtSetInformationKey : _REG_NOTIFY_CLASS = 3 ; pub const _REG_NOTIFY_CLASS_RegNtPreSetInformationKey : _REG_NOTIFY_CLASS = 3 ; pub const _REG_NOTIFY_CLASS_RegNtRenameKey : _REG_NOTIFY_CLASS = 4 ; pub const _REG_NOTIFY_CLASS_RegNtPreRenameKey : _REG_NOTIFY_CLASS = 4 ; pub const _REG_NOTIFY_CLASS_RegNtEnumerateKey : _REG_NOTIFY_CLASS = 5 ; pub const _REG_NOTIFY_CLASS_RegNtPreEnumerateKey : _REG_NOTIFY_CLASS = 5 ; pub const _REG_NOTIFY_CLASS_RegNtEnumerateValueKey : _REG_NOTIFY_CLASS = 6 ; pub const _REG_NOTIFY_CLASS_RegNtPreEnumerateValueKey : _REG_NOTIFY_CLASS = 6 ; pub const _REG_NOTIFY_CLASS_RegNtQueryKey : _REG_NOTIFY_CLASS = 7 ; pub const _REG_NOTIFY_CLASS_RegNtPreQueryKey : _REG_NOTIFY_CLASS = 7 ; pub const _REG_NOTIFY_CLASS_RegNtQueryValueKey : _REG_NOTIFY_CLASS = 8 ; pub const _REG_NOTIFY_CLASS_RegNtPreQueryValueKey : _REG_NOTIFY_CLASS = 8 ; pub const _REG_NOTIFY_CLASS_RegNtQueryMultipleValueKey : _REG_NOTIFY_CLASS = 9 ; pub const _REG_NOTIFY_CLASS_RegNtPreQueryMultipleValueKey : _REG_NOTIFY_CLASS = 9 ; pub const _REG_NOTIFY_CLASS_RegNtPreCreateKey : _REG_NOTIFY_CLASS = 10 ; pub const _REG_NOTIFY_CLASS_RegNtPostCreateKey : _REG_NOTIFY_CLASS = 11 ; pub const _REG_NOTIFY_CLASS_RegNtPreOpenKey : _REG_NOTIFY_CLASS = 12 ; pub const _REG_NOTIFY_CLASS_RegNtPostOpenKey : _REG_NOTIFY_CLASS = 13 ; pub const _REG_NOTIFY_CLASS_RegNtKeyHandleClose : _REG_NOTIFY_CLASS = 14 ; pub const _REG_NOTIFY_CLASS_RegNtPreKeyHandleClose : _REG_NOTIFY_CLASS = 14 ; pub const _REG_NOTIFY_CLASS_RegNtPostDeleteKey : _REG_NOTIFY_CLASS = 15 ; pub const _REG_NOTIFY_CLASS_RegNtPostSetValueKey : _REG_NOTIFY_CLASS = 16 ; pub const _REG_NOTIFY_CLASS_RegNtPostDeleteValueKey : _REG_NOTIFY_CLASS = 17 ; pub const _REG_NOTIFY_CLASS_RegNtPostSetInformationKey : _REG_NOTIFY_CLASS = 18 ; pub const _REG_NOTIFY_CLASS_RegNtPostRenameKey : _REG_NOTIFY_CLASS = 19 ; pub const _REG_NOTIFY_CLASS_RegNtPostEnumerateKey : _REG_NOTIFY_CLASS = 20 ; pub const _REG_NOTIFY_CLASS_RegNtPostEnumerateValueKey : _REG_NOTIFY_CLASS = 21 ; pub const _REG_NOTIFY_CLASS_RegNtPostQueryKey : _REG_NOTIFY_CLASS = 22 ; pub const _REG_NOTIFY_CLASS_RegNtPostQueryValueKey : _REG_NOTIFY_CLASS = 23 ; pub const _REG_NOTIFY_CLASS_RegNtPostQueryMultipleValueKey : _REG_NOTIFY_CLASS = 24 ; pub const _REG_NOTIFY_CLASS_RegNtPostKeyHandleClose : _REG_NOTIFY_CLASS = 25 ; pub const _REG_NOTIFY_CLASS_RegNtPreCreateKeyEx : _REG_NOTIFY_CLASS = 26 ; pub const _REG_NOTIFY_CLASS_RegNtPostCreateKeyEx : _REG_NOTIFY_CLASS = 27 ; pub const _REG_NOTIFY_CLASS_RegNtPreOpenKeyEx : _REG_NOTIFY_CLASS = 28 ; pub const _REG_NOTIFY_CLASS_RegNtPostOpenKeyEx : _REG_NOTIFY_CLASS = 29 ; pub const _REG_NOTIFY_CLASS_RegNtPreFlushKey : _REG_NOTIFY_CLASS = 30 ; pub const _REG_NOTIFY_CLASS_RegNtPostFlushKey : _REG_NOTIFY_CLASS = 31 ; pub const _REG_NOTIFY_CLASS_RegNtPreLoadKey : _REG_NOTIFY_CLASS = 32 ; pub const _REG_NOTIFY_CLASS_RegNtPostLoadKey : _REG_NOTIFY_CLASS = 33 ; pub const _REG_NOTIFY_CLASS_RegNtPreUnLoadKey : _REG_NOTIFY_CLASS = 34 ; pub const _REG_NOTIFY_CLASS_RegNtPostUnLoadKey : _REG_NOTIFY_CLASS = 35 ; pub const _REG_NOTIFY_CLASS_RegNtPreQueryKeySecurity : _REG_NOTIFY_CLASS = 36 ; pub const _REG_NOTIFY_CLASS_RegNtPostQueryKeySecurity : _REG_NOTIFY_CLASS = 37 ; pub const _REG_NOTIFY_CLASS_RegNtPreSetKeySecurity : _REG_NOTIFY_CLASS = 38 ; pub const _REG_NOTIFY_CLASS_RegNtPostSetKeySecurity : _REG_NOTIFY_CLASS = 39 ; pub const _REG_NOTIFY_CLASS_RegNtCallbackObjectContextCleanup : _REG_NOTIFY_CLASS = 40 ; pub const _REG_NOTIFY_CLASS_RegNtPreRestoreKey : _REG_NOTIFY_CLASS = 41 ; pub const _REG_NOTIFY_CLASS_RegNtPostRestoreKey : _REG_NOTIFY_CLASS = 42 ; pub const _REG_NOTIFY_CLASS_RegNtPreSaveKey : _REG_NOTIFY_CLASS = 43 ; pub const _REG_NOTIFY_CLASS_RegNtPostSaveKey : _REG_NOTIFY_CLASS = 44 ; pub const _REG_NOTIFY_CLASS_RegNtPreReplaceKey : _REG_NOTIFY_CLASS = 45 ; pub const _REG_NOTIFY_CLASS_RegNtPostReplaceKey : _REG_NOTIFY_CLASS = 46 ; pub const _REG_NOTIFY_CLASS_RegNtPreQueryKeyName : _REG_NOTIFY_CLASS = 47 ; pub const _REG_NOTIFY_CLASS_RegNtPostQueryKeyName : _REG_NOTIFY_CLASS = 48 ; pub const _REG_NOTIFY_CLASS_MaxRegNtNotifyClass : _REG_NOTIFY_CLASS = 49 ; pub type _REG_NOTIFY_CLASS = i32 ; pub use self :: _REG_NOTIFY_CLASS as REG_NOTIFY_CLASS ; # [ repr ( C ) ] pub struct _REG_DELETE_KEY_INFORMATION { pub Object : PVOID , pub CallContext : PVOID , pub ObjectContext : PVOID , pub Reserved : PVOID , } pub type REG_DELETE_KEY_INFORMATION = _REG_DELETE_KEY_INFORMATION ; pub type PREG_DELETE_KEY_INFORMATION = * mut _REG_DELETE_KEY_INFORMATION ; pub type REG_FLUSH_KEY_INFORMATION = _REG_DELETE_KEY_INFORMATION ; pub type PREG_FLUSH_KEY_INFORMATION = * mut _REG_DELETE_KEY_INFORMATION ; # [ repr ( C ) ] pub struct _REG_SET_VALUE_KEY_INFORMATION { pub Object : PVOID , pub ValueName : PUNICODE_STRING , pub TitleIndex : ULONG , pub Type : ULONG , pub Data : PVOID , pub DataSize : ULONG , pub CallContext : PVOID , pub ObjectContext : PVOID , pub Reserved : PVOID , } pub type REG_SET_VALUE_KEY_INFORMATION = _REG_SET_VALUE_KEY_INFORMATION ; pub type PREG_SET_VALUE_KEY_INFORMATION = * mut _REG_SET_VALUE_KEY_INFORMATION ; # [ repr ( C ) ] pub struct _REG_DELETE_VALUE_KEY_INFORMATION { pub Object : PVOID , pub ValueName : PUNICODE_STRING , pub CallContext : PVOID , pub ObjectContext : PVOID , pub Reserved : PVOID , } pub type REG_DELETE_VALUE_KEY_INFORMATION = _REG_DELETE_VALUE_KEY_INFORMATION ; pub type PREG_DELETE_VALUE_KEY_INFORMATION = * mut _REG_DELETE_VALUE_KEY_INFORMATION ; # [ repr ( C ) ] pub struct _REG_SET_INFORMATION_KEY_INFORMATION { pub Object : PVOID , pub KeySetInformationClass : KEY_SET_INFORMATION_CLASS , pub KeySetInformation : PVOID , pub KeySetInformationLength : ULONG , pub CallContext : PVOID , pub ObjectContext : PVOID , pub Reserved : PVOID , } pub type REG_SET_INFORMATION_KEY_INFORMATION = _REG_SET_INFORMATION_KEY_INFORMATION ; pub type PREG_SET_INFORMATION_KEY_INFORMATION = * mut _REG_SET_INFORMATION_KEY_INFORMATION ; # [ repr ( C ) ] pub struct _REG_ENUMERATE_KEY_INFORMATION { pub Object : PVOID , pub Index : ULONG , pub KeyInformationClass : KEY_INFORMATION_CLASS , pub KeyInformation : PVOID , pub Length : ULONG , pub ResultLength : PULONG , pub CallContext : PVOID , pub ObjectContext : PVOID , pub Reserved : PVOID , } pub type REG_ENUMERATE_KEY_INFORMATION = _REG_ENUMERATE_KEY_INFORMATION ; pub type PREG_ENUMERATE_KEY_INFORMATION = * mut _REG_ENUMERATE_KEY_INFORMATION ; # [ repr ( C ) ] pub struct _REG_ENUMERATE_VALUE_KEY_INFORMATION { pub Object : PVOID , pub Index : ULONG , pub KeyValueInformationClass : KEY_VALUE_INFORMATION_CLASS , pub KeyValueInformation : PVOID , pub Length : ULONG , pub ResultLength : PULONG , pub CallContext : PVOID , pub ObjectContext : PVOID , pub Reserved : PVOID , } pub type REG_ENUMERATE_VALUE_KEY_INFORMATION = _REG_ENUMERATE_VALUE_KEY_INFORMATION ; pub type PREG_ENUMERATE_VALUE_KEY_INFORMATION = * mut _REG_ENUMERATE_VALUE_KEY_INFORMATION ; # [ repr ( C ) ] pub struct _REG_QUERY_KEY_INFORMATION { pub Object : PVOID , pub KeyInformationClass : KEY_INFORMATION_CLASS , pub KeyInformation : PVOID , pub Length : ULONG , pub ResultLength : PULONG , pub CallContext : PVOID , pub ObjectContext : PVOID , pub Reserved : PVOID , } pub type REG_QUERY_KEY_INFORMATION = _REG_QUERY_KEY_INFORMATION ; pub type PREG_QUERY_KEY_INFORMATION = * mut _REG_QUERY_KEY_INFORMATION ; # [ repr ( C ) ] pub struct _REG_QUERY_VALUE_KEY_INFORMATION { pub Object : PVOID , pub ValueName : PUNICODE_STRING , pub KeyValueInformationClass : KEY_VALUE_INFORMATION_CLASS , pub KeyValueInformation : PVOID , pub Length : ULONG , pub ResultLength : PULONG , pub CallContext : PVOID , pub ObjectContext : PVOID , pub Reserved : PVOID , } pub type REG_QUERY_VALUE_KEY_INFORMATION = _REG_QUERY_VALUE_KEY_INFORMATION ; pub type PREG_QUERY_VALUE_KEY_INFORMATION = * mut _REG_QUERY_VALUE_KEY_INFORMATION ; # [ repr ( C ) ] pub struct _REG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION { pub Object : PVOID , pub ValueEntries : PKEY_VALUE_ENTRY , pub EntryCount : ULONG , pub ValueBuffer : PVOID , pub BufferLength : PULONG , pub RequiredBufferLength : PULONG , pub CallContext : PVOID , pub ObjectContext : PVOID , pub Reserved : PVOID , } pub type REG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION = _REG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION ; pub type PREG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION = * mut _REG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION ; # [ repr ( C ) ] pub struct _REG_RENAME_KEY_INFORMATION { pub Object : PVOID , pub NewName : PUNICODE_STRING , pub CallContext : PVOID , pub ObjectContext : PVOID , pub Reserved : PVOID , } pub type REG_RENAME_KEY_INFORMATION = _REG_RENAME_KEY_INFORMATION ; pub type PREG_RENAME_KEY_INFORMATION = * mut _REG_RENAME_KEY_INFORMATION ; # [ repr ( C ) ] pub struct _REG_KEY_HANDLE_CLOSE_INFORMATION { pub Object : PVOID , pub CallContext : PVOID , pub ObjectContext : PVOID , pub Reserved : PVOID , } pub type REG_KEY_HANDLE_CLOSE_INFORMATION = _REG_KEY_HANDLE_CLOSE_INFORMATION ; pub type PREG_KEY_HANDLE_CLOSE_INFORMATION = * mut _REG_KEY_HANDLE_CLOSE_INFORMATION ; # [ repr ( C ) ] pub struct _REG_CREATE_KEY_INFORMATION { pub CompleteName : PUNICODE_STRING , pub RootObject : PVOID , pub ObjectType : PVOID , pub CreateOptions : ULONG , pub Class : PUNICODE_STRING , pub SecurityDescriptor : PVOID , pub SecurityQualityOfService : PVOID , pub DesiredAccess : ACCESS_MASK , pub GrantedAccess : ACCESS_MASK , pub Disposition : PULONG , pub ResultObject : * mut PVOID , pub CallContext : PVOID , pub RootObjectContext : PVOID , pub Transaction : PVOID , pub Reserved : PVOID , } pub type REG_CREATE_KEY_INFORMATION = _REG_CREATE_KEY_INFORMATION ; pub type REG_OPEN_KEY_INFORMATION = _REG_CREATE_KEY_INFORMATION ; pub type PREG_CREATE_KEY_INFORMATION = * mut _REG_CREATE_KEY_INFORMATION ; pub type PREG_OPEN_KEY_INFORMATION = * mut _REG_CREATE_KEY_INFORMATION ; # [ repr ( C ) ] pub struct _REG_CREATE_KEY_INFORMATION_V1 { pub CompleteName : PUNICODE_STRING , pub RootObject : PVOID , pub ObjectType : PVOID , pub Options : ULONG , pub Class : PUNICODE_STRING , pub SecurityDescriptor : PVOID , pub SecurityQualityOfService : PVOID , pub DesiredAccess : ACCESS_MASK , pub GrantedAccess : ACCESS_MASK , pub Disposition : PULONG , pub ResultObject : * mut PVOID , pub CallContext : PVOID , pub RootObjectContext : PVOID , pub Transaction : PVOID , pub Version : ULONG_PTR , pub RemainingName : PUNICODE_STRING , pub Wow64Flags : ULONG , pub Attributes : ULONG , pub CheckAccessMode : KPROCESSOR_MODE , } pub type REG_CREATE_KEY_INFORMATION_V1 = _REG_CREATE_KEY_INFORMATION_V1 ; pub type REG_OPEN_KEY_INFORMATION_V1 = _REG_CREATE_KEY_INFORMATION_V1 ; pub type PREG_CREATE_KEY_INFORMATION_V1 = * mut _REG_CREATE_KEY_INFORMATION_V1 ; pub type PREG_OPEN_KEY_INFORMATION_V1 = * mut _REG_CREATE_KEY_INFORMATION_V1 ; # [ repr ( C ) ] pub struct _REG_POST_OPERATION_INFORMATION { pub Object : PVOID , pub Status : NTSTATUS , pub PreInformation : PVOID , pub ReturnStatus : NTSTATUS , pub CallContext : PVOID , pub ObjectContext : PVOID , pub Reserved : PVOID , } pub type REG_POST_OPERATION_INFORMATION = _REG_POST_OPERATION_INFORMATION ; pub type PREG_POST_OPERATION_INFORMATION = * mut _REG_POST_OPERATION_INFORMATION ; # [ repr ( C ) ] pub struct _REG_PRE_CREATE_KEY_INFORMATION { pub CompleteName : PUNICODE_STRING , } pub type REG_PRE_CREATE_KEY_INFORMATION = _REG_PRE_CREATE_KEY_INFORMATION ; pub type REG_PRE_OPEN_KEY_INFORMATION = _REG_PRE_CREATE_KEY_INFORMATION ; pub type PREG_PRE_CREATE_KEY_INFORMATION = * mut _REG_PRE_CREATE_KEY_INFORMATION ; pub type PREG_PRE_OPEN_KEY_INFORMATION = * mut _REG_PRE_CREATE_KEY_INFORMATION ; # [ repr ( C ) ] pub struct _REG_POST_CREATE_KEY_INFORMATION { pub CompleteName : PUNICODE_STRING , pub Object : PVOID , pub Status : NTSTATUS , } pub type REG_POST_CREATE_KEY_INFORMATION = _REG_POST_CREATE_KEY_INFORMATION ; pub type REG_POST_OPEN_KEY_INFORMATION = _REG_POST_CREATE_KEY_INFORMATION ; pub type PREG_POST_CREATE_KEY_INFORMATION = * mut _REG_POST_CREATE_KEY_INFORMATION ; pub type PREG_POST_OPEN_KEY_INFORMATION = * mut _REG_POST_CREATE_KEY_INFORMATION ; # [ repr ( C ) ] pub struct _REG_LOAD_KEY_INFORMATION { pub Object : PVOID , pub KeyName : PUNICODE_STRING , pub SourceFile : PUNICODE_STRING , pub Flags : ULONG , pub TrustClassObject : PVOID , pub UserEvent : PVOID , pub DesiredAccess : ACCESS_MASK , pub RootHandle : PHANDLE , pub CallContext : PVOID , pub ObjectContext : PVOID , pub Reserved : PVOID , } pub type REG_LOAD_KEY_INFORMATION = _REG_LOAD_KEY_INFORMATION ; pub type PREG_LOAD_KEY_INFORMATION = * mut _REG_LOAD_KEY_INFORMATION ; # [ repr ( C ) ] pub struct _REG_UNLOAD_KEY_INFORMATION { pub Object : PVOID , pub UserEvent : PVOID , pub CallContext : PVOID , pub ObjectContext : PVOID , pub Reserved : PVOID , } pub type REG_UNLOAD_KEY_INFORMATION = _REG_UNLOAD_KEY_INFORMATION ; pub type PREG_UNLOAD_KEY_INFORMATION = * mut _REG_UNLOAD_KEY_INFORMATION ; # [ repr ( C ) ] pub struct _REG_CALLBACK_CONTEXT_CLEANUP_INFORMATION { pub Object : PVOID , pub ObjectContext : PVOID , pub Reserved : PVOID , } pub type REG_CALLBACK_CONTEXT_CLEANUP_INFORMATION = _REG_CALLBACK_CONTEXT_CLEANUP_INFORMATION ; pub type PREG_CALLBACK_CONTEXT_CLEANUP_INFORMATION = * mut _REG_CALLBACK_CONTEXT_CLEANUP_INFORMATION ; # [ repr ( C ) ] pub struct _REG_QUERY_KEY_SECURITY_INFORMATION { pub Object : PVOID , pub SecurityInformation : PSECURITY_INFORMATION , pub SecurityDescriptor : PSECURITY_DESCRIPTOR , pub Length : PULONG , pub CallContext : PVOID , pub ObjectContext : PVOID , pub Reserved : PVOID , } pub type REG_QUERY_KEY_SECURITY_INFORMATION = _REG_QUERY_KEY_SECURITY_INFORMATION ; pub type PREG_QUERY_KEY_SECURITY_INFORMATION = * mut _REG_QUERY_KEY_SECURITY_INFORMATION ; # [ repr ( C ) ] pub struct _REG_SET_KEY_SECURITY_INFORMATION { pub Object : PVOID , pub SecurityInformation : PSECURITY_INFORMATION , pub SecurityDescriptor : PSECURITY_DESCRIPTOR , pub CallContext : PVOID , pub ObjectContext : PVOID , pub Reserved : PVOID , } pub type REG_SET_KEY_SECURITY_INFORMATION = _REG_SET_KEY_SECURITY_INFORMATION ; pub type PREG_SET_KEY_SECURITY_INFORMATION = * mut _REG_SET_KEY_SECURITY_INFORMATION ; # [ repr ( C ) ] pub struct _REG_RESTORE_KEY_INFORMATION { pub Object : PVOID , pub FileHandle : HANDLE , pub Flags : ULONG , pub CallContext : PVOID , pub ObjectContext : PVOID , pub Reserved : PVOID , } pub type REG_RESTORE_KEY_INFORMATION = _REG_RESTORE_KEY_INFORMATION ; pub type PREG_RESTORE_KEY_INFORMATION = * mut _REG_RESTORE_KEY_INFORMATION ; # [ repr ( C ) ] pub struct _REG_SAVE_KEY_INFORMATION { pub Object : PVOID , pub FileHandle : HANDLE , pub Format : ULONG , pub CallContext : PVOID , pub ObjectContext : PVOID , pub Reserved : PVOID , } pub type REG_SAVE_KEY_INFORMATION = _REG_SAVE_KEY_INFORMATION ; pub type PREG_SAVE_KEY_INFORMATION = * mut _REG_SAVE_KEY_INFORMATION ; # [ repr ( C ) ] pub struct _REG_REPLACE_KEY_INFORMATION { pub Object : PVOID , pub OldFileName : PUNICODE_STRING , pub NewFileName : PUNICODE_STRING , pub CallContext : PVOID , pub ObjectContext : PVOID , pub Reserved : PVOID , } pub type REG_REPLACE_KEY_INFORMATION = _REG_REPLACE_KEY_INFORMATION ; pub type PREG_REPLACE_KEY_INFORMATION = * mut _REG_REPLACE_KEY_INFORMATION ; # [ repr ( C ) ] pub struct _REG_QUERY_KEY_NAME { pub Object : PVOID , pub ObjectNameInfo : POBJECT_NAME_INFORMATION , pub Length : ULONG , pub ReturnLength : PULONG , pub CallContext : PVOID , pub ObjectContext : PVOID , pub Reserved : PVOID , } pub type REG_QUERY_KEY_NAME = _REG_QUERY_KEY_NAME ; pub type PREG_QUERY_KEY_NAME = * mut _REG_QUERY_KEY_NAME ; extern "C" { pub fn CmRegisterCallback ( Function : PEX_CALLBACK_FUNCTION , Context : PVOID , Cookie : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn CmUnRegisterCallback ( Cookie : LARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn CmRegisterCallbackEx ( Function : PEX_CALLBACK_FUNCTION , Altitude : PCUNICODE_STRING , Driver : PVOID , Context : PVOID , Cookie : PLARGE_INTEGER , Reserved : PVOID ) -> NTSTATUS ; } extern "C" { pub fn CmGetCallbackVersion ( Major : PULONG , Minor : PULONG ) ; } extern "C" { pub fn CmSetCallbackObjectContext ( Object : PVOID , Cookie : PLARGE_INTEGER , NewContext : PVOID , OldContext : * mut PVOID ) -> NTSTATUS ; } extern "C" { pub fn CmCallbackGetKeyObjectID ( Cookie : PLARGE_INTEGER , Object : PVOID , ObjectID : PULONG_PTR , ObjectName : * mut PCUNICODE_STRING ) -> NTSTATUS ; } extern "C" { pub fn CmGetBoundTransaction ( Cookie : PLARGE_INTEGER , Object : PVOID ) -> PVOID ; } extern "C" { pub fn CmCallbackGetKeyObjectIDEx ( Cookie : PLARGE_INTEGER , Object : PVOID , ObjectID : PULONG_PTR , ObjectName : * mut PCUNICODE_STRING , Flags : ULONG ) -> NTSTATUS ; } extern "C" { pub fn CmCallbackReleaseKeyObjectIDEx ( ObjectName : PCUNICODE_STRING ) ; } extern "C" { # [ link_name = "\u{1}Mm64BitPhysicalAddress" ] pub static mut Mm64BitPhysicalAddress : PBOOLEAN ; } extern "C" { # [ link_name = "\u{1}MmBadPointer" ] pub static mut MmBadPointer : PVOID ; } pub const _MM_SYSTEM_SIZE_MmSmallSystem : _MM_SYSTEM_SIZE = 0 ; pub const _MM_SYSTEM_SIZE_MmMediumSystem : _MM_SYSTEM_SIZE = 1 ; pub const _MM_SYSTEM_SIZE_MmLargeSystem : _MM_SYSTEM_SIZE = 2 ; pub type _MM_SYSTEM_SIZE = i32 ; pub use self :: _MM_SYSTEM_SIZE as MM_SYSTEMSIZE ; extern "C" { pub fn MmQuerySystemSize ( ) -> MM_SYSTEMSIZE ; } extern "C" { pub fn MmIsVerifierEnabled ( VerifierFlags : PULONG ) -> NTSTATUS ; } extern "C" { pub fn MmAddVerifierThunks ( ThunkBuffer : PVOID , ThunkBufferSize : ULONG ) -> NTSTATUS ; } extern "C" { pub fn MmAddVerifierSpecialThunks ( EntryRoutine : ULONG_PTR , ThunkBuffer : PVOID , ThunkBufferSize : ULONG ) -> NTSTATUS ; } extern "C" { pub fn MmProbeAndLockSelectedPages ( MemoryDescriptorList : PMDL , SegmentArray : PFILE_SEGMENT_ELEMENT , AccessMode : KPROCESSOR_MODE , Operation : LOCK_OPERATION ) ; } extern "C" { pub fn MmProbeAndLockProcessPages ( MemoryDescriptorList : PMDL , Process : PEPROCESS , AccessMode : KPROCESSOR_MODE , Operation : LOCK_OPERATION ) ; } extern "C" { pub fn MmProbeAndLockPages ( MemoryDescriptorList : PMDL , AccessMode : KPROCESSOR_MODE , Operation : LOCK_OPERATION ) ; } extern "C" { pub fn MmUnlockPages ( MemoryDescriptorList : PMDL ) ; } extern "C" { pub fn MmBuildMdlForNonPagedPool ( MemoryDescriptorList : PMDL ) ; } # [ repr ( C ) ] pub struct _MM_PHYSICAL_ADDRESS_LIST { pub PhysicalAddress : PHYSICAL_ADDRESS , pub NumberOfBytes : SIZE_T , } pub type MM_PHYSICAL_ADDRESS_LIST = _MM_PHYSICAL_ADDRESS_LIST ; pub type PMM_PHYSICAL_ADDRESS_LIST = * mut _MM_PHYSICAL_ADDRESS_LIST ; extern "C" { pub fn MmAllocateMdlForIoSpace ( PhysicalAddressList : PMM_PHYSICAL_ADDRESS_LIST , NumberOfEntries : SIZE_T , NewMdl : * mut PMDL ) -> NTSTATUS ; } extern "C" { pub fn MmAreMdlPagesCached ( MemoryDescriptorList : PMDL ) -> LOGICAL ; } extern "C" { pub fn MmSetPermanentCacheAttribute ( StartAddress : PHYSICAL_ADDRESS , NumberOfBytes : LARGE_INTEGER , CacheType : MEMORY_CACHING_TYPE , Flags : ULONG ) -> NTSTATUS ; } extern "C" { pub fn MmMapLockedPages ( MemoryDescriptorList : PMDL , AccessMode : KPROCESSOR_MODE ) -> PVOID ; } pub type MM_MDL_ROUTINE = :: std :: option :: Option < unsafe extern "C" fn ( DriverContext : PVOID , MappedVa : PVOID ) > ; pub type PMM_MDL_ROUTINE = MM_MDL_ROUTINE ; extern "C" { pub fn MmMapMdl ( MemoryDescriptorList : PMDL , Protection : ULONG , DriverRoutine : PMM_MDL_ROUTINE , DriverContext : PVOID ) -> NTSTATUS ; } extern "C" { pub fn MmIsIoSpaceActive ( StartAddress : PHYSICAL_ADDRESS , NumberOfBytes : SIZE_T ) -> LOGICAL ; } extern "C" { pub fn MmAdvanceMdl ( Mdl : PMDL , NumberOfBytes : ULONG ) -> NTSTATUS ; } extern "C" { pub fn MmProtectMdlSystemAddress ( MemoryDescriptorList : PMDL , NewProtect : ULONG ) -> NTSTATUS ; } pub const _MM_PAGE_PRIORITY_LowPagePriority : _MM_PAGE_PRIORITY = 0 ; pub const _MM_PAGE_PRIORITY_NormalPagePriority : _MM_PAGE_PRIORITY = 16 ; pub const _MM_PAGE_PRIORITY_HighPagePriority : _MM_PAGE_PRIORITY = 32 ; pub type _MM_PAGE_PRIORITY = i32 ; pub use self :: _MM_PAGE_PRIORITY as MM_PAGE_PRIORITY ; extern "C" { pub fn MmMapLockedPagesSpecifyCache ( MemoryDescriptorList : PMDL , AccessMode : KPROCESSOR_MODE , CacheType : MEMORY_CACHING_TYPE , RequestedAddress : PVOID , BugCheckOnFailure : ULONG , Priority : ULONG ) -> PVOID ; } extern "C" { pub fn MmUnmapLockedPages ( BaseAddress : PVOID , MemoryDescriptorList : PMDL ) ; } extern "C" { pub fn MmAllocateMappingAddress ( NumberOfBytes : SIZE_T , PoolTag : ULONG ) -> PVOID ; } extern "C" { pub fn MmFreeMappingAddress ( BaseAddress : PVOID , PoolTag : ULONG ) ; } extern "C" { pub fn MmMapLockedPagesWithReservedMapping ( MappingAddress : PVOID , PoolTag : ULONG , MemoryDescriptorList : PMDL , CacheType : MEMORY_CACHING_TYPE ) -> PVOID ; } extern "C" { pub fn MmUnmapReservedMapping ( BaseAddress : PVOID , PoolTag : ULONG , MemoryDescriptorList : PMDL ) ; } extern "C" { pub fn MmAllocateNodePagesForMdlEx ( LowAddress : PHYSICAL_ADDRESS , HighAddress : PHYSICAL_ADDRESS , SkipBytes : PHYSICAL_ADDRESS , TotalBytes : SIZE_T , CacheType : MEMORY_CACHING_TYPE , IdealNode : ULONG , Flags : ULONG ) -> PMDL ; } extern "C" { pub fn MmAllocatePartitionNodePagesForMdlEx ( LowAddress : PHYSICAL_ADDRESS , HighAddress : PHYSICAL_ADDRESS , SkipBytes : PHYSICAL_ADDRESS , TotalBytes : SIZE_T , CacheType : MEMORY_CACHING_TYPE , IdealNode : ULONG , Flags : ULONG , PartitionObject : PVOID ) -> PMDL ; } extern "C" { pub fn MmAllocatePagesForMdlEx ( LowAddress : PHYSICAL_ADDRESS , HighAddress : PHYSICAL_ADDRESS , SkipBytes : PHYSICAL_ADDRESS , TotalBytes : SIZE_T , CacheType : MEMORY_CACHING_TYPE , Flags : ULONG ) -> PMDL ; } extern "C" { pub fn MmAllocatePagesForMdl ( LowAddress : PHYSICAL_ADDRESS , HighAddress : PHYSICAL_ADDRESS , SkipBytes : PHYSICAL_ADDRESS , TotalBytes : SIZE_T ) -> PMDL ; } extern "C" { pub fn MmFreePagesFromMdlEx ( MemoryDescriptorList : PMDL , Flags : ULONG ) ; } extern "C" { pub fn MmFreePagesFromMdl ( MemoryDescriptorList : PMDL ) ; } extern "C" { pub fn MmMapIoSpace ( PhysicalAddress : PHYSICAL_ADDRESS , NumberOfBytes : SIZE_T , CacheType : MEMORY_CACHING_TYPE ) -> PVOID ; } extern "C" { pub fn MmUnmapIoSpace ( BaseAddress : PVOID , NumberOfBytes : SIZE_T ) ; } extern "C" { pub fn MmMapIoSpaceEx ( PhysicalAddress : PHYSICAL_ADDRESS , NumberOfBytes : SIZE_T , Protect : ULONG ) -> PVOID ; } extern "C" { pub fn MmAllocateContiguousMemory ( NumberOfBytes : SIZE_T , HighestAcceptableAddress : PHYSICAL_ADDRESS ) -> PVOID ; } extern "C" { pub fn MmAllocateContiguousMemorySpecifyCache ( NumberOfBytes : SIZE_T , LowestAcceptableAddress : PHYSICAL_ADDRESS , HighestAcceptableAddress : PHYSICAL_ADDRESS , BoundaryAddressMultiple : PHYSICAL_ADDRESS , CacheType : MEMORY_CACHING_TYPE ) -> PVOID ; } pub type NODE_REQUIREMENT = ULONG ; extern "C" { pub fn MmAllocateContiguousMemorySpecifyCacheNode ( NumberOfBytes : SIZE_T , LowestAcceptableAddress : PHYSICAL_ADDRESS , HighestAcceptableAddress : PHYSICAL_ADDRESS , BoundaryAddressMultiple : PHYSICAL_ADDRESS , CacheType : MEMORY_CACHING_TYPE , PreferredNode : NODE_REQUIREMENT ) -> PVOID ; } extern "C" { pub fn MmAllocateContiguousNodeMemory ( NumberOfBytes : SIZE_T , LowestAcceptableAddress : PHYSICAL_ADDRESS , HighestAcceptableAddress : PHYSICAL_ADDRESS , BoundaryAddressMultiple : PHYSICAL_ADDRESS , Protect : ULONG , PreferredNode : NODE_REQUIREMENT ) -> PVOID ; } extern "C" { pub fn MmFreeContiguousMemory ( BaseAddress : PVOID ) ; } extern "C" { pub fn MmFreeContiguousMemorySpecifyCache ( BaseAddress : PVOID , NumberOfBytes : SIZE_T , CacheType : MEMORY_CACHING_TYPE ) ; } extern "C" { pub fn MmSizeOfMdl ( Base : PVOID , Length : SIZE_T ) -> SIZE_T ; } extern "C" { pub fn MmCreateMdl ( MemoryDescriptorList : PMDL , Base : PVOID , Length : SIZE_T ) -> PMDL ; } pub const _MM_MDL_PAGE_CONTENTS_STATE_MmMdlPageContentsDynamic : _MM_MDL_PAGE_CONTENTS_STATE = 0 ; pub const _MM_MDL_PAGE_CONTENTS_STATE_MmMdlPageContentsInvariant : _MM_MDL_PAGE_CONTENTS_STATE = 1 ; pub const _MM_MDL_PAGE_CONTENTS_STATE_MmMdlPageContentsQuery : _MM_MDL_PAGE_CONTENTS_STATE = 2 ; pub type _MM_MDL_PAGE_CONTENTS_STATE = i32 ; pub use self :: _MM_MDL_PAGE_CONTENTS_STATE as MM_MDL_PAGE_CONTENTS_STATE ; pub use self :: _MM_MDL_PAGE_CONTENTS_STATE as PMM_MDL_PAGE_CONTENTS_STATE ; extern "C" { pub fn MmMdlPageContentsState ( MemoryDescriptorList : PMDL , State : MM_MDL_PAGE_CONTENTS_STATE ) -> MM_MDL_PAGE_CONTENTS_STATE ; } extern "C" { pub fn MmLockPagableDataSection ( AddressWithinSection : PVOID ) -> PVOID ; } extern "C" { pub fn MmResetDriverPaging ( AddressWithinSection : PVOID ) ; } extern "C" { pub fn MmPageEntireDriver ( AddressWithinSection : PVOID ) -> PVOID ; } extern "C" { pub fn MmUnlockPagableImageSection ( ImageSectionHandle : PVOID ) ; } pub type PMM_DLL_INITIALIZE = :: std :: option :: Option < unsafe extern "C" fn ( RegistryPath : PUNICODE_STRING ) -> NTSTATUS > ; pub type PMM_DLL_UNLOAD = :: std :: option :: Option < unsafe extern "C" fn ( ) -> NTSTATUS > ; extern "C" { pub fn MmIsDriverSuspectForVerifier ( DriverObject : * mut _DRIVER_OBJECT ) -> LOGICAL ; } extern "C" { pub fn MmIsDriverVerifying ( DriverObject : * mut _DRIVER_OBJECT ) -> LOGICAL ; } extern "C" { pub fn MmIsDriverVerifyingByAddress ( AddressWithinSection : PVOID ) -> LOGICAL ; } pub const _SECURITY_OPERATION_CODE_SetSecurityDescriptor : _SECURITY_OPERATION_CODE = 0 ; pub const _SECURITY_OPERATION_CODE_QuerySecurityDescriptor : _SECURITY_OPERATION_CODE = 1 ; pub const _SECURITY_OPERATION_CODE_DeleteSecurityDescriptor : _SECURITY_OPERATION_CODE = 2 ; pub const _SECURITY_OPERATION_CODE_AssignSecurityDescriptor : _SECURITY_OPERATION_CODE = 3 ; pub type _SECURITY_OPERATION_CODE = i32 ; pub use self :: _SECURITY_OPERATION_CODE as SECURITY_OPERATION_CODE ; pub type PSECURITY_OPERATION_CODE = * mut _SECURITY_OPERATION_CODE ; # [ repr ( C ) ] pub struct _SECURITY_SUBJECT_CONTEXT { pub ClientToken : PACCESS_TOKEN , pub ImpersonationLevel : SECURITY_IMPERSONATION_LEVEL , pub PrimaryToken : PACCESS_TOKEN , pub ProcessAuditId : PVOID , } pub type SECURITY_SUBJECT_CONTEXT = _SECURITY_SUBJECT_CONTEXT ; pub type PSECURITY_SUBJECT_CONTEXT = * mut _SECURITY_SUBJECT_CONTEXT ; # [ repr ( C ) ] pub struct _INITIAL_PRIVILEGE_SET { pub PrivilegeCount : ULONG , pub Control : ULONG , pub Privilege : [ LUID_AND_ATTRIBUTES ; 3usize ] , } pub type INITIAL_PRIVILEGE_SET = _INITIAL_PRIVILEGE_SET ; pub type PINITIAL_PRIVILEGE_SET = * mut _INITIAL_PRIVILEGE_SET ; # [ repr ( C ) ] pub struct _ACCESS_STATE { pub OperationID : LUID , pub SecurityEvaluated : BOOLEAN , pub GenerateAudit : BOOLEAN , pub GenerateOnClose : BOOLEAN , pub PrivilegesAllocated : BOOLEAN , pub Flags : ULONG , pub RemainingDesiredAccess : ACCESS_MASK , pub PreviouslyGrantedAccess : ACCESS_MASK , pub OriginalDesiredAccess : ACCESS_MASK , pub SubjectSecurityContext : SECURITY_SUBJECT_CONTEXT , pub SecurityDescriptor : PSECURITY_DESCRIPTOR , pub AuxData : PVOID , pub Privileges : _ACCESS_STATE__bindgen_ty_1 , pub AuditPrivileges : BOOLEAN , pub ObjectName : UNICODE_STRING , pub ObjectTypeName : UNICODE_STRING , } # [ repr ( C ) ] pub struct _ACCESS_STATE__bindgen_ty_1 { pub InitialPrivilegeSet : __BindgenUnionField < INITIAL_PRIVILEGE_SET > , pub PrivilegeSet : __BindgenUnionField < PRIVILEGE_SET > , pub bindgen_union_field : [ u32 ; 11usize ] , } pub type ACCESS_STATE = _ACCESS_STATE ; pub type NTFS_DEREF_EXPORTED_SECURITY_DESCRIPTOR = :: std :: option :: Option < unsafe extern "C" fn ( Vcb : PVOID , SecurityDescriptor : PSECURITY_DESCRIPTOR ) > ; pub type PNTFS_DEREF_EXPORTED_SECURITY_DESCRIPTOR = NTFS_DEREF_EXPORTED_SECURITY_DESCRIPTOR ; extern "C" { pub fn SeCaptureSubjectContext ( SubjectContext : PSECURITY_SUBJECT_CONTEXT ) ; } extern "C" { pub fn SeLockSubjectContext ( SubjectContext : PSECURITY_SUBJECT_CONTEXT ) ; } extern "C" { pub fn SeUnlockSubjectContext ( SubjectContext : PSECURITY_SUBJECT_CONTEXT ) ; } extern "C" { pub fn SeReleaseSubjectContext ( SubjectContext : PSECURITY_SUBJECT_CONTEXT ) ; } extern "C" { pub fn SeAssignSecurity ( ParentDescriptor : PSECURITY_DESCRIPTOR , ExplicitDescriptor : PSECURITY_DESCRIPTOR , NewDescriptor : * mut PSECURITY_DESCRIPTOR , IsDirectoryObject : BOOLEAN , SubjectContext : PSECURITY_SUBJECT_CONTEXT , GenericMapping : PGENERIC_MAPPING , PoolType : POOL_TYPE ) -> NTSTATUS ; } extern "C" { pub fn SeComputeAutoInheritByObjectType ( ObjectType : PVOID , SecurityDescriptor : PSECURITY_DESCRIPTOR , ParentSecurityDescriptor : PSECURITY_DESCRIPTOR ) -> ULONG ; } extern "C" { pub fn SeAssignSecurityEx ( ParentDescriptor : PSECURITY_DESCRIPTOR , ExplicitDescriptor : PSECURITY_DESCRIPTOR , NewDescriptor : * mut PSECURITY_DESCRIPTOR , ObjectType : * mut GUID , IsDirectoryObject : BOOLEAN , AutoInheritFlags : ULONG , SubjectContext : PSECURITY_SUBJECT_CONTEXT , GenericMapping : PGENERIC_MAPPING , PoolType : POOL_TYPE ) -> NTSTATUS ; } extern "C" { pub fn SeDeassignSecurity ( SecurityDescriptor : * mut PSECURITY_DESCRIPTOR ) -> NTSTATUS ; } extern "C" { pub fn SeObjectCreateSaclAccessBits ( SecurityDescriptor : PSECURITY_DESCRIPTOR ) -> ULONG ; } extern "C" { pub fn SeAccessCheck ( SecurityDescriptor : PSECURITY_DESCRIPTOR , SubjectSecurityContext : PSECURITY_SUBJECT_CONTEXT , SubjectContextLocked : BOOLEAN , DesiredAccess : ACCESS_MASK , PreviouslyGrantedAccess : ACCESS_MASK , Privileges : * mut PPRIVILEGE_SET , GenericMapping : PGENERIC_MAPPING , AccessMode : KPROCESSOR_MODE , GrantedAccess : PACCESS_MASK , AccessStatus : PNTSTATUS ) -> BOOLEAN ; } extern "C" { pub fn SeSetAuditParameter ( AuditParameters : PSE_ADT_PARAMETER_ARRAY , Type : SE_ADT_PARAMETER_TYPE , Index : ULONG , Data : PVOID ) -> NTSTATUS ; } extern "C" { pub fn SeReportSecurityEvent ( Flags : ULONG , SourceName : PUNICODE_STRING , UserSid : PSID , AuditParameters : PSE_ADT_PARAMETER_ARRAY ) -> NTSTATUS ; } extern "C" { pub fn SeValidSecurityDescriptor ( Length : ULONG , SecurityDescriptor : PSECURITY_DESCRIPTOR ) -> BOOLEAN ; } pub const _SE_IMAGE_TYPE_SeImageTypeElamDriver : _SE_IMAGE_TYPE = 0 ; pub const _SE_IMAGE_TYPE_SeImageTypeDriver : _SE_IMAGE_TYPE = 1 ; pub const _SE_IMAGE_TYPE_SeImageTypePlatformSecureFile : _SE_IMAGE_TYPE = 2 ; pub const _SE_IMAGE_TYPE_SeImageTypeMax : _SE_IMAGE_TYPE = 3 ; pub type _SE_IMAGE_TYPE = i32 ; pub use self :: _SE_IMAGE_TYPE as SE_IMAGE_TYPE ; pub type PSE_IMAGE_TYPE = * mut _SE_IMAGE_TYPE ; pub type PBDCB_IMAGE_INFORMATION = * mut _BDCB_IMAGE_INFORMATION ; pub type SE_IMAGE_VERIFICATION_CALLBACK_FUNCTION = :: std :: option :: Option < unsafe extern "C" fn ( CallbackContext : PVOID , ImageType : SE_IMAGE_TYPE , ImageInformation : PBDCB_IMAGE_INFORMATION ) > ; pub type PSE_IMAGE_VERIFICATION_CALLBACK_FUNCTION = SE_IMAGE_VERIFICATION_CALLBACK_FUNCTION ; pub const _SE_IMAGE_VERIFICATION_CALLBACK_TYPE_SeImageVerificationCallbackInformational : _SE_IMAGE_VERIFICATION_CALLBACK_TYPE = 0 ; pub type _SE_IMAGE_VERIFICATION_CALLBACK_TYPE = i32 ; pub use self :: _SE_IMAGE_VERIFICATION_CALLBACK_TYPE as SE_IMAGE_VERIFICATION_CALLBACK_TYPE ; pub type PSE_IMAGE_VERIFICATION_CALLBACK_TYPE = * mut _SE_IMAGE_VERIFICATION_CALLBACK_TYPE ; pub type SE_IMAGE_VERIFICATION_CALLBACK_TOKEN = PVOID ; pub type PSE_IMAGE_VERIFICATION_CALLBACK_TOKEN = * mut PVOID ; extern "C" { pub fn SeRegisterImageVerificationCallback ( ImageType : SE_IMAGE_TYPE , CallbackType : SE_IMAGE_VERIFICATION_CALLBACK_TYPE , CallbackFunction : PSE_IMAGE_VERIFICATION_CALLBACK_FUNCTION , CallbackContext : PVOID , Token : SE_IMAGE_VERIFICATION_CALLBACK_TOKEN , CallbackHandle : * mut PVOID ) -> NTSTATUS ; } extern "C" { pub fn SeUnregisterImageVerificationCallback ( CallbackHandle : PVOID ) ; } extern "C" { pub fn PsCreateSystemThread ( ThreadHandle : PHANDLE , DesiredAccess : ULONG , ObjectAttributes : POBJECT_ATTRIBUTES , ProcessHandle : HANDLE , ClientId : PCLIENT_ID , StartRoutine : PKSTART_ROUTINE , StartContext : PVOID ) -> NTSTATUS ; } extern "C" { pub fn PsTerminateSystemThread ( ExitStatus : NTSTATUS ) -> NTSTATUS ; } extern "C" { pub fn PsWrapApcWow64Thread ( ApcContext : * mut PVOID , ApcRoutine : * mut PVOID ) -> NTSTATUS ; } extern "C" { pub fn PsGetVersion ( MajorVersion : PULONG , MinorVersion : PULONG , BuildNumber : PULONG , CSDVersion : PUNICODE_STRING ) -> BOOLEAN ; } extern "C" { pub fn PsQueryTotalCycleTimeProcess ( Process : PEPROCESS , CycleTimeStamp : PULONG64 ) -> ULONG64 ; } pub const _CREATE_FILE_TYPE_CreateFileTypeNone : _CREATE_FILE_TYPE = 0 ; pub const _CREATE_FILE_TYPE_CreateFileTypeNamedPipe : _CREATE_FILE_TYPE = 1 ; pub const _CREATE_FILE_TYPE_CreateFileTypeMailslot : _CREATE_FILE_TYPE = 2 ; pub type _CREATE_FILE_TYPE = i32 ; pub use self :: _CREATE_FILE_TYPE as CREATE_FILE_TYPE ; # [ repr ( C ) ] pub struct _NAMED_PIPE_CREATE_PARAMETERS { pub NamedPipeType : ULONG , pub ReadMode : ULONG , pub CompletionMode : ULONG , pub MaximumInstances : ULONG , pub InboundQuota : ULONG , pub OutboundQuota : ULONG , pub DefaultTimeout : LARGE_INTEGER , pub TimeoutSpecified : BOOLEAN , } pub type NAMED_PIPE_CREATE_PARAMETERS = _NAMED_PIPE_CREATE_PARAMETERS ; pub type PNAMED_PIPE_CREATE_PARAMETERS = * mut _NAMED_PIPE_CREATE_PARAMETERS ; # [ repr ( C ) ] pub struct _MAILSLOT_CREATE_PARAMETERS { pub MailslotQuota : ULONG , pub MaximumMessageSize : ULONG , pub ReadTimeout : LARGE_INTEGER , pub TimeoutSpecified : BOOLEAN , } pub type MAILSLOT_CREATE_PARAMETERS = _MAILSLOT_CREATE_PARAMETERS ; pub type PMAILSLOT_CREATE_PARAMETERS = * mut _MAILSLOT_CREATE_PARAMETERS ; # [ repr ( C ) ] pub struct _DRIVE_LAYOUT_INFORMATION { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] pub struct _DISK_PARTITION { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] pub struct _SCSI_REQUEST_BLOCK { _unused : [ u8 ; 0 ] , } pub type IO_DPC_ROUTINE = :: std :: option :: Option < unsafe extern "C" fn ( Dpc : PKDPC , DeviceObject : * mut _DEVICE_OBJECT , Irp : * mut _IRP , Context : PVOID ) > ; pub type PIO_DPC_ROUTINE = IO_DPC_ROUTINE ; pub type IO_TIMER_ROUTINE = :: std :: option :: Option < unsafe extern "C" fn ( DeviceObject : * mut _DEVICE_OBJECT , Context : PVOID ) > ; pub type PIO_TIMER_ROUTINE = IO_TIMER_ROUTINE ; pub type DRIVER_INITIALIZE = :: std :: option :: Option < unsafe extern "C" fn ( DriverObject : * mut _DRIVER_OBJECT , RegistryPath : PUNICODE_STRING ) -> NTSTATUS > ; pub type PDRIVER_INITIALIZE = DRIVER_INITIALIZE ; pub type DRIVER_CANCEL = :: std :: option :: Option < unsafe extern "C" fn ( DeviceObject : * mut _DEVICE_OBJECT , Irp : * mut _IRP ) > ; pub type PDRIVER_CANCEL = DRIVER_CANCEL ; pub type DRIVER_DISPATCH = :: std :: option :: Option < unsafe extern "C" fn ( DeviceObject : * mut _DEVICE_OBJECT , Irp : * mut _IRP ) -> NTSTATUS > ; pub type PDRIVER_DISPATCH = DRIVER_DISPATCH ; pub type DRIVER_DISPATCH_RAISED = DRIVER_DISPATCH ; pub type DRIVER_DISPATCH_PAGED = :: std :: option :: Option < unsafe extern "C" fn ( DeviceObject : * mut _DEVICE_OBJECT , Irp : * mut _IRP ) -> NTSTATUS > ; pub type PDRIVER_DISPATCH_PAGED = DRIVER_DISPATCH_PAGED ; pub type DRIVER_STARTIO = :: std :: option :: Option < unsafe extern "C" fn ( DeviceObject : * mut _DEVICE_OBJECT , Irp : * mut _IRP ) > ; pub type PDRIVER_STARTIO = DRIVER_STARTIO ; pub type DRIVER_UNLOAD = :: std :: option :: Option < unsafe extern "C" fn ( DriverObject : * mut _DRIVER_OBJECT ) > ; pub type PDRIVER_UNLOAD = DRIVER_UNLOAD ; pub type DRIVER_ADD_DEVICE = :: std :: option :: Option < unsafe extern "C" fn ( DriverObject : * mut _DRIVER_OBJECT , PhysicalDeviceObject : * mut _DEVICE_OBJECT ) -> NTSTATUS > ; pub type PDRIVER_ADD_DEVICE = DRIVER_ADD_DEVICE ; pub type FAST_IO_CHECK_IF_POSSIBLE = :: std :: option :: Option < unsafe extern "C" fn ( FileObject : * mut _FILE_OBJECT , FileOffset : PLARGE_INTEGER , Length : ULONG , Wait : BOOLEAN , LockKey : ULONG , CheckForReadOperation : BOOLEAN , IoStatus : PIO_STATUS_BLOCK , DeviceObject : * mut _DEVICE_OBJECT ) -> BOOLEAN > ; pub type PFAST_IO_CHECK_IF_POSSIBLE = FAST_IO_CHECK_IF_POSSIBLE ; pub type FAST_IO_READ = :: std :: option :: Option < unsafe extern "C" fn ( FileObject : * mut _FILE_OBJECT , FileOffset : PLARGE_INTEGER , Length : ULONG , Wait : BOOLEAN , LockKey : ULONG , Buffer : PVOID , IoStatus : PIO_STATUS_BLOCK , DeviceObject : * mut _DEVICE_OBJECT ) -> BOOLEAN > ; pub type PFAST_IO_READ = FAST_IO_READ ; pub type FAST_IO_WRITE = :: std :: option :: Option < unsafe extern "C" fn ( FileObject : * mut _FILE_OBJECT , FileOffset : PLARGE_INTEGER , Length : ULONG , Wait : BOOLEAN , LockKey : ULONG , Buffer : PVOID , IoStatus : PIO_STATUS_BLOCK , DeviceObject : * mut _DEVICE_OBJECT ) -> BOOLEAN > ; pub type PFAST_IO_WRITE = FAST_IO_WRITE ; pub type FAST_IO_QUERY_BASIC_INFO = :: std :: option :: Option < unsafe extern "C" fn ( FileObject : * mut _FILE_OBJECT , Wait : BOOLEAN , Buffer : PFILE_BASIC_INFORMATION , IoStatus : PIO_STATUS_BLOCK , DeviceObject : * mut _DEVICE_OBJECT ) -> BOOLEAN > ; pub type PFAST_IO_QUERY_BASIC_INFO = FAST_IO_QUERY_BASIC_INFO ; pub type FAST_IO_QUERY_STANDARD_INFO = :: std :: option :: Option < unsafe extern "C" fn ( FileObject : * mut _FILE_OBJECT , Wait : BOOLEAN , Buffer : PFILE_STANDARD_INFORMATION , IoStatus : PIO_STATUS_BLOCK , DeviceObject : * mut _DEVICE_OBJECT ) -> BOOLEAN > ; pub type PFAST_IO_QUERY_STANDARD_INFO = FAST_IO_QUERY_STANDARD_INFO ; pub type FAST_IO_LOCK = :: std :: option :: Option < unsafe extern "C" fn ( FileObject : * mut _FILE_OBJECT , FileOffset : PLARGE_INTEGER , Length : PLARGE_INTEGER , ProcessId : PEPROCESS , Key : ULONG , FailImmediately : BOOLEAN , ExclusiveLock : BOOLEAN , IoStatus : PIO_STATUS_BLOCK , DeviceObject : * mut _DEVICE_OBJECT ) -> BOOLEAN > ; pub type PFAST_IO_LOCK = FAST_IO_LOCK ; pub type FAST_IO_UNLOCK_SINGLE = :: std :: option :: Option < unsafe extern "C" fn ( FileObject : * mut _FILE_OBJECT , FileOffset : PLARGE_INTEGER , Length : PLARGE_INTEGER , ProcessId : PEPROCESS , Key : ULONG , IoStatus : PIO_STATUS_BLOCK , DeviceObject : * mut _DEVICE_OBJECT ) -> BOOLEAN > ; pub type PFAST_IO_UNLOCK_SINGLE = FAST_IO_UNLOCK_SINGLE ; pub type FAST_IO_UNLOCK_ALL = :: std :: option :: Option < unsafe extern "C" fn ( FileObject : * mut _FILE_OBJECT , ProcessId : PEPROCESS , IoStatus : PIO_STATUS_BLOCK , DeviceObject : * mut _DEVICE_OBJECT ) -> BOOLEAN > ; pub type PFAST_IO_UNLOCK_ALL = FAST_IO_UNLOCK_ALL ; pub type FAST_IO_UNLOCK_ALL_BY_KEY = :: std :: option :: Option < unsafe extern "C" fn ( FileObject : * mut _FILE_OBJECT , ProcessId : PVOID , Key : ULONG , IoStatus : PIO_STATUS_BLOCK , DeviceObject : * mut _DEVICE_OBJECT ) -> BOOLEAN > ; pub type PFAST_IO_UNLOCK_ALL_BY_KEY = FAST_IO_UNLOCK_ALL_BY_KEY ; pub type FAST_IO_DEVICE_CONTROL = :: std :: option :: Option < unsafe extern "C" fn ( FileObject : * mut _FILE_OBJECT , Wait : BOOLEAN , InputBuffer : PVOID , InputBufferLength : ULONG , OutputBuffer : PVOID , OutputBufferLength : ULONG , IoControlCode : ULONG , IoStatus : PIO_STATUS_BLOCK , DeviceObject : * mut _DEVICE_OBJECT ) -> BOOLEAN > ; pub type PFAST_IO_DEVICE_CONTROL = FAST_IO_DEVICE_CONTROL ; pub type FAST_IO_ACQUIRE_FILE = :: std :: option :: Option < unsafe extern "C" fn ( FileObject : * mut _FILE_OBJECT ) > ; pub type PFAST_IO_ACQUIRE_FILE = FAST_IO_ACQUIRE_FILE ; pub type FAST_IO_RELEASE_FILE = :: std :: option :: Option < unsafe extern "C" fn ( FileObject : * mut _FILE_OBJECT ) > ; pub type PFAST_IO_RELEASE_FILE = FAST_IO_RELEASE_FILE ; pub type FAST_IO_DETACH_DEVICE = :: std :: option :: Option < unsafe extern "C" fn ( SourceDevice : * mut _DEVICE_OBJECT , TargetDevice : * mut _DEVICE_OBJECT ) > ; pub type PFAST_IO_DETACH_DEVICE = FAST_IO_DETACH_DEVICE ; pub type FAST_IO_QUERY_NETWORK_OPEN_INFO = :: std :: option :: Option < unsafe extern "C" fn ( FileObject : * mut _FILE_OBJECT , Wait : BOOLEAN , Buffer : * mut _FILE_NETWORK_OPEN_INFORMATION , IoStatus : * mut _IO_STATUS_BLOCK , DeviceObject : * mut _DEVICE_OBJECT ) -> BOOLEAN > ; pub type PFAST_IO_QUERY_NETWORK_OPEN_INFO = FAST_IO_QUERY_NETWORK_OPEN_INFO ; pub type FAST_IO_MDL_READ = :: std :: option :: Option < unsafe extern "C" fn ( FileObject : * mut _FILE_OBJECT , FileOffset : PLARGE_INTEGER , Length : ULONG , LockKey : ULONG , MdlChain : * mut PMDL , IoStatus : PIO_STATUS_BLOCK , DeviceObject : * mut _DEVICE_OBJECT ) -> BOOLEAN > ; pub type PFAST_IO_MDL_READ = FAST_IO_MDL_READ ; pub type FAST_IO_MDL_READ_COMPLETE = :: std :: option :: Option < unsafe extern "C" fn ( FileObject : * mut _FILE_OBJECT , MdlChain : PMDL , DeviceObject : * mut _DEVICE_OBJECT ) -> BOOLEAN > ; pub type PFAST_IO_MDL_READ_COMPLETE = FAST_IO_MDL_READ_COMPLETE ; pub type FAST_IO_PREPARE_MDL_WRITE = :: std :: option :: Option < unsafe extern "C" fn ( FileObject : * mut _FILE_OBJECT , FileOffset : PLARGE_INTEGER , Length : ULONG , LockKey : ULONG , MdlChain : * mut PMDL , IoStatus : PIO_STATUS_BLOCK , DeviceObject : * mut _DEVICE_OBJECT ) -> BOOLEAN > ; pub type PFAST_IO_PREPARE_MDL_WRITE = FAST_IO_PREPARE_MDL_WRITE ; pub type FAST_IO_MDL_WRITE_COMPLETE = :: std :: option :: Option < unsafe extern "C" fn ( FileObject : * mut _FILE_OBJECT , FileOffset : PLARGE_INTEGER , MdlChain : PMDL , DeviceObject : * mut _DEVICE_OBJECT ) -> BOOLEAN > ; pub type PFAST_IO_MDL_WRITE_COMPLETE = FAST_IO_MDL_WRITE_COMPLETE ; pub type FAST_IO_ACQUIRE_FOR_MOD_WRITE = :: std :: option :: Option < unsafe extern "C" fn ( FileObject : * mut _FILE_OBJECT , EndingOffset : PLARGE_INTEGER , ResourceToRelease : * mut * mut _ERESOURCE , DeviceObject : * mut _DEVICE_OBJECT ) -> NTSTATUS > ; pub type PFAST_IO_ACQUIRE_FOR_MOD_WRITE = FAST_IO_ACQUIRE_FOR_MOD_WRITE ; pub type FAST_IO_RELEASE_FOR_MOD_WRITE = :: std :: option :: Option < unsafe extern "C" fn ( FileObject : * mut _FILE_OBJECT , ResourceToRelease : * mut _ERESOURCE , DeviceObject : * mut _DEVICE_OBJECT ) -> NTSTATUS > ; pub type PFAST_IO_RELEASE_FOR_MOD_WRITE = FAST_IO_RELEASE_FOR_MOD_WRITE ; pub type FAST_IO_ACQUIRE_FOR_CCFLUSH = :: std :: option :: Option < unsafe extern "C" fn ( FileObject : * mut _FILE_OBJECT , DeviceObject : * mut _DEVICE_OBJECT ) -> NTSTATUS > ; pub type PFAST_IO_ACQUIRE_FOR_CCFLUSH = FAST_IO_ACQUIRE_FOR_CCFLUSH ; pub type FAST_IO_RELEASE_FOR_CCFLUSH = :: std :: option :: Option < unsafe extern "C" fn ( FileObject : * mut _FILE_OBJECT , DeviceObject : * mut _DEVICE_OBJECT ) -> NTSTATUS > ; pub type PFAST_IO_RELEASE_FOR_CCFLUSH = FAST_IO_RELEASE_FOR_CCFLUSH ; # [ repr ( C ) ] pub struct _COMPRESSED_DATA_INFO { _unused : [ u8 ; 0 ] , } pub type FAST_IO_READ_COMPRESSED = :: std :: option :: Option < unsafe extern "C" fn ( FileObject : * mut _FILE_OBJECT , FileOffset : PLARGE_INTEGER , Length : ULONG , LockKey : ULONG , Buffer : PVOID , MdlChain : * mut PMDL , IoStatus : PIO_STATUS_BLOCK , CompressedDataInfo : * mut _COMPRESSED_DATA_INFO , CompressedDataInfoLength : ULONG , DeviceObject : * mut _DEVICE_OBJECT ) -> BOOLEAN > ; pub type PFAST_IO_READ_COMPRESSED = FAST_IO_READ_COMPRESSED ; pub type FAST_IO_WRITE_COMPRESSED = :: std :: option :: Option < unsafe extern "C" fn ( FileObject : * mut _FILE_OBJECT , FileOffset : PLARGE_INTEGER , Length : ULONG , LockKey : ULONG , Buffer : PVOID , MdlChain : * mut PMDL , IoStatus : PIO_STATUS_BLOCK , CompressedDataInfo : * mut _COMPRESSED_DATA_INFO , CompressedDataInfoLength : ULONG , DeviceObject : * mut _DEVICE_OBJECT ) -> BOOLEAN > ; pub type PFAST_IO_WRITE_COMPRESSED = FAST_IO_WRITE_COMPRESSED ; pub type FAST_IO_MDL_READ_COMPLETE_COMPRESSED = :: std :: option :: Option < unsafe extern "C" fn ( FileObject : * mut _FILE_OBJECT , MdlChain : PMDL , DeviceObject : * mut _DEVICE_OBJECT ) -> BOOLEAN > ; pub type PFAST_IO_MDL_READ_COMPLETE_COMPRESSED = FAST_IO_MDL_READ_COMPLETE_COMPRESSED ; pub type FAST_IO_MDL_WRITE_COMPLETE_COMPRESSED = :: std :: option :: Option < unsafe extern "C" fn ( FileObject : * mut _FILE_OBJECT , FileOffset : PLARGE_INTEGER , MdlChain : PMDL , DeviceObject : * mut _DEVICE_OBJECT ) -> BOOLEAN > ; pub type PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED = FAST_IO_MDL_WRITE_COMPLETE_COMPRESSED ; pub type FAST_IO_QUERY_OPEN = :: std :: option :: Option < unsafe extern "C" fn ( Irp : * mut _IRP , NetworkInformation : PFILE_NETWORK_OPEN_INFORMATION , DeviceObject : * mut _DEVICE_OBJECT ) -> BOOLEAN > ; pub type PFAST_IO_QUERY_OPEN = FAST_IO_QUERY_OPEN ; # [ repr ( C ) ] pub struct _FAST_IO_DISPATCH { pub SizeOfFastIoDispatch : ULONG , pub FastIoCheckIfPossible : PFAST_IO_CHECK_IF_POSSIBLE , pub FastIoRead : PFAST_IO_READ , pub FastIoWrite : PFAST_IO_WRITE , pub FastIoQueryBasicInfo : PFAST_IO_QUERY_BASIC_INFO , pub FastIoQueryStandardInfo : PFAST_IO_QUERY_STANDARD_INFO , pub FastIoLock : PFAST_IO_LOCK , pub FastIoUnlockSingle : PFAST_IO_UNLOCK_SINGLE , pub FastIoUnlockAll : PFAST_IO_UNLOCK_ALL , pub FastIoUnlockAllByKey : PFAST_IO_UNLOCK_ALL_BY_KEY , pub FastIoDeviceControl : PFAST_IO_DEVICE_CONTROL , pub AcquireFileForNtCreateSection : PFAST_IO_ACQUIRE_FILE , pub ReleaseFileForNtCreateSection : PFAST_IO_RELEASE_FILE , pub FastIoDetachDevice : PFAST_IO_DETACH_DEVICE , pub FastIoQueryNetworkOpenInfo : PFAST_IO_QUERY_NETWORK_OPEN_INFO , pub AcquireForModWrite : PFAST_IO_ACQUIRE_FOR_MOD_WRITE , pub MdlRead : PFAST_IO_MDL_READ , pub MdlReadComplete : PFAST_IO_MDL_READ_COMPLETE , pub PrepareMdlWrite : PFAST_IO_PREPARE_MDL_WRITE , pub MdlWriteComplete : PFAST_IO_MDL_WRITE_COMPLETE , pub FastIoReadCompressed : PFAST_IO_READ_COMPRESSED , pub FastIoWriteCompressed : PFAST_IO_WRITE_COMPRESSED , pub MdlReadCompleteCompressed : PFAST_IO_MDL_READ_COMPLETE_COMPRESSED , pub MdlWriteCompleteCompressed : PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED , pub FastIoQueryOpen : PFAST_IO_QUERY_OPEN , pub ReleaseForModWrite : PFAST_IO_RELEASE_FOR_MOD_WRITE , pub AcquireForCcFlush : PFAST_IO_ACQUIRE_FOR_CCFLUSH , pub ReleaseForCcFlush : PFAST_IO_RELEASE_FOR_CCFLUSH , } pub type FAST_IO_DISPATCH = _FAST_IO_DISPATCH ; pub type PFAST_IO_DISPATCH = * mut _FAST_IO_DISPATCH ; pub const _IO_ALLOCATION_ACTION_KeepObject : _IO_ALLOCATION_ACTION = 1 ; pub const _IO_ALLOCATION_ACTION_DeallocateObject : _IO_ALLOCATION_ACTION = 2 ; pub const _IO_ALLOCATION_ACTION_DeallocateObjectKeepRegisters : _IO_ALLOCATION_ACTION = 3 ; pub type _IO_ALLOCATION_ACTION = i32 ; pub use self :: _IO_ALLOCATION_ACTION as IO_ALLOCATION_ACTION ; pub type PIO_ALLOCATION_ACTION = * mut _IO_ALLOCATION_ACTION ; pub type DRIVER_CONTROL = :: std :: option :: Option < unsafe extern "C" fn ( DeviceObject : * mut _DEVICE_OBJECT , Irp : * mut _IRP , MapRegisterBase : PVOID , Context : PVOID ) -> IO_ALLOCATION_ACTION > ; pub type PDRIVER_CONTROL = DRIVER_CONTROL ; # [ repr ( C ) ] pub struct _IO_SECURITY_CONTEXT { pub SecurityQos : PSECURITY_QUALITY_OF_SERVICE , pub AccessState : PACCESS_STATE , pub DesiredAccess : ACCESS_MASK , pub FullCreateOptions : ULONG , } pub type IO_SECURITY_CONTEXT = _IO_SECURITY_CONTEXT ; pub type PIO_SECURITY_CONTEXT = * mut _IO_SECURITY_CONTEXT ; # [ repr ( C ) ] pub struct _VPB { pub Type : CSHORT , pub Size : CSHORT , pub Flags : USHORT , pub VolumeLabelLength : USHORT , pub DeviceObject : * mut _DEVICE_OBJECT , pub RealDevice : * mut _DEVICE_OBJECT , pub SerialNumber : ULONG , pub ReferenceCount : ULONG , pub VolumeLabel : [ WCHAR ; 32usize ] , } pub type VPB = _VPB ; pub type PADAPTER_OBJECT = * mut _DMA_ADAPTER ; # [ repr ( C ) ] pub struct _WAIT_CONTEXT_BLOCK { pub __bindgen_anon_1 : _WAIT_CONTEXT_BLOCK__bindgen_ty_1 , pub DeviceRoutine : PDRIVER_CONTROL , pub DeviceContext : PVOID , pub NumberOfMapRegisters : ULONG , pub DeviceObject : PVOID , pub CurrentIrp : PVOID , pub BufferChainingDpc : PKDPC , } # [ repr ( C ) ] pub struct _WAIT_CONTEXT_BLOCK__bindgen_ty_1 { pub WaitQueueEntry : __BindgenUnionField < KDEVICE_QUEUE_ENTRY > , pub __bindgen_anon_1 : __BindgenUnionField < _WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : [ u64 ; 3usize ] , } # [ repr ( C ) ] pub struct _WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1 { pub DmaWaitEntry : LIST_ENTRY , pub NumberOfChannels : ULONG , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , } impl _WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn SyncCallback ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_SyncCallback ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn DmaContext ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_DmaContext ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ZeroMapRegisters ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ZeroMapRegisters ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 29u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 29u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( SyncCallback : ULONG , DmaContext : ULONG , ZeroMapRegisters : ULONG , Reserved : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let SyncCallback : u32 = unsafe { :: std :: mem :: transmute ( SyncCallback ) } ; SyncCallback as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let DmaContext : u32 = unsafe { :: std :: mem :: transmute ( DmaContext ) } ; DmaContext as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let ZeroMapRegisters : u32 = unsafe { :: std :: mem :: transmute ( ZeroMapRegisters ) } ; ZeroMapRegisters as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 29u8 , { let Reserved : u32 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type WAIT_CONTEXT_BLOCK = _WAIT_CONTEXT_BLOCK ; pub type PWAIT_CONTEXT_BLOCK = * mut _WAIT_CONTEXT_BLOCK ; # [ repr ( C ) ] pub struct _DEVICE_OBJECT { pub Type : CSHORT , pub Size : USHORT , pub ReferenceCount : LONG , pub DriverObject : * mut _DRIVER_OBJECT , pub NextDevice : * mut _DEVICE_OBJECT , pub AttachedDevice : * mut _DEVICE_OBJECT , pub CurrentIrp : * mut _IRP , pub Timer : PIO_TIMER , pub Flags : ULONG , pub Characteristics : ULONG , pub Vpb : PVPB , pub DeviceExtension : PVOID , pub DeviceType : ULONG , pub StackSize : CCHAR , pub Queue : _DEVICE_OBJECT__bindgen_ty_1 , pub AlignmentRequirement : ULONG , pub DeviceQueue : KDEVICE_QUEUE , pub Dpc : KDPC , pub ActiveThreadCount : ULONG , pub SecurityDescriptor : PSECURITY_DESCRIPTOR , pub DeviceLock : KEVENT , pub SectorSize : USHORT , pub Spare1 : USHORT , pub DeviceObjectExtension : * mut _DEVOBJ_EXTENSION , pub Reserved : PVOID , pub __bindgen_padding_0 : u64 , } # [ repr ( C ) ] pub struct _DEVICE_OBJECT__bindgen_ty_1 { pub ListEntry : __BindgenUnionField < LIST_ENTRY > , pub Wcb : __BindgenUnionField < WAIT_CONTEXT_BLOCK > , pub bindgen_union_field : [ u64 ; 9usize ] , } pub type DEVICE_OBJECT = _DEVICE_OBJECT ; pub type PDEVICE_OBJECT = * mut _DEVICE_OBJECT ; # [ repr ( C ) ] pub struct _DEVICE_OBJECT_POWER_EXTENSION { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] pub struct _DEVOBJ_EXTENSION { pub Type : CSHORT , pub Size : USHORT , pub DeviceObject : PDEVICE_OBJECT , pub PowerFlags : ULONG , pub Dope : * mut _DEVICE_OBJECT_POWER_EXTENSION , pub ExtensionFlags : ULONG , pub DeviceNode : PVOID , pub AttachedTo : PDEVICE_OBJECT , pub StartIoCount : LONG , pub StartIoKey : LONG , pub StartIoFlags : ULONG , pub Vpb : PVPB , pub DependencyNode : PVOID , pub InterruptContext : PVOID , pub VerifierContext : PVOID , } pub type DEVOBJ_EXTENSION = _DEVOBJ_EXTENSION ; pub type PDEVOBJ_EXTENSION = * mut _DEVOBJ_EXTENSION ; # [ repr ( C ) ] pub struct _DRIVER_EXTENSION { pub DriverObject : * mut _DRIVER_OBJECT , pub AddDevice : PDRIVER_ADD_DEVICE , pub Count : ULONG , pub ServiceKeyName : UNICODE_STRING , } pub type DRIVER_EXTENSION = _DRIVER_EXTENSION ; pub type PDRIVER_EXTENSION = * mut _DRIVER_EXTENSION ; # [ repr ( C ) ] pub struct _DRIVER_OBJECT { pub Type : CSHORT , pub Size : CSHORT , pub DeviceObject : PDEVICE_OBJECT , pub Flags : ULONG , pub DriverStart : PVOID , pub DriverSize : ULONG , pub DriverSection : PVOID , pub DriverExtension : PDRIVER_EXTENSION , pub DriverName : UNICODE_STRING , pub HardwareDatabase : PUNICODE_STRING , pub FastIoDispatch : PFAST_IO_DISPATCH , pub DriverInit : PDRIVER_INITIALIZE , pub DriverStartIo : PDRIVER_STARTIO , pub DriverUnload : PDRIVER_UNLOAD , pub MajorFunction : [ PDRIVER_DISPATCH ; 28usize ] , } pub type DRIVER_OBJECT = _DRIVER_OBJECT ; pub type PDRIVER_OBJECT = * mut _DRIVER_OBJECT ; # [ repr ( C ) ] pub struct _SECTION_OBJECT_POINTERS { pub DataSectionObject : PVOID , pub SharedCacheMap : PVOID , pub ImageSectionObject : PVOID , } pub type SECTION_OBJECT_POINTERS = _SECTION_OBJECT_POINTERS ; pub type PSECTION_OBJECT_POINTERS = * mut SECTION_OBJECT_POINTERS ; # [ repr ( C ) ] pub struct _IO_COMPLETION_CONTEXT { pub Port : PVOID , pub Key : PVOID , } pub type IO_COMPLETION_CONTEXT = _IO_COMPLETION_CONTEXT ; pub type PIO_COMPLETION_CONTEXT = * mut _IO_COMPLETION_CONTEXT ; # [ repr ( C ) ] pub struct _FILE_OBJECT { pub Type : CSHORT , pub Size : CSHORT , pub DeviceObject : PDEVICE_OBJECT , pub Vpb : PVPB , pub FsContext : PVOID , pub FsContext2 : PVOID , pub SectionObjectPointer : PSECTION_OBJECT_POINTERS , pub PrivateCacheMap : PVOID , pub FinalStatus : NTSTATUS , pub RelatedFileObject : * mut _FILE_OBJECT , pub LockOperation : BOOLEAN , pub DeletePending : BOOLEAN , pub ReadAccess : BOOLEAN , pub WriteAccess : BOOLEAN , pub DeleteAccess : BOOLEAN , pub SharedRead : BOOLEAN , pub SharedWrite : BOOLEAN , pub SharedDelete : BOOLEAN , pub Flags : ULONG , pub FileName : UNICODE_STRING , pub CurrentByteOffset : LARGE_INTEGER , pub Waiters : ULONG , pub Busy : ULONG , pub LastLock : PVOID , pub Lock : KEVENT , pub Event : KEVENT , pub CompletionContext : PIO_COMPLETION_CONTEXT , pub IrpListLock : KSPIN_LOCK , pub IrpList : LIST_ENTRY , pub FileObjectExtension : PVOID , } pub type FILE_OBJECT = _FILE_OBJECT ; pub type PFILE_OBJECT = * mut _FILE_OBJECT ; # [ repr ( C ) ] pub struct _IRP { pub Type : CSHORT , pub Size : USHORT , pub MdlAddress : PMDL , pub Flags : ULONG , pub AssociatedIrp : _IRP__bindgen_ty_1 , pub ThreadListEntry : LIST_ENTRY , pub IoStatus : IO_STATUS_BLOCK , pub RequestorMode : KPROCESSOR_MODE , pub PendingReturned : BOOLEAN , pub StackCount : CHAR , pub CurrentLocation : CHAR , pub Cancel : BOOLEAN , pub CancelIrql : KIRQL , pub ApcEnvironment : CCHAR , pub AllocationFlags : UCHAR , pub UserIosb : PIO_STATUS_BLOCK , pub UserEvent : PKEVENT , pub Overlay : _IRP__bindgen_ty_2 , pub CancelRoutine : PDRIVER_CANCEL , pub UserBuffer : PVOID , pub Tail : _IRP__bindgen_ty_3 , } # [ repr ( C ) ] pub struct _IRP__bindgen_ty_1 { pub MasterIrp : __BindgenUnionField < * mut _IRP > , pub IrpCount : __BindgenUnionField < LONG > , pub SystemBuffer : __BindgenUnionField < PVOID > , pub bindgen_union_field : u64 , } # [ repr ( C ) ] pub struct _IRP__bindgen_ty_2 { pub AsynchronousParameters : __BindgenUnionField < _IRP__bindgen_ty_2__bindgen_ty_1 > , pub AllocationSize : __BindgenUnionField < LARGE_INTEGER > , pub bindgen_union_field : [ u64 ; 2usize ] , } # [ repr ( C ) ] pub struct _IRP__bindgen_ty_2__bindgen_ty_1 { pub __bindgen_anon_1 : _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 , pub UserApcContext : PVOID , } # [ repr ( C ) ] pub struct _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 { pub UserApcRoutine : __BindgenUnionField < PIO_APC_ROUTINE > , pub IssuingProcess : __BindgenUnionField < PVOID > , pub bindgen_union_field : u64 , } # [ repr ( C ) ] pub struct _IRP__bindgen_ty_3 { pub Overlay : __BindgenUnionField < _IRP__bindgen_ty_3__bindgen_ty_1 > , pub Apc : __BindgenUnionField < KAPC > , pub CompletionKey : __BindgenUnionField < PVOID > , pub bindgen_union_field : [ u64 ; 11usize ] , } # [ repr ( C ) ] pub struct _IRP__bindgen_ty_3__bindgen_ty_1 { pub __bindgen_anon_1 : _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 , pub Thread : PETHREAD , pub AuxiliaryBuffer : PCHAR , pub __bindgen_anon_2 : _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2 , pub OriginalFileObject : PFILE_OBJECT , } # [ repr ( C ) ] pub struct _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 { pub DeviceQueueEntry : __BindgenUnionField < KDEVICE_QUEUE_ENTRY > , pub __bindgen_anon_1 : __BindgenUnionField < _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : [ u64 ; 4usize ] , } # [ repr ( C ) ] pub struct _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 { pub DriverContext : [ PVOID ; 4usize ] , } # [ repr ( C ) ] pub struct _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2 { pub ListEntry : LIST_ENTRY , pub __bindgen_anon_1 : _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 { pub CurrentStackLocation : __BindgenUnionField < * mut _IO_STACK_LOCATION > , pub PacketType : __BindgenUnionField < ULONG > , pub bindgen_union_field : u64 , } pub type IRP = _IRP ; pub type PIRP = * mut IRP ; pub type IO_COMPLETION_ROUTINE = :: std :: option :: Option < unsafe extern "C" fn ( DeviceObject : PDEVICE_OBJECT , Irp : PIRP , Context : PVOID ) -> NTSTATUS > ; pub type PIO_COMPLETION_ROUTINE = IO_COMPLETION_ROUTINE ; pub const _DEVICE_RELATION_TYPE_BusRelations : _DEVICE_RELATION_TYPE = 0 ; pub const _DEVICE_RELATION_TYPE_EjectionRelations : _DEVICE_RELATION_TYPE = 1 ; pub const _DEVICE_RELATION_TYPE_PowerRelations : _DEVICE_RELATION_TYPE = 2 ; pub const _DEVICE_RELATION_TYPE_RemovalRelations : _DEVICE_RELATION_TYPE = 3 ; pub const _DEVICE_RELATION_TYPE_TargetDeviceRelation : _DEVICE_RELATION_TYPE = 4 ; pub const _DEVICE_RELATION_TYPE_SingleBusRelations : _DEVICE_RELATION_TYPE = 5 ; pub const _DEVICE_RELATION_TYPE_TransportRelations : _DEVICE_RELATION_TYPE = 6 ; pub type _DEVICE_RELATION_TYPE = i32 ; pub use self :: _DEVICE_RELATION_TYPE as DEVICE_RELATION_TYPE ; pub type PDEVICE_RELATION_TYPE = * mut _DEVICE_RELATION_TYPE ; # [ repr ( C ) ] pub struct _DEVICE_RELATIONS { pub Count : ULONG , pub Objects : [ PDEVICE_OBJECT ; 1usize ] , } pub type DEVICE_RELATIONS = _DEVICE_RELATIONS ; pub type PDEVICE_RELATIONS = * mut _DEVICE_RELATIONS ; pub const _DEVICE_USAGE_NOTIFICATION_TYPE_DeviceUsageTypeUndefined : _DEVICE_USAGE_NOTIFICATION_TYPE = 0 ; pub const _DEVICE_USAGE_NOTIFICATION_TYPE_DeviceUsageTypePaging : _DEVICE_USAGE_NOTIFICATION_TYPE = 1 ; pub const _DEVICE_USAGE_NOTIFICATION_TYPE_DeviceUsageTypeHibernation : _DEVICE_USAGE_NOTIFICATION_TYPE = 2 ; pub const _DEVICE_USAGE_NOTIFICATION_TYPE_DeviceUsageTypeDumpFile : _DEVICE_USAGE_NOTIFICATION_TYPE = 3 ; pub const _DEVICE_USAGE_NOTIFICATION_TYPE_DeviceUsageTypeBoot : _DEVICE_USAGE_NOTIFICATION_TYPE = 4 ; pub const _DEVICE_USAGE_NOTIFICATION_TYPE_DeviceUsageTypePostDisplay : _DEVICE_USAGE_NOTIFICATION_TYPE = 5 ; pub type _DEVICE_USAGE_NOTIFICATION_TYPE = i32 ; pub use self :: _DEVICE_USAGE_NOTIFICATION_TYPE as DEVICE_USAGE_NOTIFICATION_TYPE ; # [ repr ( C ) ] pub struct _INTERFACE { pub Size : USHORT , pub Version : USHORT , pub Context : PVOID , pub InterfaceReference : PINTERFACE_REFERENCE , pub InterfaceDereference : PINTERFACE_DEREFERENCE , } pub type INTERFACE = _INTERFACE ; pub type PINTERFACE = * mut _INTERFACE ; # [ repr ( C ) ] pub struct _DEVICE_CAPABILITIES { pub Size : USHORT , pub Version : USHORT , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub Address : ULONG , pub UINumber : ULONG , pub DeviceState : [ DEVICE_POWER_STATE ; 7usize ] , pub SystemWake : SYSTEM_POWER_STATE , pub DeviceWake : DEVICE_POWER_STATE , pub D1Latency : ULONG , pub D2Latency : ULONG , pub D3Latency : ULONG , } impl _DEVICE_CAPABILITIES { # [ inline ] pub fn DeviceD1 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_DeviceD1 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn DeviceD2 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_DeviceD2 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn LockSupported ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_LockSupported ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn EjectSupported ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_EjectSupported ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Removable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Removable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn DockDevice ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_DockDevice ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UniqueID ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_UniqueID ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn SilentInstall ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_SilentInstall ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn RawDeviceOK ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_RawDeviceOK ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn SurpriseRemovalOK ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_SurpriseRemovalOK ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn WakeFromD0 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_WakeFromD0 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 1u8 , val as u64 ) } } # [ inline ] pub fn WakeFromD1 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_WakeFromD1 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 1u8 , val as u64 ) } } # [ inline ] pub fn WakeFromD2 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_WakeFromD2 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 1u8 , val as u64 ) } } # [ inline ] pub fn WakeFromD3 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 13usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_WakeFromD3 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 13usize , 1u8 , val as u64 ) } } # [ inline ] pub fn HardwareDisabled ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_HardwareDisabled ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 1u8 , val as u64 ) } } # [ inline ] pub fn NonDynamic ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 15usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_NonDynamic ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 15usize , 1u8 , val as u64 ) } } # [ inline ] pub fn WarmEjectSupported ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_WarmEjectSupported ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 1u8 , val as u64 ) } } # [ inline ] pub fn NoDisplayInUI ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 17usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_NoDisplayInUI ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 17usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved1 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 18usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved1 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 18usize , 1u8 , val as u64 ) } } # [ inline ] pub fn WakeFromInterrupt ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 19usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_WakeFromInterrupt ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 19usize , 1u8 , val as u64 ) } } # [ inline ] pub fn SecureDevice ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 20usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_SecureDevice ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 20usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 21usize , 11u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 21usize , 11u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( DeviceD1 : ULONG , DeviceD2 : ULONG , LockSupported : ULONG , EjectSupported : ULONG , Removable : ULONG , DockDevice : ULONG , UniqueID : ULONG , SilentInstall : ULONG , RawDeviceOK : ULONG , SurpriseRemovalOK : ULONG , WakeFromD0 : ULONG , WakeFromD1 : ULONG , WakeFromD2 : ULONG , WakeFromD3 : ULONG , HardwareDisabled : ULONG , NonDynamic : ULONG , WarmEjectSupported : ULONG , NoDisplayInUI : ULONG , Reserved1 : ULONG , WakeFromInterrupt : ULONG , SecureDevice : ULONG , Reserved : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let DeviceD1 : u32 = unsafe { :: std :: mem :: transmute ( DeviceD1 ) } ; DeviceD1 as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let DeviceD2 : u32 = unsafe { :: std :: mem :: transmute ( DeviceD2 ) } ; DeviceD2 as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let LockSupported : u32 = unsafe { :: std :: mem :: transmute ( LockSupported ) } ; LockSupported as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let EjectSupported : u32 = unsafe { :: std :: mem :: transmute ( EjectSupported ) } ; EjectSupported as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let Removable : u32 = unsafe { :: std :: mem :: transmute ( Removable ) } ; Removable as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let DockDevice : u32 = unsafe { :: std :: mem :: transmute ( DockDevice ) } ; DockDevice as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let UniqueID : u32 = unsafe { :: std :: mem :: transmute ( UniqueID ) } ; UniqueID as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let SilentInstall : u32 = unsafe { :: std :: mem :: transmute ( SilentInstall ) } ; SilentInstall as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let RawDeviceOK : u32 = unsafe { :: std :: mem :: transmute ( RawDeviceOK ) } ; RawDeviceOK as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let SurpriseRemovalOK : u32 = unsafe { :: std :: mem :: transmute ( SurpriseRemovalOK ) } ; SurpriseRemovalOK as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 1u8 , { let WakeFromD0 : u32 = unsafe { :: std :: mem :: transmute ( WakeFromD0 ) } ; WakeFromD0 as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 1u8 , { let WakeFromD1 : u32 = unsafe { :: std :: mem :: transmute ( WakeFromD1 ) } ; WakeFromD1 as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 1u8 , { let WakeFromD2 : u32 = unsafe { :: std :: mem :: transmute ( WakeFromD2 ) } ; WakeFromD2 as u64 } ) ; __bindgen_bitfield_unit . set ( 13usize , 1u8 , { let WakeFromD3 : u32 = unsafe { :: std :: mem :: transmute ( WakeFromD3 ) } ; WakeFromD3 as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 1u8 , { let HardwareDisabled : u32 = unsafe { :: std :: mem :: transmute ( HardwareDisabled ) } ; HardwareDisabled as u64 } ) ; __bindgen_bitfield_unit . set ( 15usize , 1u8 , { let NonDynamic : u32 = unsafe { :: std :: mem :: transmute ( NonDynamic ) } ; NonDynamic as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 1u8 , { let WarmEjectSupported : u32 = unsafe { :: std :: mem :: transmute ( WarmEjectSupported ) } ; WarmEjectSupported as u64 } ) ; __bindgen_bitfield_unit . set ( 17usize , 1u8 , { let NoDisplayInUI : u32 = unsafe { :: std :: mem :: transmute ( NoDisplayInUI ) } ; NoDisplayInUI as u64 } ) ; __bindgen_bitfield_unit . set ( 18usize , 1u8 , { let Reserved1 : u32 = unsafe { :: std :: mem :: transmute ( Reserved1 ) } ; Reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 19usize , 1u8 , { let WakeFromInterrupt : u32 = unsafe { :: std :: mem :: transmute ( WakeFromInterrupt ) } ; WakeFromInterrupt as u64 } ) ; __bindgen_bitfield_unit . set ( 20usize , 1u8 , { let SecureDevice : u32 = unsafe { :: std :: mem :: transmute ( SecureDevice ) } ; SecureDevice as u64 } ) ; __bindgen_bitfield_unit . set ( 21usize , 11u8 , { let Reserved : u32 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type DEVICE_CAPABILITIES = _DEVICE_CAPABILITIES ; pub type PDEVICE_CAPABILITIES = * mut _DEVICE_CAPABILITIES ; # [ repr ( C ) ] pub struct _POWER_SEQUENCE { pub SequenceD1 : ULONG , pub SequenceD2 : ULONG , pub SequenceD3 : ULONG , } pub type POWER_SEQUENCE = _POWER_SEQUENCE ; pub type PPOWER_SEQUENCE = * mut _POWER_SEQUENCE ; pub const BUS_QUERY_ID_TYPE_BusQueryDeviceID : BUS_QUERY_ID_TYPE = 0 ; pub const BUS_QUERY_ID_TYPE_BusQueryHardwareIDs : BUS_QUERY_ID_TYPE = 1 ; pub const BUS_QUERY_ID_TYPE_BusQueryCompatibleIDs : BUS_QUERY_ID_TYPE = 2 ; pub const BUS_QUERY_ID_TYPE_BusQueryInstanceID : BUS_QUERY_ID_TYPE = 3 ; pub const BUS_QUERY_ID_TYPE_BusQueryDeviceSerialNumber : BUS_QUERY_ID_TYPE = 4 ; pub const BUS_QUERY_ID_TYPE_BusQueryContainerID : BUS_QUERY_ID_TYPE = 5 ; pub type BUS_QUERY_ID_TYPE = i32 ; pub type PBUS_QUERY_ID_TYPE = * mut BUS_QUERY_ID_TYPE ; pub type PNP_DEVICE_STATE = ULONG ; pub type PPNP_DEVICE_STATE = * mut ULONG ; pub const DEVICE_TEXT_TYPE_DeviceTextDescription : DEVICE_TEXT_TYPE = 0 ; pub const DEVICE_TEXT_TYPE_DeviceTextLocationInformation : DEVICE_TEXT_TYPE = 1 ; pub type DEVICE_TEXT_TYPE = i32 ; pub type PDEVICE_TEXT_TYPE = * mut DEVICE_TEXT_TYPE ; # [ repr ( C ) ] pub struct _IO_STACK_LOCATION { pub MajorFunction : UCHAR , pub MinorFunction : UCHAR , pub Flags : UCHAR , pub Control : UCHAR , pub Parameters : _IO_STACK_LOCATION__bindgen_ty_1 , pub DeviceObject : PDEVICE_OBJECT , pub FileObject : PFILE_OBJECT , pub CompletionRoutine : PIO_COMPLETION_ROUTINE , pub Context : PVOID , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1 { pub Create : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1 > , pub CreatePipe : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2 > , pub CreateMailslot : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3 > , pub Read : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4 > , pub Write : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5 > , pub QueryDirectory : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6 > , pub NotifyDirectory : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_7 > , pub NotifyDirectoryEx : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8 > , pub QueryFile : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9 > , pub SetFile : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10 > , pub QueryEa : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11 > , pub SetEa : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_12 > , pub QueryVolume : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13 > , pub SetVolume : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14 > , pub FileSystemControl : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15 > , pub LockControl : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16 > , pub DeviceIoControl : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17 > , pub QuerySecurity : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18 > , pub SetSecurity : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19 > , pub MountVolume : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20 > , pub VerifyVolume : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21 > , pub Scsi : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_22 > , pub QueryQuota : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23 > , pub SetQuota : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_24 > , pub QueryDeviceRelations : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_25 > , pub QueryInterface : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26 > , pub DeviceCapabilities : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_27 > , pub FilterResourceRequirements : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_28 > , pub ReadWriteConfig : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29 > , pub SetLock : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_30 > , pub QueryId : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_31 > , pub QueryDeviceText : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32 > , pub UsageNotification : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33 > , pub WaitWake : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_34 > , pub PowerSequence : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35 > , pub Power : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36 > , pub StartDevice : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37 > , pub WMI : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38 > , pub Others : __BindgenUnionField < _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39 > , pub bindgen_union_field : [ u64 ; 4usize ] , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1 { pub SecurityContext : PIO_SECURITY_CONTEXT , pub Options : ULONG , pub __bindgen_padding_0 : [ u16 ; 2usize ] , pub FileAttributes : USHORT , pub ShareAccess : USHORT , pub __bindgen_padding_1 : u32 , pub EaLength : ULONG , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2 { pub SecurityContext : PIO_SECURITY_CONTEXT , pub Options : ULONG , pub __bindgen_padding_0 : [ u16 ; 2usize ] , pub Reserved : USHORT , pub ShareAccess : USHORT , pub Parameters : PNAMED_PIPE_CREATE_PARAMETERS , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3 { pub SecurityContext : PIO_SECURITY_CONTEXT , pub Options : ULONG , pub __bindgen_padding_0 : [ u16 ; 2usize ] , pub Reserved : USHORT , pub ShareAccess : USHORT , pub Parameters : PMAILSLOT_CREATE_PARAMETERS , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4 { pub Length : ULONG , pub __bindgen_padding_0 : u32 , pub Key : ULONG , pub ByteOffset : LARGE_INTEGER , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5 { pub Length : ULONG , pub __bindgen_padding_0 : u32 , pub Key : ULONG , pub ByteOffset : LARGE_INTEGER , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6 { pub Length : ULONG , pub FileName : PUNICODE_STRING , pub FileInformationClass : FILE_INFORMATION_CLASS , pub FileIndex : ULONG , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_7 { pub Length : ULONG , pub __bindgen_padding_0 : u32 , pub CompletionFilter : ULONG , pub __bindgen_align : [ u64 ; 0usize ] , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8 { pub Length : ULONG , pub __bindgen_padding_0 : u32 , pub CompletionFilter : ULONG , pub __bindgen_padding_1 : u32 , pub DirectoryNotifyInformationClass : DIRECTORY_NOTIFY_INFORMATION_CLASS , pub __bindgen_align : [ u64 ; 0usize ] , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9 { pub Length : ULONG , pub __bindgen_padding_0 : u32 , pub FileInformationClass : FILE_INFORMATION_CLASS , pub __bindgen_align : [ u64 ; 0usize ] , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10 { pub Length : ULONG , pub __bindgen_padding_0 : u32 , pub FileInformationClass : FILE_INFORMATION_CLASS , pub FileObject : PFILE_OBJECT , pub __bindgen_anon_1 : _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1 { pub _bindgen_opaque_blob : [ u32 ; 2usize ] , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1__bindgen_ty_1 { pub ReplaceIfExists : BOOLEAN , pub AdvanceOnly : BOOLEAN , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11 { pub Length : ULONG , pub EaList : PVOID , pub EaListLength : ULONG , pub EaIndex : ULONG , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_12 { pub Length : ULONG , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13 { pub Length : ULONG , pub __bindgen_padding_0 : u32 , pub FsInformationClass : FS_INFORMATION_CLASS , pub __bindgen_align : [ u64 ; 0usize ] , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14 { pub Length : ULONG , pub __bindgen_padding_0 : u32 , pub FsInformationClass : FS_INFORMATION_CLASS , pub __bindgen_align : [ u64 ; 0usize ] , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15 { pub OutputBufferLength : ULONG , pub __bindgen_padding_0 : u32 , pub InputBufferLength : ULONG , pub __bindgen_padding_1 : u32 , pub FsControlCode : ULONG , pub Type3InputBuffer : PVOID , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16 { pub Length : PLARGE_INTEGER , pub Key : ULONG , pub ByteOffset : LARGE_INTEGER , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17 { pub OutputBufferLength : ULONG , pub __bindgen_padding_0 : u32 , pub InputBufferLength : ULONG , pub __bindgen_padding_1 : u32 , pub IoControlCode : ULONG , pub Type3InputBuffer : PVOID , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18 { pub SecurityInformation : SECURITY_INFORMATION , pub __bindgen_padding_0 : u32 , pub Length : ULONG , pub __bindgen_align : [ u64 ; 0usize ] , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19 { pub _bindgen_opaque_blob : [ u32 ; 3usize ] , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20 { pub _bindgen_opaque_blob : [ u32 ; 4usize ] , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21 { pub _bindgen_opaque_blob : [ u32 ; 4usize ] , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_22 { pub _bindgen_opaque_blob : [ u32 ; 2usize ] , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23 { pub _bindgen_opaque_blob : [ u32 ; 6usize ] , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_24 { pub Length : ULONG , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_25 { pub Type : DEVICE_RELATION_TYPE , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26 { pub _bindgen_opaque_blob : [ u32 ; 7usize ] , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_27 { pub _bindgen_opaque_blob : [ u32 ; 2usize ] , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_28 { pub _bindgen_opaque_blob : [ u32 ; 2usize ] , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29 { pub WhichSpace : ULONG , pub Buffer : PVOID , pub Offset : ULONG , pub Length : ULONG , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_30 { pub Lock : BOOLEAN , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_31 { pub IdType : BUS_QUERY_ID_TYPE , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32 { pub DeviceTextType : DEVICE_TEXT_TYPE , pub __bindgen_padding_0 : u32 , pub LocaleId : LCID , pub __bindgen_align : [ u64 ; 0usize ] , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33 { pub InPath : BOOLEAN , pub Reserved : [ BOOLEAN ; 3usize ] , pub __bindgen_padding_0 : u32 , pub Type : DEVICE_USAGE_NOTIFICATION_TYPE , pub __bindgen_align : [ u64 ; 0usize ] , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_34 { pub PowerState : SYSTEM_POWER_STATE , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35 { pub _bindgen_opaque_blob : [ u32 ; 2usize ] , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36 { pub __bindgen_anon_1 : _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36__bindgen_ty_1 , pub __bindgen_padding_0 : u32 , pub Type : POWER_STATE_TYPE , pub __bindgen_padding_1 : u32 , pub State : POWER_STATE , pub __bindgen_padding_2 : u32 , pub ShutdownType : POWER_ACTION , pub __bindgen_align : [ u64 ; 0usize ] , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36__bindgen_ty_1 { pub SystemContext : __BindgenUnionField < ULONG > , pub SystemPowerStateContext : __BindgenUnionField < SYSTEM_POWER_STATE_CONTEXT > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37 { pub _bindgen_opaque_blob : [ u32 ; 4usize ] , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38 { pub _bindgen_opaque_blob : [ u32 ; 7usize ] , } # [ repr ( C ) ] pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39 { pub _bindgen_opaque_blob : [ u32 ; 8usize ] , } pub type IO_STACK_LOCATION = _IO_STACK_LOCATION ; # [ repr ( C ) ] pub struct _SHARE_ACCESS { pub OpenCount : ULONG , pub Readers : ULONG , pub Writers : ULONG , pub Deleters : ULONG , pub SharedRead : ULONG , pub SharedWrite : ULONG , pub SharedDelete : ULONG , } pub type SHARE_ACCESS = _SHARE_ACCESS ; pub type PSHARE_ACCESS = * mut _SHARE_ACCESS ; # [ repr ( C ) ] pub struct _LINK_SHARE_ACCESS { pub OpenCount : ULONG , pub Deleters : ULONG , pub SharedDelete : ULONG , } pub type LINK_SHARE_ACCESS = _LINK_SHARE_ACCESS ; pub type PLINK_SHARE_ACCESS = * mut _LINK_SHARE_ACCESS ; extern "C" { pub fn IoAcquireCancelSpinLock ( Irql : PKIRQL ) ; } extern "C" { pub fn IoAllocateDriverObjectExtension ( DriverObject : PDRIVER_OBJECT , ClientIdentificationAddress : PVOID , DriverObjectExtensionSize : ULONG , DriverObjectExtension : * mut PVOID ) -> NTSTATUS ; } extern "C" { pub fn IoAllocateErrorLogEntry ( IoObject : PVOID , EntrySize : UCHAR ) -> PVOID ; } extern "C" { pub fn IoAllocateIrp ( StackSize : CCHAR , ChargeQuota : BOOLEAN ) -> PIRP ; } extern "C" { pub fn IoAllocateIrpEx ( DeviceObject : PDEVICE_OBJECT , StackSize : CCHAR , ChargeQuota : BOOLEAN ) -> PIRP ; } extern "C" { pub fn IoAllocateMdl ( VirtualAddress : PVOID , Length : ULONG , SecondaryBuffer : BOOLEAN , ChargeQuota : BOOLEAN , Irp : PIRP ) -> PMDL ; } pub const _IO_PAGING_PRIORITY_IoPagingPriorityInvalid : _IO_PAGING_PRIORITY = 0 ; pub const _IO_PAGING_PRIORITY_IoPagingPriorityNormal : _IO_PAGING_PRIORITY = 1 ; pub const _IO_PAGING_PRIORITY_IoPagingPriorityHigh : _IO_PAGING_PRIORITY = 2 ; pub const _IO_PAGING_PRIORITY_IoPagingPriorityReserved1 : _IO_PAGING_PRIORITY = 3 ; pub const _IO_PAGING_PRIORITY_IoPagingPriorityReserved2 : _IO_PAGING_PRIORITY = 4 ; pub type _IO_PAGING_PRIORITY = i32 ; pub use self :: _IO_PAGING_PRIORITY as IO_PAGING_PRIORITY ; extern "C" { pub fn IoAttachDevice ( SourceDevice : PDEVICE_OBJECT , TargetDevice : PUNICODE_STRING , AttachedDevice : * mut PDEVICE_OBJECT ) -> NTSTATUS ; } extern "C" { pub fn IoAttachDeviceToDeviceStack ( SourceDevice : PDEVICE_OBJECT , TargetDevice : PDEVICE_OBJECT ) -> PDEVICE_OBJECT ; } extern "C" { pub fn IoBuildAsynchronousFsdRequest ( MajorFunction : ULONG , DeviceObject : PDEVICE_OBJECT , Buffer : PVOID , Length : ULONG , StartingOffset : PLARGE_INTEGER , IoStatusBlock : PIO_STATUS_BLOCK ) -> PIRP ; } extern "C" { pub fn IoBuildDeviceIoControlRequest ( IoControlCode : ULONG , DeviceObject : PDEVICE_OBJECT , InputBuffer : PVOID , InputBufferLength : ULONG , OutputBuffer : PVOID , OutputBufferLength : ULONG , InternalDeviceIoControl : BOOLEAN , Event : PKEVENT , IoStatusBlock : PIO_STATUS_BLOCK ) -> PIRP ; } extern "C" { pub fn IoBuildPartialMdl ( SourceMdl : PMDL , TargetMdl : PMDL , VirtualAddress : PVOID , Length : ULONG ) ; } # [ repr ( C ) ] pub struct _BOOTDISK_INFORMATION { pub BootPartitionOffset : LONGLONG , pub SystemPartitionOffset : LONGLONG , pub BootDeviceSignature : ULONG , pub SystemDeviceSignature : ULONG , } pub type BOOTDISK_INFORMATION = _BOOTDISK_INFORMATION ; pub type PBOOTDISK_INFORMATION = * mut _BOOTDISK_INFORMATION ; # [ repr ( C ) ] pub struct _BOOTDISK_INFORMATION_EX { pub BootPartitionOffset : LONGLONG , pub SystemPartitionOffset : LONGLONG , pub BootDeviceSignature : ULONG , pub SystemDeviceSignature : ULONG , pub BootDeviceGuid : GUID , pub SystemDeviceGuid : GUID , pub BootDeviceIsGpt : BOOLEAN , pub SystemDeviceIsGpt : BOOLEAN , } pub type BOOTDISK_INFORMATION_EX = _BOOTDISK_INFORMATION_EX ; pub type PBOOTDISK_INFORMATION_EX = * mut _BOOTDISK_INFORMATION_EX ; # [ repr ( C ) ] pub struct _LOADER_PARTITION_INFORMATION_EX { pub PartitionStyle : ULONG , pub PartitionNumber : ULONG , pub __bindgen_anon_1 : _LOADER_PARTITION_INFORMATION_EX__bindgen_ty_1 , pub Flags : ULONG , } # [ repr ( C ) ] pub struct _LOADER_PARTITION_INFORMATION_EX__bindgen_ty_1 { pub Signature : __BindgenUnionField < ULONG > , pub DeviceId : __BindgenUnionField < GUID > , pub bindgen_union_field : [ u32 ; 4usize ] , } pub type LOADER_PARTITION_INFORMATION_EX = _LOADER_PARTITION_INFORMATION_EX ; pub type PLOADER_PARTITION_INFORMATION_EX = * mut _LOADER_PARTITION_INFORMATION_EX ; # [ repr ( C ) ] pub struct _BOOTDISK_INFORMATION_LITE { pub NumberEntries : ULONG , pub Entries : [ LOADER_PARTITION_INFORMATION_EX ; 1usize ] , } pub type BOOTDISK_INFORMATION_LITE = _BOOTDISK_INFORMATION_LITE ; pub type PBOOTDISK_INFORMATION_LITE = * mut _BOOTDISK_INFORMATION_LITE ; extern "C" { pub fn IoGetBootDiskInformation ( BootDiskInformation : PBOOTDISK_INFORMATION , Size : ULONG ) -> NTSTATUS ; } extern "C" { pub fn IoGetBootDiskInformationLite ( BootDiskInformation : * mut PBOOTDISK_INFORMATION_LITE ) -> NTSTATUS ; } extern "C" { pub fn IoBuildSynchronousFsdRequest ( MajorFunction : ULONG , DeviceObject : PDEVICE_OBJECT , Buffer : PVOID , Length : ULONG , StartingOffset : PLARGE_INTEGER , Event : PKEVENT , IoStatusBlock : PIO_STATUS_BLOCK ) -> PIRP ; } extern "C" { pub fn IofCallDriver ( DeviceObject : PDEVICE_OBJECT , Irp : PIRP ) -> NTSTATUS ; } extern "C" { pub fn IoCancelIrp ( Irp : PIRP ) -> BOOLEAN ; } extern "C" { pub fn IoCheckShareAccess ( DesiredAccess : ACCESS_MASK , DesiredShareAccess : ULONG , FileObject : PFILE_OBJECT , ShareAccess : PSHARE_ACCESS , Update : BOOLEAN ) -> NTSTATUS ; } extern "C" { pub fn IoCheckShareAccessEx ( DesiredAccess : ACCESS_MASK , DesiredShareAccess : ULONG , FileObject : PFILE_OBJECT , ShareAccess : PSHARE_ACCESS , Update : BOOLEAN , WritePermission : PBOOLEAN ) -> NTSTATUS ; } extern "C" { pub fn IoCheckLinkShareAccess ( DesiredAccess : ACCESS_MASK , DesiredShareAccess : ULONG , FileObject : PFILE_OBJECT , ShareAccess : PSHARE_ACCESS , LinkShareAccess : PLINK_SHARE_ACCESS , IoShareAccessFlags : ULONG ) -> NTSTATUS ; } pub const _IO_COMPLETION_ROUTINE_RESULT_ContinueCompletion : _IO_COMPLETION_ROUTINE_RESULT = 0 ; pub const _IO_COMPLETION_ROUTINE_RESULT_StopCompletion : _IO_COMPLETION_ROUTINE_RESULT = -1073741802 ; pub type _IO_COMPLETION_ROUTINE_RESULT = i32 ; pub use self :: _IO_COMPLETION_ROUTINE_RESULT as IO_COMPLETION_ROUTINE_RESULT ; pub type PIO_COMPLETION_ROUTINE_RESULT = * mut _IO_COMPLETION_ROUTINE_RESULT ; extern "C" { pub fn IofCompleteRequest ( Irp : PIRP , PriorityBoost : CCHAR ) ; } extern "C" { pub fn IoConnectInterrupt ( InterruptObject : * mut PKINTERRUPT , ServiceRoutine : PKSERVICE_ROUTINE , ServiceContext : PVOID , SpinLock : PKSPIN_LOCK , Vector : ULONG , Irql : KIRQL , SynchronizeIrql : KIRQL , InterruptMode : KINTERRUPT_MODE , ShareVector : BOOLEAN , ProcessorEnableMask : KAFFINITY , FloatingSave : BOOLEAN ) -> NTSTATUS ; } # [ repr ( C ) ] pub struct _IO_INTERRUPT_MESSAGE_INFO_ENTRY { pub MessageAddress : PHYSICAL_ADDRESS , pub TargetProcessorSet : KAFFINITY , pub InterruptObject : PKINTERRUPT , pub MessageData : ULONG , pub Vector : ULONG , pub Irql : KIRQL , pub Mode : KINTERRUPT_MODE , pub Polarity : KINTERRUPT_POLARITY , } pub type IO_INTERRUPT_MESSAGE_INFO_ENTRY = _IO_INTERRUPT_MESSAGE_INFO_ENTRY ; pub type PIO_INTERRUPT_MESSAGE_INFO_ENTRY = * mut _IO_INTERRUPT_MESSAGE_INFO_ENTRY ; # [ repr ( C ) ] pub struct _IO_INTERRUPT_MESSAGE_INFO { pub UnifiedIrql : KIRQL , pub MessageCount : ULONG , pub MessageInfo : [ IO_INTERRUPT_MESSAGE_INFO_ENTRY ; 1usize ] , } pub type IO_INTERRUPT_MESSAGE_INFO = _IO_INTERRUPT_MESSAGE_INFO ; pub type PIO_INTERRUPT_MESSAGE_INFO = * mut _IO_INTERRUPT_MESSAGE_INFO ; # [ repr ( C ) ] pub struct _IO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS { pub PhysicalDeviceObject : PDEVICE_OBJECT , pub InterruptObject : * mut PKINTERRUPT , pub ServiceRoutine : PKSERVICE_ROUTINE , pub ServiceContext : PVOID , pub SpinLock : PKSPIN_LOCK , pub SynchronizeIrql : KIRQL , pub FloatingSave : BOOLEAN , pub ShareVector : BOOLEAN , pub Vector : ULONG , pub Irql : KIRQL , pub InterruptMode : KINTERRUPT_MODE , pub ProcessorEnableMask : KAFFINITY , pub Group : USHORT , } pub type IO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS = _IO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS ; pub type PIO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS = * mut _IO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS ; # [ repr ( C ) ] pub struct _IO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS { pub PhysicalDeviceObject : PDEVICE_OBJECT , pub InterruptObject : * mut PKINTERRUPT , pub ServiceRoutine : PKSERVICE_ROUTINE , pub ServiceContext : PVOID , pub SpinLock : PKSPIN_LOCK , pub SynchronizeIrql : KIRQL , pub FloatingSave : BOOLEAN , } pub type IO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS = _IO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS ; pub type PIO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS = * mut _IO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS ; # [ repr ( C ) ] pub struct _IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS { pub PhysicalDeviceObject : PDEVICE_OBJECT , pub ConnectionContext : _IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS__bindgen_ty_1 , pub MessageServiceRoutine : PKMESSAGE_SERVICE_ROUTINE , pub ServiceContext : PVOID , pub SpinLock : PKSPIN_LOCK , pub SynchronizeIrql : KIRQL , pub FloatingSave : BOOLEAN , pub FallBackServiceRoutine : PKSERVICE_ROUTINE , } # [ repr ( C ) ] pub struct _IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS__bindgen_ty_1 { pub Generic : __BindgenUnionField < * mut PVOID > , pub InterruptMessageTable : __BindgenUnionField < * mut PIO_INTERRUPT_MESSAGE_INFO > , pub InterruptObject : __BindgenUnionField < * mut PKINTERRUPT > , pub bindgen_union_field : u64 , } pub type IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS = _IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS ; pub type PIO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS = * mut _IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS ; # [ repr ( C ) ] pub struct _IO_CONNECT_INTERRUPT_PARAMETERS { pub Version : ULONG , pub __bindgen_anon_1 : _IO_CONNECT_INTERRUPT_PARAMETERS__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _IO_CONNECT_INTERRUPT_PARAMETERS__bindgen_ty_1 { pub FullySpecified : __BindgenUnionField < IO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS > , pub LineBased : __BindgenUnionField < IO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS > , pub MessageBased : __BindgenUnionField < IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS > , pub bindgen_union_field : [ u64 ; 9usize ] , } pub type IO_CONNECT_INTERRUPT_PARAMETERS = _IO_CONNECT_INTERRUPT_PARAMETERS ; pub type PIO_CONNECT_INTERRUPT_PARAMETERS = * mut _IO_CONNECT_INTERRUPT_PARAMETERS ; extern "C" { pub fn IoConnectInterruptEx ( Parameters : PIO_CONNECT_INTERRUPT_PARAMETERS ) -> NTSTATUS ; } extern "C" { pub fn IoCreateDevice ( DriverObject : PDRIVER_OBJECT , DeviceExtensionSize : ULONG , DeviceName : PUNICODE_STRING , DeviceType : ULONG , DeviceCharacteristics : ULONG , Exclusive : BOOLEAN , DeviceObject : * mut PDEVICE_OBJECT ) -> NTSTATUS ; } extern "C" { pub fn IoIsWdmVersionAvailable ( MajorVersion : UCHAR , MinorVersion : UCHAR ) -> BOOLEAN ; } extern "C" { pub fn IoCreateFile ( FileHandle : PHANDLE , DesiredAccess : ACCESS_MASK , ObjectAttributes : POBJECT_ATTRIBUTES , IoStatusBlock : PIO_STATUS_BLOCK , AllocationSize : PLARGE_INTEGER , FileAttributes : ULONG , ShareAccess : ULONG , Disposition : ULONG , CreateOptions : ULONG , EaBuffer : PVOID , EaLength : ULONG , CreateFileType : CREATE_FILE_TYPE , InternalParameters : PVOID , Options : ULONG ) -> NTSTATUS ; } extern "C" { pub fn IoCreateNotificationEvent ( EventName : PUNICODE_STRING , EventHandle : PHANDLE ) -> PKEVENT ; } extern "C" { pub fn IoCreateSymbolicLink ( SymbolicLinkName : PUNICODE_STRING , DeviceName : PUNICODE_STRING ) -> NTSTATUS ; } extern "C" { pub fn IoCreateSynchronizationEvent ( EventName : PUNICODE_STRING , EventHandle : PHANDLE ) -> PKEVENT ; } extern "C" { pub fn IoCreateUnprotectedSymbolicLink ( SymbolicLinkName : PUNICODE_STRING , DeviceName : PUNICODE_STRING ) -> NTSTATUS ; } extern "C" { pub fn IoDeleteDevice ( DeviceObject : PDEVICE_OBJECT ) ; } extern "C" { pub fn IoDeleteSymbolicLink ( SymbolicLinkName : PUNICODE_STRING ) -> NTSTATUS ; } extern "C" { pub fn IoDetachDevice ( TargetDevice : PDEVICE_OBJECT ) ; } extern "C" { pub fn IoDisconnectInterrupt ( InterruptObject : PKINTERRUPT ) ; } # [ repr ( C ) ] pub struct _IO_DISCONNECT_INTERRUPT_PARAMETERS { pub Version : ULONG , pub ConnectionContext : _IO_DISCONNECT_INTERRUPT_PARAMETERS__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _IO_DISCONNECT_INTERRUPT_PARAMETERS__bindgen_ty_1 { pub Generic : __BindgenUnionField < PVOID > , pub InterruptObject : __BindgenUnionField < PKINTERRUPT > , pub InterruptMessageTable : __BindgenUnionField < PIO_INTERRUPT_MESSAGE_INFO > , pub bindgen_union_field : u64 , } pub type IO_DISCONNECT_INTERRUPT_PARAMETERS = _IO_DISCONNECT_INTERRUPT_PARAMETERS ; pub type PIO_DISCONNECT_INTERRUPT_PARAMETERS = * mut _IO_DISCONNECT_INTERRUPT_PARAMETERS ; extern "C" { pub fn IoDisconnectInterruptEx ( Parameters : PIO_DISCONNECT_INTERRUPT_PARAMETERS ) ; } # [ repr ( C ) ] pub struct _IO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS { pub Version : ULONG , pub ConnectionContext : _IO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _IO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS__bindgen_ty_1 { pub Generic : __BindgenUnionField < PVOID > , pub InterruptObject : __BindgenUnionField < PKINTERRUPT > , pub InterruptMessageTable : __BindgenUnionField < PIO_INTERRUPT_MESSAGE_INFO > , pub bindgen_union_field : u64 , } pub type IO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS = _IO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS ; pub type PIO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS = * mut _IO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS ; extern "C" { pub fn IoReportInterruptActive ( Parameters : PIO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS ) ; } extern "C" { pub fn IoReportInterruptInactive ( Parameters : PIO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS ) ; } extern "C" { pub fn IoGetAffinityInterrupt ( InterruptObject : PKINTERRUPT , GroupAffinity : PGROUP_AFFINITY ) -> NTSTATUS ; } extern "C" { pub fn IoFreeIrp ( Irp : PIRP ) ; } extern "C" { pub fn IoFreeMdl ( Mdl : PMDL ) ; } extern "C" { pub fn IoGetAttachedDeviceReference ( DeviceObject : PDEVICE_OBJECT ) -> PDEVICE_OBJECT ; } extern "C" { pub fn IoGetDriverObjectExtension ( DriverObject : PDRIVER_OBJECT , ClientIdentificationAddress : PVOID ) -> PVOID ; } extern "C" { pub fn IoGetCurrentProcess ( ) -> PEPROCESS ; } extern "C" { pub fn IoGetDeviceObjectPointer ( ObjectName : PUNICODE_STRING , DesiredAccess : ACCESS_MASK , FileObject : * mut PFILE_OBJECT , DeviceObject : * mut PDEVICE_OBJECT ) -> NTSTATUS ; } extern "C" { pub fn IoGetDmaAdapter ( PhysicalDeviceObject : PDEVICE_OBJECT , DeviceDescription : * mut _DEVICE_DESCRIPTION , NumberOfMapRegisters : PULONG ) -> * mut _DMA_ADAPTER ; } extern "C" { pub fn IoForwardIrpSynchronously ( DeviceObject : PDEVICE_OBJECT , Irp : PIRP ) -> BOOLEAN ; } extern "C" { pub fn IoSynchronousCallDriver ( DeviceObject : PDEVICE_OBJECT , Irp : PIRP ) -> NTSTATUS ; } extern "C" { pub fn IoGetInitialStack ( ) -> PVOID ; } extern "C" { pub fn IoGetStackLimits ( LowLimit : PULONG_PTR , HighLimit : PULONG_PTR ) ; } extern "C" { pub fn IoWithinStackLimits ( RegionStart : ULONG_PTR , RegionSize : SIZE_T ) -> LOGICAL ; } extern "C" { pub fn IoGetRelatedDeviceObject ( FileObject : PFILE_OBJECT ) -> PDEVICE_OBJECT ; } extern "C" { pub fn IoGetTopLevelIrp ( ) -> PIRP ; } extern "C" { pub fn IoInitializeIrp ( Irp : PIRP , PacketSize : USHORT , StackSize : CCHAR ) ; } extern "C" { pub fn IoCleanupIrp ( Irp : PIRP ) ; } extern "C" { pub fn IoInitializeIrpEx ( Irp : PIRP , DeviceObject : PDEVICE_OBJECT , PacketSize : USHORT , StackSize : CCHAR ) ; } extern "C" { pub fn IoInitializeTimer ( DeviceObject : PDEVICE_OBJECT , TimerRoutine : PIO_TIMER_ROUTINE , Context : PVOID ) -> NTSTATUS ; } extern "C" { pub fn IoReuseIrp ( Irp : PIRP , Iostatus : NTSTATUS ) ; } extern "C" { pub fn IoRegisterShutdownNotification ( DeviceObject : PDEVICE_OBJECT ) -> NTSTATUS ; } extern "C" { pub fn IoRegisterLastChanceShutdownNotification ( DeviceObject : PDEVICE_OBJECT ) -> NTSTATUS ; } extern "C" { pub fn IoReleaseCancelSpinLock ( Irql : KIRQL ) ; } extern "C" { pub fn IoRemoveShareAccess ( FileObject : PFILE_OBJECT , ShareAccess : PSHARE_ACCESS ) ; } extern "C" { pub fn IoRemoveLinkShareAccess ( FileObject : PFILE_OBJECT , ShareAccess : PSHARE_ACCESS , LinkShareAccess : PLINK_SHARE_ACCESS ) ; } extern "C" { pub fn IoSetCompletionRoutineEx ( DeviceObject : PDEVICE_OBJECT , Irp : PIRP , CompletionRoutine : PIO_COMPLETION_ROUTINE , Context : PVOID , InvokeOnSuccess : BOOLEAN , InvokeOnError : BOOLEAN , InvokeOnCancel : BOOLEAN ) -> NTSTATUS ; } extern "C" { pub fn IoSetShareAccess ( DesiredAccess : ACCESS_MASK , DesiredShareAccess : ULONG , FileObject : PFILE_OBJECT , ShareAccess : PSHARE_ACCESS ) ; } extern "C" { pub fn IoSetShareAccessEx ( DesiredAccess : ACCESS_MASK , DesiredShareAccess : ULONG , FileObject : PFILE_OBJECT , ShareAccess : PSHARE_ACCESS , WritePermission : PBOOLEAN ) ; } extern "C" { pub fn IoSetLinkShareAccess ( DesiredAccess : ACCESS_MASK , DesiredShareAccess : ULONG , FileObject : PFILE_OBJECT , ShareAccess : PSHARE_ACCESS , LinkShareAccess : PLINK_SHARE_ACCESS , IoShareAccessFlags : ULONG ) ; } extern "C" { pub fn IoSetTopLevelIrp ( Irp : PIRP ) ; } # [ repr ( C ) ] pub struct _IO_REMOVE_LOCK_TRACKING_BLOCK { _unused : [ u8 ; 0 ] , } pub type PIO_REMOVE_LOCK_TRACKING_BLOCK = * mut _IO_REMOVE_LOCK_TRACKING_BLOCK ; # [ repr ( C ) ] pub struct _IO_REMOVE_LOCK_COMMON_BLOCK { pub Removed : BOOLEAN , pub Reserved : [ BOOLEAN ; 3usize ] , pub IoCount : LONG , pub RemoveEvent : KEVENT , } pub type IO_REMOVE_LOCK_COMMON_BLOCK = _IO_REMOVE_LOCK_COMMON_BLOCK ; # [ repr ( C ) ] pub struct _IO_REMOVE_LOCK_DBG_BLOCK { pub Signature : LONG , pub HighWatermark : ULONG , pub MaxLockedTicks : LONGLONG , pub AllocateTag : LONG , pub LockList : LIST_ENTRY , pub Spin : KSPIN_LOCK , pub LowMemoryCount : LONG , pub Reserved1 : [ ULONG ; 4usize ] , pub Reserved2 : PVOID , pub Blocks : PIO_REMOVE_LOCK_TRACKING_BLOCK , } pub type IO_REMOVE_LOCK_DBG_BLOCK = _IO_REMOVE_LOCK_DBG_BLOCK ; # [ repr ( C ) ] pub struct _IO_REMOVE_LOCK { pub Common : IO_REMOVE_LOCK_COMMON_BLOCK , } pub type IO_REMOVE_LOCK = _IO_REMOVE_LOCK ; pub type PIO_REMOVE_LOCK = * mut _IO_REMOVE_LOCK ; extern "C" { pub fn IoInitializeRemoveLockEx ( Lock : PIO_REMOVE_LOCK , AllocateTag : ULONG , MaxLockedMinutes : ULONG , HighWatermark : ULONG , RemlockSize : ULONG ) ; } extern "C" { pub fn IoAcquireRemoveLockEx ( RemoveLock : PIO_REMOVE_LOCK , Tag : PVOID , File : PCSTR , Line : ULONG , RemlockSize : ULONG ) -> NTSTATUS ; } extern "C" { pub fn IoReleaseRemoveLockEx ( RemoveLock : PIO_REMOVE_LOCK , Tag : PVOID , RemlockSize : ULONG ) ; } extern "C" { pub fn IoReleaseRemoveLockAndWaitEx ( RemoveLock : PIO_REMOVE_LOCK , Tag : PVOID , RemlockSize : ULONG ) ; } extern "C" { pub fn IoSizeOfIrpEx ( DeviceObject : PDEVICE_OBJECT , StackSize : CCHAR ) -> USHORT ; } extern "C" { pub fn IoStartNextPacket ( DeviceObject : PDEVICE_OBJECT , Cancelable : BOOLEAN ) ; } extern "C" { pub fn IoStartNextPacketByKey ( DeviceObject : PDEVICE_OBJECT , Cancelable : BOOLEAN , Key : ULONG ) ; } extern "C" { pub fn IoStartPacket ( DeviceObject : PDEVICE_OBJECT , Irp : PIRP , Key : PULONG , CancelFunction : PDRIVER_CANCEL ) ; } extern "C" { pub fn IoSetStartIoAttributes ( DeviceObject : PDEVICE_OBJECT , DeferredStartIo : BOOLEAN , NonCancelable : BOOLEAN ) ; } extern "C" { pub fn IoStartTimer ( DeviceObject : PDEVICE_OBJECT ) ; } extern "C" { pub fn IoStopTimer ( DeviceObject : PDEVICE_OBJECT ) ; } extern "C" { pub fn IoUnregisterShutdownNotification ( DeviceObject : PDEVICE_OBJECT ) ; } extern "C" { pub fn IoUpdateShareAccess ( FileObject : PFILE_OBJECT , ShareAccess : PSHARE_ACCESS ) ; } extern "C" { pub fn IoUpdateLinkShareAccess ( FileObject : PFILE_OBJECT , ShareAccess : PSHARE_ACCESS , LinkShareAccess : PLINK_SHARE_ACCESS ) ; } extern "C" { pub fn IoWriteErrorLogEntry ( ElEntry : PVOID ) ; } extern "C" { pub fn IoCreateSystemThread ( IoObject : PVOID , ThreadHandle : PHANDLE , DesiredAccess : ULONG , ObjectAttributes : POBJECT_ATTRIBUTES , ProcessHandle : HANDLE , ClientId : PCLIENT_ID , StartRoutine : PKSTART_ROUTINE , StartContext : PVOID ) -> NTSTATUS ; } # [ repr ( C ) ] pub struct _IO_WORKITEM { _unused : [ u8 ; 0 ] , } pub type PIO_WORKITEM = * mut _IO_WORKITEM ; pub type IO_WORKITEM_ROUTINE = :: std :: option :: Option < unsafe extern "C" fn ( DeviceObject : PDEVICE_OBJECT , Context : PVOID ) > ; pub type PIO_WORKITEM_ROUTINE = IO_WORKITEM_ROUTINE ; extern "C" { pub fn IoAllocateWorkItem ( DeviceObject : PDEVICE_OBJECT ) -> PIO_WORKITEM ; } extern "C" { pub fn IoFreeWorkItem ( IoWorkItem : PIO_WORKITEM ) ; } extern "C" { pub fn IoQueueWorkItem ( IoWorkItem : PIO_WORKITEM , WorkerRoutine : PIO_WORKITEM_ROUTINE , QueueType : WORK_QUEUE_TYPE , Context : PVOID ) ; } pub type IO_WORKITEM_ROUTINE_EX = :: std :: option :: Option < unsafe extern "C" fn ( IoObject : PVOID , Context : PVOID , IoWorkItem : PIO_WORKITEM ) > ; pub type PIO_WORKITEM_ROUTINE_EX = IO_WORKITEM_ROUTINE_EX ; extern "C" { pub fn IoQueueWorkItemEx ( IoWorkItem : PIO_WORKITEM , WorkerRoutine : PIO_WORKITEM_ROUTINE_EX , QueueType : WORK_QUEUE_TYPE , Context : PVOID ) ; } extern "C" { pub fn IoSizeofWorkItem ( ) -> ULONG ; } extern "C" { pub fn IoInitializeWorkItem ( IoObject : PVOID , IoWorkItem : PIO_WORKITEM ) ; } extern "C" { pub fn IoUninitializeWorkItem ( IoWorkItem : PIO_WORKITEM ) ; } extern "C" { pub fn IoTryQueueWorkItem ( IoWorkItem : PIO_WORKITEM , WorkerRoutine : PIO_WORKITEM_ROUTINE_EX , QueueType : WORK_QUEUE_TYPE , Context : PVOID ) -> BOOLEAN ; } extern "C" { pub fn IoWMIRegistrationControl ( DeviceObject : PDEVICE_OBJECT , Action : ULONG ) -> NTSTATUS ; } extern "C" { pub fn IoWMIAllocateInstanceIds ( Guid : LPCGUID , InstanceCount : ULONG , FirstInstanceId : * mut ULONG ) -> NTSTATUS ; } extern "C" { pub fn IoWMISuggestInstanceName ( PhysicalDeviceObject : PDEVICE_OBJECT , SymbolicLinkName : PUNICODE_STRING , CombineNames : BOOLEAN , SuggestedInstanceName : PUNICODE_STRING ) -> NTSTATUS ; } extern "C" { pub fn IoWMIWriteEvent ( WnodeEventItem : PVOID ) -> NTSTATUS ; } extern "C" { pub fn IoWMIDeviceObjectToProviderId ( DeviceObject : PDEVICE_OBJECT ) -> ULONG ; } extern "C" { pub fn IoWMIOpenBlock ( Guid : LPCGUID , DesiredAccess : ULONG , DataBlockObject : * mut PVOID ) -> NTSTATUS ; } extern "C" { pub fn IoWMIQueryAllData ( DataBlockObject : PVOID , InOutBufferSize : PULONG , OutBuffer : PVOID ) -> NTSTATUS ; } extern "C" { pub fn IoWMIQueryAllDataMultiple ( DataBlockObjectList : * mut PVOID , ObjectCount : ULONG , InOutBufferSize : PULONG , OutBuffer : PVOID ) -> NTSTATUS ; } extern "C" { pub fn IoWMIQuerySingleInstance ( DataBlockObject : PVOID , InstanceName : PUNICODE_STRING , InOutBufferSize : PULONG , OutBuffer : PVOID ) -> NTSTATUS ; } extern "C" { pub fn IoWMIQuerySingleInstanceMultiple ( DataBlockObjectList : * mut PVOID , InstanceNames : PUNICODE_STRING , ObjectCount : ULONG , InOutBufferSize : PULONG , OutBuffer : PVOID ) -> NTSTATUS ; } extern "C" { pub fn IoWMISetSingleInstance ( DataBlockObject : PVOID , InstanceName : PUNICODE_STRING , Version : ULONG , ValueBufferSize : ULONG , ValueBuffer : PVOID ) -> NTSTATUS ; } extern "C" { pub fn IoWMISetSingleItem ( DataBlockObject : PVOID , InstanceName : PUNICODE_STRING , DataItemId : ULONG , Version : ULONG , ValueBufferSize : ULONG , ValueBuffer : PVOID ) -> NTSTATUS ; } extern "C" { pub fn IoWMIExecuteMethod ( DataBlockObject : PVOID , InstanceName : PUNICODE_STRING , MethodId : ULONG , InBufferSize : ULONG , OutBufferSize : PULONG , InOutBuffer : PUCHAR ) -> NTSTATUS ; } pub type FWMI_NOTIFICATION_CALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( Wnode : PVOID , Context : PVOID ) > ; pub type WMI_NOTIFICATION_CALLBACK = FWMI_NOTIFICATION_CALLBACK ; extern "C" { pub fn IoWMISetNotificationCallback ( Object : PVOID , Callback : WMI_NOTIFICATION_CALLBACK , Context : PVOID ) -> NTSTATUS ; } extern "C" { pub fn IoWMIHandleToInstanceName ( DataBlockObject : PVOID , FileHandle : HANDLE , InstanceName : PUNICODE_STRING ) -> NTSTATUS ; } extern "C" { pub fn IoWMIDeviceObjectToInstanceName ( DataBlockObject : PVOID , DeviceObject : PDEVICE_OBJECT , InstanceName : PUNICODE_STRING ) -> NTSTATUS ; } extern "C" { pub fn IoIs32bitProcess ( Irp : PIRP ) -> BOOLEAN ; } extern "C" { pub fn IoIsInitiator32bitProcess ( Irp : PIRP ) -> BOOLEAN ; } extern "C" { pub fn IoFreeErrorLogEntry ( ElEntry : PVOID ) ; } pub type IO_CSQ = _IO_CSQ ; pub type PIO_CSQ = * mut _IO_CSQ ; # [ repr ( C ) ] pub struct _IO_CSQ_IRP_CONTEXT { pub Type : ULONG , pub Irp : PIRP , pub Csq : PIO_CSQ , } pub type IO_CSQ_IRP_CONTEXT = _IO_CSQ_IRP_CONTEXT ; pub type PIO_CSQ_IRP_CONTEXT = * mut _IO_CSQ_IRP_CONTEXT ; pub type IO_CSQ_INSERT_IRP = :: std :: option :: Option < unsafe extern "C" fn ( Csq : * mut _IO_CSQ , Irp : PIRP ) > ; pub type PIO_CSQ_INSERT_IRP = IO_CSQ_INSERT_IRP ; pub type IO_CSQ_INSERT_IRP_EX = :: std :: option :: Option < unsafe extern "C" fn ( Csq : * mut _IO_CSQ , Irp : PIRP , InsertContext : PVOID ) -> NTSTATUS > ; pub type PIO_CSQ_INSERT_IRP_EX = IO_CSQ_INSERT_IRP_EX ; pub type IO_CSQ_REMOVE_IRP = :: std :: option :: Option < unsafe extern "C" fn ( Csq : PIO_CSQ , Irp : PIRP ) > ; pub type PIO_CSQ_REMOVE_IRP = IO_CSQ_REMOVE_IRP ; pub type IO_CSQ_PEEK_NEXT_IRP = :: std :: option :: Option < unsafe extern "C" fn ( Csq : PIO_CSQ , Irp : PIRP , PeekContext : PVOID ) -> PIRP > ; pub type PIO_CSQ_PEEK_NEXT_IRP = IO_CSQ_PEEK_NEXT_IRP ; pub type IO_CSQ_ACQUIRE_LOCK = :: std :: option :: Option < unsafe extern "C" fn ( Csq : PIO_CSQ , Irql : PKIRQL ) > ; pub type PIO_CSQ_ACQUIRE_LOCK = IO_CSQ_ACQUIRE_LOCK ; pub type IO_CSQ_RELEASE_LOCK = :: std :: option :: Option < unsafe extern "C" fn ( Csq : PIO_CSQ , Irql : KIRQL ) > ; pub type PIO_CSQ_RELEASE_LOCK = IO_CSQ_RELEASE_LOCK ; pub type IO_CSQ_COMPLETE_CANCELED_IRP = :: std :: option :: Option < unsafe extern "C" fn ( Csq : PIO_CSQ , Irp : PIRP ) > ; pub type PIO_CSQ_COMPLETE_CANCELED_IRP = IO_CSQ_COMPLETE_CANCELED_IRP ; # [ repr ( C ) ] pub struct _IO_CSQ { pub Type : ULONG , pub CsqInsertIrp : PIO_CSQ_INSERT_IRP , pub CsqRemoveIrp : PIO_CSQ_REMOVE_IRP , pub CsqPeekNextIrp : PIO_CSQ_PEEK_NEXT_IRP , pub CsqAcquireLock : PIO_CSQ_ACQUIRE_LOCK , pub CsqReleaseLock : PIO_CSQ_RELEASE_LOCK , pub CsqCompleteCanceledIrp : PIO_CSQ_COMPLETE_CANCELED_IRP , pub ReservePointer : PVOID , } extern "C" { pub fn IoCsqInitialize ( Csq : PIO_CSQ , CsqInsertIrp : PIO_CSQ_INSERT_IRP , CsqRemoveIrp : PIO_CSQ_REMOVE_IRP , CsqPeekNextIrp : PIO_CSQ_PEEK_NEXT_IRP , CsqAcquireLock : PIO_CSQ_ACQUIRE_LOCK , CsqReleaseLock : PIO_CSQ_RELEASE_LOCK , CsqCompleteCanceledIrp : PIO_CSQ_COMPLETE_CANCELED_IRP ) -> NTSTATUS ; } extern "C" { pub fn IoCsqInitializeEx ( Csq : PIO_CSQ , CsqInsertIrp : PIO_CSQ_INSERT_IRP_EX , CsqRemoveIrp : PIO_CSQ_REMOVE_IRP , CsqPeekNextIrp : PIO_CSQ_PEEK_NEXT_IRP , CsqAcquireLock : PIO_CSQ_ACQUIRE_LOCK , CsqReleaseLock : PIO_CSQ_RELEASE_LOCK , CsqCompleteCanceledIrp : PIO_CSQ_COMPLETE_CANCELED_IRP ) -> NTSTATUS ; } extern "C" { pub fn IoCsqInsertIrp ( Csq : PIO_CSQ , Irp : PIRP , Context : PIO_CSQ_IRP_CONTEXT ) ; } extern "C" { pub fn IoCsqInsertIrpEx ( Csq : PIO_CSQ , Irp : PIRP , Context : PIO_CSQ_IRP_CONTEXT , InsertContext : PVOID ) -> NTSTATUS ; } extern "C" { pub fn IoCsqRemoveNextIrp ( Csq : PIO_CSQ , PeekContext : PVOID ) -> PIRP ; } extern "C" { pub fn IoCsqRemoveIrp ( Csq : PIO_CSQ , Context : PIO_CSQ_IRP_CONTEXT ) -> PIRP ; } extern "C" { pub fn IoValidateDeviceIoControlAccess ( Irp : PIRP , RequiredAccess : ULONG ) -> NTSTATUS ; } extern "C" { pub fn IoGetIoPriorityHint ( Irp : PIRP ) -> IO_PRIORITY_HINT ; } extern "C" { pub fn IoSetIoPriorityHint ( Irp : PIRP , PriorityHint : IO_PRIORITY_HINT ) -> NTSTATUS ; } extern "C" { pub fn IoAllocateSfioStreamIdentifier ( FileObject : PFILE_OBJECT , Length : ULONG , Signature : PVOID , StreamIdentifier : * mut PVOID ) -> NTSTATUS ; } extern "C" { pub fn IoGetSfioStreamIdentifier ( FileObject : PFILE_OBJECT , Signature : PVOID ) -> PVOID ; } extern "C" { pub fn IoFreeSfioStreamIdentifier ( FileObject : PFILE_OBJECT , Signature : PVOID ) -> NTSTATUS ; } extern "C" { pub fn IoGetIoAttributionHandle ( Irp : PIRP , IoAttributionHandle : * mut PVOID ) -> NTSTATUS ; } # [ repr ( C ) ] pub struct _IO_ATTRIBUTION_INFORMATION { pub Version : ULONG , pub Flags : _IO_ATTRIBUTION_INFORMATION__bindgen_ty_1 , pub Length : ULONG , pub ServiceStartTime : ULONGLONG , pub CurrentTime : ULONGLONG , } # [ repr ( C ) ] pub struct _IO_ATTRIBUTION_INFORMATION__bindgen_ty_1 { pub __bindgen_anon_1 : __BindgenUnionField < _IO_ATTRIBUTION_INFORMATION__bindgen_ty_1__bindgen_ty_1 > , pub AllFlags : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _IO_ATTRIBUTION_INFORMATION__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _IO_ATTRIBUTION_INFORMATION__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn MajorCode ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_MajorCode ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn IoStart ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_IoStart ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn QueueOnly ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_QueueOnly ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn IoFailed ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_IoFailed ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 1u8 , val as u64 ) } } # [ inline ] pub fn VirtualDevice ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_VirtualDevice ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Spare ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 20u8 ) as u32 ) } } # [ inline ] pub fn set_Spare ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 20u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( MajorCode : ULONG , IoStart : ULONG , QueueOnly : ULONG , IoFailed : ULONG , VirtualDevice : ULONG , Spare : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let MajorCode : u32 = unsafe { :: std :: mem :: transmute ( MajorCode ) } ; MajorCode as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let IoStart : u32 = unsafe { :: std :: mem :: transmute ( IoStart ) } ; IoStart as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let QueueOnly : u32 = unsafe { :: std :: mem :: transmute ( QueueOnly ) } ; QueueOnly as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 1u8 , { let IoFailed : u32 = unsafe { :: std :: mem :: transmute ( IoFailed ) } ; IoFailed as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 1u8 , { let VirtualDevice : u32 = unsafe { :: std :: mem :: transmute ( VirtualDevice ) } ; VirtualDevice as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 20u8 , { let Spare : u32 = unsafe { :: std :: mem :: transmute ( Spare ) } ; Spare as u64 } ) ; __bindgen_bitfield_unit } } pub type IO_ATTRIBUTION_INFORMATION = _IO_ATTRIBUTION_INFORMATION ; pub type PIO_ATTRIBUTION_INFORMATION = * mut _IO_ATTRIBUTION_INFORMATION ; extern "C" { pub fn IoRecordIoAttribution ( OpaqueHandle : PVOID , AttributionInformation : * mut IO_ATTRIBUTION_INFORMATION ) -> NTSTATUS ; } extern "C" { pub fn IoSetIoAttributionIrp ( Irp : PIRP , AttributionSource : PVOID , Flags : ULONG ) -> NTSTATUS ; } pub const _IO_ACCESS_TYPE_ReadAccess : _IO_ACCESS_TYPE = 0 ; pub const _IO_ACCESS_TYPE_WriteAccess : _IO_ACCESS_TYPE = 1 ; pub const _IO_ACCESS_TYPE_ModifyAccess : _IO_ACCESS_TYPE = 2 ; pub type _IO_ACCESS_TYPE = i32 ; pub use self :: _IO_ACCESS_TYPE as IO_ACCESS_TYPE ; pub const _IO_ACCESS_MODE_SequentialAccess : _IO_ACCESS_MODE = 0 ; pub const _IO_ACCESS_MODE_RandomAccess : _IO_ACCESS_MODE = 1 ; pub type _IO_ACCESS_MODE = i32 ; pub use self :: _IO_ACCESS_MODE as IO_ACCESS_MODE ; pub const _IO_CONTAINER_NOTIFICATION_CLASS_IoSessionStateNotification : _IO_CONTAINER_NOTIFICATION_CLASS = 0 ; pub const _IO_CONTAINER_NOTIFICATION_CLASS_IoMaxContainerNotificationClass : _IO_CONTAINER_NOTIFICATION_CLASS = 1 ; pub type _IO_CONTAINER_NOTIFICATION_CLASS = i32 ; pub use self :: _IO_CONTAINER_NOTIFICATION_CLASS as IO_CONTAINER_NOTIFICATION_CLASS ; # [ repr ( C ) ] pub struct _IO_SESSION_STATE_NOTIFICATION { pub Size : ULONG , pub Flags : ULONG , pub IoObject : PVOID , pub EventMask : ULONG , pub Context : PVOID , } pub type IO_SESSION_STATE_NOTIFICATION = _IO_SESSION_STATE_NOTIFICATION ; pub type PIO_SESSION_STATE_NOTIFICATION = * mut _IO_SESSION_STATE_NOTIFICATION ; pub const _IO_CONTAINER_INFORMATION_CLASS_IoSessionStateInformation : _IO_CONTAINER_INFORMATION_CLASS = 0 ; pub const _IO_CONTAINER_INFORMATION_CLASS_IoMaxContainerInformationClass : _IO_CONTAINER_INFORMATION_CLASS = 1 ; pub type _IO_CONTAINER_INFORMATION_CLASS = i32 ; pub use self :: _IO_CONTAINER_INFORMATION_CLASS as IO_CONTAINER_INFORMATION_CLASS ; # [ repr ( C ) ] pub struct _IO_SESSION_STATE_INFORMATION { pub SessionId : ULONG , pub SessionState : IO_SESSION_STATE , pub LocalSession : BOOLEAN , } pub type IO_SESSION_STATE_INFORMATION = _IO_SESSION_STATE_INFORMATION ; pub type PIO_SESSION_STATE_INFORMATION = * mut _IO_SESSION_STATE_INFORMATION ; extern "C" { pub fn IoGetContainerInformation ( InformationClass : IO_CONTAINER_INFORMATION_CLASS , ContainerObject : PVOID , Buffer : PVOID , BufferLength : ULONG ) -> NTSTATUS ; } pub type PIO_CONTAINER_NOTIFICATION_FUNCTION = :: std :: option :: Option < unsafe extern "C" fn ( ) -> NTSTATUS > ; pub type IO_SESSION_NOTIFICATION_FUNCTION = :: std :: option :: Option < unsafe extern "C" fn ( SessionObject : PVOID , IoObject : PVOID , Event : ULONG , Context : PVOID , NotificationPayload : PVOID , PayloadLength : ULONG ) -> NTSTATUS > ; pub type PIO_SESSION_NOTIFICATION_FUNCTION = IO_SESSION_NOTIFICATION_FUNCTION ; extern "C" { pub fn IoRegisterContainerNotification ( NotificationClass : IO_CONTAINER_NOTIFICATION_CLASS , CallbackFunction : PIO_CONTAINER_NOTIFICATION_FUNCTION , NotificationInformation : PVOID , NotificationInformationLength : ULONG , CallbackRegistration : PVOID ) -> NTSTATUS ; } extern "C" { pub fn IoUnregisterContainerNotification ( CallbackRegistration : PVOID ) ; } pub type TRACEHANDLE = ULONG64 ; pub type PTRACEHANDLE = * mut ULONG64 ; # [ repr ( C ) ] pub struct _ETW_TRACE_SESSION_SETTINGS { pub Version : ULONG , pub BufferSize : ULONG , pub MinimumBuffers : ULONG , pub MaximumBuffers : ULONG , pub LoggerMode : ULONG , pub FlushTimer : ULONG , pub FlushThreshold : ULONG , pub ClockType : ULONG , } pub type ETW_TRACE_SESSION_SETTINGS = _ETW_TRACE_SESSION_SETTINGS ; pub type PETW_TRACE_SESSION_SETTINGS = * mut _ETW_TRACE_SESSION_SETTINGS ; pub const _TRACE_INFORMATION_CLASS_TraceIdClass : _TRACE_INFORMATION_CLASS = 0 ; pub const _TRACE_INFORMATION_CLASS_TraceHandleClass : _TRACE_INFORMATION_CLASS = 1 ; pub const _TRACE_INFORMATION_CLASS_TraceEnableFlagsClass : _TRACE_INFORMATION_CLASS = 2 ; pub const _TRACE_INFORMATION_CLASS_TraceEnableLevelClass : _TRACE_INFORMATION_CLASS = 3 ; pub const _TRACE_INFORMATION_CLASS_GlobalLoggerHandleClass : _TRACE_INFORMATION_CLASS = 4 ; pub const _TRACE_INFORMATION_CLASS_EventLoggerHandleClass : _TRACE_INFORMATION_CLASS = 5 ; pub const _TRACE_INFORMATION_CLASS_AllLoggerHandlesClass : _TRACE_INFORMATION_CLASS = 6 ; pub const _TRACE_INFORMATION_CLASS_TraceHandleByNameClass : _TRACE_INFORMATION_CLASS = 7 ; pub const _TRACE_INFORMATION_CLASS_LoggerEventsLostClass : _TRACE_INFORMATION_CLASS = 8 ; pub const _TRACE_INFORMATION_CLASS_TraceSessionSettingsClass : _TRACE_INFORMATION_CLASS = 9 ; pub const _TRACE_INFORMATION_CLASS_LoggerEventsLoggedClass : _TRACE_INFORMATION_CLASS = 10 ; pub const _TRACE_INFORMATION_CLASS_DiskIoNotifyRoutinesClass : _TRACE_INFORMATION_CLASS = 11 ; pub const _TRACE_INFORMATION_CLASS_TraceInformationClassReserved1 : _TRACE_INFORMATION_CLASS = 12 ; pub const _TRACE_INFORMATION_CLASS_FltIoNotifyRoutinesClass : _TRACE_INFORMATION_CLASS = 13 ; pub const _TRACE_INFORMATION_CLASS_TraceInformationClassReserved2 : _TRACE_INFORMATION_CLASS = 14 ; pub const _TRACE_INFORMATION_CLASS_WdfNotifyRoutinesClass : _TRACE_INFORMATION_CLASS = 15 ; pub const _TRACE_INFORMATION_CLASS_MaxTraceInformationClass : _TRACE_INFORMATION_CLASS = 16 ; pub type _TRACE_INFORMATION_CLASS = i32 ; pub use self :: _TRACE_INFORMATION_CLASS as TRACE_INFORMATION_CLASS ; extern "C" { pub fn WmiQueryTraceInformation ( TraceInformationClass : TRACE_INFORMATION_CLASS , TraceInformation : PVOID , TraceInformationLength : ULONG , RequiredLength : PULONG , Buffer : PVOID ) -> NTSTATUS ; } pub type REGHANDLE = ULONGLONG ; pub type PREGHANDLE = * mut ULONGLONG ; # [ repr ( C ) ] pub struct _EVENT_DATA_DESCRIPTOR { pub Ptr : ULONGLONG , pub Size : ULONG , pub __bindgen_anon_1 : _EVENT_DATA_DESCRIPTOR__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _EVENT_DATA_DESCRIPTOR__bindgen_ty_1 { pub Reserved : __BindgenUnionField < ULONG > , pub __bindgen_anon_1 : __BindgenUnionField < _EVENT_DATA_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _EVENT_DATA_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 { pub Type : UCHAR , pub Reserved1 : UCHAR , pub Reserved2 : USHORT , } pub type EVENT_DATA_DESCRIPTOR = _EVENT_DATA_DESCRIPTOR ; pub type PEVENT_DATA_DESCRIPTOR = * mut _EVENT_DATA_DESCRIPTOR ; # [ repr ( C ) ] pub struct _EVENT_DESCRIPTOR { pub Id : USHORT , pub Version : UCHAR , pub Channel : UCHAR , pub Level : UCHAR , pub Opcode : UCHAR , pub Task : USHORT , pub Keyword : ULONGLONG , } pub type EVENT_DESCRIPTOR = _EVENT_DESCRIPTOR ; pub type PEVENT_DESCRIPTOR = * mut _EVENT_DESCRIPTOR ; pub type PCEVENT_DESCRIPTOR = * const EVENT_DESCRIPTOR ; # [ repr ( C ) ] pub struct _EVENT_FILTER_DESCRIPTOR { pub Ptr : ULONGLONG , pub Size : ULONG , pub Type : ULONG , } pub type EVENT_FILTER_DESCRIPTOR = _EVENT_FILTER_DESCRIPTOR ; pub type PEVENT_FILTER_DESCRIPTOR = * mut _EVENT_FILTER_DESCRIPTOR ; # [ repr ( C ) ] pub struct _EVENT_FILTER_HEADER { pub Id : USHORT , pub Version : UCHAR , pub Reserved : [ UCHAR ; 5usize ] , pub InstanceId : ULONGLONG , pub Size : ULONG , pub NextOffset : ULONG , } pub type EVENT_FILTER_HEADER = _EVENT_FILTER_HEADER ; pub type PEVENT_FILTER_HEADER = * mut _EVENT_FILTER_HEADER ; # [ repr ( C ) ] pub struct _EVENT_FILTER_EVENT_ID { pub FilterIn : BOOLEAN , pub Reserved : UCHAR , pub Count : USHORT , pub Events : [ USHORT ; 1usize ] , } pub type EVENT_FILTER_EVENT_ID = _EVENT_FILTER_EVENT_ID ; pub type PEVENT_FILTER_EVENT_ID = * mut _EVENT_FILTER_EVENT_ID ; # [ repr ( C ) ] pub struct _EVENT_FILTER_EVENT_NAME { pub MatchAnyKeyword : ULONGLONG , pub MatchAllKeyword : ULONGLONG , pub Level : UCHAR , pub FilterIn : BOOLEAN , pub NameCount : USHORT , pub Names : [ UCHAR ; 1usize ] , } pub type EVENT_FILTER_EVENT_NAME = _EVENT_FILTER_EVENT_NAME ; pub type PEVENT_FILTER_EVENT_NAME = * mut _EVENT_FILTER_EVENT_NAME ; # [ repr ( C ) ] pub struct _EVENT_FILTER_LEVEL_KW { pub MatchAnyKeyword : ULONGLONG , pub MatchAllKeyword : ULONGLONG , pub Level : UCHAR , pub FilterIn : BOOLEAN , } pub type EVENT_FILTER_LEVEL_KW = _EVENT_FILTER_LEVEL_KW ; pub type PEVENT_FILTER_LEVEL_KW = * mut _EVENT_FILTER_LEVEL_KW ; pub const _EVENT_INFO_CLASS_EventProviderBinaryTrackInfo : _EVENT_INFO_CLASS = 0 ; pub const _EVENT_INFO_CLASS_EventProviderSetReserved1 : _EVENT_INFO_CLASS = 1 ; pub const _EVENT_INFO_CLASS_EventProviderSetTraits : _EVENT_INFO_CLASS = 2 ; pub const _EVENT_INFO_CLASS_EventProviderUseDescriptorType : _EVENT_INFO_CLASS = 3 ; pub const _EVENT_INFO_CLASS_MaxEventInfo : _EVENT_INFO_CLASS = 4 ; pub type _EVENT_INFO_CLASS = i32 ; pub use self :: _EVENT_INFO_CLASS as EVENT_INFO_CLASS ; pub type PETWENABLECALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( ) > ; extern "C" { pub fn EtwRegister ( ProviderId : LPCGUID , EnableCallback : PETWENABLECALLBACK , CallbackContext : PVOID , RegHandle : PREGHANDLE ) -> NTSTATUS ; } extern "C" { pub fn EtwUnregister ( RegHandle : REGHANDLE ) -> NTSTATUS ; } extern "C" { pub fn EtwSetInformation ( RegHandle : REGHANDLE , InformationClass : EVENT_INFO_CLASS , EventInformation : PVOID , InformationLength : ULONG ) -> NTSTATUS ; } extern "C" { pub fn EtwEventEnabled ( RegHandle : REGHANDLE , EventDescriptor : PCEVENT_DESCRIPTOR ) -> BOOLEAN ; } extern "C" { pub fn EtwProviderEnabled ( RegHandle : REGHANDLE , Level : UCHAR , Keyword : ULONGLONG ) -> BOOLEAN ; } extern "C" { pub fn EtwActivityIdControl ( ControlCode : ULONG , ActivityId : LPGUID ) -> NTSTATUS ; } extern "C" { pub fn EtwWrite ( RegHandle : REGHANDLE , EventDescriptor : PCEVENT_DESCRIPTOR , ActivityId : LPCGUID , UserDataCount : ULONG , UserData : PEVENT_DATA_DESCRIPTOR ) -> NTSTATUS ; } extern "C" { pub fn EtwWriteTransfer ( RegHandle : REGHANDLE , EventDescriptor : PCEVENT_DESCRIPTOR , ActivityId : LPCGUID , RelatedActivityId : LPCGUID , UserDataCount : ULONG , UserData : PEVENT_DATA_DESCRIPTOR ) -> NTSTATUS ; } extern "C" { pub fn EtwWriteString ( RegHandle : REGHANDLE , Level : UCHAR , Keyword : ULONGLONG , ActivityId : LPCGUID , String : PCWSTR ) -> NTSTATUS ; } extern "C" { pub fn EtwWriteEx ( RegHandle : REGHANDLE , EventDescriptor : PCEVENT_DESCRIPTOR , Filter : ULONG64 , Flags : ULONG , ActivityId : LPCGUID , RelatedActivityId : LPCGUID , UserDataCount : ULONG , UserData : PEVENT_DATA_DESCRIPTOR ) -> NTSTATUS ; } extern "C" { pub fn SeEtwWriteKMCveEvent ( CveId : PCUNICODE_STRING , AdditionalDetails : PCUNICODE_STRING ) -> NTSTATUS ; } pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyDeviceDescription : DEVICE_REGISTRY_PROPERTY = 0 ; pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyHardwareID : DEVICE_REGISTRY_PROPERTY = 1 ; pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyCompatibleIDs : DEVICE_REGISTRY_PROPERTY = 2 ; pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyBootConfiguration : DEVICE_REGISTRY_PROPERTY = 3 ; pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyBootConfigurationTranslated : DEVICE_REGISTRY_PROPERTY = 4 ; pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyClassName : DEVICE_REGISTRY_PROPERTY = 5 ; pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyClassGuid : DEVICE_REGISTRY_PROPERTY = 6 ; pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyDriverKeyName : DEVICE_REGISTRY_PROPERTY = 7 ; pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyManufacturer : DEVICE_REGISTRY_PROPERTY = 8 ; pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyFriendlyName : DEVICE_REGISTRY_PROPERTY = 9 ; pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyLocationInformation : DEVICE_REGISTRY_PROPERTY = 10 ; pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyPhysicalDeviceObjectName : DEVICE_REGISTRY_PROPERTY = 11 ; pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyBusTypeGuid : DEVICE_REGISTRY_PROPERTY = 12 ; pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyLegacyBusType : DEVICE_REGISTRY_PROPERTY = 13 ; pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyBusNumber : DEVICE_REGISTRY_PROPERTY = 14 ; pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyEnumeratorName : DEVICE_REGISTRY_PROPERTY = 15 ; pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyAddress : DEVICE_REGISTRY_PROPERTY = 16 ; pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyUINumber : DEVICE_REGISTRY_PROPERTY = 17 ; pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyInstallState : DEVICE_REGISTRY_PROPERTY = 18 ; pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyRemovalPolicy : DEVICE_REGISTRY_PROPERTY = 19 ; pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyResourceRequirements : DEVICE_REGISTRY_PROPERTY = 20 ; pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyAllocatedResources : DEVICE_REGISTRY_PROPERTY = 21 ; pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyContainerID : DEVICE_REGISTRY_PROPERTY = 22 ; pub type DEVICE_REGISTRY_PROPERTY = i32 ; pub type TRANSLATE_BUS_ADDRESS = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , BusAddress : PHYSICAL_ADDRESS , Length : ULONG , AddressSpace : PULONG , TranslatedAddress : PPHYSICAL_ADDRESS ) -> BOOLEAN > ; pub type PTRANSLATE_BUS_ADDRESS = TRANSLATE_BUS_ADDRESS ; pub type GET_DMA_ADAPTER = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , DeviceDescriptor : * mut _DEVICE_DESCRIPTION , NumberOfMapRegisters : PULONG ) -> * mut _DMA_ADAPTER > ; pub type PGET_DMA_ADAPTER = GET_DMA_ADAPTER ; pub type GET_SET_DEVICE_DATA = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , DataType : ULONG , Buffer : PVOID , Offset : ULONG , Length : ULONG ) -> ULONG > ; pub type PGET_SET_DEVICE_DATA = GET_SET_DEVICE_DATA ; pub const _DEVICE_INSTALL_STATE_InstallStateInstalled : _DEVICE_INSTALL_STATE = 0 ; pub const _DEVICE_INSTALL_STATE_InstallStateNeedsReinstall : _DEVICE_INSTALL_STATE = 1 ; pub const _DEVICE_INSTALL_STATE_InstallStateFailedInstall : _DEVICE_INSTALL_STATE = 2 ; pub const _DEVICE_INSTALL_STATE_InstallStateFinishInstall : _DEVICE_INSTALL_STATE = 3 ; pub type _DEVICE_INSTALL_STATE = i32 ; pub use self :: _DEVICE_INSTALL_STATE as DEVICE_INSTALL_STATE ; pub type PDEVICE_INSTALL_STATE = * mut _DEVICE_INSTALL_STATE ; # [ repr ( C ) ] pub struct _PNP_BUS_INFORMATION { pub BusTypeGuid : GUID , pub LegacyBusType : INTERFACE_TYPE , pub BusNumber : ULONG , } pub type PNP_BUS_INFORMATION = _PNP_BUS_INFORMATION ; pub type PPNP_BUS_INFORMATION = * mut _PNP_BUS_INFORMATION ; # [ repr ( C ) ] pub struct _LEGACY_BUS_INFORMATION { pub BusTypeGuid : GUID , pub LegacyBusType : INTERFACE_TYPE , pub BusNumber : ULONG , } pub type LEGACY_BUS_INFORMATION = _LEGACY_BUS_INFORMATION ; pub type PLEGACY_BUS_INFORMATION = * mut _LEGACY_BUS_INFORMATION ; pub const _DEVICE_REMOVAL_POLICY_RemovalPolicyExpectNoRemoval : _DEVICE_REMOVAL_POLICY = 1 ; pub const _DEVICE_REMOVAL_POLICY_RemovalPolicyExpectOrderlyRemoval : _DEVICE_REMOVAL_POLICY = 2 ; pub const _DEVICE_REMOVAL_POLICY_RemovalPolicyExpectSurpriseRemoval : _DEVICE_REMOVAL_POLICY = 3 ; pub type _DEVICE_REMOVAL_POLICY = i32 ; pub use self :: _DEVICE_REMOVAL_POLICY as DEVICE_REMOVAL_POLICY ; pub type PDEVICE_REMOVAL_POLICY = * mut _DEVICE_REMOVAL_POLICY ; # [ repr ( C ) ] pub struct _BUS_INTERFACE_STANDARD { pub Size : USHORT , pub Version : USHORT , pub Context : PVOID , pub InterfaceReference : PINTERFACE_REFERENCE , pub InterfaceDereference : PINTERFACE_DEREFERENCE , pub TranslateBusAddress : PTRANSLATE_BUS_ADDRESS , pub GetDmaAdapter : PGET_DMA_ADAPTER , pub SetBusData : PGET_SET_DEVICE_DATA , pub GetBusData : PGET_SET_DEVICE_DATA , } pub type BUS_INTERFACE_STANDARD = _BUS_INTERFACE_STANDARD ; pub type PBUS_INTERFACE_STANDARD = * mut _BUS_INTERFACE_STANDARD ; pub type GET_VIRTUAL_DEVICE_DATA = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , VirtualFunction : USHORT , Buffer : PVOID , Offset : ULONG , Length : ULONG ) -> ULONG > ; pub type PGET_VIRTUAL_DEVICE_DATA = GET_VIRTUAL_DEVICE_DATA ; pub type SET_VIRTUAL_DEVICE_DATA = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , VirtualFunction : USHORT , Buffer : PVOID , Offset : ULONG , Length : ULONG ) -> ULONG > ; pub type PSET_VIRTUAL_DEVICE_DATA = SET_VIRTUAL_DEVICE_DATA ; pub type GET_VIRTUAL_DEVICE_LOCATION = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , VirtualFunction : USHORT , SegmentNumber : PUINT16 , BusNumber : PUINT8 , FunctionNumber : PUINT8 ) -> NTSTATUS > ; pub type PGET_VIRTUAL_DEVICE_LOCATION = GET_VIRTUAL_DEVICE_LOCATION ; pub type GET_VIRTUAL_DEVICE_RESOURCES = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , CapturedBusNumbers : PUINT8 ) > ; pub type PGET_VIRTUAL_DEVICE_RESOURCES = GET_VIRTUAL_DEVICE_RESOURCES ; pub type ENABLE_VIRTUALIZATION = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , NumVFs : UINT16 , EnableVfMigration : BOOLEAN , EnableMigrationInterrupt : BOOLEAN , EnableVirtualization : BOOLEAN ) -> NTSTATUS > ; pub type PENABLE_VIRTUALIZATION = ENABLE_VIRTUALIZATION ; pub type GET_VIRTUAL_FUNCTION_PROBED_BARS = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , BaseRegisterValues : PULONG ) -> NTSTATUS > ; pub type PGET_VIRTUAL_FUNCTION_PROBED_BARS = GET_VIRTUAL_FUNCTION_PROBED_BARS ; # [ repr ( C ) ] pub struct _PCI_VIRTUALIZATION_INTERFACE { pub Size : USHORT , pub Version : USHORT , pub Context : PVOID , pub InterfaceReference : PINTERFACE_REFERENCE , pub InterfaceDereference : PINTERFACE_DEREFERENCE , pub SetVirtualFunctionData : PSET_VIRTUAL_DEVICE_DATA , pub GetVirtualFunctionData : PGET_VIRTUAL_DEVICE_DATA , pub GetLocation : PGET_VIRTUAL_DEVICE_LOCATION , pub GetResources : PGET_VIRTUAL_DEVICE_RESOURCES , pub EnableVirtualization : PENABLE_VIRTUALIZATION , pub GetVirtualFunctionProbedBars : PGET_VIRTUAL_FUNCTION_PROBED_BARS , } pub type PCI_VIRTUALIZATION_INTERFACE = _PCI_VIRTUALIZATION_INTERFACE ; pub type PPCI_VIRTUALIZATION_INTERFACE = * mut _PCI_VIRTUALIZATION_INTERFACE ; pub const _PCI_ACS_BIT_PciAcsReserved : _PCI_ACS_BIT = 0 ; pub const _PCI_ACS_BIT_PciAcsBitEnable : _PCI_ACS_BIT = 1 ; pub const _PCI_ACS_BIT_PciAcsBitDisable : _PCI_ACS_BIT = 2 ; pub const _PCI_ACS_BIT_PciAcsBitDontCare : _PCI_ACS_BIT = 3 ; pub type _PCI_ACS_BIT = i32 ; pub use self :: _PCI_ACS_BIT as PCI_ACS_BIT ; pub type PPCI_ACS_BIT = * mut _PCI_ACS_BIT ; pub type PCI_SET_ACS = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , EnableSourceValidation : PCI_ACS_BIT , EnableTranslationBlocking : PCI_ACS_BIT , EnableP2PRequestRedirect : PCI_ACS_BIT , EnableCompletionRedirect : PCI_ACS_BIT , EnableUpstreamForwarding : PCI_ACS_BIT , EnableEgressControl : PCI_ACS_BIT , EnableDirectTranslatedP2P : PCI_ACS_BIT ) -> NTSTATUS > ; pub type PPCI_SET_ACS = PCI_SET_ACS ; # [ repr ( C ) ] pub struct _PCI_SECURITY_INTERFACE { pub Size : USHORT , pub Version : USHORT , pub Context : PVOID , pub InterfaceReference : PINTERFACE_REFERENCE , pub InterfaceDereference : PINTERFACE_DEREFERENCE , pub SetAccessControlServices : PPCI_SET_ACS , } pub type PCI_SECURITY_INTERFACE = _PCI_SECURITY_INTERFACE ; pub type PPCI_SECURITY_INTERFACE = * mut _PCI_SECURITY_INTERFACE ; pub type PREENUMERATE_SELF = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID ) > ; # [ repr ( C ) ] pub struct _REENUMERATE_SELF_INTERFACE_STANDARD { pub Size : USHORT , pub Version : USHORT , pub Context : PVOID , pub InterfaceReference : PINTERFACE_REFERENCE , pub InterfaceDereference : PINTERFACE_DEREFERENCE , pub SurpriseRemoveAndReenumerateSelf : PREENUMERATE_SELF , } pub type REENUMERATE_SELF_INTERFACE_STANDARD = _REENUMERATE_SELF_INTERFACE_STANDARD ; pub type PREENUMERATE_SELF_INTERFACE_STANDARD = * mut _REENUMERATE_SELF_INTERFACE_STANDARD ; pub type PQUERYEXTENDEDADDRESS = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , ExtendedAddress : PULONG64 ) > ; # [ repr ( C ) ] pub struct _PNP_EXTENDED_ADDRESS_INTERFACE { pub Size : USHORT , pub Version : USHORT , pub Context : PVOID , pub InterfaceReference : PINTERFACE_REFERENCE , pub InterfaceDereference : PINTERFACE_DEREFERENCE , pub QueryExtendedAddress : PQUERYEXTENDEDADDRESS , } pub type PNP_EXTENDED_ADDRESS_INTERFACE = _PNP_EXTENDED_ADDRESS_INTERFACE ; pub type PPNP_EXTENDED_ADDRESS_INTERFACE = * mut _PNP_EXTENDED_ADDRESS_INTERFACE ; pub type SET_D3COLD_SUPPORT = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , D3ColdSupport : BOOLEAN ) > ; pub type PSET_D3COLD_SUPPORT = SET_D3COLD_SUPPORT ; pub const _DEVICE_WAKE_DEPTH_DeviceWakeDepthNotWakeable : _DEVICE_WAKE_DEPTH = 0 ; pub const _DEVICE_WAKE_DEPTH_DeviceWakeDepthD0 : _DEVICE_WAKE_DEPTH = 1 ; pub const _DEVICE_WAKE_DEPTH_DeviceWakeDepthD1 : _DEVICE_WAKE_DEPTH = 2 ; pub const _DEVICE_WAKE_DEPTH_DeviceWakeDepthD2 : _DEVICE_WAKE_DEPTH = 3 ; pub const _DEVICE_WAKE_DEPTH_DeviceWakeDepthD3hot : _DEVICE_WAKE_DEPTH = 4 ; pub const _DEVICE_WAKE_DEPTH_DeviceWakeDepthD3cold : _DEVICE_WAKE_DEPTH = 5 ; pub const _DEVICE_WAKE_DEPTH_DeviceWakeDepthMaximum : _DEVICE_WAKE_DEPTH = 6 ; pub type _DEVICE_WAKE_DEPTH = i32 ; pub use self :: _DEVICE_WAKE_DEPTH as DEVICE_WAKE_DEPTH ; pub type PDEVICE_WAKE_DEPTH = * mut _DEVICE_WAKE_DEPTH ; pub type GET_IDLE_WAKE_INFO = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , SystemPowerState : SYSTEM_POWER_STATE , DeepestWakeableDstate : PDEVICE_WAKE_DEPTH ) -> NTSTATUS > ; pub type PGET_IDLE_WAKE_INFO = GET_IDLE_WAKE_INFO ; pub type GET_D3COLD_CAPABILITY = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , D3ColdSupported : PBOOLEAN ) -> NTSTATUS > ; pub type PGET_D3COLD_CAPABILITY = GET_D3COLD_CAPABILITY ; pub const _D3COLD_LAST_TRANSITION_STATUS_LastDStateTransitionStatusUnknown : _D3COLD_LAST_TRANSITION_STATUS = 0 ; pub const _D3COLD_LAST_TRANSITION_STATUS_LastDStateTransitionD3hot : _D3COLD_LAST_TRANSITION_STATUS = 1 ; pub const _D3COLD_LAST_TRANSITION_STATUS_LastDStateTransitionD3cold : _D3COLD_LAST_TRANSITION_STATUS = 2 ; pub type _D3COLD_LAST_TRANSITION_STATUS = i32 ; pub use self :: _D3COLD_LAST_TRANSITION_STATUS as D3COLD_LAST_TRANSITION_STATUS ; pub type PD3COLD_LAST_TRANSITION_STATUS = * mut _D3COLD_LAST_TRANSITION_STATUS ; pub type GET_D3COLD_LAST_TRANSITION_STATUS = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , LastTransitionStatus : PD3COLD_LAST_TRANSITION_STATUS ) > ; pub type PGET_D3COLD_LAST_TRANSITION_STATUS = GET_D3COLD_LAST_TRANSITION_STATUS ; # [ repr ( C ) ] pub struct _D3COLD_SUPPORT_INTERFACE { pub Size : USHORT , pub Version : USHORT , pub Context : PVOID , pub InterfaceReference : PINTERFACE_REFERENCE , pub InterfaceDereference : PINTERFACE_DEREFERENCE , pub SetD3ColdSupport : PSET_D3COLD_SUPPORT , pub GetIdleWakeInfo : PGET_IDLE_WAKE_INFO , pub GetD3ColdCapability : PGET_D3COLD_CAPABILITY , pub GetBusDriverD3ColdSupport : PGET_D3COLD_CAPABILITY , pub GetLastTransitionStatus : PGET_D3COLD_LAST_TRANSITION_STATUS , } pub type D3COLD_SUPPORT_INTERFACE = _D3COLD_SUPPORT_INTERFACE ; pub type PD3COLD_SUPPORT_INTERFACE = * mut _D3COLD_SUPPORT_INTERFACE ; pub type PGPE_SERVICE_ROUTINE = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : PVOID , arg2 : PVOID ) -> BOOLEAN > ; pub type PGPE_CONNECT_VECTOR = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : PDEVICE_OBJECT , arg2 : ULONG , arg3 : KINTERRUPT_MODE , arg4 : BOOLEAN , arg5 : PGPE_SERVICE_ROUTINE , arg6 : PVOID , arg7 : PVOID ) -> NTSTATUS > ; pub type PGPE_DISCONNECT_VECTOR = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : PVOID ) -> NTSTATUS > ; pub type PGPE_ENABLE_EVENT = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : PDEVICE_OBJECT , arg2 : PVOID ) -> NTSTATUS > ; pub type PGPE_DISABLE_EVENT = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : PDEVICE_OBJECT , arg2 : PVOID ) -> NTSTATUS > ; pub type PGPE_CLEAR_STATUS = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : PDEVICE_OBJECT , arg2 : PVOID ) -> NTSTATUS > ; pub type PDEVICE_NOTIFY_CALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : PVOID , arg2 : ULONG ) > ; pub type PREGISTER_FOR_DEVICE_NOTIFICATIONS = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : PDEVICE_OBJECT , arg2 : PDEVICE_NOTIFY_CALLBACK , arg3 : PVOID ) -> NTSTATUS > ; pub type PUNREGISTER_FOR_DEVICE_NOTIFICATIONS = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : PDEVICE_OBJECT , arg2 : PDEVICE_NOTIFY_CALLBACK ) > ; # [ repr ( C ) ] pub struct _ACPI_INTERFACE_STANDARD { pub Size : USHORT , pub Version : USHORT , pub Context : PVOID , pub InterfaceReference : PINTERFACE_REFERENCE , pub InterfaceDereference : PINTERFACE_DEREFERENCE , pub GpeConnectVector : PGPE_CONNECT_VECTOR , pub GpeDisconnectVector : PGPE_DISCONNECT_VECTOR , pub GpeEnableEvent : PGPE_ENABLE_EVENT , pub GpeDisableEvent : PGPE_DISABLE_EVENT , pub GpeClearStatus : PGPE_CLEAR_STATUS , pub RegisterForDeviceNotifications : PREGISTER_FOR_DEVICE_NOTIFICATIONS , pub UnregisterForDeviceNotifications : PUNREGISTER_FOR_DEVICE_NOTIFICATIONS , } pub type ACPI_INTERFACE_STANDARD = _ACPI_INTERFACE_STANDARD ; pub type PACPI_INTERFACE_STANDARD = * mut _ACPI_INTERFACE_STANDARD ; pub type PGPE_SERVICE_ROUTINE2 = :: std :: option :: Option < unsafe extern "C" fn ( ObjectContext : PVOID , ServiceContext : PVOID ) -> BOOLEAN > ; pub type PGPE_CONNECT_VECTOR2 = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , GpeNumber : ULONG , Mode : KINTERRUPT_MODE , Shareable : BOOLEAN , ServiceRoutine : PGPE_SERVICE_ROUTINE , ServiceContext : PVOID , ObjectContext : * mut PVOID ) -> NTSTATUS > ; pub type PGPE_DISCONNECT_VECTOR2 = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , ObjectContext : PVOID ) -> NTSTATUS > ; pub type PGPE_ENABLE_EVENT2 = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , ObjectContext : PVOID ) -> NTSTATUS > ; pub type PGPE_DISABLE_EVENT2 = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , ObjectContext : PVOID ) -> NTSTATUS > ; pub type PGPE_CLEAR_STATUS2 = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , ObjectContext : PVOID ) -> NTSTATUS > ; pub type PDEVICE_NOTIFY_CALLBACK2 = :: std :: option :: Option < unsafe extern "C" fn ( NotificationContext : PVOID , NotifyCode : ULONG ) > ; pub type PREGISTER_FOR_DEVICE_NOTIFICATIONS2 = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , NotificationHandler : PDEVICE_NOTIFY_CALLBACK2 , NotificationContext : PVOID ) -> NTSTATUS > ; pub type PUNREGISTER_FOR_DEVICE_NOTIFICATIONS2 = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID ) > ; # [ repr ( C ) ] pub struct ACPI_INTERFACE_STANDARD2 { pub Size : USHORT , pub Version : USHORT , pub Context : PVOID , pub InterfaceReference : PINTERFACE_REFERENCE , pub InterfaceDereference : PINTERFACE_DEREFERENCE , pub GpeConnectVector : PGPE_CONNECT_VECTOR2 , pub GpeDisconnectVector : PGPE_DISCONNECT_VECTOR2 , pub GpeEnableEvent : PGPE_ENABLE_EVENT2 , pub GpeDisableEvent : PGPE_DISABLE_EVENT2 , pub GpeClearStatus : PGPE_CLEAR_STATUS2 , pub RegisterForDeviceNotifications : PREGISTER_FOR_DEVICE_NOTIFICATIONS2 , pub UnregisterForDeviceNotifications : PUNREGISTER_FOR_DEVICE_NOTIFICATIONS2 , } pub type PACPI_INTERFACE_STANDARD2 = * mut ACPI_INTERFACE_STANDARD2 ; extern "C" { pub fn IoInvalidateDeviceRelations ( DeviceObject : PDEVICE_OBJECT , Type : DEVICE_RELATION_TYPE ) ; } extern "C" { pub fn IoRequestDeviceEject ( PhysicalDeviceObject : PDEVICE_OBJECT ) ; } pub type PIO_DEVICE_EJECT_CALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( Status : NTSTATUS , Context : PVOID ) > ; extern "C" { pub fn IoRequestDeviceEjectEx ( PhysicalDeviceObject : PDEVICE_OBJECT , Callback : PIO_DEVICE_EJECT_CALLBACK , Context : PVOID , DriverObject : PDRIVER_OBJECT ) -> NTSTATUS ; } extern "C" { pub fn IoGetDeviceProperty ( DeviceObject : PDEVICE_OBJECT , DeviceProperty : DEVICE_REGISTRY_PROPERTY , BufferLength : ULONG , PropertyBuffer : PVOID , ResultLength : PULONG ) -> NTSTATUS ; } extern "C" { pub fn IoOpenDeviceRegistryKey ( DeviceObject : PDEVICE_OBJECT , DevInstKeyType : ULONG , DesiredAccess : ACCESS_MASK , DevInstRegKey : PHANDLE ) -> NTSTATUS ; } extern "C" { pub fn IoRegisterDeviceInterface ( PhysicalDeviceObject : PDEVICE_OBJECT , InterfaceClassGuid : * const GUID , ReferenceString : PUNICODE_STRING , SymbolicLinkName : PUNICODE_STRING ) -> NTSTATUS ; } extern "C" { pub fn IoOpenDeviceInterfaceRegistryKey ( SymbolicLinkName : PUNICODE_STRING , DesiredAccess : ACCESS_MASK , DeviceInterfaceKey : PHANDLE ) -> NTSTATUS ; } extern "C" { pub fn IoSetDeviceInterfaceState ( SymbolicLinkName : PUNICODE_STRING , Enable : BOOLEAN ) -> NTSTATUS ; } extern "C" { pub fn IoGetDeviceInterfaces ( InterfaceClassGuid : * const GUID , PhysicalDeviceObject : PDEVICE_OBJECT , Flags : ULONG , SymbolicLinkList : * mut PZZWSTR ) -> NTSTATUS ; } extern "C" { pub fn IoGetDeviceInterfaceAlias ( SymbolicLinkName : PUNICODE_STRING , AliasInterfaceClassGuid : * const GUID , AliasSymbolicLinkName : PUNICODE_STRING ) -> NTSTATUS ; } pub const _IO_NOTIFICATION_EVENT_CATEGORY_EventCategoryReserved : _IO_NOTIFICATION_EVENT_CATEGORY = 0 ; pub const _IO_NOTIFICATION_EVENT_CATEGORY_EventCategoryHardwareProfileChange : _IO_NOTIFICATION_EVENT_CATEGORY = 1 ; pub const _IO_NOTIFICATION_EVENT_CATEGORY_EventCategoryDeviceInterfaceChange : _IO_NOTIFICATION_EVENT_CATEGORY = 2 ; pub const _IO_NOTIFICATION_EVENT_CATEGORY_EventCategoryTargetDeviceChange : _IO_NOTIFICATION_EVENT_CATEGORY = 3 ; pub type _IO_NOTIFICATION_EVENT_CATEGORY = i32 ; pub use self :: _IO_NOTIFICATION_EVENT_CATEGORY as IO_NOTIFICATION_EVENT_CATEGORY ; pub type DRIVER_NOTIFICATION_CALLBACK_ROUTINE = :: std :: option :: Option < unsafe extern "C" fn ( NotificationStructure : PVOID , Context : PVOID ) -> NTSTATUS > ; pub type PDRIVER_NOTIFICATION_CALLBACK_ROUTINE = DRIVER_NOTIFICATION_CALLBACK_ROUTINE ; extern "C" { pub fn IoRegisterPlugPlayNotification ( EventCategory : IO_NOTIFICATION_EVENT_CATEGORY , EventCategoryFlags : ULONG , EventCategoryData : PVOID , DriverObject : PDRIVER_OBJECT , CallbackRoutine : PDRIVER_NOTIFICATION_CALLBACK_ROUTINE , Context : PVOID , NotificationEntry : * mut PVOID ) -> NTSTATUS ; } extern "C" { pub fn IoUnregisterPlugPlayNotification ( NotificationEntry : PVOID ) -> NTSTATUS ; } extern "C" { pub fn IoUnregisterPlugPlayNotificationEx ( NotificationEntry : PVOID ) -> NTSTATUS ; } extern "C" { pub fn IoReportTargetDeviceChange ( PhysicalDeviceObject : PDEVICE_OBJECT , NotificationStructure : PVOID ) -> NTSTATUS ; } pub type DEVICE_CHANGE_COMPLETE_CALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID ) > ; pub type PDEVICE_CHANGE_COMPLETE_CALLBACK = DEVICE_CHANGE_COMPLETE_CALLBACK ; extern "C" { pub fn IoInvalidateDeviceState ( PhysicalDeviceObject : PDEVICE_OBJECT ) ; } extern "C" { pub fn IoReportTargetDeviceChangeAsynchronous ( PhysicalDeviceObject : PDEVICE_OBJECT , NotificationStructure : PVOID , Callback : PDEVICE_CHANGE_COMPLETE_CALLBACK , Context : PVOID ) -> NTSTATUS ; } # [ repr ( C ) ] pub struct _PLUGPLAY_NOTIFICATION_HEADER { pub Version : USHORT , pub Size : USHORT , pub Event : GUID , } pub type PLUGPLAY_NOTIFICATION_HEADER = _PLUGPLAY_NOTIFICATION_HEADER ; pub type PPLUGPLAY_NOTIFICATION_HEADER = * mut _PLUGPLAY_NOTIFICATION_HEADER ; # [ repr ( C ) ] pub struct _HWPROFILE_CHANGE_NOTIFICATION { pub Version : USHORT , pub Size : USHORT , pub Event : GUID , } pub type HWPROFILE_CHANGE_NOTIFICATION = _HWPROFILE_CHANGE_NOTIFICATION ; pub type PHWPROFILE_CHANGE_NOTIFICATION = * mut _HWPROFILE_CHANGE_NOTIFICATION ; # [ repr ( C ) ] pub struct _DEVICE_INTERFACE_CHANGE_NOTIFICATION { pub Version : USHORT , pub Size : USHORT , pub Event : GUID , pub InterfaceClassGuid : GUID , pub SymbolicLinkName : PUNICODE_STRING , } pub type DEVICE_INTERFACE_CHANGE_NOTIFICATION = _DEVICE_INTERFACE_CHANGE_NOTIFICATION ; pub type PDEVICE_INTERFACE_CHANGE_NOTIFICATION = * mut _DEVICE_INTERFACE_CHANGE_NOTIFICATION ; # [ repr ( C ) ] pub struct _TARGET_DEVICE_REMOVAL_NOTIFICATION { pub Version : USHORT , pub Size : USHORT , pub Event : GUID , pub FileObject : PFILE_OBJECT , } pub type TARGET_DEVICE_REMOVAL_NOTIFICATION = _TARGET_DEVICE_REMOVAL_NOTIFICATION ; pub type PTARGET_DEVICE_REMOVAL_NOTIFICATION = * mut _TARGET_DEVICE_REMOVAL_NOTIFICATION ; # [ repr ( C ) ] pub struct _TARGET_DEVICE_CUSTOM_NOTIFICATION { pub Version : USHORT , pub Size : USHORT , pub Event : GUID , pub FileObject : PFILE_OBJECT , pub NameBufferOffset : LONG , pub CustomDataBuffer : [ UCHAR ; 1usize ] , } pub type TARGET_DEVICE_CUSTOM_NOTIFICATION = _TARGET_DEVICE_CUSTOM_NOTIFICATION ; pub type PTARGET_DEVICE_CUSTOM_NOTIFICATION = * mut _TARGET_DEVICE_CUSTOM_NOTIFICATION ; pub type DEVPROPTYPE = ULONG ; pub type PDEVPROPTYPE = * mut ULONG ; pub type DEVPROP_BOOLEAN = CHAR ; pub type PDEVPROP_BOOLEAN = * mut CHAR ; pub type DEVPROPGUID = GUID ; pub type PDEVPROPGUID = * mut GUID ; pub type DEVPROPID = ULONG ; pub type PDEVPROPID = * mut ULONG ; # [ repr ( C ) ] pub struct _DEVPROPKEY { pub fmtid : DEVPROPGUID , pub pid : DEVPROPID , } pub type DEVPROPKEY = _DEVPROPKEY ; pub type PDEVPROPKEY = * mut _DEVPROPKEY ; pub const _DEVPROPSTORE_DEVPROP_STORE_SYSTEM : _DEVPROPSTORE = 0 ; pub const _DEVPROPSTORE_DEVPROP_STORE_USER : _DEVPROPSTORE = 1 ; pub type _DEVPROPSTORE = i32 ; pub use self :: _DEVPROPSTORE as DEVPROPSTORE ; pub type PDEVPROPSTORE = * mut _DEVPROPSTORE ; # [ repr ( C ) ] pub struct _DEVPROPCOMPKEY { pub Key : DEVPROPKEY , pub Store : DEVPROPSTORE , pub LocaleName : PCWSTR , } pub type DEVPROPCOMPKEY = _DEVPROPCOMPKEY ; pub type PDEVPROPCOMPKEY = * mut _DEVPROPCOMPKEY ; # [ repr ( C ) ] pub struct _DEVPROPERTY { pub CompKey : DEVPROPCOMPKEY , pub Type : DEVPROPTYPE , pub BufferSize : ULONG , pub Buffer : PVOID , } pub type DEVPROPERTY = _DEVPROPERTY ; pub type PDEVPROPERTY = * mut _DEVPROPERTY ; extern "C" { pub fn IoSetDevicePropertyData ( Pdo : PDEVICE_OBJECT , PropertyKey : * const DEVPROPKEY , Lcid : LCID , Flags : ULONG , Type : DEVPROPTYPE , Size : ULONG , Data : PVOID ) -> NTSTATUS ; } extern "C" { pub fn IoGetDevicePropertyData ( Pdo : PDEVICE_OBJECT , PropertyKey : * const DEVPROPKEY , Lcid : LCID , Flags : ULONG , Size : ULONG , Data : PVOID , RequiredSize : PULONG , Type : PDEVPROPTYPE ) -> NTSTATUS ; } extern "C" { pub fn IoSetDeviceInterfacePropertyData ( SymbolicLinkName : PUNICODE_STRING , PropertyKey : * const DEVPROPKEY , Lcid : LCID , Flags : ULONG , Type : DEVPROPTYPE , Size : ULONG , Data : PVOID ) -> NTSTATUS ; } extern "C" { pub fn IoGetDeviceInterfacePropertyData ( SymbolicLinkName : PUNICODE_STRING , PropertyKey : * const DEVPROPKEY , Lcid : LCID , Flags : ULONG , Size : ULONG , Data : PVOID , RequiredSize : PULONG , Type : PDEVPROPTYPE ) -> NTSTATUS ; } extern "C" { pub fn IoGetDeviceNumaNode ( Pdo : PDEVICE_OBJECT , NodeNumber : PUSHORT ) -> NTSTATUS ; } extern "C" { pub fn IoReplacePartitionUnit ( TargetPdo : PDEVICE_OBJECT , SparePdo : PDEVICE_OBJECT , Flags : ULONG ) -> NTSTATUS ; } pub type PPNP_REPLACE_DRIVER_INTERFACE = * mut _PNP_REPLACE_DRIVER_INTERFACE ; pub type PREPLACE_DRIVER_INIT = :: std :: option :: Option < unsafe extern "C" fn ( Interface : PPNP_REPLACE_DRIVER_INTERFACE , Unused : PVOID ) -> NTSTATUS > ; pub type PREPLACE_MAP_MEMORY = :: std :: option :: Option < unsafe extern "C" fn ( TargetPhysicalAddress : PHYSICAL_ADDRESS , SparePhysicalAddress : PHYSICAL_ADDRESS , NumberOfBytes : PLARGE_INTEGER , TargetAddress : * mut PVOID , SpareAddress : * mut PVOID ) -> NTSTATUS > ; # [ repr ( C ) ] pub struct _PNP_REPLACE_MEMORY_LIST { pub AllocatedCount : ULONG , pub Count : ULONG , pub TotalLength : ULONGLONG , pub Ranges : [ _PNP_REPLACE_MEMORY_LIST__bindgen_ty_1 ; 1usize ] , } # [ repr ( C ) ] pub struct _PNP_REPLACE_MEMORY_LIST__bindgen_ty_1 { pub Address : PHYSICAL_ADDRESS , pub Length : ULONGLONG , } pub type PNP_REPLACE_MEMORY_LIST = _PNP_REPLACE_MEMORY_LIST ; pub type PPNP_REPLACE_MEMORY_LIST = * mut _PNP_REPLACE_MEMORY_LIST ; # [ repr ( C ) ] pub struct _PNP_REPLACE_PROCESSOR_LIST { pub Affinity : PKAFFINITY , pub GroupCount : ULONG , pub AllocatedCount : ULONG , pub Count : ULONG , pub ApicIds : [ ULONG ; 1usize ] , } pub type PNP_REPLACE_PROCESSOR_LIST = _PNP_REPLACE_PROCESSOR_LIST ; pub type PPNP_REPLACE_PROCESSOR_LIST = * mut _PNP_REPLACE_PROCESSOR_LIST ; # [ repr ( C ) ] pub struct _PNP_REPLACE_PROCESSOR_LIST_V1 { pub AffinityMask : KAFFINITY , pub AllocatedCount : ULONG , pub Count : ULONG , pub ApicIds : [ ULONG ; 1usize ] , } pub type PNP_REPLACE_PROCESSOR_LIST_V1 = _PNP_REPLACE_PROCESSOR_LIST_V1 ; pub type PPNP_REPLACE_PROCESSOR_LIST_V1 = * mut _PNP_REPLACE_PROCESSOR_LIST_V1 ; # [ repr ( C ) ] pub struct _PNP_REPLACE_PARAMETERS { pub Size : ULONG , pub Version : ULONG , pub Target : ULONG64 , pub Spare : ULONG64 , pub TargetProcessors : PPNP_REPLACE_PROCESSOR_LIST , pub SpareProcessors : PPNP_REPLACE_PROCESSOR_LIST , pub TargetMemory : PPNP_REPLACE_MEMORY_LIST , pub SpareMemory : PPNP_REPLACE_MEMORY_LIST , pub MapMemory : PREPLACE_MAP_MEMORY , } pub type PNP_REPLACE_PARAMETERS = _PNP_REPLACE_PARAMETERS ; pub type PPNP_REPLACE_PARAMETERS = * mut _PNP_REPLACE_PARAMETERS ; pub type PREPLACE_UNLOAD = :: std :: option :: Option < unsafe extern "C" fn ( ) > ; pub type PREPLACE_BEGIN = :: std :: option :: Option < unsafe extern "C" fn ( Parameters : PPNP_REPLACE_PARAMETERS , Context : * mut PVOID ) -> NTSTATUS > ; pub type PREPLACE_END = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID ) -> NTSTATUS > ; pub type PREPLACE_MIRROR_PHYSICAL_MEMORY = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , PhysicalAddress : PHYSICAL_ADDRESS , ByteCount : LARGE_INTEGER ) -> NTSTATUS > ; pub type PREPLACE_SET_PROCESSOR_ID = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , ApicId : ULONG , Target : BOOLEAN ) -> NTSTATUS > ; pub type PREPLACE_SWAP = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID ) -> NTSTATUS > ; pub type PREPLACE_INITIATE_HARDWARE_MIRROR = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID ) -> NTSTATUS > ; pub type PREPLACE_MIRROR_PLATFORM_MEMORY = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID ) -> NTSTATUS > ; pub type PREPLACE_GET_MEMORY_DESTINATION = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , SourceAddress : PHYSICAL_ADDRESS , DestinationAddress : PPHYSICAL_ADDRESS ) -> NTSTATUS > ; pub type PREPLACE_ENABLE_DISABLE_HARDWARE_QUIESCE = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , Enable : BOOLEAN ) -> NTSTATUS > ; # [ repr ( C ) ] pub struct _PNP_REPLACE_DRIVER_INTERFACE { pub Size : ULONG , pub Version : ULONG , pub Flags : ULONG , pub Unload : PREPLACE_UNLOAD , pub BeginReplace : PREPLACE_BEGIN , pub EndReplace : PREPLACE_END , pub MirrorPhysicalMemory : PREPLACE_MIRROR_PHYSICAL_MEMORY , pub SetProcessorId : PREPLACE_SET_PROCESSOR_ID , pub Swap : PREPLACE_SWAP , pub InitiateHardwareMirror : PREPLACE_INITIATE_HARDWARE_MIRROR , pub MirrorPlatformMemory : PREPLACE_MIRROR_PLATFORM_MEMORY , pub GetMemoryDestination : PREPLACE_GET_MEMORY_DESTINATION , pub EnableDisableHardwareQuiesce : PREPLACE_ENABLE_DISABLE_HARDWARE_QUIESCE , } pub type PNP_REPLACE_DRIVER_INTERFACE = _PNP_REPLACE_DRIVER_INTERFACE ; pub type PCRASHDUMP_POWER_ON = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID ) -> NTSTATUS > ; # [ repr ( C ) ] pub struct _CRASHDUMP_FUNCTIONS_INTERFACE { pub Size : USHORT , pub Version : USHORT , pub Context : PVOID , pub InterfaceReference : PINTERFACE_REFERENCE , pub InterfaceDereference : PINTERFACE_DEREFERENCE , pub PowerOn : PCRASHDUMP_POWER_ON , } pub type CRASHDUMP_FUNCTIONS_INTERFACE = _CRASHDUMP_FUNCTIONS_INTERFACE ; pub type PCRASHDUMP_FUNCTIONS_INTERFACE = * mut _CRASHDUMP_FUNCTIONS_INTERFACE ; pub const _DEVICE_RESET_TYPE_FunctionLevelDeviceReset : _DEVICE_RESET_TYPE = 0 ; pub const _DEVICE_RESET_TYPE_PlatformLevelDeviceReset : _DEVICE_RESET_TYPE = 1 ; pub type _DEVICE_RESET_TYPE = i32 ; pub use self :: _DEVICE_RESET_TYPE as DEVICE_RESET_TYPE ; pub type DEVICE_RESET_COMPLETION = :: std :: option :: Option < unsafe extern "C" fn ( Status : NTSTATUS , Context : PVOID ) > ; pub type PDEVICE_RESET_COMPLETION = DEVICE_RESET_COMPLETION ; # [ repr ( C ) ] pub struct _FUNCTION_LEVEL_DEVICE_RESET_PARAMETERS { pub Size : ULONG , pub DeviceResetCompletion : PDEVICE_RESET_COMPLETION , pub CompletionContext : PVOID , } pub type FUNCTION_LEVEL_DEVICE_RESET_PARAMETERS = _FUNCTION_LEVEL_DEVICE_RESET_PARAMETERS ; pub type PFUNCTION_LEVEL_DEVICE_RESET_PARAMETERS = * mut _FUNCTION_LEVEL_DEVICE_RESET_PARAMETERS ; pub type PDEVICE_RESET_HANDLER = :: std :: option :: Option < unsafe extern "C" fn ( InterfaceContext : PVOID , ResetType : DEVICE_RESET_TYPE , Flags : ULONG , ResetParameters : PVOID ) -> NTSTATUS > ; # [ repr ( C ) ] pub struct _DEVICE_RESET_INTERFACE_STANDARD { pub Size : USHORT , pub Version : USHORT , pub Context : PVOID , pub InterfaceReference : PINTERFACE_REFERENCE , pub InterfaceDereference : PINTERFACE_DEREFERENCE , pub DeviceReset : PDEVICE_RESET_HANDLER , pub SupportedResetTypes : ULONG , pub Reserved : PVOID , } pub type DEVICE_RESET_INTERFACE_STANDARD = _DEVICE_RESET_INTERFACE_STANDARD ; pub type PDEVICE_RESET_INTERFACE_STANDARD = * mut _DEVICE_RESET_INTERFACE_STANDARD ; pub type SECURE_DRIVER_PROCESS_REFERENCE = :: std :: option :: Option < unsafe extern "C" fn ( InterfaceContext : PVOID ) -> PEPROCESS > ; pub type PSECURE_DRIVER_PROCESS_REFERENCE = SECURE_DRIVER_PROCESS_REFERENCE ; pub type SECURE_DRIVER_PROCESS_DEREFERENCE = :: std :: option :: Option < unsafe extern "C" fn ( InterfaceContext : PVOID , Process : PEPROCESS ) > ; pub type PSECURE_DRIVER_PROCESS_DEREFERENCE = SECURE_DRIVER_PROCESS_DEREFERENCE ; # [ repr ( C ) ] pub struct _SECURE_DRIVER_INTERFACE { pub InterfaceHeader : INTERFACE , pub ProcessReference : PSECURE_DRIVER_PROCESS_REFERENCE , pub ProcessDereference : PSECURE_DRIVER_PROCESS_DEREFERENCE , pub Reserved : ULONG , } pub type SECURE_DRIVER_INTERFACE = _SECURE_DRIVER_INTERFACE ; pub type PSECURE_DRIVER_INTERFACE = * mut _SECURE_DRIVER_INTERFACE ; pub type GET_SDEV_IDENTIFIER = :: std :: option :: Option < unsafe extern "C" fn ( InterfaceContext : PVOID ) -> ULONGLONG > ; pub type PGET_SDEV_IDENTIFIER = GET_SDEV_IDENTIFIER ; # [ repr ( C ) ] pub struct _SDEV_IDENTIFIER_INTERFACE { pub InterfaceHeader : INTERFACE , pub GetIdentifier : PGET_SDEV_IDENTIFIER , } pub type SDEV_IDENTIFIER_INTERFACE = _SDEV_IDENTIFIER_INTERFACE ; pub type PSDEV_IDENTIFIER_INTERFACE = * mut _SDEV_IDENTIFIER_INTERFACE ; # [ repr ( C ) ] pub struct _DEVICE_DESCRIPTION { pub Version : ULONG , pub Master : BOOLEAN , pub ScatterGather : BOOLEAN , pub DemandMode : BOOLEAN , pub AutoInitialize : BOOLEAN , pub Dma32BitAddresses : BOOLEAN , pub IgnoreCount : BOOLEAN , pub Reserved1 : BOOLEAN , pub Dma64BitAddresses : BOOLEAN , pub BusNumber : ULONG , pub DmaChannel : ULONG , pub InterfaceType : INTERFACE_TYPE , pub DmaWidth : DMA_WIDTH , pub DmaSpeed : DMA_SPEED , pub MaximumLength : ULONG , pub DmaPort : ULONG , pub DmaAddressWidth : ULONG , pub DmaControllerInstance : ULONG , pub DmaRequestLine : ULONG , pub DeviceAddress : PHYSICAL_ADDRESS , } pub type DEVICE_DESCRIPTION = _DEVICE_DESCRIPTION ; pub type PDEVICE_DESCRIPTION = * mut _DEVICE_DESCRIPTION ; # [ repr ( C ) ] pub struct _DMA_ADAPTER_INFO_V1 { pub ReadDmaCounterAvailable : ULONG , pub ScatterGatherLimit : ULONG , pub DmaAddressWidth : ULONG , pub Flags : ULONG , pub MinimumTransferUnit : ULONG , } pub type DMA_ADAPTER_INFO_V1 = _DMA_ADAPTER_INFO_V1 ; pub type PDMA_ADAPTER_INFO_V1 = * mut _DMA_ADAPTER_INFO_V1 ; # [ repr ( C ) ] pub struct _DMA_ADAPTER_INFO { pub Version : ULONG , pub __bindgen_anon_1 : _DMA_ADAPTER_INFO__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _DMA_ADAPTER_INFO__bindgen_ty_1 { pub V1 : __BindgenUnionField < DMA_ADAPTER_INFO_V1 > , pub bindgen_union_field : [ u32 ; 5usize ] , } pub type DMA_ADAPTER_INFO = _DMA_ADAPTER_INFO ; pub type PDMA_ADAPTER_INFO = * mut _DMA_ADAPTER_INFO ; # [ repr ( C ) ] pub struct _DMA_TRANSFER_INFO_V1 { pub MapRegisterCount : ULONG , pub ScatterGatherElementCount : ULONG , pub ScatterGatherListSize : ULONG , } pub type DMA_TRANSFER_INFO_V1 = _DMA_TRANSFER_INFO_V1 ; pub type PDMA_TRANSFER_INFO_V1 = * mut _DMA_TRANSFER_INFO_V1 ; # [ repr ( C ) ] pub struct _DMA_TRANSFER_INFO { pub Version : ULONG , pub __bindgen_anon_1 : _DMA_TRANSFER_INFO__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _DMA_TRANSFER_INFO__bindgen_ty_1 { pub V1 : __BindgenUnionField < DMA_TRANSFER_INFO_V1 > , pub bindgen_union_field : [ u32 ; 3usize ] , } pub type DMA_TRANSFER_INFO = _DMA_TRANSFER_INFO ; pub type PDMA_TRANSFER_INFO = * mut _DMA_TRANSFER_INFO ; extern "C" { pub fn KeFlushWriteBuffer ( ) ; } extern "C" { pub fn KeQueryPerformanceCounter ( PerformanceFrequency : PLARGE_INTEGER ) -> LARGE_INTEGER ; } extern "C" { pub fn KeStallExecutionProcessor ( MicroSeconds : ULONG ) ; } pub type PROCESSOR_HALT_ROUTINE = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID ) -> NTSTATUS > ; pub type PPROCESSOR_HALT_ROUTINE = PROCESSOR_HALT_ROUTINE ; # [ repr ( C ) ] pub struct _SCATTER_GATHER_ELEMENT { pub Address : PHYSICAL_ADDRESS , pub Length : ULONG , pub Reserved : ULONG_PTR , } pub type SCATTER_GATHER_ELEMENT = _SCATTER_GATHER_ELEMENT ; pub type PSCATTER_GATHER_ELEMENT = * mut _SCATTER_GATHER_ELEMENT ; # [ repr ( C ) ] pub struct _SCATTER_GATHER_LIST { pub NumberOfElements : ULONG , pub Reserved : ULONG_PTR , pub Elements : __IncompleteArrayField < SCATTER_GATHER_ELEMENT > , } pub type SCATTER_GATHER_LIST = _SCATTER_GATHER_LIST ; pub type PSCATTER_GATHER_LIST = * mut _SCATTER_GATHER_LIST ; pub type PDMA_OPERATIONS = * mut _DMA_OPERATIONS ; # [ repr ( C ) ] pub struct _DMA_ADAPTER { pub Version : USHORT , pub Size : USHORT , pub DmaOperations : PDMA_OPERATIONS , } pub type DMA_ADAPTER = _DMA_ADAPTER ; pub type PDMA_ADAPTER = * mut _DMA_ADAPTER ; pub const DMA_COMPLETION_STATUS_DmaComplete : DMA_COMPLETION_STATUS = 0 ; pub const DMA_COMPLETION_STATUS_DmaAborted : DMA_COMPLETION_STATUS = 1 ; pub const DMA_COMPLETION_STATUS_DmaError : DMA_COMPLETION_STATUS = 2 ; pub const DMA_COMPLETION_STATUS_DmaCancelled : DMA_COMPLETION_STATUS = 3 ; pub type DMA_COMPLETION_STATUS = i32 ; pub type PPUT_DMA_ADAPTER = :: std :: option :: Option < unsafe extern "C" fn ( DmaAdapter : PDMA_ADAPTER ) > ; pub type PALLOCATE_COMMON_BUFFER = :: std :: option :: Option < unsafe extern "C" fn ( DmaAdapter : PDMA_ADAPTER , Length : ULONG , LogicalAddress : PPHYSICAL_ADDRESS , CacheEnabled : BOOLEAN ) -> PVOID > ; pub type PFREE_COMMON_BUFFER = :: std :: option :: Option < unsafe extern "C" fn ( DmaAdapter : PDMA_ADAPTER , Length : ULONG , LogicalAddress : PHYSICAL_ADDRESS , VirtualAddress : PVOID , CacheEnabled : BOOLEAN ) > ; pub type PALLOCATE_ADAPTER_CHANNEL = :: std :: option :: Option < unsafe extern "C" fn ( DmaAdapter : PDMA_ADAPTER , DeviceObject : PDEVICE_OBJECT , NumberOfMapRegisters : ULONG , ExecutionRoutine : PDRIVER_CONTROL , Context : PVOID ) -> NTSTATUS > ; pub type PFLUSH_ADAPTER_BUFFERS = :: std :: option :: Option < unsafe extern "C" fn ( DmaAdapter : PDMA_ADAPTER , Mdl : PMDL , MapRegisterBase : PVOID , CurrentVa : PVOID , Length : ULONG , WriteToDevice : BOOLEAN ) -> BOOLEAN > ; pub type PFREE_ADAPTER_CHANNEL = :: std :: option :: Option < unsafe extern "C" fn ( DmaAdapter : PDMA_ADAPTER ) > ; pub type PFREE_ADAPTER_OBJECT = :: std :: option :: Option < unsafe extern "C" fn ( DmaAdapter : PDMA_ADAPTER , AllocationAction : IO_ALLOCATION_ACTION ) > ; pub type PFREE_MAP_REGISTERS = :: std :: option :: Option < unsafe extern "C" fn ( DmaAdapter : PDMA_ADAPTER , MapRegisterBase : PVOID , NumberOfMapRegisters : ULONG ) > ; pub type PMAP_TRANSFER = :: std :: option :: Option < unsafe extern "C" fn ( DmaAdapter : PDMA_ADAPTER , Mdl : PMDL , MapRegisterBase : PVOID , CurrentVa : PVOID , Length : PULONG , WriteToDevice : BOOLEAN ) -> PHYSICAL_ADDRESS > ; pub type PGET_DMA_ALIGNMENT = :: std :: option :: Option < unsafe extern "C" fn ( DmaAdapter : PDMA_ADAPTER ) -> ULONG > ; pub type PREAD_DMA_COUNTER = :: std :: option :: Option < unsafe extern "C" fn ( DmaAdapter : PDMA_ADAPTER ) -> ULONG > ; pub type DRIVER_LIST_CONTROL = :: std :: option :: Option < unsafe extern "C" fn ( DeviceObject : * mut _DEVICE_OBJECT , Irp : * mut _IRP , ScatterGather : PSCATTER_GATHER_LIST , Context : PVOID ) > ; pub type PDRIVER_LIST_CONTROL = DRIVER_LIST_CONTROL ; pub type PGET_SCATTER_GATHER_LIST = :: std :: option :: Option < unsafe extern "C" fn ( DmaAdapter : PDMA_ADAPTER , DeviceObject : PDEVICE_OBJECT , Mdl : PMDL , CurrentVa : PVOID , Length : ULONG , ExecutionRoutine : PDRIVER_LIST_CONTROL , Context : PVOID , WriteToDevice : BOOLEAN ) -> NTSTATUS > ; pub type PPUT_SCATTER_GATHER_LIST = :: std :: option :: Option < unsafe extern "C" fn ( DmaAdapter : PDMA_ADAPTER , ScatterGather : PSCATTER_GATHER_LIST , WriteToDevice : BOOLEAN ) > ; pub type PCALCULATE_SCATTER_GATHER_LIST_SIZE = :: std :: option :: Option < unsafe extern "C" fn ( DmaAdapter : PDMA_ADAPTER , Mdl : PMDL , CurrentVa : PVOID , Length : ULONG , ScatterGatherListSize : PULONG , pNumberOfMapRegisters : PULONG ) -> NTSTATUS > ; pub type PBUILD_SCATTER_GATHER_LIST = :: std :: option :: Option < unsafe extern "C" fn ( DmaAdapter : PDMA_ADAPTER , DeviceObject : PDEVICE_OBJECT , Mdl : PMDL , CurrentVa : PVOID , Length : ULONG , ExecutionRoutine : PDRIVER_LIST_CONTROL , Context : PVOID , WriteToDevice : BOOLEAN , ScatterGatherBuffer : PVOID , ScatterGatherLength : ULONG ) -> NTSTATUS > ; pub type PBUILD_MDL_FROM_SCATTER_GATHER_LIST = :: std :: option :: Option < unsafe extern "C" fn ( DmaAdapter : PDMA_ADAPTER , ScatterGather : PSCATTER_GATHER_LIST , OriginalMdl : PMDL , TargetMdl : * mut PMDL ) -> NTSTATUS > ; pub type PGET_DMA_ADAPTER_INFO = :: std :: option :: Option < unsafe extern "C" fn ( DmaAdapter : PDMA_ADAPTER , AdapterInfo : PDMA_ADAPTER_INFO ) -> NTSTATUS > ; pub type PGET_DMA_TRANSFER_INFO = :: std :: option :: Option < unsafe extern "C" fn ( DmaAdapter : PDMA_ADAPTER , Mdl : PMDL , Offset : ULONGLONG , Length : ULONG , WriteOnly : BOOLEAN , TransferInfo : PDMA_TRANSFER_INFO ) -> NTSTATUS > ; pub type PCONFIGURE_ADAPTER_CHANNEL = :: std :: option :: Option < unsafe extern "C" fn ( DmaAdapter : PDMA_ADAPTER , FunctionNumber : ULONG , Context : PVOID ) -> NTSTATUS > ; pub type PINITIALIZE_DMA_TRANSFER_CONTEXT = :: std :: option :: Option < unsafe extern "C" fn ( DmaAdapter : PDMA_ADAPTER , DmaTransferContext : PVOID ) -> NTSTATUS > ; pub type PALLOCATE_COMMON_BUFFER_EX = :: std :: option :: Option < unsafe extern "C" fn ( DmaAdapter : PDMA_ADAPTER , MaximumAddress : PPHYSICAL_ADDRESS , Length : ULONG , LogicalAddress : PPHYSICAL_ADDRESS , CacheEnabled : BOOLEAN , PreferredNode : NODE_REQUIREMENT ) -> PVOID > ; pub type PALLOCATE_ADAPTER_CHANNEL_EX = :: std :: option :: Option < unsafe extern "C" fn ( DmaAdapter : PDMA_ADAPTER , DeviceObject : PDEVICE_OBJECT , DmaTransferContext : PVOID , NumberOfMapRegisters : ULONG , Flags : ULONG , ExecutionRoutine : PDRIVER_CONTROL , ExecutionContext : PVOID , MapRegisterBase : * mut PVOID ) -> NTSTATUS > ; pub type DMA_COMPLETION_ROUTINE = :: std :: option :: Option < unsafe extern "C" fn ( DmaAdapter : PDMA_ADAPTER , DeviceObject : PDEVICE_OBJECT , CompletionContext : PVOID , Status : DMA_COMPLETION_STATUS ) > ; pub type PDMA_COMPLETION_ROUTINE = DMA_COMPLETION_ROUTINE ; pub type PMAP_TRANSFER_EX = :: std :: option :: Option < unsafe extern "C" fn ( DmaAdapter : PDMA_ADAPTER , Mdl : PMDL , MapRegisterBase : PVOID , Offset : ULONGLONG , DeviceOffset : ULONG , Length : PULONG , WriteToDevice : BOOLEAN , ScatterGatherBuffer : PSCATTER_GATHER_LIST , ScatterGatherBufferLength : ULONG , DmaCompletionRoutine : PDMA_COMPLETION_ROUTINE , CompletionContext : PVOID ) -> NTSTATUS > ; pub type PCANCEL_ADAPTER_CHANNEL = :: std :: option :: Option < unsafe extern "C" fn ( DmaAdapter : PDMA_ADAPTER , DeviceObject : PDEVICE_OBJECT , DmaTransferContext : PVOID ) -> BOOLEAN > ; pub type PCANCEL_MAPPED_TRANSFER = :: std :: option :: Option < unsafe extern "C" fn ( DmaAdapter : PDMA_ADAPTER , DmaTransferContext : PVOID ) -> NTSTATUS > ; pub type PFLUSH_ADAPTER_BUFFERS_EX = :: std :: option :: Option < unsafe extern "C" fn ( DmaAdapter : PDMA_ADAPTER , Mdl : PMDL , MapRegisterBase : PVOID , Offset : ULONGLONG , Length : ULONG , WriteToDevice : BOOLEAN ) -> NTSTATUS > ; pub type PGET_SCATTER_GATHER_LIST_EX = :: std :: option :: Option < unsafe extern "C" fn ( DmaAdapter : PDMA_ADAPTER , DeviceObject : PDEVICE_OBJECT , DmaTransferContext : PVOID , Mdl : PMDL , Offset : ULONGLONG , Length : ULONG , Flags : ULONG , ExecutionRoutine : PDRIVER_LIST_CONTROL , Context : PVOID , WriteToDevice : BOOLEAN , DmaCompletionRoutine : PDMA_COMPLETION_ROUTINE , CompletionContext : PVOID , ScatterGatherList : * mut PSCATTER_GATHER_LIST ) -> NTSTATUS > ; pub type PBUILD_SCATTER_GATHER_LIST_EX = :: std :: option :: Option < unsafe extern "C" fn ( DmaAdapter : PDMA_ADAPTER , DeviceObject : PDEVICE_OBJECT , DmaTransferContext : PVOID , Mdl : PMDL , Offset : ULONGLONG , Length : ULONG , Flags : ULONG , ExecutionRoutine : PDRIVER_LIST_CONTROL , Context : PVOID , WriteToDevice : BOOLEAN , ScatterGatherBuffer : PVOID , ScatterGatherLength : ULONG , DmaCompletionRoutine : PDMA_COMPLETION_ROUTINE , CompletionContext : PVOID , ScatterGatherList : PVOID ) -> NTSTATUS > ; pub type PALLOCATE_DOMAIN_COMMON_BUFFER = :: std :: option :: Option < unsafe extern "C" fn ( DmaAdapter : PDMA_ADAPTER , DomainHandle : HANDLE , MaximumAddress : PPHYSICAL_ADDRESS , Length : ULONG , Flags : ULONG , CacheType : * mut MEMORY_CACHING_TYPE , PreferredNode : NODE_REQUIREMENT , LogicalAddress : PPHYSICAL_ADDRESS , VirtualAddress : * mut PVOID ) -> NTSTATUS > ; pub type PFLUSH_DMA_BUFFER = :: std :: option :: Option < unsafe extern "C" fn ( DmaAdapter : PDMA_ADAPTER , Mdl : PMDL , ReadOperation : BOOLEAN ) -> NTSTATUS > ; pub type PJOIN_DMA_DOMAIN = :: std :: option :: Option < unsafe extern "C" fn ( DmaAdapter : PDMA_ADAPTER , DomainHandle : HANDLE ) -> NTSTATUS > ; pub type PLEAVE_DMA_DOMAIN = :: std :: option :: Option < unsafe extern "C" fn ( DmaAdapter : PDMA_ADAPTER ) -> NTSTATUS > ; pub type PGET_DMA_DOMAIN = :: std :: option :: Option < unsafe extern "C" fn ( DmaAdapter : PDMA_ADAPTER ) -> HANDLE > ; # [ repr ( C ) ] pub struct _DMA_OPERATIONS { pub Size : ULONG , pub PutDmaAdapter : PPUT_DMA_ADAPTER , pub AllocateCommonBuffer : PALLOCATE_COMMON_BUFFER , pub FreeCommonBuffer : PFREE_COMMON_BUFFER , pub AllocateAdapterChannel : PALLOCATE_ADAPTER_CHANNEL , pub FlushAdapterBuffers : PFLUSH_ADAPTER_BUFFERS , pub FreeAdapterChannel : PFREE_ADAPTER_CHANNEL , pub FreeMapRegisters : PFREE_MAP_REGISTERS , pub MapTransfer : PMAP_TRANSFER , pub GetDmaAlignment : PGET_DMA_ALIGNMENT , pub ReadDmaCounter : PREAD_DMA_COUNTER , pub GetScatterGatherList : PGET_SCATTER_GATHER_LIST , pub PutScatterGatherList : PPUT_SCATTER_GATHER_LIST , pub CalculateScatterGatherList : PCALCULATE_SCATTER_GATHER_LIST_SIZE , pub BuildScatterGatherList : PBUILD_SCATTER_GATHER_LIST , pub BuildMdlFromScatterGatherList : PBUILD_MDL_FROM_SCATTER_GATHER_LIST , pub GetDmaAdapterInfo : PGET_DMA_ADAPTER_INFO , pub GetDmaTransferInfo : PGET_DMA_TRANSFER_INFO , pub InitializeDmaTransferContext : PINITIALIZE_DMA_TRANSFER_CONTEXT , pub AllocateCommonBufferEx : PALLOCATE_COMMON_BUFFER_EX , pub AllocateAdapterChannelEx : PALLOCATE_ADAPTER_CHANNEL_EX , pub ConfigureAdapterChannel : PCONFIGURE_ADAPTER_CHANNEL , pub CancelAdapterChannel : PCANCEL_ADAPTER_CHANNEL , pub MapTransferEx : PMAP_TRANSFER_EX , pub GetScatterGatherListEx : PGET_SCATTER_GATHER_LIST_EX , pub BuildScatterGatherListEx : PBUILD_SCATTER_GATHER_LIST_EX , pub FlushAdapterBuffersEx : PFLUSH_ADAPTER_BUFFERS_EX , pub FreeAdapterObject : PFREE_ADAPTER_OBJECT , pub CancelMappedTransfer : PCANCEL_MAPPED_TRANSFER , pub AllocateDomainCommonBuffer : PALLOCATE_DOMAIN_COMMON_BUFFER , pub FlushDmaBuffer : PFLUSH_DMA_BUFFER , pub JoinDmaDomain : PJOIN_DMA_DOMAIN , pub LeaveDmaDomain : PLEAVE_DMA_DOMAIN , pub GetDmaDomain : PGET_DMA_DOMAIN , } pub type DMA_OPERATIONS = _DMA_OPERATIONS ; extern "C" { pub fn PoSetHiberRange ( MemoryMap : PVOID , Flags : ULONG , Address : PVOID , Length : ULONG_PTR , Tag : ULONG ) ; } extern "C" { pub fn PoSetSystemState ( Flags : EXECUTION_STATE ) ; } extern "C" { pub fn PoRegisterSystemState ( StateHandle : PVOID , Flags : EXECUTION_STATE ) -> PVOID ; } extern "C" { pub fn PoCreatePowerRequest ( PowerRequest : * mut PVOID , DeviceObject : PDEVICE_OBJECT , Context : PCOUNTED_REASON_CONTEXT ) -> NTSTATUS ; } extern "C" { pub fn PoSetPowerRequest ( PowerRequest : PVOID , Type : POWER_REQUEST_TYPE ) -> NTSTATUS ; } extern "C" { pub fn PoClearPowerRequest ( PowerRequest : PVOID , Type : POWER_REQUEST_TYPE ) -> NTSTATUS ; } extern "C" { pub fn PoDeletePowerRequest ( PowerRequest : PVOID ) ; } pub type REQUEST_POWER_COMPLETE = :: std :: option :: Option < unsafe extern "C" fn ( DeviceObject : PDEVICE_OBJECT , MinorFunction : UCHAR , PowerState : POWER_STATE , Context : PVOID , IoStatus : PIO_STATUS_BLOCK ) > ; pub type PREQUEST_POWER_COMPLETE = REQUEST_POWER_COMPLETE ; extern "C" { pub fn PoRequestPowerIrp ( DeviceObject : PDEVICE_OBJECT , MinorFunction : UCHAR , PowerState : POWER_STATE , CompletionFunction : PREQUEST_POWER_COMPLETE , Context : PVOID , Irp : * mut PIRP ) -> NTSTATUS ; } extern "C" { pub fn PoSetSystemWake ( Irp : PIRP ) ; } extern "C" { pub fn PoGetSystemWake ( Irp : PIRP ) -> BOOLEAN ; } extern "C" { pub fn PoUnregisterSystemState ( StateHandle : PVOID ) ; } extern "C" { pub fn PoSetPowerState ( DeviceObject : PDEVICE_OBJECT , Type : POWER_STATE_TYPE , State : POWER_STATE ) -> POWER_STATE ; } extern "C" { pub fn PoCallDriver ( DeviceObject : PDEVICE_OBJECT , Irp : PIRP ) -> NTSTATUS ; } extern "C" { pub fn PoStartNextPowerIrp ( Irp : PIRP ) ; } extern "C" { pub fn PoRegisterDeviceForIdleDetection ( DeviceObject : PDEVICE_OBJECT , ConservationIdleTime : ULONG , PerformanceIdleTime : ULONG , State : DEVICE_POWER_STATE ) -> PULONG ; } extern "C" { pub fn PoSetDeviceBusyEx ( IdlePointer : PULONG ) ; } extern "C" { pub fn PoStartDeviceBusy ( IdlePointer : PULONG ) ; } extern "C" { pub fn PoEndDeviceBusy ( IdlePointer : PULONG ) ; } extern "C" { pub fn PoQueryWatchdogTime ( Pdo : PDEVICE_OBJECT , SecondsRemaining : PULONG ) -> BOOLEAN ; } pub type POWER_SETTING_CALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( SettingGuid : LPCGUID , Value : PVOID , ValueLength : ULONG , Context : PVOID ) -> NTSTATUS > ; pub type PPOWER_SETTING_CALLBACK = POWER_SETTING_CALLBACK ; extern "C" { pub fn PoRegisterPowerSettingCallback ( DeviceObject : PDEVICE_OBJECT , SettingGuid : LPCGUID , Callback : PPOWER_SETTING_CALLBACK , Context : PVOID , Handle : * mut PVOID ) -> NTSTATUS ; } extern "C" { pub fn PoUnregisterPowerSettingCallback ( Handle : PVOID ) -> NTSTATUS ; } # [ repr ( C ) ] pub struct POHANDLE__ { pub unused : :: std :: os :: raw :: c_int , } pub type POHANDLE = * mut POHANDLE__ ; pub type PO_FX_COMPONENT_ACTIVE_CONDITION_CALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , Component : ULONG ) > ; pub type PPO_FX_COMPONENT_ACTIVE_CONDITION_CALLBACK = PO_FX_COMPONENT_ACTIVE_CONDITION_CALLBACK ; pub type PO_FX_COMPONENT_IDLE_CONDITION_CALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , Component : ULONG ) > ; pub type PPO_FX_COMPONENT_IDLE_CONDITION_CALLBACK = PO_FX_COMPONENT_IDLE_CONDITION_CALLBACK ; pub type PO_FX_COMPONENT_IDLE_STATE_CALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , Component : ULONG , State : ULONG ) > ; pub type PPO_FX_COMPONENT_IDLE_STATE_CALLBACK = PO_FX_COMPONENT_IDLE_STATE_CALLBACK ; pub type PO_FX_DEVICE_POWER_REQUIRED_CALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID ) > ; pub type PPO_FX_DEVICE_POWER_REQUIRED_CALLBACK = PO_FX_DEVICE_POWER_REQUIRED_CALLBACK ; pub type PO_FX_DEVICE_POWER_NOT_REQUIRED_CALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID ) > ; pub type PPO_FX_DEVICE_POWER_NOT_REQUIRED_CALLBACK = PO_FX_DEVICE_POWER_NOT_REQUIRED_CALLBACK ; pub type PO_FX_POWER_CONTROL_CALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( DeviceContext : PVOID , PowerControlCode : LPCGUID , InBuffer : PVOID , InBufferSize : SIZE_T , OutBuffer : PVOID , OutBufferSize : SIZE_T , BytesReturned : PSIZE_T ) -> NTSTATUS > ; pub type PPO_FX_POWER_CONTROL_CALLBACK = PO_FX_POWER_CONTROL_CALLBACK ; pub type PO_FX_COMPONENT_CRITICAL_TRANSITION_CALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , Component : ULONG , Active : BOOLEAN ) > ; pub type PPO_FX_COMPONENT_CRITICAL_TRANSITION_CALLBACK = PO_FX_COMPONENT_CRITICAL_TRANSITION_CALLBACK ; # [ repr ( C ) ] pub struct _PO_FX_COMPONENT_IDLE_STATE { pub TransitionLatency : ULONGLONG , pub ResidencyRequirement : ULONGLONG , pub NominalPower : ULONG , } pub type PO_FX_COMPONENT_IDLE_STATE = _PO_FX_COMPONENT_IDLE_STATE ; pub type PPO_FX_COMPONENT_IDLE_STATE = * mut _PO_FX_COMPONENT_IDLE_STATE ; # [ repr ( C ) ] pub struct _PO_FX_COMPONENT_V1 { pub Id : GUID , pub IdleStateCount : ULONG , pub DeepestWakeableIdleState : ULONG , pub IdleStates : PPO_FX_COMPONENT_IDLE_STATE , } pub type PO_FX_COMPONENT_V1 = _PO_FX_COMPONENT_V1 ; pub type PPO_FX_COMPONENT_V1 = * mut _PO_FX_COMPONENT_V1 ; # [ repr ( C ) ] pub struct _PO_FX_DEVICE_V1 { pub Version : ULONG , pub ComponentCount : ULONG , pub ComponentActiveConditionCallback : PPO_FX_COMPONENT_ACTIVE_CONDITION_CALLBACK , pub ComponentIdleConditionCallback : PPO_FX_COMPONENT_IDLE_CONDITION_CALLBACK , pub ComponentIdleStateCallback : PPO_FX_COMPONENT_IDLE_STATE_CALLBACK , pub DevicePowerRequiredCallback : PPO_FX_DEVICE_POWER_REQUIRED_CALLBACK , pub DevicePowerNotRequiredCallback : PPO_FX_DEVICE_POWER_NOT_REQUIRED_CALLBACK , pub PowerControlCallback : PPO_FX_POWER_CONTROL_CALLBACK , pub DeviceContext : PVOID , pub Components : [ PO_FX_COMPONENT_V1 ; 1usize ] , } pub type PO_FX_DEVICE_V1 = _PO_FX_DEVICE_V1 ; pub type PPO_FX_DEVICE_V1 = * mut _PO_FX_DEVICE_V1 ; # [ repr ( C ) ] pub struct _PO_FX_COMPONENT_V2 { pub Id : GUID , pub Flags : ULONGLONG , pub DeepestWakeableIdleState : ULONG , pub IdleStateCount : ULONG , pub IdleStates : PPO_FX_COMPONENT_IDLE_STATE , pub ProviderCount : ULONG , pub Providers : PULONG , } pub type PO_FX_COMPONENT_V2 = _PO_FX_COMPONENT_V2 ; pub type PPO_FX_COMPONENT_V2 = * mut _PO_FX_COMPONENT_V2 ; # [ repr ( C ) ] pub struct _PO_FX_DEVICE_V2 { pub Version : ULONG , pub Flags : ULONGLONG , pub ComponentActiveConditionCallback : PPO_FX_COMPONENT_ACTIVE_CONDITION_CALLBACK , pub ComponentIdleConditionCallback : PPO_FX_COMPONENT_IDLE_CONDITION_CALLBACK , pub ComponentIdleStateCallback : PPO_FX_COMPONENT_IDLE_STATE_CALLBACK , pub DevicePowerRequiredCallback : PPO_FX_DEVICE_POWER_REQUIRED_CALLBACK , pub DevicePowerNotRequiredCallback : PPO_FX_DEVICE_POWER_NOT_REQUIRED_CALLBACK , pub PowerControlCallback : PPO_FX_POWER_CONTROL_CALLBACK , pub DeviceContext : PVOID , pub ComponentCount : ULONG , pub Components : [ PO_FX_COMPONENT_V2 ; 1usize ] , } pub type PO_FX_DEVICE_V2 = _PO_FX_DEVICE_V2 ; pub type PPO_FX_DEVICE_V2 = * mut _PO_FX_DEVICE_V2 ; pub type PO_FX_COMPONENT = PO_FX_COMPONENT_V1 ; pub type PPO_FX_COMPONENT = * mut PO_FX_COMPONENT_V1 ; pub type PO_FX_DEVICE = PO_FX_DEVICE_V1 ; pub type PPO_FX_DEVICE = * mut PO_FX_DEVICE_V1 ; pub const _PO_FX_PERF_STATE_UNIT_PoFxPerfStateUnitOther : _PO_FX_PERF_STATE_UNIT = 0 ; pub const _PO_FX_PERF_STATE_UNIT_PoFxPerfStateUnitFrequency : _PO_FX_PERF_STATE_UNIT = 1 ; pub const _PO_FX_PERF_STATE_UNIT_PoFxPerfStateUnitBandwidth : _PO_FX_PERF_STATE_UNIT = 2 ; pub const _PO_FX_PERF_STATE_UNIT_PoFxPerfStateUnitMaximum : _PO_FX_PERF_STATE_UNIT = 3 ; pub type _PO_FX_PERF_STATE_UNIT = i32 ; pub use self :: _PO_FX_PERF_STATE_UNIT as PO_FX_PERF_STATE_UNIT ; pub type PPO_FX_PERF_STATE_UNIT = * mut _PO_FX_PERF_STATE_UNIT ; pub const _PO_FX_PERF_STATE_TYPE_PoFxPerfStateTypeDiscrete : _PO_FX_PERF_STATE_TYPE = 0 ; pub const _PO_FX_PERF_STATE_TYPE_PoFxPerfStateTypeRange : _PO_FX_PERF_STATE_TYPE = 1 ; pub const _PO_FX_PERF_STATE_TYPE_PoFxPerfStateTypeMaximum : _PO_FX_PERF_STATE_TYPE = 2 ; pub type _PO_FX_PERF_STATE_TYPE = i32 ; pub use self :: _PO_FX_PERF_STATE_TYPE as PO_FX_PERF_STATE_TYPE ; pub type PPO_FX_PERF_STATE_TYPE = * mut _PO_FX_PERF_STATE_TYPE ; # [ repr ( C ) ] pub struct _PO_FX_PERF_STATE { pub Value : ULONGLONG , pub Context : PVOID , } pub type PO_FX_PERF_STATE = _PO_FX_PERF_STATE ; pub type PPO_FX_PERF_STATE = * mut _PO_FX_PERF_STATE ; # [ repr ( C ) ] pub struct _PO_FX_COMPONENT_PERF_SET { pub Name : UNICODE_STRING , pub Flags : ULONGLONG , pub Unit : PO_FX_PERF_STATE_UNIT , pub Type : PO_FX_PERF_STATE_TYPE , pub __bindgen_anon_1 : _PO_FX_COMPONENT_PERF_SET__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _PO_FX_COMPONENT_PERF_SET__bindgen_ty_1 { pub Discrete : __BindgenUnionField < _PO_FX_COMPONENT_PERF_SET__bindgen_ty_1__bindgen_ty_1 > , pub Range : __BindgenUnionField < _PO_FX_COMPONENT_PERF_SET__bindgen_ty_1__bindgen_ty_2 > , pub bindgen_union_field : [ u64 ; 2usize ] , } # [ repr ( C ) ] pub struct _PO_FX_COMPONENT_PERF_SET__bindgen_ty_1__bindgen_ty_1 { pub Count : ULONG , pub States : PPO_FX_PERF_STATE , } # [ repr ( C ) ] pub struct _PO_FX_COMPONENT_PERF_SET__bindgen_ty_1__bindgen_ty_2 { pub Minimum : ULONGLONG , pub Maximum : ULONGLONG , } pub type PO_FX_COMPONENT_PERF_SET = _PO_FX_COMPONENT_PERF_SET ; pub type PPO_FX_COMPONENT_PERF_SET = * mut _PO_FX_COMPONENT_PERF_SET ; # [ repr ( C ) ] pub struct _PO_FX_COMPONENT_PERF_INFO { pub PerfStateSetsCount : ULONG , pub PerfStateSets : [ PO_FX_COMPONENT_PERF_SET ; 1usize ] , } pub type PO_FX_COMPONENT_PERF_INFO = _PO_FX_COMPONENT_PERF_INFO ; pub type PPO_FX_COMPONENT_PERF_INFO = * mut _PO_FX_COMPONENT_PERF_INFO ; # [ repr ( C ) ] pub struct _PO_FX_PERF_STATE_CHANGE { pub Set : ULONG , pub __bindgen_anon_1 : _PO_FX_PERF_STATE_CHANGE__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _PO_FX_PERF_STATE_CHANGE__bindgen_ty_1 { pub StateIndex : __BindgenUnionField < ULONG > , pub StateValue : __BindgenUnionField < ULONGLONG > , pub bindgen_union_field : u64 , } pub type PO_FX_PERF_STATE_CHANGE = _PO_FX_PERF_STATE_CHANGE ; pub type PPO_FX_PERF_STATE_CHANGE = * mut _PO_FX_PERF_STATE_CHANGE ; extern "C" { pub fn PoFxRegisterDevice ( Pdo : PDEVICE_OBJECT , Device : PPO_FX_DEVICE , Handle : * mut POHANDLE ) -> NTSTATUS ; } extern "C" { pub fn PoFxStartDevicePowerManagement ( Handle : POHANDLE ) ; } extern "C" { pub fn PoFxUnregisterDevice ( Handle : POHANDLE ) ; } extern "C" { pub fn PoFxRegisterCrashdumpDevice ( Handle : POHANDLE ) -> NTSTATUS ; } extern "C" { pub fn PoFxPowerOnCrashdumpDevice ( Handle : POHANDLE , Context : PVOID ) -> NTSTATUS ; } extern "C" { pub fn PoFxActivateComponent ( Handle : POHANDLE , Component : ULONG , Flags : ULONG ) ; } extern "C" { pub fn PoFxCompleteDevicePowerNotRequired ( Handle : POHANDLE ) ; } extern "C" { pub fn PoFxCompleteIdleCondition ( Handle : POHANDLE , Component : ULONG ) ; } extern "C" { pub fn PoFxCompleteIdleState ( Handle : POHANDLE , Component : ULONG ) ; } extern "C" { pub fn PoFxIdleComponent ( Handle : POHANDLE , Component : ULONG , Flags : ULONG ) ; } extern "C" { pub fn PoFxSetComponentLatency ( Handle : POHANDLE , Component : ULONG , Latency : ULONGLONG ) ; } extern "C" { pub fn PoFxSetComponentResidency ( Handle : POHANDLE , Component : ULONG , Residency : ULONGLONG ) ; } extern "C" { pub fn PoFxSetComponentWake ( Handle : POHANDLE , Component : ULONG , WakeHint : BOOLEAN ) ; } extern "C" { pub fn PoFxSetDeviceIdleTimeout ( Handle : POHANDLE , IdleTimeout : ULONGLONG ) ; } extern "C" { pub fn PoFxReportDevicePoweredOn ( Handle : POHANDLE ) ; } extern "C" { pub fn PoFxPowerControl ( Handle : POHANDLE , PowerControlCode : LPCGUID , InBuffer : PVOID , InBufferSize : SIZE_T , OutBuffer : PVOID , OutBufferSize : SIZE_T , BytesReturned : PSIZE_T ) -> NTSTATUS ; } extern "C" { pub fn PoFxNotifySurprisePowerOn ( Pdo : PDEVICE_OBJECT ) ; } pub type PO_FX_COMPONENT_PERF_STATE_CALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , Component : ULONG , Succeeded : BOOLEAN , RequestContext : PVOID ) > ; pub type PPO_FX_COMPONENT_PERF_STATE_CALLBACK = PO_FX_COMPONENT_PERF_STATE_CALLBACK ; extern "C" { pub fn PoFxRegisterComponentPerfStates ( Handle : POHANDLE , Component : ULONG , Flags : ULONGLONG , ComponentPerfStateCallback : PPO_FX_COMPONENT_PERF_STATE_CALLBACK , InputStateInfo : PPO_FX_COMPONENT_PERF_INFO , OutputStateInfo : * mut PPO_FX_COMPONENT_PERF_INFO ) -> NTSTATUS ; } extern "C" { pub fn PoFxIssueComponentPerfStateChange ( Handle : POHANDLE , Flags : ULONG , Component : ULONG , PerfChange : PPO_FX_PERF_STATE_CHANGE , Context : PVOID ) ; } extern "C" { pub fn PoFxIssueComponentPerfStateChangeMultiple ( Handle : POHANDLE , Flags : ULONG , Component : ULONG , PerfChangesCount : ULONG , PerfChanges : * mut PO_FX_PERF_STATE_CHANGE , Context : PVOID ) ; } extern "C" { pub fn PoFxQueryCurrentComponentPerfState ( Handle : POHANDLE , Flags : ULONG , Component : ULONG , SetIndex : ULONG , CurrentPerf : PULONGLONG ) -> NTSTATUS ; } extern "C" { pub fn PoFxSetTargetDripsDevicePowerState ( Handle : POHANDLE , TargetState : DEVICE_POWER_STATE ) -> NTSTATUS ; } extern "C" { pub fn PoCreateThermalRequest ( ThermalRequest : * mut PVOID , TargetDeviceObject : PDEVICE_OBJECT , PolicyDeviceObject : PDEVICE_OBJECT , Context : PCOUNTED_REASON_CONTEXT , Flags : ULONG ) -> NTSTATUS ; } pub const _PO_THERMAL_REQUEST_TYPE_PoThermalRequestPassive : _PO_THERMAL_REQUEST_TYPE = 0 ; pub const _PO_THERMAL_REQUEST_TYPE_PoThermalRequestActive : _PO_THERMAL_REQUEST_TYPE = 1 ; pub type _PO_THERMAL_REQUEST_TYPE = i32 ; pub use self :: _PO_THERMAL_REQUEST_TYPE as PO_THERMAL_REQUEST_TYPE ; pub type PPO_THERMAL_REQUEST_TYPE = * mut _PO_THERMAL_REQUEST_TYPE ; extern "C" { pub fn PoGetThermalRequestSupport ( ThermalRequest : PVOID , Type : PO_THERMAL_REQUEST_TYPE ) -> BOOLEAN ; } extern "C" { pub fn PoSetThermalPassiveCooling ( ThermalRequest : PVOID , Throttle : UCHAR ) -> NTSTATUS ; } extern "C" { pub fn PoSetThermalActiveCooling ( ThermalRequest : PVOID , Engaged : BOOLEAN ) -> NTSTATUS ; } extern "C" { pub fn PoDeleteThermalRequest ( ThermalRequest : PVOID ) ; } pub type PO_FX_DRIPS_WATCHDOG_CALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , PhysicalDeviceObject : PDEVICE_OBJECT , UniqueId : ULONG ) > ; pub type PPO_FX_DRIPS_WATCHDOG_CALLBACK = PO_FX_DRIPS_WATCHDOG_CALLBACK ; extern "C" { pub fn PoFxRegisterDripsWatchdogCallback ( Handle : POHANDLE , Callback : PPO_FX_DRIPS_WATCHDOG_CALLBACK , IncludeChildDevices : BOOLEAN , MatchingDriverObject : PDRIVER_OBJECT ) ; } # [ repr ( C ) ] pub struct _OBJECT_HANDLE_INFORMATION { pub HandleAttributes : ULONG , pub GrantedAccess : ACCESS_MASK , } pub type OBJECT_HANDLE_INFORMATION = _OBJECT_HANDLE_INFORMATION ; pub type POBJECT_HANDLE_INFORMATION = * mut _OBJECT_HANDLE_INFORMATION ; extern "C" { pub fn ObReferenceObjectByHandle ( Handle : HANDLE , DesiredAccess : ACCESS_MASK , ObjectType : POBJECT_TYPE , AccessMode : KPROCESSOR_MODE , Object : * mut PVOID , HandleInformation : POBJECT_HANDLE_INFORMATION ) -> NTSTATUS ; } extern "C" { pub fn ObReferenceObjectByHandleWithTag ( Handle : HANDLE , DesiredAccess : ACCESS_MASK , ObjectType : POBJECT_TYPE , AccessMode : KPROCESSOR_MODE , Tag : ULONG , Object : * mut PVOID , HandleInformation : POBJECT_HANDLE_INFORMATION ) -> NTSTATUS ; } extern "C" { pub fn ObReferenceObjectSafe ( Object : PVOID ) -> BOOLEAN ; } extern "C" { pub fn ObReferenceObjectSafeWithTag ( Object : PVOID , Tag : ULONG ) -> BOOLEAN ; } extern "C" { pub fn ObCloseHandle ( Handle : HANDLE , PreviousMode : KPROCESSOR_MODE ) -> NTSTATUS ; } extern "C" { pub fn ObfReferenceObject ( Object : PVOID ) -> LONG_PTR ; } extern "C" { pub fn ObfReferenceObjectWithTag ( Object : PVOID , Tag : ULONG ) -> LONG_PTR ; } extern "C" { pub fn ObReferenceObjectByPointer ( Object : PVOID , DesiredAccess : ACCESS_MASK , ObjectType : POBJECT_TYPE , AccessMode : KPROCESSOR_MODE ) -> NTSTATUS ; } extern "C" { pub fn ObReferenceObjectByPointerWithTag ( Object : PVOID , DesiredAccess : ACCESS_MASK , ObjectType : POBJECT_TYPE , AccessMode : KPROCESSOR_MODE , Tag : ULONG ) -> NTSTATUS ; } extern "C" { pub fn ObfDereferenceObject ( Object : PVOID ) -> LONG_PTR ; } extern "C" { pub fn ObfDereferenceObjectWithTag ( Object : PVOID , Tag : ULONG ) -> LONG_PTR ; } extern "C" { pub fn ObDereferenceObjectDeferDelete ( Object : PVOID ) ; } extern "C" { pub fn ObDereferenceObjectDeferDeleteWithTag ( Object : PVOID , Tag : ULONG ) ; } extern "C" { pub fn ObGetObjectSecurity ( Object : PVOID , SecurityDescriptor : * mut PSECURITY_DESCRIPTOR , MemoryAllocated : PBOOLEAN ) -> NTSTATUS ; } extern "C" { pub fn ObReleaseObjectSecurity ( SecurityDescriptor : PSECURITY_DESCRIPTOR , MemoryAllocated : BOOLEAN ) ; } pub type OB_OPERATION = ULONG ; # [ repr ( C ) ] pub struct _OB_PRE_CREATE_HANDLE_INFORMATION { pub DesiredAccess : ACCESS_MASK , pub OriginalDesiredAccess : ACCESS_MASK , } pub type OB_PRE_CREATE_HANDLE_INFORMATION = _OB_PRE_CREATE_HANDLE_INFORMATION ; pub type POB_PRE_CREATE_HANDLE_INFORMATION = * mut _OB_PRE_CREATE_HANDLE_INFORMATION ; # [ repr ( C ) ] pub struct _OB_PRE_DUPLICATE_HANDLE_INFORMATION { pub DesiredAccess : ACCESS_MASK , pub OriginalDesiredAccess : ACCESS_MASK , pub SourceProcess : PVOID , pub TargetProcess : PVOID , } pub type OB_PRE_DUPLICATE_HANDLE_INFORMATION = _OB_PRE_DUPLICATE_HANDLE_INFORMATION ; pub type POB_PRE_DUPLICATE_HANDLE_INFORMATION = * mut _OB_PRE_DUPLICATE_HANDLE_INFORMATION ; # [ repr ( C ) ] pub struct _OB_PRE_OPERATION_PARAMETERS { pub CreateHandleInformation : __BindgenUnionField < OB_PRE_CREATE_HANDLE_INFORMATION > , pub DuplicateHandleInformation : __BindgenUnionField < OB_PRE_DUPLICATE_HANDLE_INFORMATION > , pub bindgen_union_field : [ u64 ; 3usize ] , } pub type OB_PRE_OPERATION_PARAMETERS = _OB_PRE_OPERATION_PARAMETERS ; pub type POB_PRE_OPERATION_PARAMETERS = * mut _OB_PRE_OPERATION_PARAMETERS ; # [ repr ( C ) ] pub struct _OB_PRE_OPERATION_INFORMATION { pub Operation : OB_OPERATION , pub __bindgen_anon_1 : _OB_PRE_OPERATION_INFORMATION__bindgen_ty_1 , pub Object : PVOID , pub ObjectType : POBJECT_TYPE , pub CallContext : PVOID , pub Parameters : POB_PRE_OPERATION_PARAMETERS , } # [ repr ( C ) ] pub struct _OB_PRE_OPERATION_INFORMATION__bindgen_ty_1 { pub Flags : __BindgenUnionField < ULONG > , pub __bindgen_anon_1 : __BindgenUnionField < _OB_PRE_OPERATION_INFORMATION__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _OB_PRE_OPERATION_INFORMATION__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _OB_PRE_OPERATION_INFORMATION__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn KernelHandle ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_KernelHandle ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 31u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 31u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( KernelHandle : ULONG , Reserved : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let KernelHandle : u32 = unsafe { :: std :: mem :: transmute ( KernelHandle ) } ; KernelHandle as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 31u8 , { let Reserved : u32 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type OB_PRE_OPERATION_INFORMATION = _OB_PRE_OPERATION_INFORMATION ; pub type POB_PRE_OPERATION_INFORMATION = * mut _OB_PRE_OPERATION_INFORMATION ; # [ repr ( C ) ] pub struct _OB_POST_CREATE_HANDLE_INFORMATION { pub GrantedAccess : ACCESS_MASK , } pub type OB_POST_CREATE_HANDLE_INFORMATION = _OB_POST_CREATE_HANDLE_INFORMATION ; pub type POB_POST_CREATE_HANDLE_INFORMATION = * mut _OB_POST_CREATE_HANDLE_INFORMATION ; # [ repr ( C ) ] pub struct _OB_POST_DUPLICATE_HANDLE_INFORMATION { pub GrantedAccess : ACCESS_MASK , } pub type OB_POST_DUPLICATE_HANDLE_INFORMATION = _OB_POST_DUPLICATE_HANDLE_INFORMATION ; pub type POB_POST_DUPLICATE_HANDLE_INFORMATION = * mut _OB_POST_DUPLICATE_HANDLE_INFORMATION ; # [ repr ( C ) ] pub struct _OB_POST_OPERATION_PARAMETERS { pub CreateHandleInformation : __BindgenUnionField < OB_POST_CREATE_HANDLE_INFORMATION > , pub DuplicateHandleInformation : __BindgenUnionField < OB_POST_DUPLICATE_HANDLE_INFORMATION > , pub bindgen_union_field : u32 , } pub type OB_POST_OPERATION_PARAMETERS = _OB_POST_OPERATION_PARAMETERS ; pub type POB_POST_OPERATION_PARAMETERS = * mut _OB_POST_OPERATION_PARAMETERS ; # [ repr ( C ) ] pub struct _OB_POST_OPERATION_INFORMATION { pub Operation : OB_OPERATION , pub __bindgen_anon_1 : _OB_POST_OPERATION_INFORMATION__bindgen_ty_1 , pub Object : PVOID , pub ObjectType : POBJECT_TYPE , pub CallContext : PVOID , pub ReturnStatus : NTSTATUS , pub Parameters : POB_POST_OPERATION_PARAMETERS , } # [ repr ( C ) ] pub struct _OB_POST_OPERATION_INFORMATION__bindgen_ty_1 { pub Flags : __BindgenUnionField < ULONG > , pub __bindgen_anon_1 : __BindgenUnionField < _OB_POST_OPERATION_INFORMATION__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _OB_POST_OPERATION_INFORMATION__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _OB_POST_OPERATION_INFORMATION__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn KernelHandle ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_KernelHandle ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 31u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 31u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( KernelHandle : ULONG , Reserved : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let KernelHandle : u32 = unsafe { :: std :: mem :: transmute ( KernelHandle ) } ; KernelHandle as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 31u8 , { let Reserved : u32 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type OB_POST_OPERATION_INFORMATION = _OB_POST_OPERATION_INFORMATION ; pub type POB_POST_OPERATION_INFORMATION = * mut _OB_POST_OPERATION_INFORMATION ; pub const _OB_PREOP_CALLBACK_STATUS_OB_PREOP_SUCCESS : _OB_PREOP_CALLBACK_STATUS = 0 ; pub type _OB_PREOP_CALLBACK_STATUS = i32 ; pub use self :: _OB_PREOP_CALLBACK_STATUS as OB_PREOP_CALLBACK_STATUS ; pub type POB_PREOP_CALLBACK_STATUS = * mut _OB_PREOP_CALLBACK_STATUS ; pub type POB_PRE_OPERATION_CALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( RegistrationContext : PVOID , OperationInformation : POB_PRE_OPERATION_INFORMATION ) -> OB_PREOP_CALLBACK_STATUS > ; pub type POB_POST_OPERATION_CALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( RegistrationContext : PVOID , OperationInformation : POB_POST_OPERATION_INFORMATION ) > ; # [ repr ( C ) ] pub struct _OB_OPERATION_REGISTRATION { pub ObjectType : * mut POBJECT_TYPE , pub Operations : OB_OPERATION , pub PreOperation : POB_PRE_OPERATION_CALLBACK , pub PostOperation : POB_POST_OPERATION_CALLBACK , } pub type OB_OPERATION_REGISTRATION = _OB_OPERATION_REGISTRATION ; pub type POB_OPERATION_REGISTRATION = * mut _OB_OPERATION_REGISTRATION ; # [ repr ( C ) ] pub struct _OB_CALLBACK_REGISTRATION { pub Version : USHORT , pub OperationRegistrationCount : USHORT , pub Altitude : UNICODE_STRING , pub RegistrationContext : PVOID , pub OperationRegistration : * mut OB_OPERATION_REGISTRATION , } pub type OB_CALLBACK_REGISTRATION = _OB_CALLBACK_REGISTRATION ; pub type POB_CALLBACK_REGISTRATION = * mut _OB_CALLBACK_REGISTRATION ; extern "C" { pub fn ObRegisterCallbacks ( CallbackRegistration : POB_CALLBACK_REGISTRATION , RegistrationHandle : * mut PVOID ) -> NTSTATUS ; } extern "C" { pub fn ObUnRegisterCallbacks ( RegistrationHandle : PVOID ) ; } extern "C" { pub fn ObGetFilterVersion ( ) -> USHORT ; } # [ repr ( C ) ] pub struct _PCI_SLOT_NUMBER { pub u : _PCI_SLOT_NUMBER__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _PCI_SLOT_NUMBER__bindgen_ty_1 { pub bits : __BindgenUnionField < _PCI_SLOT_NUMBER__bindgen_ty_1__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PCI_SLOT_NUMBER__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PCI_SLOT_NUMBER__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn DeviceNumber ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_DeviceNumber ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 5u8 , val as u64 ) } } # [ inline ] pub fn FunctionNumber ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_FunctionNumber ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 24u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 24u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( DeviceNumber : ULONG , FunctionNumber : ULONG , Reserved : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 5u8 , { let DeviceNumber : u32 = unsafe { :: std :: mem :: transmute ( DeviceNumber ) } ; DeviceNumber as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let FunctionNumber : u32 = unsafe { :: std :: mem :: transmute ( FunctionNumber ) } ; FunctionNumber as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 24u8 , { let Reserved : u32 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_SLOT_NUMBER = _PCI_SLOT_NUMBER ; pub type PPCI_SLOT_NUMBER = * mut _PCI_SLOT_NUMBER ; # [ repr ( C ) ] pub struct _PCI_COMMON_HEADER { pub VendorID : USHORT , pub DeviceID : USHORT , pub Command : USHORT , pub Status : USHORT , pub RevisionID : UCHAR , pub ProgIf : UCHAR , pub SubClass : UCHAR , pub BaseClass : UCHAR , pub CacheLineSize : UCHAR , pub LatencyTimer : UCHAR , pub HeaderType : UCHAR , pub BIST : UCHAR , pub u : _PCI_COMMON_HEADER__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _PCI_COMMON_HEADER__bindgen_ty_1 { pub type0 : __BindgenUnionField < _PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_0 > , pub type1 : __BindgenUnionField < _PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_1 > , pub type2 : __BindgenUnionField < _PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_2 > , pub bindgen_union_field : [ u32 ; 12usize ] , } # [ repr ( C ) ] pub struct _PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_0 { pub BaseAddresses : [ ULONG ; 6usize ] , pub CIS : ULONG , pub SubVendorID : USHORT , pub SubSystemID : USHORT , pub ROMBaseAddress : ULONG , pub CapabilitiesPtr : UCHAR , pub Reserved1 : [ UCHAR ; 3usize ] , pub Reserved2 : ULONG , pub InterruptLine : UCHAR , pub InterruptPin : UCHAR , pub MinimumGrant : UCHAR , pub MaximumLatency : UCHAR , } # [ repr ( C ) ] pub struct _PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_1 { pub BaseAddresses : [ ULONG ; 2usize ] , pub PrimaryBus : UCHAR , pub SecondaryBus : UCHAR , pub SubordinateBus : UCHAR , pub SecondaryLatency : UCHAR , pub IOBase : UCHAR , pub IOLimit : UCHAR , pub SecondaryStatus : USHORT , pub MemoryBase : USHORT , pub MemoryLimit : USHORT , pub PrefetchBase : USHORT , pub PrefetchLimit : USHORT , pub PrefetchBaseUpper32 : ULONG , pub PrefetchLimitUpper32 : ULONG , pub IOBaseUpper16 : USHORT , pub IOLimitUpper16 : USHORT , pub CapabilitiesPtr : UCHAR , pub Reserved1 : [ UCHAR ; 3usize ] , pub ROMBaseAddress : ULONG , pub InterruptLine : UCHAR , pub InterruptPin : UCHAR , pub BridgeControl : USHORT , } # [ repr ( C ) ] pub struct _PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_2 { pub SocketRegistersBaseAddress : ULONG , pub CapabilitiesPtr : UCHAR , pub Reserved : UCHAR , pub SecondaryStatus : USHORT , pub PrimaryBus : UCHAR , pub SecondaryBus : UCHAR , pub SubordinateBus : UCHAR , pub SecondaryLatency : UCHAR , pub Range : [ _PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_2__bindgen_ty_1 ; 4usize ] , pub InterruptLine : UCHAR , pub InterruptPin : UCHAR , pub BridgeControl : USHORT , } # [ repr ( C ) ] pub struct _PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_2__bindgen_ty_1 { pub Base : ULONG , pub Limit : ULONG , } pub type PCI_COMMON_HEADER = _PCI_COMMON_HEADER ; pub type PPCI_COMMON_HEADER = * mut _PCI_COMMON_HEADER ; # [ repr ( C ) ] pub struct _PCI_COMMON_CONFIG { pub __bindgen_padding_0 : [ u8 ; 64usize ] , pub DeviceSpecific : [ UCHAR ; 192usize ] , pub __bindgen_align : [ u32 ; 0usize ] , } pub type PCI_COMMON_CONFIG = _PCI_COMMON_CONFIG ; pub type PPCI_COMMON_CONFIG = * mut _PCI_COMMON_CONFIG ; # [ repr ( C ) ] pub struct _PCI_CAPABILITIES_HEADER { pub CapabilityID : UCHAR , pub Next : UCHAR , } pub type PCI_CAPABILITIES_HEADER = _PCI_CAPABILITIES_HEADER ; pub type PPCI_CAPABILITIES_HEADER = * mut _PCI_CAPABILITIES_HEADER ; # [ repr ( C ) ] pub struct _PCI_PMC { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub Support : _PCI_PMC__PM_SUPPORT , } # [ repr ( C , packed ) ] pub struct _PCI_PMC__PM_SUPPORT { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl _PCI_PMC__PM_SUPPORT { # [ inline ] pub fn Rsvd2 ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_Rsvd2 ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn D1 ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_D1 ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn D2 ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_D2 ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PMED0 ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_PMED0 ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PMED1 ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_PMED1 ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PMED2 ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_PMED2 ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PMED3Hot ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_PMED3Hot ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PMED3Cold ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_PMED3Cold ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Rsvd2 : UCHAR , D1 : UCHAR , D2 : UCHAR , PMED0 : UCHAR , PMED1 : UCHAR , PMED2 : UCHAR , PMED3Hot : UCHAR , PMED3Cold : UCHAR ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let Rsvd2 : u8 = unsafe { :: std :: mem :: transmute ( Rsvd2 ) } ; Rsvd2 as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let D1 : u8 = unsafe { :: std :: mem :: transmute ( D1 ) } ; D1 as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let D2 : u8 = unsafe { :: std :: mem :: transmute ( D2 ) } ; D2 as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let PMED0 : u8 = unsafe { :: std :: mem :: transmute ( PMED0 ) } ; PMED0 as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let PMED1 : u8 = unsafe { :: std :: mem :: transmute ( PMED1 ) } ; PMED1 as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let PMED2 : u8 = unsafe { :: std :: mem :: transmute ( PMED2 ) } ; PMED2 as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let PMED3Hot : u8 = unsafe { :: std :: mem :: transmute ( PMED3Hot ) } ; PMED3Hot as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let PMED3Cold : u8 = unsafe { :: std :: mem :: transmute ( PMED3Cold ) } ; PMED3Cold as u64 } ) ; __bindgen_bitfield_unit } } impl _PCI_PMC { # [ inline ] pub fn Version ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_Version ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn PMEClock ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_PMEClock ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Rsvd1 ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_Rsvd1 ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn DeviceSpecificInitialization ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_DeviceSpecificInitialization ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Rsvd2 ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_Rsvd2 ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 2u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Version : UCHAR , PMEClock : UCHAR , Rsvd1 : UCHAR , DeviceSpecificInitialization : UCHAR , Rsvd2 : UCHAR ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let Version : u8 = unsafe { :: std :: mem :: transmute ( Version ) } ; Version as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let PMEClock : u8 = unsafe { :: std :: mem :: transmute ( PMEClock ) } ; PMEClock as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let Rsvd1 : u8 = unsafe { :: std :: mem :: transmute ( Rsvd1 ) } ; Rsvd1 as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let DeviceSpecificInitialization : u8 = unsafe { :: std :: mem :: transmute ( DeviceSpecificInitialization ) } ; DeviceSpecificInitialization as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 2u8 , { let Rsvd2 : u8 = unsafe { :: std :: mem :: transmute ( Rsvd2 ) } ; Rsvd2 as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_PMC = _PCI_PMC ; pub type PPCI_PMC = * mut _PCI_PMC ; # [ repr ( C ) ] pub struct _PCI_PMCSR { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl _PCI_PMCSR { # [ inline ] pub fn PowerState ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 2u8 ) as u16 ) } } # [ inline ] pub fn set_PowerState ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 2u8 , val as u64 ) } } # [ inline ] pub fn Rsvd1 ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_Rsvd1 ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn NoSoftReset ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_NoSoftReset ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Rsvd2 ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u16 ) } } # [ inline ] pub fn set_Rsvd2 ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn PMEEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_PMEEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn DataSelect ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 4u8 ) as u16 ) } } # [ inline ] pub fn set_DataSelect ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 4u8 , val as u64 ) } } # [ inline ] pub fn DataScale ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 13usize , 2u8 ) as u16 ) } } # [ inline ] pub fn set_DataScale ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 13usize , 2u8 , val as u64 ) } } # [ inline ] pub fn PMEStatus ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 15usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_PMEStatus ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 15usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( PowerState : USHORT , Rsvd1 : USHORT , NoSoftReset : USHORT , Rsvd2 : USHORT , PMEEnable : USHORT , DataSelect : USHORT , DataScale : USHORT , PMEStatus : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 2u8 , { let PowerState : u16 = unsafe { :: std :: mem :: transmute ( PowerState ) } ; PowerState as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let Rsvd1 : u16 = unsafe { :: std :: mem :: transmute ( Rsvd1 ) } ; Rsvd1 as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let NoSoftReset : u16 = unsafe { :: std :: mem :: transmute ( NoSoftReset ) } ; NoSoftReset as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let Rsvd2 : u16 = unsafe { :: std :: mem :: transmute ( Rsvd2 ) } ; Rsvd2 as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let PMEEnable : u16 = unsafe { :: std :: mem :: transmute ( PMEEnable ) } ; PMEEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 4u8 , { let DataSelect : u16 = unsafe { :: std :: mem :: transmute ( DataSelect ) } ; DataSelect as u64 } ) ; __bindgen_bitfield_unit . set ( 13usize , 2u8 , { let DataScale : u16 = unsafe { :: std :: mem :: transmute ( DataScale ) } ; DataScale as u64 } ) ; __bindgen_bitfield_unit . set ( 15usize , 1u8 , { let PMEStatus : u16 = unsafe { :: std :: mem :: transmute ( PMEStatus ) } ; PMEStatus as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_PMCSR = _PCI_PMCSR ; pub type PPCI_PMCSR = * mut _PCI_PMCSR ; # [ repr ( C , packed ) ] pub struct _PCI_PMCSR_BSE { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl _PCI_PMCSR_BSE { # [ inline ] pub fn Rsvd1 ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_Rsvd1 ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 6u8 , val as u64 ) } } # [ inline ] pub fn D3HotSupportsStopClock ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_D3HotSupportsStopClock ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn BusPowerClockControlEnabled ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_BusPowerClockControlEnabled ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Rsvd1 : UCHAR , D3HotSupportsStopClock : UCHAR , BusPowerClockControlEnabled : UCHAR ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 6u8 , { let Rsvd1 : u8 = unsafe { :: std :: mem :: transmute ( Rsvd1 ) } ; Rsvd1 as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let D3HotSupportsStopClock : u8 = unsafe { :: std :: mem :: transmute ( D3HotSupportsStopClock ) } ; D3HotSupportsStopClock as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let BusPowerClockControlEnabled : u8 = unsafe { :: std :: mem :: transmute ( BusPowerClockControlEnabled ) } ; BusPowerClockControlEnabled as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_PMCSR_BSE = _PCI_PMCSR_BSE ; pub type PPCI_PMCSR_BSE = * mut _PCI_PMCSR_BSE ; # [ repr ( C ) ] pub struct _PCI_PM_CAPABILITY { pub Header : PCI_CAPABILITIES_HEADER , pub PMC : _PCI_PM_CAPABILITY__bindgen_ty_1 , pub PMCSR : _PCI_PM_CAPABILITY__bindgen_ty_2 , pub PMCSR_BSE : _PCI_PM_CAPABILITY__bindgen_ty_3 , pub Data : UCHAR , } # [ repr ( C ) ] pub struct _PCI_PM_CAPABILITY__bindgen_ty_1 { pub Capabilities : __BindgenUnionField < PCI_PMC > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : u16 , } # [ repr ( C ) ] pub struct _PCI_PM_CAPABILITY__bindgen_ty_2 { pub ControlStatus : __BindgenUnionField < PCI_PMCSR > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : u16 , } # [ repr ( C ) ] pub struct _PCI_PM_CAPABILITY__bindgen_ty_3 { pub BridgeSupport : __BindgenUnionField < PCI_PMCSR_BSE > , pub AsUCHAR : __BindgenUnionField < UCHAR > , pub bindgen_union_field : u8 , } pub type PCI_PM_CAPABILITY = _PCI_PM_CAPABILITY ; pub type PPCI_PM_CAPABILITY = * mut _PCI_PM_CAPABILITY ; # [ repr ( C ) ] pub struct PCI_X_CAPABILITY { pub Header : PCI_CAPABILITIES_HEADER , pub Command : PCI_X_CAPABILITY__bindgen_ty_1 , pub Status : PCI_X_CAPABILITY__bindgen_ty_2 , } # [ repr ( C ) ] pub struct PCI_X_CAPABILITY__bindgen_ty_1 { pub bits : __BindgenUnionField < PCI_X_CAPABILITY__bindgen_ty_1__bindgen_ty_1 > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : u16 , } # [ repr ( C ) ] pub struct PCI_X_CAPABILITY__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl PCI_X_CAPABILITY__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn DataParityErrorRecoveryEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_DataParityErrorRecoveryEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn EnableRelaxedOrdering ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_EnableRelaxedOrdering ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MaxMemoryReadByteCount ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 2u8 ) as u16 ) } } # [ inline ] pub fn set_MaxMemoryReadByteCount ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 2u8 , val as u64 ) } } # [ inline ] pub fn MaxOutstandingSplitTransactions ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 3u8 ) as u16 ) } } # [ inline ] pub fn set_MaxOutstandingSplitTransactions ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 3u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 9u8 ) as u16 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 9u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( DataParityErrorRecoveryEnable : USHORT , EnableRelaxedOrdering : USHORT , MaxMemoryReadByteCount : USHORT , MaxOutstandingSplitTransactions : USHORT , Reserved : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let DataParityErrorRecoveryEnable : u16 = unsafe { :: std :: mem :: transmute ( DataParityErrorRecoveryEnable ) } ; DataParityErrorRecoveryEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let EnableRelaxedOrdering : u16 = unsafe { :: std :: mem :: transmute ( EnableRelaxedOrdering ) } ; EnableRelaxedOrdering as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 2u8 , { let MaxMemoryReadByteCount : u16 = unsafe { :: std :: mem :: transmute ( MaxMemoryReadByteCount ) } ; MaxMemoryReadByteCount as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 3u8 , { let MaxOutstandingSplitTransactions : u16 = unsafe { :: std :: mem :: transmute ( MaxOutstandingSplitTransactions ) } ; MaxOutstandingSplitTransactions as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 9u8 , { let Reserved : u16 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] pub struct PCI_X_CAPABILITY__bindgen_ty_2 { pub bits : __BindgenUnionField < PCI_X_CAPABILITY__bindgen_ty_2__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct PCI_X_CAPABILITY__bindgen_ty_2__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl PCI_X_CAPABILITY__bindgen_ty_2__bindgen_ty_1 { # [ inline ] pub fn FunctionNumber ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_FunctionNumber ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn DeviceNumber ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_DeviceNumber ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 5u8 , val as u64 ) } } # [ inline ] pub fn BusNumber ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_BusNumber ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn Device64Bit ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Device64Bit ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Capable133MHz ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 17usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Capable133MHz ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 17usize , 1u8 , val as u64 ) } } # [ inline ] pub fn SplitCompletionDiscarded ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 18usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_SplitCompletionDiscarded ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 18usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UnexpectedSplitCompletion ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 19usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_UnexpectedSplitCompletion ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 19usize , 1u8 , val as u64 ) } } # [ inline ] pub fn DeviceComplexity ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 20usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_DeviceComplexity ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 20usize , 1u8 , val as u64 ) } } # [ inline ] pub fn DesignedMaxMemoryReadByteCount ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 21usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_DesignedMaxMemoryReadByteCount ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 21usize , 2u8 , val as u64 ) } } # [ inline ] pub fn DesignedMaxOutstandingSplitTransactions ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 23usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_DesignedMaxOutstandingSplitTransactions ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 23usize , 3u8 , val as u64 ) } } # [ inline ] pub fn DesignedMaxCumulativeReadSize ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 26usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_DesignedMaxCumulativeReadSize ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 26usize , 3u8 , val as u64 ) } } # [ inline ] pub fn ReceivedSplitCompletionErrorMessage ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 29usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ReceivedSplitCompletionErrorMessage ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 29usize , 1u8 , val as u64 ) } } # [ inline ] pub fn CapablePCIX266 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 30usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_CapablePCIX266 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 30usize , 1u8 , val as u64 ) } } # [ inline ] pub fn CapablePCIX533 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 31usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_CapablePCIX533 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 31usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( FunctionNumber : ULONG , DeviceNumber : ULONG , BusNumber : ULONG , Device64Bit : ULONG , Capable133MHz : ULONG , SplitCompletionDiscarded : ULONG , UnexpectedSplitCompletion : ULONG , DeviceComplexity : ULONG , DesignedMaxMemoryReadByteCount : ULONG , DesignedMaxOutstandingSplitTransactions : ULONG , DesignedMaxCumulativeReadSize : ULONG , ReceivedSplitCompletionErrorMessage : ULONG , CapablePCIX266 : ULONG , CapablePCIX533 : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let FunctionNumber : u32 = unsafe { :: std :: mem :: transmute ( FunctionNumber ) } ; FunctionNumber as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 5u8 , { let DeviceNumber : u32 = unsafe { :: std :: mem :: transmute ( DeviceNumber ) } ; DeviceNumber as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let BusNumber : u32 = unsafe { :: std :: mem :: transmute ( BusNumber ) } ; BusNumber as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 1u8 , { let Device64Bit : u32 = unsafe { :: std :: mem :: transmute ( Device64Bit ) } ; Device64Bit as u64 } ) ; __bindgen_bitfield_unit . set ( 17usize , 1u8 , { let Capable133MHz : u32 = unsafe { :: std :: mem :: transmute ( Capable133MHz ) } ; Capable133MHz as u64 } ) ; __bindgen_bitfield_unit . set ( 18usize , 1u8 , { let SplitCompletionDiscarded : u32 = unsafe { :: std :: mem :: transmute ( SplitCompletionDiscarded ) } ; SplitCompletionDiscarded as u64 } ) ; __bindgen_bitfield_unit . set ( 19usize , 1u8 , { let UnexpectedSplitCompletion : u32 = unsafe { :: std :: mem :: transmute ( UnexpectedSplitCompletion ) } ; UnexpectedSplitCompletion as u64 } ) ; __bindgen_bitfield_unit . set ( 20usize , 1u8 , { let DeviceComplexity : u32 = unsafe { :: std :: mem :: transmute ( DeviceComplexity ) } ; DeviceComplexity as u64 } ) ; __bindgen_bitfield_unit . set ( 21usize , 2u8 , { let DesignedMaxMemoryReadByteCount : u32 = unsafe { :: std :: mem :: transmute ( DesignedMaxMemoryReadByteCount ) } ; DesignedMaxMemoryReadByteCount as u64 } ) ; __bindgen_bitfield_unit . set ( 23usize , 3u8 , { let DesignedMaxOutstandingSplitTransactions : u32 = unsafe { :: std :: mem :: transmute ( DesignedMaxOutstandingSplitTransactions ) } ; DesignedMaxOutstandingSplitTransactions as u64 } ) ; __bindgen_bitfield_unit . set ( 26usize , 3u8 , { let DesignedMaxCumulativeReadSize : u32 = unsafe { :: std :: mem :: transmute ( DesignedMaxCumulativeReadSize ) } ; DesignedMaxCumulativeReadSize as u64 } ) ; __bindgen_bitfield_unit . set ( 29usize , 1u8 , { let ReceivedSplitCompletionErrorMessage : u32 = unsafe { :: std :: mem :: transmute ( ReceivedSplitCompletionErrorMessage ) } ; ReceivedSplitCompletionErrorMessage as u64 } ) ; __bindgen_bitfield_unit . set ( 30usize , 1u8 , { let CapablePCIX266 : u32 = unsafe { :: std :: mem :: transmute ( CapablePCIX266 ) } ; CapablePCIX266 as u64 } ) ; __bindgen_bitfield_unit . set ( 31usize , 1u8 , { let CapablePCIX533 : u32 = unsafe { :: std :: mem :: transmute ( CapablePCIX533 ) } ; CapablePCIX533 as u64 } ) ; __bindgen_bitfield_unit } } pub type PPCI_X_CAPABILITY = * mut PCI_X_CAPABILITY ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER { pub CapabilityID : USHORT , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > , } impl _PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER { # [ inline ] pub fn Version ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u16 ) } } # [ inline ] pub fn set_Version ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn Next ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 12u8 ) as u16 ) } } # [ inline ] pub fn set_Next ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 12u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Version : USHORT , Next : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let Version : u16 = unsafe { :: std :: mem :: transmute ( Version ) } ; Version as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 12u8 , { let Next : u16 = unsafe { :: std :: mem :: transmute ( Next ) } ; Next as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER = _PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER ; pub type PPCI_EXPRESS_ENHANCED_CAPABILITY_HEADER = * mut _PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_VENDOR_SPECIFIC_CAPABILITY { pub Header : PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER , pub VsecId : USHORT , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > , } impl _PCI_EXPRESS_VENDOR_SPECIFIC_CAPABILITY { # [ inline ] pub fn VsecRev ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u16 ) } } # [ inline ] pub fn set_VsecRev ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn VsecLength ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 12u8 ) as u16 ) } } # [ inline ] pub fn set_VsecLength ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 12u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( VsecRev : USHORT , VsecLength : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let VsecRev : u16 = unsafe { :: std :: mem :: transmute ( VsecRev ) } ; VsecRev as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 12u8 , { let VsecLength : u16 = unsafe { :: std :: mem :: transmute ( VsecLength ) } ; VsecLength as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_VENDOR_SPECIFIC_CAPABILITY = _PCI_EXPRESS_VENDOR_SPECIFIC_CAPABILITY ; pub type PPCI_EXPRESS_VENDOR_SPECIFIC_CAPABILITY = * mut _PCI_EXPRESS_VENDOR_SPECIFIC_CAPABILITY ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_SERIAL_NUMBER_CAPABILITY { pub Header : PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER , pub LowSerialNumber : ULONG , pub HighSerialNumber : ULONG , } pub type PCI_EXPRESS_SERIAL_NUMBER_CAPABILITY = _PCI_EXPRESS_SERIAL_NUMBER_CAPABILITY ; pub type PPCI_EXPRESS_SERIAL_NUMBER_CAPABILITY = * mut _PCI_EXPRESS_SERIAL_NUMBER_CAPABILITY ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_ARI_CAPABILITY_REGISTER { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl _PCI_EXPRESS_ARI_CAPABILITY_REGISTER { # [ inline ] pub fn MfvcFunctionGroupsCapability ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_MfvcFunctionGroupsCapability ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AcsFunctionGroupsCapability ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_AcsFunctionGroupsCapability ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 6u8 ) as u16 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 6u8 , val as u64 ) } } # [ inline ] pub fn NextFunctionNumber ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u16 ) } } # [ inline ] pub fn set_NextFunctionNumber ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( MfvcFunctionGroupsCapability : USHORT , AcsFunctionGroupsCapability : USHORT , Reserved : USHORT , NextFunctionNumber : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let MfvcFunctionGroupsCapability : u16 = unsafe { :: std :: mem :: transmute ( MfvcFunctionGroupsCapability ) } ; MfvcFunctionGroupsCapability as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let AcsFunctionGroupsCapability : u16 = unsafe { :: std :: mem :: transmute ( AcsFunctionGroupsCapability ) } ; AcsFunctionGroupsCapability as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 6u8 , { let Reserved : u16 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let NextFunctionNumber : u16 = unsafe { :: std :: mem :: transmute ( NextFunctionNumber ) } ; NextFunctionNumber as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_ARI_CAPABILITY_REGISTER = _PCI_EXPRESS_ARI_CAPABILITY_REGISTER ; pub type PPCI_EXPRESS_ARI_CAPABILITY_REGISTER = * mut _PCI_EXPRESS_ARI_CAPABILITY_REGISTER ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_ARI_CONTROL_REGISTER { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl _PCI_EXPRESS_ARI_CONTROL_REGISTER { # [ inline ] pub fn MfvcFunctionGroupsEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_MfvcFunctionGroupsEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AcsFunctionGroupsEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_AcsFunctionGroupsEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved1 ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 2u8 ) as u16 ) } } # [ inline ] pub fn set_Reserved1 ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 2u8 , val as u64 ) } } # [ inline ] pub fn FunctionGroup ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 3u8 ) as u16 ) } } # [ inline ] pub fn set_FunctionGroup ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 3u8 , val as u64 ) } } # [ inline ] pub fn Reserved2 ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 9u8 ) as u16 ) } } # [ inline ] pub fn set_Reserved2 ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 9u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( MfvcFunctionGroupsEnable : USHORT , AcsFunctionGroupsEnable : USHORT , Reserved1 : USHORT , FunctionGroup : USHORT , Reserved2 : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let MfvcFunctionGroupsEnable : u16 = unsafe { :: std :: mem :: transmute ( MfvcFunctionGroupsEnable ) } ; MfvcFunctionGroupsEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let AcsFunctionGroupsEnable : u16 = unsafe { :: std :: mem :: transmute ( AcsFunctionGroupsEnable ) } ; AcsFunctionGroupsEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 2u8 , { let Reserved1 : u16 = unsafe { :: std :: mem :: transmute ( Reserved1 ) } ; Reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 3u8 , { let FunctionGroup : u16 = unsafe { :: std :: mem :: transmute ( FunctionGroup ) } ; FunctionGroup as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 9u8 , { let Reserved2 : u16 = unsafe { :: std :: mem :: transmute ( Reserved2 ) } ; Reserved2 as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_ARI_CONTROL_REGISTER = _PCI_EXPRESS_ARI_CONTROL_REGISTER ; pub type PPCI_EXPRESS_ARI_CONTROL_REGISTER = * mut _PCI_EXPRESS_ARI_CONTROL_REGISTER ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_ARI_CAPABILITY { pub Header : PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER , pub Capability : PCI_EXPRESS_ARI_CAPABILITY_REGISTER , pub Control : PCI_EXPRESS_ARI_CONTROL_REGISTER , } pub type PCI_EXPRESS_ARI_CAPABILITY = _PCI_EXPRESS_ARI_CAPABILITY ; pub type PPCI_EXPRESS_ARI_CAPABILITY = * mut _PCI_EXPRESS_ARI_CAPABILITY ; # [ repr ( C ) ] pub struct _VIRTUAL_CHANNEL_CAPABILITIES1 { pub __bindgen_anon_1 : __BindgenUnionField < _VIRTUAL_CHANNEL_CAPABILITIES1__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _VIRTUAL_CHANNEL_CAPABILITIES1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _VIRTUAL_CHANNEL_CAPABILITIES1__bindgen_ty_1 { # [ inline ] pub fn ExtendedVCCount ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_ExtendedVCCount ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn RsvdP1 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_RsvdP1 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn LowPriorityExtendedVCCount ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_LowPriorityExtendedVCCount ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 3u8 , val as u64 ) } } # [ inline ] pub fn RsvdP2 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_RsvdP2 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ReferenceClock ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_ReferenceClock ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 2u8 , val as u64 ) } } # [ inline ] pub fn PortArbitrationTableEntrySize ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_PortArbitrationTableEntrySize ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 2u8 , val as u64 ) } } # [ inline ] pub fn RsvdP3 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 20u8 ) as u32 ) } } # [ inline ] pub fn set_RsvdP3 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 20u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ExtendedVCCount : ULONG , RsvdP1 : ULONG , LowPriorityExtendedVCCount : ULONG , RsvdP2 : ULONG , ReferenceClock : ULONG , PortArbitrationTableEntrySize : ULONG , RsvdP3 : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let ExtendedVCCount : u32 = unsafe { :: std :: mem :: transmute ( ExtendedVCCount ) } ; ExtendedVCCount as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let RsvdP1 : u32 = unsafe { :: std :: mem :: transmute ( RsvdP1 ) } ; RsvdP1 as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 3u8 , { let LowPriorityExtendedVCCount : u32 = unsafe { :: std :: mem :: transmute ( LowPriorityExtendedVCCount ) } ; LowPriorityExtendedVCCount as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let RsvdP2 : u32 = unsafe { :: std :: mem :: transmute ( RsvdP2 ) } ; RsvdP2 as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 2u8 , { let ReferenceClock : u32 = unsafe { :: std :: mem :: transmute ( ReferenceClock ) } ; ReferenceClock as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 2u8 , { let PortArbitrationTableEntrySize : u32 = unsafe { :: std :: mem :: transmute ( PortArbitrationTableEntrySize ) } ; PortArbitrationTableEntrySize as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 20u8 , { let RsvdP3 : u32 = unsafe { :: std :: mem :: transmute ( RsvdP3 ) } ; RsvdP3 as u64 } ) ; __bindgen_bitfield_unit } } pub type VIRTUAL_CHANNEL_CAPABILITIES1 = _VIRTUAL_CHANNEL_CAPABILITIES1 ; pub type PVIRTUAL_CHANNEL_CAPABILITIES1 = * mut _VIRTUAL_CHANNEL_CAPABILITIES1 ; # [ repr ( C ) ] pub struct _VIRTUAL_CHANNEL_CAPABILITIES2 { pub __bindgen_anon_1 : __BindgenUnionField < _VIRTUAL_CHANNEL_CAPABILITIES2__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _VIRTUAL_CHANNEL_CAPABILITIES2__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _VIRTUAL_CHANNEL_CAPABILITIES2__bindgen_ty_1 { # [ inline ] pub fn VCArbitrationCapability ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_VCArbitrationCapability ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn RsvdP ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_RsvdP ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 16u8 , val as u64 ) } } # [ inline ] pub fn VCArbitrationTableOffset ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_VCArbitrationTableOffset ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( VCArbitrationCapability : ULONG , RsvdP : ULONG , VCArbitrationTableOffset : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let VCArbitrationCapability : u32 = unsafe { :: std :: mem :: transmute ( VCArbitrationCapability ) } ; VCArbitrationCapability as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 16u8 , { let RsvdP : u32 = unsafe { :: std :: mem :: transmute ( RsvdP ) } ; RsvdP as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let VCArbitrationTableOffset : u32 = unsafe { :: std :: mem :: transmute ( VCArbitrationTableOffset ) } ; VCArbitrationTableOffset as u64 } ) ; __bindgen_bitfield_unit } } pub type VIRTUAL_CHANNEL_CAPABILITIES2 = _VIRTUAL_CHANNEL_CAPABILITIES2 ; pub type PVIRTUAL_CHANNEL_CAPABILITIES2 = * mut _VIRTUAL_CHANNEL_CAPABILITIES2 ; # [ repr ( C ) ] pub struct _VIRTUAL_CHANNEL_CONTROL { pub __bindgen_anon_1 : __BindgenUnionField < _VIRTUAL_CHANNEL_CONTROL__bindgen_ty_1 > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : u16 , } # [ repr ( C ) ] pub struct _VIRTUAL_CHANNEL_CONTROL__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl _VIRTUAL_CHANNEL_CONTROL__bindgen_ty_1 { # [ inline ] pub fn LoadVCArbitrationTable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_LoadVCArbitrationTable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn VCArbitrationSelect ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 3u8 ) as u16 ) } } # [ inline ] pub fn set_VCArbitrationSelect ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 3u8 , val as u64 ) } } # [ inline ] pub fn RsvdP ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 12u8 ) as u16 ) } } # [ inline ] pub fn set_RsvdP ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 12u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( LoadVCArbitrationTable : USHORT , VCArbitrationSelect : USHORT , RsvdP : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let LoadVCArbitrationTable : u16 = unsafe { :: std :: mem :: transmute ( LoadVCArbitrationTable ) } ; LoadVCArbitrationTable as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 3u8 , { let VCArbitrationSelect : u16 = unsafe { :: std :: mem :: transmute ( VCArbitrationSelect ) } ; VCArbitrationSelect as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 12u8 , { let RsvdP : u16 = unsafe { :: std :: mem :: transmute ( RsvdP ) } ; RsvdP as u64 } ) ; __bindgen_bitfield_unit } } pub type VIRTUAL_CHANNEL_CONTROL = _VIRTUAL_CHANNEL_CONTROL ; pub type PVIRTUAL_CHANNEL_CONTROL = * mut _VIRTUAL_CHANNEL_CONTROL ; # [ repr ( C ) ] pub struct _VIRTUAL_CHANNEL_STATUS { pub __bindgen_anon_1 : __BindgenUnionField < _VIRTUAL_CHANNEL_STATUS__bindgen_ty_1 > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : u16 , } # [ repr ( C ) ] pub struct _VIRTUAL_CHANNEL_STATUS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl _VIRTUAL_CHANNEL_STATUS__bindgen_ty_1 { # [ inline ] pub fn VCArbitrationTableStatus ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_VCArbitrationTableStatus ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn RsvdZ ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 15u8 ) as u16 ) } } # [ inline ] pub fn set_RsvdZ ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 15u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( VCArbitrationTableStatus : USHORT , RsvdZ : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let VCArbitrationTableStatus : u16 = unsafe { :: std :: mem :: transmute ( VCArbitrationTableStatus ) } ; VCArbitrationTableStatus as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 15u8 , { let RsvdZ : u16 = unsafe { :: std :: mem :: transmute ( RsvdZ ) } ; RsvdZ as u64 } ) ; __bindgen_bitfield_unit } } pub type VIRTUAL_CHANNEL_STATUS = _VIRTUAL_CHANNEL_STATUS ; pub type PVIRTUAL_CHANNEL_STATUS = * mut _VIRTUAL_CHANNEL_STATUS ; # [ repr ( C ) ] pub struct _VIRTUAL_RESOURCE_CAPABILITY { pub __bindgen_anon_1 : __BindgenUnionField < _VIRTUAL_RESOURCE_CAPABILITY__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _VIRTUAL_RESOURCE_CAPABILITY__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _VIRTUAL_RESOURCE_CAPABILITY__bindgen_ty_1 { # [ inline ] pub fn PortArbitrationCapability ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_PortArbitrationCapability ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn RsvdP1 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 6u8 ) as u32 ) } } # [ inline ] pub fn set_RsvdP1 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 6u8 , val as u64 ) } } # [ inline ] pub fn Undefined ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Undefined ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 1u8 , val as u64 ) } } # [ inline ] pub fn RejectSnoopTransactions ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 15usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_RejectSnoopTransactions ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 15usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MaximumTimeSlots ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 7u8 ) as u32 ) } } # [ inline ] pub fn set_MaximumTimeSlots ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 7u8 , val as u64 ) } } # [ inline ] pub fn RsvdP2 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 23usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_RsvdP2 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 23usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PortArbitrationTableOffset ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_PortArbitrationTableOffset ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( PortArbitrationCapability : ULONG , RsvdP1 : ULONG , Undefined : ULONG , RejectSnoopTransactions : ULONG , MaximumTimeSlots : ULONG , RsvdP2 : ULONG , PortArbitrationTableOffset : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let PortArbitrationCapability : u32 = unsafe { :: std :: mem :: transmute ( PortArbitrationCapability ) } ; PortArbitrationCapability as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 6u8 , { let RsvdP1 : u32 = unsafe { :: std :: mem :: transmute ( RsvdP1 ) } ; RsvdP1 as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 1u8 , { let Undefined : u32 = unsafe { :: std :: mem :: transmute ( Undefined ) } ; Undefined as u64 } ) ; __bindgen_bitfield_unit . set ( 15usize , 1u8 , { let RejectSnoopTransactions : u32 = unsafe { :: std :: mem :: transmute ( RejectSnoopTransactions ) } ; RejectSnoopTransactions as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 7u8 , { let MaximumTimeSlots : u32 = unsafe { :: std :: mem :: transmute ( MaximumTimeSlots ) } ; MaximumTimeSlots as u64 } ) ; __bindgen_bitfield_unit . set ( 23usize , 1u8 , { let RsvdP2 : u32 = unsafe { :: std :: mem :: transmute ( RsvdP2 ) } ; RsvdP2 as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let PortArbitrationTableOffset : u32 = unsafe { :: std :: mem :: transmute ( PortArbitrationTableOffset ) } ; PortArbitrationTableOffset as u64 } ) ; __bindgen_bitfield_unit } } pub type VIRTUAL_RESOURCE_CAPABILITY = _VIRTUAL_RESOURCE_CAPABILITY ; pub type PVIRTUAL_RESOURCE_CAPABILITY = * mut _VIRTUAL_RESOURCE_CAPABILITY ; # [ repr ( C ) ] pub struct _VIRTUAL_RESOURCE_CONTROL { pub __bindgen_anon_1 : __BindgenUnionField < _VIRTUAL_RESOURCE_CONTROL__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _VIRTUAL_RESOURCE_CONTROL__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _VIRTUAL_RESOURCE_CONTROL__bindgen_ty_1 { # [ inline ] pub fn TcVcMap ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_TcVcMap ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn RsvdP1 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_RsvdP1 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn LoadPortArbitrationTable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_LoadPortArbitrationTable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PortArbitrationSelect ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 17usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_PortArbitrationSelect ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 17usize , 3u8 , val as u64 ) } } # [ inline ] pub fn RsvdP2 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 20usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_RsvdP2 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 20usize , 4u8 , val as u64 ) } } # [ inline ] pub fn VcID ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_VcID ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 3u8 , val as u64 ) } } # [ inline ] pub fn RsvdP3 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 27usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_RsvdP3 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 27usize , 4u8 , val as u64 ) } } # [ inline ] pub fn VcEnable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 31usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_VcEnable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 31usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( TcVcMap : ULONG , RsvdP1 : ULONG , LoadPortArbitrationTable : ULONG , PortArbitrationSelect : ULONG , RsvdP2 : ULONG , VcID : ULONG , RsvdP3 : ULONG , VcEnable : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let TcVcMap : u32 = unsafe { :: std :: mem :: transmute ( TcVcMap ) } ; TcVcMap as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let RsvdP1 : u32 = unsafe { :: std :: mem :: transmute ( RsvdP1 ) } ; RsvdP1 as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 1u8 , { let LoadPortArbitrationTable : u32 = unsafe { :: std :: mem :: transmute ( LoadPortArbitrationTable ) } ; LoadPortArbitrationTable as u64 } ) ; __bindgen_bitfield_unit . set ( 17usize , 3u8 , { let PortArbitrationSelect : u32 = unsafe { :: std :: mem :: transmute ( PortArbitrationSelect ) } ; PortArbitrationSelect as u64 } ) ; __bindgen_bitfield_unit . set ( 20usize , 4u8 , { let RsvdP2 : u32 = unsafe { :: std :: mem :: transmute ( RsvdP2 ) } ; RsvdP2 as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 3u8 , { let VcID : u32 = unsafe { :: std :: mem :: transmute ( VcID ) } ; VcID as u64 } ) ; __bindgen_bitfield_unit . set ( 27usize , 4u8 , { let RsvdP3 : u32 = unsafe { :: std :: mem :: transmute ( RsvdP3 ) } ; RsvdP3 as u64 } ) ; __bindgen_bitfield_unit . set ( 31usize , 1u8 , { let VcEnable : u32 = unsafe { :: std :: mem :: transmute ( VcEnable ) } ; VcEnable as u64 } ) ; __bindgen_bitfield_unit } } pub type VIRTUAL_RESOURCE_CONTROL = _VIRTUAL_RESOURCE_CONTROL ; pub type PVIRTUAL_RESOURCE_CONTROL = * mut _VIRTUAL_RESOURCE_CONTROL ; # [ repr ( C ) ] pub struct _VIRTUAL_RESOURCE_STATUS { pub __bindgen_anon_1 : __BindgenUnionField < _VIRTUAL_RESOURCE_STATUS__bindgen_ty_1 > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : u16 , } # [ repr ( C ) ] pub struct _VIRTUAL_RESOURCE_STATUS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl _VIRTUAL_RESOURCE_STATUS__bindgen_ty_1 { # [ inline ] pub fn PortArbitrationTableStatus ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_PortArbitrationTableStatus ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn VcNegotiationPending ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_VcNegotiationPending ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn RsvdZ ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 14u8 ) as u16 ) } } # [ inline ] pub fn set_RsvdZ ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 14u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( PortArbitrationTableStatus : USHORT , VcNegotiationPending : USHORT , RsvdZ : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let PortArbitrationTableStatus : u16 = unsafe { :: std :: mem :: transmute ( PortArbitrationTableStatus ) } ; PortArbitrationTableStatus as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let VcNegotiationPending : u16 = unsafe { :: std :: mem :: transmute ( VcNegotiationPending ) } ; VcNegotiationPending as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 14u8 , { let RsvdZ : u16 = unsafe { :: std :: mem :: transmute ( RsvdZ ) } ; RsvdZ as u64 } ) ; __bindgen_bitfield_unit } } pub type VIRTUAL_RESOURCE_STATUS = _VIRTUAL_RESOURCE_STATUS ; pub type PVIRTUAL_RESOURCE_STATUS = * mut _VIRTUAL_RESOURCE_STATUS ; # [ repr ( C ) ] pub struct _VIRTUAL_RESOURCE { pub Capability : VIRTUAL_RESOURCE_CAPABILITY , pub Control : VIRTUAL_RESOURCE_CONTROL , pub RsvdP : USHORT , pub Status : VIRTUAL_RESOURCE_STATUS , } pub type VIRTUAL_RESOURCE = _VIRTUAL_RESOURCE ; pub type PVIRTUAL_RESOURCE = * mut _VIRTUAL_RESOURCE ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_VIRTUAL_CHANNEL_CAPABILITY { pub Header : PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER , pub Capabilities1 : VIRTUAL_CHANNEL_CAPABILITIES1 , pub Capabilities2 : VIRTUAL_CHANNEL_CAPABILITIES2 , pub Control : VIRTUAL_CHANNEL_CONTROL , pub Status : VIRTUAL_CHANNEL_STATUS , pub Resource : [ VIRTUAL_RESOURCE ; 8usize ] , } pub type PCI_EXPRESS_VIRTUAL_CHANNEL_CAPABILITY = _PCI_EXPRESS_VIRTUAL_CHANNEL_CAPABILITY ; pub type PPCI_EXPRESS_VIRTUAL_CHANNEL_CAPABILITY = * mut _PCI_EXPRESS_VIRTUAL_CHANNEL_CAPABILITY ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_ATS_CAPABILITY_REGISTER { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl _PCI_EXPRESS_ATS_CAPABILITY_REGISTER { # [ inline ] pub fn InvalidateQueueDepth ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 5u8 ) as u16 ) } } # [ inline ] pub fn set_InvalidateQueueDepth ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 5u8 , val as u64 ) } } # [ inline ] pub fn PageAlignedRequest ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_PageAlignedRequest ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn GlobalInvalidateSupported ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_GlobalInvalidateSupported ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 9u8 ) as u16 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 9u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( InvalidateQueueDepth : USHORT , PageAlignedRequest : USHORT , GlobalInvalidateSupported : USHORT , Reserved : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 5u8 , { let InvalidateQueueDepth : u16 = unsafe { :: std :: mem :: transmute ( InvalidateQueueDepth ) } ; InvalidateQueueDepth as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let PageAlignedRequest : u16 = unsafe { :: std :: mem :: transmute ( PageAlignedRequest ) } ; PageAlignedRequest as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let GlobalInvalidateSupported : u16 = unsafe { :: std :: mem :: transmute ( GlobalInvalidateSupported ) } ; GlobalInvalidateSupported as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 9u8 , { let Reserved : u16 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_ATS_CAPABILITY_REGISTER = _PCI_EXPRESS_ATS_CAPABILITY_REGISTER ; pub type PPCI_EXPRESS_ATS_CAPABILITY_REGISTER = * mut _PCI_EXPRESS_ATS_CAPABILITY_REGISTER ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_ATS_CONTROL_REGISTER { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl _PCI_EXPRESS_ATS_CONTROL_REGISTER { # [ inline ] pub fn SmallestTransactionUnit ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 5u8 ) as u16 ) } } # [ inline ] pub fn set_SmallestTransactionUnit ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 5u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 10u8 ) as u16 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 10u8 , val as u64 ) } } # [ inline ] pub fn Enable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 15usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_Enable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 15usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( SmallestTransactionUnit : USHORT , Reserved : USHORT , Enable : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 5u8 , { let SmallestTransactionUnit : u16 = unsafe { :: std :: mem :: transmute ( SmallestTransactionUnit ) } ; SmallestTransactionUnit as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 10u8 , { let Reserved : u16 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit . set ( 15usize , 1u8 , { let Enable : u16 = unsafe { :: std :: mem :: transmute ( Enable ) } ; Enable as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_ATS_CONTROL_REGISTER = _PCI_EXPRESS_ATS_CONTROL_REGISTER ; pub type PPCI_EXPRESS_ATS_CONTROL_REGISTER = * mut _PCI_EXPRESS_ATS_CONTROL_REGISTER ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_ATS_CAPABILITY { pub Header : PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER , pub Capability : PCI_EXPRESS_ATS_CAPABILITY_REGISTER , pub Control : PCI_EXPRESS_ATS_CONTROL_REGISTER , } pub type PCI_EXPRESS_ATS_CAPABILITY = _PCI_EXPRESS_ATS_CAPABILITY ; pub type PPCI_EXPRESS_ATS_CAPABILITY = * mut _PCI_EXPRESS_ATS_CAPABILITY ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_PASID_CAPABILITY_REGISTER { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_PASID_CAPABILITY_REGISTER__bindgen_ty_1 > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : u16 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_PASID_CAPABILITY_REGISTER__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl _PCI_EXPRESS_PASID_CAPABILITY_REGISTER__bindgen_ty_1 { # [ inline ] pub fn Rsvd ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_Rsvd ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ExecutePermissionSupported ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_ExecutePermissionSupported ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PrivilegedModeSupported ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_PrivilegedModeSupported ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Rsvd2 ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 5u8 ) as u16 ) } } # [ inline ] pub fn set_Rsvd2 ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 5u8 , val as u64 ) } } # [ inline ] pub fn MaxPASIDWidth ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 5u8 ) as u16 ) } } # [ inline ] pub fn set_MaxPASIDWidth ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 5u8 , val as u64 ) } } # [ inline ] pub fn Rsvd3 ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 13usize , 3u8 ) as u16 ) } } # [ inline ] pub fn set_Rsvd3 ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 13usize , 3u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Rsvd : USHORT , ExecutePermissionSupported : USHORT , PrivilegedModeSupported : USHORT , Rsvd2 : USHORT , MaxPASIDWidth : USHORT , Rsvd3 : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let Rsvd : u16 = unsafe { :: std :: mem :: transmute ( Rsvd ) } ; Rsvd as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let ExecutePermissionSupported : u16 = unsafe { :: std :: mem :: transmute ( ExecutePermissionSupported ) } ; ExecutePermissionSupported as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let PrivilegedModeSupported : u16 = unsafe { :: std :: mem :: transmute ( PrivilegedModeSupported ) } ; PrivilegedModeSupported as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 5u8 , { let Rsvd2 : u16 = unsafe { :: std :: mem :: transmute ( Rsvd2 ) } ; Rsvd2 as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 5u8 , { let MaxPASIDWidth : u16 = unsafe { :: std :: mem :: transmute ( MaxPASIDWidth ) } ; MaxPASIDWidth as u64 } ) ; __bindgen_bitfield_unit . set ( 13usize , 3u8 , { let Rsvd3 : u16 = unsafe { :: std :: mem :: transmute ( Rsvd3 ) } ; Rsvd3 as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_PASID_CAPABILITY_REGISTER = _PCI_EXPRESS_PASID_CAPABILITY_REGISTER ; pub type PPCI_EXPRESS_PASID_CAPABILITY_REGISTER = * mut _PCI_EXPRESS_PASID_CAPABILITY_REGISTER ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_PASID_CONTROL_REGISTER { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_PASID_CONTROL_REGISTER__bindgen_ty_1 > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : u16 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_PASID_CONTROL_REGISTER__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl _PCI_EXPRESS_PASID_CONTROL_REGISTER__bindgen_ty_1 { # [ inline ] pub fn PASIDEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_PASIDEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ExecutePermissionEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_ExecutePermissionEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PrivilegedModeEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_PrivilegedModeEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Rsvd ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 13u8 ) as u16 ) } } # [ inline ] pub fn set_Rsvd ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 13u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( PASIDEnable : USHORT , ExecutePermissionEnable : USHORT , PrivilegedModeEnable : USHORT , Rsvd : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let PASIDEnable : u16 = unsafe { :: std :: mem :: transmute ( PASIDEnable ) } ; PASIDEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let ExecutePermissionEnable : u16 = unsafe { :: std :: mem :: transmute ( ExecutePermissionEnable ) } ; ExecutePermissionEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let PrivilegedModeEnable : u16 = unsafe { :: std :: mem :: transmute ( PrivilegedModeEnable ) } ; PrivilegedModeEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 13u8 , { let Rsvd : u16 = unsafe { :: std :: mem :: transmute ( Rsvd ) } ; Rsvd as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_PASID_CONTROL_REGISTER = _PCI_EXPRESS_PASID_CONTROL_REGISTER ; pub type PPCI_EXPRESS_PASID_CONTROL_REGISTER = * mut _PCI_EXPRESS_PASID_CONTROL_REGISTER ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_PASID_CAPABILITY { pub Header : PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER , pub Capability : PCI_EXPRESS_PASID_CAPABILITY_REGISTER , pub Control : PCI_EXPRESS_PASID_CONTROL_REGISTER , } pub type PCI_EXPRESS_PASID_CAPABILITY = _PCI_EXPRESS_PASID_CAPABILITY ; pub type PPCI_EXPRESS_PASID_CAPABILITY = * mut _PCI_EXPRESS_PASID_CAPABILITY ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_PRI_STATUS_REGISTER { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_PRI_STATUS_REGISTER__bindgen_ty_1 > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : u16 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_PRI_STATUS_REGISTER__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl _PCI_EXPRESS_PRI_STATUS_REGISTER__bindgen_ty_1 { # [ inline ] pub fn ResponseFailure ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_ResponseFailure ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UnexpectedPageRequestGroupIndex ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_UnexpectedPageRequestGroupIndex ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Rsvd ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 6u8 ) as u16 ) } } # [ inline ] pub fn set_Rsvd ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 6u8 , val as u64 ) } } # [ inline ] pub fn Stopped ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_Stopped ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Rsvd2 ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 6u8 ) as u16 ) } } # [ inline ] pub fn set_Rsvd2 ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 6u8 , val as u64 ) } } # [ inline ] pub fn PrgResponsePasidRequired ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 15usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_PrgResponsePasidRequired ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 15usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ResponseFailure : USHORT , UnexpectedPageRequestGroupIndex : USHORT , Rsvd : USHORT , Stopped : USHORT , Rsvd2 : USHORT , PrgResponsePasidRequired : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let ResponseFailure : u16 = unsafe { :: std :: mem :: transmute ( ResponseFailure ) } ; ResponseFailure as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let UnexpectedPageRequestGroupIndex : u16 = unsafe { :: std :: mem :: transmute ( UnexpectedPageRequestGroupIndex ) } ; UnexpectedPageRequestGroupIndex as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 6u8 , { let Rsvd : u16 = unsafe { :: std :: mem :: transmute ( Rsvd ) } ; Rsvd as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let Stopped : u16 = unsafe { :: std :: mem :: transmute ( Stopped ) } ; Stopped as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 6u8 , { let Rsvd2 : u16 = unsafe { :: std :: mem :: transmute ( Rsvd2 ) } ; Rsvd2 as u64 } ) ; __bindgen_bitfield_unit . set ( 15usize , 1u8 , { let PrgResponsePasidRequired : u16 = unsafe { :: std :: mem :: transmute ( PrgResponsePasidRequired ) } ; PrgResponsePasidRequired as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_PRI_STATUS_REGISTER = _PCI_EXPRESS_PRI_STATUS_REGISTER ; pub type PPCI_EXPRESS_PRI_STATUS_REGISTER = * mut _PCI_EXPRESS_PRI_STATUS_REGISTER ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_PRI_CONTROL_REGISTER { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_PRI_CONTROL_REGISTER__bindgen_ty_1 > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : u16 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_PRI_CONTROL_REGISTER__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl _PCI_EXPRESS_PRI_CONTROL_REGISTER__bindgen_ty_1 { # [ inline ] pub fn Enable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_Enable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reset ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_Reset ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Rsvd ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 14u8 ) as u16 ) } } # [ inline ] pub fn set_Rsvd ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 14u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Enable : USHORT , Reset : USHORT , Rsvd : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let Enable : u16 = unsafe { :: std :: mem :: transmute ( Enable ) } ; Enable as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let Reset : u16 = unsafe { :: std :: mem :: transmute ( Reset ) } ; Reset as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 14u8 , { let Rsvd : u16 = unsafe { :: std :: mem :: transmute ( Rsvd ) } ; Rsvd as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_PRI_CONTROL_REGISTER = _PCI_EXPRESS_PRI_CONTROL_REGISTER ; pub type PPCI_EXPRESS_PRI_CONTROL_REGISTER = * mut _PCI_EXPRESS_PRI_CONTROL_REGISTER ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_PRI_CAPABILITY { pub Header : PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER , pub Control : PCI_EXPRESS_PRI_CONTROL_REGISTER , pub Status : PCI_EXPRESS_PRI_STATUS_REGISTER , pub PRCapacity : ULONG , pub PRAllocation : ULONG , } pub type PCI_EXPRESS_PRI_CAPABILITY = _PCI_EXPRESS_PRI_CAPABILITY ; pub type PPCI_EXPRESS_PRI_CAPABILITY = * mut _PCI_EXPRESS_PRI_CAPABILITY ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS__bindgen_ty_1 { # [ inline ] pub fn Undefined ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Undefined ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved1 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved1 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 3u8 , val as u64 ) } } # [ inline ] pub fn DataLinkProtocolError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_DataLinkProtocolError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn SurpriseDownError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_SurpriseDownError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved2 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 6u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved2 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 6u8 , val as u64 ) } } # [ inline ] pub fn PoisonedTLP ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_PoisonedTLP ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 1u8 , val as u64 ) } } # [ inline ] pub fn FlowControlProtocolError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 13usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_FlowControlProtocolError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 13usize , 1u8 , val as u64 ) } } # [ inline ] pub fn CompletionTimeout ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_CompletionTimeout ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 1u8 , val as u64 ) } } # [ inline ] pub fn CompleterAbort ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 15usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_CompleterAbort ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 15usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UnexpectedCompletion ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_UnexpectedCompletion ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ReceiverOverflow ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 17usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ReceiverOverflow ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 17usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MalformedTLP ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 18usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_MalformedTLP ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 18usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ECRCError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 19usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ECRCError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 19usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UnsupportedRequestError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 20usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_UnsupportedRequestError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 20usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AcsViolation ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 21usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AcsViolation ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 21usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UncorrectableInternalError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 22usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_UncorrectableInternalError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 22usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MCBlockedTlp ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 23usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_MCBlockedTlp ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 23usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AtomicOpEgressBlocked ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AtomicOpEgressBlocked ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 1u8 , val as u64 ) } } # [ inline ] pub fn TlpPrefixBlocked ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 25usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_TlpPrefixBlocked ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 25usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved3 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 26usize , 6u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved3 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 26usize , 6u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Undefined : ULONG , Reserved1 : ULONG , DataLinkProtocolError : ULONG , SurpriseDownError : ULONG , Reserved2 : ULONG , PoisonedTLP : ULONG , FlowControlProtocolError : ULONG , CompletionTimeout : ULONG , CompleterAbort : ULONG , UnexpectedCompletion : ULONG , ReceiverOverflow : ULONG , MalformedTLP : ULONG , ECRCError : ULONG , UnsupportedRequestError : ULONG , AcsViolation : ULONG , UncorrectableInternalError : ULONG , MCBlockedTlp : ULONG , AtomicOpEgressBlocked : ULONG , TlpPrefixBlocked : ULONG , Reserved3 : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let Undefined : u32 = unsafe { :: std :: mem :: transmute ( Undefined ) } ; Undefined as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 3u8 , { let Reserved1 : u32 = unsafe { :: std :: mem :: transmute ( Reserved1 ) } ; Reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let DataLinkProtocolError : u32 = unsafe { :: std :: mem :: transmute ( DataLinkProtocolError ) } ; DataLinkProtocolError as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let SurpriseDownError : u32 = unsafe { :: std :: mem :: transmute ( SurpriseDownError ) } ; SurpriseDownError as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 6u8 , { let Reserved2 : u32 = unsafe { :: std :: mem :: transmute ( Reserved2 ) } ; Reserved2 as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 1u8 , { let PoisonedTLP : u32 = unsafe { :: std :: mem :: transmute ( PoisonedTLP ) } ; PoisonedTLP as u64 } ) ; __bindgen_bitfield_unit . set ( 13usize , 1u8 , { let FlowControlProtocolError : u32 = unsafe { :: std :: mem :: transmute ( FlowControlProtocolError ) } ; FlowControlProtocolError as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 1u8 , { let CompletionTimeout : u32 = unsafe { :: std :: mem :: transmute ( CompletionTimeout ) } ; CompletionTimeout as u64 } ) ; __bindgen_bitfield_unit . set ( 15usize , 1u8 , { let CompleterAbort : u32 = unsafe { :: std :: mem :: transmute ( CompleterAbort ) } ; CompleterAbort as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 1u8 , { let UnexpectedCompletion : u32 = unsafe { :: std :: mem :: transmute ( UnexpectedCompletion ) } ; UnexpectedCompletion as u64 } ) ; __bindgen_bitfield_unit . set ( 17usize , 1u8 , { let ReceiverOverflow : u32 = unsafe { :: std :: mem :: transmute ( ReceiverOverflow ) } ; ReceiverOverflow as u64 } ) ; __bindgen_bitfield_unit . set ( 18usize , 1u8 , { let MalformedTLP : u32 = unsafe { :: std :: mem :: transmute ( MalformedTLP ) } ; MalformedTLP as u64 } ) ; __bindgen_bitfield_unit . set ( 19usize , 1u8 , { let ECRCError : u32 = unsafe { :: std :: mem :: transmute ( ECRCError ) } ; ECRCError as u64 } ) ; __bindgen_bitfield_unit . set ( 20usize , 1u8 , { let UnsupportedRequestError : u32 = unsafe { :: std :: mem :: transmute ( UnsupportedRequestError ) } ; UnsupportedRequestError as u64 } ) ; __bindgen_bitfield_unit . set ( 21usize , 1u8 , { let AcsViolation : u32 = unsafe { :: std :: mem :: transmute ( AcsViolation ) } ; AcsViolation as u64 } ) ; __bindgen_bitfield_unit . set ( 22usize , 1u8 , { let UncorrectableInternalError : u32 = unsafe { :: std :: mem :: transmute ( UncorrectableInternalError ) } ; UncorrectableInternalError as u64 } ) ; __bindgen_bitfield_unit . set ( 23usize , 1u8 , { let MCBlockedTlp : u32 = unsafe { :: std :: mem :: transmute ( MCBlockedTlp ) } ; MCBlockedTlp as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 1u8 , { let AtomicOpEgressBlocked : u32 = unsafe { :: std :: mem :: transmute ( AtomicOpEgressBlocked ) } ; AtomicOpEgressBlocked as u64 } ) ; __bindgen_bitfield_unit . set ( 25usize , 1u8 , { let TlpPrefixBlocked : u32 = unsafe { :: std :: mem :: transmute ( TlpPrefixBlocked ) } ; TlpPrefixBlocked as u64 } ) ; __bindgen_bitfield_unit . set ( 26usize , 6u8 , { let Reserved3 : u32 = unsafe { :: std :: mem :: transmute ( Reserved3 ) } ; Reserved3 as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS = _PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS ; pub type PPCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS = * mut _PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK__bindgen_ty_1 { # [ inline ] pub fn Undefined ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Undefined ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved1 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved1 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 3u8 , val as u64 ) } } # [ inline ] pub fn DataLinkProtocolError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_DataLinkProtocolError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn SurpriseDownError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_SurpriseDownError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved2 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 6u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved2 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 6u8 , val as u64 ) } } # [ inline ] pub fn PoisonedTLP ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_PoisonedTLP ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 1u8 , val as u64 ) } } # [ inline ] pub fn FlowControlProtocolError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 13usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_FlowControlProtocolError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 13usize , 1u8 , val as u64 ) } } # [ inline ] pub fn CompletionTimeout ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_CompletionTimeout ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 1u8 , val as u64 ) } } # [ inline ] pub fn CompleterAbort ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 15usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_CompleterAbort ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 15usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UnexpectedCompletion ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_UnexpectedCompletion ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ReceiverOverflow ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 17usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ReceiverOverflow ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 17usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MalformedTLP ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 18usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_MalformedTLP ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 18usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ECRCError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 19usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ECRCError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 19usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UnsupportedRequestError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 20usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_UnsupportedRequestError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 20usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AcsViolation ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 21usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AcsViolation ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 21usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UncorrectableInternalError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 22usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_UncorrectableInternalError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 22usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MCBlockedTlp ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 23usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_MCBlockedTlp ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 23usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AtomicOpEgressBlocked ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AtomicOpEgressBlocked ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 1u8 , val as u64 ) } } # [ inline ] pub fn TlpPrefixBlocked ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 25usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_TlpPrefixBlocked ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 25usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved3 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 26usize , 6u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved3 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 26usize , 6u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Undefined : ULONG , Reserved1 : ULONG , DataLinkProtocolError : ULONG , SurpriseDownError : ULONG , Reserved2 : ULONG , PoisonedTLP : ULONG , FlowControlProtocolError : ULONG , CompletionTimeout : ULONG , CompleterAbort : ULONG , UnexpectedCompletion : ULONG , ReceiverOverflow : ULONG , MalformedTLP : ULONG , ECRCError : ULONG , UnsupportedRequestError : ULONG , AcsViolation : ULONG , UncorrectableInternalError : ULONG , MCBlockedTlp : ULONG , AtomicOpEgressBlocked : ULONG , TlpPrefixBlocked : ULONG , Reserved3 : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let Undefined : u32 = unsafe { :: std :: mem :: transmute ( Undefined ) } ; Undefined as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 3u8 , { let Reserved1 : u32 = unsafe { :: std :: mem :: transmute ( Reserved1 ) } ; Reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let DataLinkProtocolError : u32 = unsafe { :: std :: mem :: transmute ( DataLinkProtocolError ) } ; DataLinkProtocolError as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let SurpriseDownError : u32 = unsafe { :: std :: mem :: transmute ( SurpriseDownError ) } ; SurpriseDownError as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 6u8 , { let Reserved2 : u32 = unsafe { :: std :: mem :: transmute ( Reserved2 ) } ; Reserved2 as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 1u8 , { let PoisonedTLP : u32 = unsafe { :: std :: mem :: transmute ( PoisonedTLP ) } ; PoisonedTLP as u64 } ) ; __bindgen_bitfield_unit . set ( 13usize , 1u8 , { let FlowControlProtocolError : u32 = unsafe { :: std :: mem :: transmute ( FlowControlProtocolError ) } ; FlowControlProtocolError as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 1u8 , { let CompletionTimeout : u32 = unsafe { :: std :: mem :: transmute ( CompletionTimeout ) } ; CompletionTimeout as u64 } ) ; __bindgen_bitfield_unit . set ( 15usize , 1u8 , { let CompleterAbort : u32 = unsafe { :: std :: mem :: transmute ( CompleterAbort ) } ; CompleterAbort as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 1u8 , { let UnexpectedCompletion : u32 = unsafe { :: std :: mem :: transmute ( UnexpectedCompletion ) } ; UnexpectedCompletion as u64 } ) ; __bindgen_bitfield_unit . set ( 17usize , 1u8 , { let ReceiverOverflow : u32 = unsafe { :: std :: mem :: transmute ( ReceiverOverflow ) } ; ReceiverOverflow as u64 } ) ; __bindgen_bitfield_unit . set ( 18usize , 1u8 , { let MalformedTLP : u32 = unsafe { :: std :: mem :: transmute ( MalformedTLP ) } ; MalformedTLP as u64 } ) ; __bindgen_bitfield_unit . set ( 19usize , 1u8 , { let ECRCError : u32 = unsafe { :: std :: mem :: transmute ( ECRCError ) } ; ECRCError as u64 } ) ; __bindgen_bitfield_unit . set ( 20usize , 1u8 , { let UnsupportedRequestError : u32 = unsafe { :: std :: mem :: transmute ( UnsupportedRequestError ) } ; UnsupportedRequestError as u64 } ) ; __bindgen_bitfield_unit . set ( 21usize , 1u8 , { let AcsViolation : u32 = unsafe { :: std :: mem :: transmute ( AcsViolation ) } ; AcsViolation as u64 } ) ; __bindgen_bitfield_unit . set ( 22usize , 1u8 , { let UncorrectableInternalError : u32 = unsafe { :: std :: mem :: transmute ( UncorrectableInternalError ) } ; UncorrectableInternalError as u64 } ) ; __bindgen_bitfield_unit . set ( 23usize , 1u8 , { let MCBlockedTlp : u32 = unsafe { :: std :: mem :: transmute ( MCBlockedTlp ) } ; MCBlockedTlp as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 1u8 , { let AtomicOpEgressBlocked : u32 = unsafe { :: std :: mem :: transmute ( AtomicOpEgressBlocked ) } ; AtomicOpEgressBlocked as u64 } ) ; __bindgen_bitfield_unit . set ( 25usize , 1u8 , { let TlpPrefixBlocked : u32 = unsafe { :: std :: mem :: transmute ( TlpPrefixBlocked ) } ; TlpPrefixBlocked as u64 } ) ; __bindgen_bitfield_unit . set ( 26usize , 6u8 , { let Reserved3 : u32 = unsafe { :: std :: mem :: transmute ( Reserved3 ) } ; Reserved3 as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK = _PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK ; pub type PPCI_EXPRESS_UNCORRECTABLE_ERROR_MASK = * mut _PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY__bindgen_ty_1 { # [ inline ] pub fn Undefined ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Undefined ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved1 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved1 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 3u8 , val as u64 ) } } # [ inline ] pub fn DataLinkProtocolError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_DataLinkProtocolError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn SurpriseDownError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_SurpriseDownError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved2 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 6u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved2 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 6u8 , val as u64 ) } } # [ inline ] pub fn PoisonedTLP ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_PoisonedTLP ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 1u8 , val as u64 ) } } # [ inline ] pub fn FlowControlProtocolError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 13usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_FlowControlProtocolError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 13usize , 1u8 , val as u64 ) } } # [ inline ] pub fn CompletionTimeout ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_CompletionTimeout ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 1u8 , val as u64 ) } } # [ inline ] pub fn CompleterAbort ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 15usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_CompleterAbort ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 15usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UnexpectedCompletion ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_UnexpectedCompletion ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ReceiverOverflow ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 17usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ReceiverOverflow ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 17usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MalformedTLP ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 18usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_MalformedTLP ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 18usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ECRCError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 19usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ECRCError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 19usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UnsupportedRequestError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 20usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_UnsupportedRequestError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 20usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AcsViolation ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 21usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AcsViolation ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 21usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UncorrectableInternalError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 22usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_UncorrectableInternalError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 22usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MCBlockedTlp ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 23usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_MCBlockedTlp ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 23usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AtomicOpEgressBlocked ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AtomicOpEgressBlocked ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 1u8 , val as u64 ) } } # [ inline ] pub fn TlpPrefixBlocked ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 25usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_TlpPrefixBlocked ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 25usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved3 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 26usize , 6u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved3 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 26usize , 6u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Undefined : ULONG , Reserved1 : ULONG , DataLinkProtocolError : ULONG , SurpriseDownError : ULONG , Reserved2 : ULONG , PoisonedTLP : ULONG , FlowControlProtocolError : ULONG , CompletionTimeout : ULONG , CompleterAbort : ULONG , UnexpectedCompletion : ULONG , ReceiverOverflow : ULONG , MalformedTLP : ULONG , ECRCError : ULONG , UnsupportedRequestError : ULONG , AcsViolation : ULONG , UncorrectableInternalError : ULONG , MCBlockedTlp : ULONG , AtomicOpEgressBlocked : ULONG , TlpPrefixBlocked : ULONG , Reserved3 : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let Undefined : u32 = unsafe { :: std :: mem :: transmute ( Undefined ) } ; Undefined as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 3u8 , { let Reserved1 : u32 = unsafe { :: std :: mem :: transmute ( Reserved1 ) } ; Reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let DataLinkProtocolError : u32 = unsafe { :: std :: mem :: transmute ( DataLinkProtocolError ) } ; DataLinkProtocolError as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let SurpriseDownError : u32 = unsafe { :: std :: mem :: transmute ( SurpriseDownError ) } ; SurpriseDownError as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 6u8 , { let Reserved2 : u32 = unsafe { :: std :: mem :: transmute ( Reserved2 ) } ; Reserved2 as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 1u8 , { let PoisonedTLP : u32 = unsafe { :: std :: mem :: transmute ( PoisonedTLP ) } ; PoisonedTLP as u64 } ) ; __bindgen_bitfield_unit . set ( 13usize , 1u8 , { let FlowControlProtocolError : u32 = unsafe { :: std :: mem :: transmute ( FlowControlProtocolError ) } ; FlowControlProtocolError as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 1u8 , { let CompletionTimeout : u32 = unsafe { :: std :: mem :: transmute ( CompletionTimeout ) } ; CompletionTimeout as u64 } ) ; __bindgen_bitfield_unit . set ( 15usize , 1u8 , { let CompleterAbort : u32 = unsafe { :: std :: mem :: transmute ( CompleterAbort ) } ; CompleterAbort as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 1u8 , { let UnexpectedCompletion : u32 = unsafe { :: std :: mem :: transmute ( UnexpectedCompletion ) } ; UnexpectedCompletion as u64 } ) ; __bindgen_bitfield_unit . set ( 17usize , 1u8 , { let ReceiverOverflow : u32 = unsafe { :: std :: mem :: transmute ( ReceiverOverflow ) } ; ReceiverOverflow as u64 } ) ; __bindgen_bitfield_unit . set ( 18usize , 1u8 , { let MalformedTLP : u32 = unsafe { :: std :: mem :: transmute ( MalformedTLP ) } ; MalformedTLP as u64 } ) ; __bindgen_bitfield_unit . set ( 19usize , 1u8 , { let ECRCError : u32 = unsafe { :: std :: mem :: transmute ( ECRCError ) } ; ECRCError as u64 } ) ; __bindgen_bitfield_unit . set ( 20usize , 1u8 , { let UnsupportedRequestError : u32 = unsafe { :: std :: mem :: transmute ( UnsupportedRequestError ) } ; UnsupportedRequestError as u64 } ) ; __bindgen_bitfield_unit . set ( 21usize , 1u8 , { let AcsViolation : u32 = unsafe { :: std :: mem :: transmute ( AcsViolation ) } ; AcsViolation as u64 } ) ; __bindgen_bitfield_unit . set ( 22usize , 1u8 , { let UncorrectableInternalError : u32 = unsafe { :: std :: mem :: transmute ( UncorrectableInternalError ) } ; UncorrectableInternalError as u64 } ) ; __bindgen_bitfield_unit . set ( 23usize , 1u8 , { let MCBlockedTlp : u32 = unsafe { :: std :: mem :: transmute ( MCBlockedTlp ) } ; MCBlockedTlp as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 1u8 , { let AtomicOpEgressBlocked : u32 = unsafe { :: std :: mem :: transmute ( AtomicOpEgressBlocked ) } ; AtomicOpEgressBlocked as u64 } ) ; __bindgen_bitfield_unit . set ( 25usize , 1u8 , { let TlpPrefixBlocked : u32 = unsafe { :: std :: mem :: transmute ( TlpPrefixBlocked ) } ; TlpPrefixBlocked as u64 } ) ; __bindgen_bitfield_unit . set ( 26usize , 6u8 , { let Reserved3 : u32 = unsafe { :: std :: mem :: transmute ( Reserved3 ) } ; Reserved3 as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY = _PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY ; pub type PPCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY = * mut _PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_CORRECTABLE_ERROR_STATUS { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_CORRECTABLE_ERROR_STATUS__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_CORRECTABLE_ERROR_STATUS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PCI_EXPRESS_CORRECTABLE_ERROR_STATUS__bindgen_ty_1 { # [ inline ] pub fn ReceiverError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ReceiverError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved1 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved1 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 5u8 , val as u64 ) } } # [ inline ] pub fn BadTLP ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_BadTLP ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn BadDLLP ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_BadDLLP ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ReplayNumRollover ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ReplayNumRollover ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved2 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved2 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 3u8 , val as u64 ) } } # [ inline ] pub fn ReplayTimerTimeout ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ReplayTimerTimeout ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AdvisoryNonFatalError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 13usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AdvisoryNonFatalError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 13usize , 1u8 , val as u64 ) } } # [ inline ] pub fn CorrectedInternalError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_CorrectedInternalError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 1u8 , val as u64 ) } } # [ inline ] pub fn HeaderLogOverflow ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 15usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_HeaderLogOverflow ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 15usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved3 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved3 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 16u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ReceiverError : ULONG , Reserved1 : ULONG , BadTLP : ULONG , BadDLLP : ULONG , ReplayNumRollover : ULONG , Reserved2 : ULONG , ReplayTimerTimeout : ULONG , AdvisoryNonFatalError : ULONG , CorrectedInternalError : ULONG , HeaderLogOverflow : ULONG , Reserved3 : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let ReceiverError : u32 = unsafe { :: std :: mem :: transmute ( ReceiverError ) } ; ReceiverError as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 5u8 , { let Reserved1 : u32 = unsafe { :: std :: mem :: transmute ( Reserved1 ) } ; Reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let BadTLP : u32 = unsafe { :: std :: mem :: transmute ( BadTLP ) } ; BadTLP as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let BadDLLP : u32 = unsafe { :: std :: mem :: transmute ( BadDLLP ) } ; BadDLLP as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let ReplayNumRollover : u32 = unsafe { :: std :: mem :: transmute ( ReplayNumRollover ) } ; ReplayNumRollover as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 3u8 , { let Reserved2 : u32 = unsafe { :: std :: mem :: transmute ( Reserved2 ) } ; Reserved2 as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 1u8 , { let ReplayTimerTimeout : u32 = unsafe { :: std :: mem :: transmute ( ReplayTimerTimeout ) } ; ReplayTimerTimeout as u64 } ) ; __bindgen_bitfield_unit . set ( 13usize , 1u8 , { let AdvisoryNonFatalError : u32 = unsafe { :: std :: mem :: transmute ( AdvisoryNonFatalError ) } ; AdvisoryNonFatalError as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 1u8 , { let CorrectedInternalError : u32 = unsafe { :: std :: mem :: transmute ( CorrectedInternalError ) } ; CorrectedInternalError as u64 } ) ; __bindgen_bitfield_unit . set ( 15usize , 1u8 , { let HeaderLogOverflow : u32 = unsafe { :: std :: mem :: transmute ( HeaderLogOverflow ) } ; HeaderLogOverflow as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 16u8 , { let Reserved3 : u32 = unsafe { :: std :: mem :: transmute ( Reserved3 ) } ; Reserved3 as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_CORRECTABLE_ERROR_STATUS = _PCI_EXPRESS_CORRECTABLE_ERROR_STATUS ; pub type PPCI_CORRECTABLE_ERROR_STATUS = * mut _PCI_EXPRESS_CORRECTABLE_ERROR_STATUS ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_CORRECTABLE_ERROR_MASK { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_CORRECTABLE_ERROR_MASK__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_CORRECTABLE_ERROR_MASK__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PCI_EXPRESS_CORRECTABLE_ERROR_MASK__bindgen_ty_1 { # [ inline ] pub fn ReceiverError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ReceiverError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved1 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved1 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 5u8 , val as u64 ) } } # [ inline ] pub fn BadTLP ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_BadTLP ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn BadDLLP ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_BadDLLP ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ReplayNumRollover ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ReplayNumRollover ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved2 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved2 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 3u8 , val as u64 ) } } # [ inline ] pub fn ReplayTimerTimeout ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ReplayTimerTimeout ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AdvisoryNonFatalError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 13usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AdvisoryNonFatalError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 13usize , 1u8 , val as u64 ) } } # [ inline ] pub fn CorrectedInternalError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_CorrectedInternalError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 1u8 , val as u64 ) } } # [ inline ] pub fn HeaderLogOverflow ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 15usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_HeaderLogOverflow ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 15usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved3 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved3 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 16u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ReceiverError : ULONG , Reserved1 : ULONG , BadTLP : ULONG , BadDLLP : ULONG , ReplayNumRollover : ULONG , Reserved2 : ULONG , ReplayTimerTimeout : ULONG , AdvisoryNonFatalError : ULONG , CorrectedInternalError : ULONG , HeaderLogOverflow : ULONG , Reserved3 : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let ReceiverError : u32 = unsafe { :: std :: mem :: transmute ( ReceiverError ) } ; ReceiverError as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 5u8 , { let Reserved1 : u32 = unsafe { :: std :: mem :: transmute ( Reserved1 ) } ; Reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let BadTLP : u32 = unsafe { :: std :: mem :: transmute ( BadTLP ) } ; BadTLP as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let BadDLLP : u32 = unsafe { :: std :: mem :: transmute ( BadDLLP ) } ; BadDLLP as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let ReplayNumRollover : u32 = unsafe { :: std :: mem :: transmute ( ReplayNumRollover ) } ; ReplayNumRollover as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 3u8 , { let Reserved2 : u32 = unsafe { :: std :: mem :: transmute ( Reserved2 ) } ; Reserved2 as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 1u8 , { let ReplayTimerTimeout : u32 = unsafe { :: std :: mem :: transmute ( ReplayTimerTimeout ) } ; ReplayTimerTimeout as u64 } ) ; __bindgen_bitfield_unit . set ( 13usize , 1u8 , { let AdvisoryNonFatalError : u32 = unsafe { :: std :: mem :: transmute ( AdvisoryNonFatalError ) } ; AdvisoryNonFatalError as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 1u8 , { let CorrectedInternalError : u32 = unsafe { :: std :: mem :: transmute ( CorrectedInternalError ) } ; CorrectedInternalError as u64 } ) ; __bindgen_bitfield_unit . set ( 15usize , 1u8 , { let HeaderLogOverflow : u32 = unsafe { :: std :: mem :: transmute ( HeaderLogOverflow ) } ; HeaderLogOverflow as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 16u8 , { let Reserved3 : u32 = unsafe { :: std :: mem :: transmute ( Reserved3 ) } ; Reserved3 as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_CORRECTABLE_ERROR_MASK = _PCI_EXPRESS_CORRECTABLE_ERROR_MASK ; pub type PPCI_CORRECTABLE_ERROR_MASK = * mut _PCI_EXPRESS_CORRECTABLE_ERROR_MASK ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_AER_CAPABILITIES { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_AER_CAPABILITIES__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_AER_CAPABILITIES__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PCI_EXPRESS_AER_CAPABILITIES__bindgen_ty_1 { # [ inline ] pub fn FirstErrorPointer ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_FirstErrorPointer ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 5u8 , val as u64 ) } } # [ inline ] pub fn ECRCGenerationCapable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ECRCGenerationCapable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ECRCGenerationEnable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ECRCGenerationEnable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ECRCCheckCapable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ECRCCheckCapable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ECRCCheckEnable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ECRCCheckEnable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MultipleHeaderRecordingCapable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_MultipleHeaderRecordingCapable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MultipleHeaderRecordingEnable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_MultipleHeaderRecordingEnable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 1u8 , val as u64 ) } } # [ inline ] pub fn TlpPrefixLogPresent ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_TlpPrefixLogPresent ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 20u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 20u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( FirstErrorPointer : ULONG , ECRCGenerationCapable : ULONG , ECRCGenerationEnable : ULONG , ECRCCheckCapable : ULONG , ECRCCheckEnable : ULONG , MultipleHeaderRecordingCapable : ULONG , MultipleHeaderRecordingEnable : ULONG , TlpPrefixLogPresent : ULONG , Reserved : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 5u8 , { let FirstErrorPointer : u32 = unsafe { :: std :: mem :: transmute ( FirstErrorPointer ) } ; FirstErrorPointer as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let ECRCGenerationCapable : u32 = unsafe { :: std :: mem :: transmute ( ECRCGenerationCapable ) } ; ECRCGenerationCapable as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let ECRCGenerationEnable : u32 = unsafe { :: std :: mem :: transmute ( ECRCGenerationEnable ) } ; ECRCGenerationEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let ECRCCheckCapable : u32 = unsafe { :: std :: mem :: transmute ( ECRCCheckCapable ) } ; ECRCCheckCapable as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let ECRCCheckEnable : u32 = unsafe { :: std :: mem :: transmute ( ECRCCheckEnable ) } ; ECRCCheckEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let MultipleHeaderRecordingCapable : u32 = unsafe { :: std :: mem :: transmute ( MultipleHeaderRecordingCapable ) } ; MultipleHeaderRecordingCapable as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 1u8 , { let MultipleHeaderRecordingEnable : u32 = unsafe { :: std :: mem :: transmute ( MultipleHeaderRecordingEnable ) } ; MultipleHeaderRecordingEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 1u8 , { let TlpPrefixLogPresent : u32 = unsafe { :: std :: mem :: transmute ( TlpPrefixLogPresent ) } ; TlpPrefixLogPresent as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 20u8 , { let Reserved : u32 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_AER_CAPABILITIES = _PCI_EXPRESS_AER_CAPABILITIES ; pub type PPCI_EXPRESS_AER_CAPABILITIES = * mut _PCI_EXPRESS_AER_CAPABILITIES ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_ROOT_ERROR_COMMAND { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_ROOT_ERROR_COMMAND__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_ROOT_ERROR_COMMAND__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PCI_EXPRESS_ROOT_ERROR_COMMAND__bindgen_ty_1 { # [ inline ] pub fn CorrectableErrorReportingEnable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_CorrectableErrorReportingEnable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn NonFatalErrorReportingEnable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_NonFatalErrorReportingEnable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn FatalErrorReportingEnable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_FatalErrorReportingEnable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 29u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 29u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( CorrectableErrorReportingEnable : ULONG , NonFatalErrorReportingEnable : ULONG , FatalErrorReportingEnable : ULONG , Reserved : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let CorrectableErrorReportingEnable : u32 = unsafe { :: std :: mem :: transmute ( CorrectableErrorReportingEnable ) } ; CorrectableErrorReportingEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let NonFatalErrorReportingEnable : u32 = unsafe { :: std :: mem :: transmute ( NonFatalErrorReportingEnable ) } ; NonFatalErrorReportingEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let FatalErrorReportingEnable : u32 = unsafe { :: std :: mem :: transmute ( FatalErrorReportingEnable ) } ; FatalErrorReportingEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 29u8 , { let Reserved : u32 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_ROOT_ERROR_COMMAND = _PCI_EXPRESS_ROOT_ERROR_COMMAND ; pub type PPCI_EXPRESS_ROOT_ERROR_COMMAND = * mut _PCI_EXPRESS_ROOT_ERROR_COMMAND ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_ROOT_ERROR_STATUS { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_ROOT_ERROR_STATUS__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_ROOT_ERROR_STATUS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PCI_EXPRESS_ROOT_ERROR_STATUS__bindgen_ty_1 { # [ inline ] pub fn CorrectableErrorReceived ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_CorrectableErrorReceived ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MultipleCorrectableErrorsReceived ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_MultipleCorrectableErrorsReceived ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UncorrectableErrorReceived ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_UncorrectableErrorReceived ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MultipleUncorrectableErrorsReceived ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_MultipleUncorrectableErrorsReceived ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn FirstUncorrectableFatal ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_FirstUncorrectableFatal ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn NonFatalErrorMessagesReceived ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_NonFatalErrorMessagesReceived ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn FatalErrorMessagesReceived ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_FatalErrorMessagesReceived ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 20u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 20u8 , val as u64 ) } } # [ inline ] pub fn AdvancedErrorInterruptMessageNumber ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 27usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_AdvancedErrorInterruptMessageNumber ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 27usize , 5u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( CorrectableErrorReceived : ULONG , MultipleCorrectableErrorsReceived : ULONG , UncorrectableErrorReceived : ULONG , MultipleUncorrectableErrorsReceived : ULONG , FirstUncorrectableFatal : ULONG , NonFatalErrorMessagesReceived : ULONG , FatalErrorMessagesReceived : ULONG , Reserved : ULONG , AdvancedErrorInterruptMessageNumber : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let CorrectableErrorReceived : u32 = unsafe { :: std :: mem :: transmute ( CorrectableErrorReceived ) } ; CorrectableErrorReceived as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let MultipleCorrectableErrorsReceived : u32 = unsafe { :: std :: mem :: transmute ( MultipleCorrectableErrorsReceived ) } ; MultipleCorrectableErrorsReceived as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let UncorrectableErrorReceived : u32 = unsafe { :: std :: mem :: transmute ( UncorrectableErrorReceived ) } ; UncorrectableErrorReceived as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let MultipleUncorrectableErrorsReceived : u32 = unsafe { :: std :: mem :: transmute ( MultipleUncorrectableErrorsReceived ) } ; MultipleUncorrectableErrorsReceived as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let FirstUncorrectableFatal : u32 = unsafe { :: std :: mem :: transmute ( FirstUncorrectableFatal ) } ; FirstUncorrectableFatal as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let NonFatalErrorMessagesReceived : u32 = unsafe { :: std :: mem :: transmute ( NonFatalErrorMessagesReceived ) } ; NonFatalErrorMessagesReceived as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let FatalErrorMessagesReceived : u32 = unsafe { :: std :: mem :: transmute ( FatalErrorMessagesReceived ) } ; FatalErrorMessagesReceived as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 20u8 , { let Reserved : u32 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit . set ( 27usize , 5u8 , { let AdvancedErrorInterruptMessageNumber : u32 = unsafe { :: std :: mem :: transmute ( AdvancedErrorInterruptMessageNumber ) } ; AdvancedErrorInterruptMessageNumber as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_ROOT_ERROR_STATUS = _PCI_EXPRESS_ROOT_ERROR_STATUS ; pub type PPCI_EXPRESS_ROOT_ERROR_STATUS = * mut _PCI_EXPRESS_ROOT_ERROR_STATUS ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_ERROR_SOURCE_ID { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_ERROR_SOURCE_ID__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_ERROR_SOURCE_ID__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl _PCI_EXPRESS_ERROR_SOURCE_ID__bindgen_ty_1 { # [ inline ] pub fn CorrectableSourceIdFun ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u16 ) } } # [ inline ] pub fn set_CorrectableSourceIdFun ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn CorrectableSourceIdDev ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 5u8 ) as u16 ) } } # [ inline ] pub fn set_CorrectableSourceIdDev ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 5u8 , val as u64 ) } } # [ inline ] pub fn CorrectableSourceIdBus ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u16 ) } } # [ inline ] pub fn set_CorrectableSourceIdBus ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn UncorrectableSourceIdFun ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 3u8 ) as u16 ) } } # [ inline ] pub fn set_UncorrectableSourceIdFun ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 3u8 , val as u64 ) } } # [ inline ] pub fn UncorrectableSourceIdDev ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 19usize , 5u8 ) as u16 ) } } # [ inline ] pub fn set_UncorrectableSourceIdDev ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 19usize , 5u8 , val as u64 ) } } # [ inline ] pub fn UncorrectableSourceIdBus ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u16 ) } } # [ inline ] pub fn set_UncorrectableSourceIdBus ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( CorrectableSourceIdFun : USHORT , CorrectableSourceIdDev : USHORT , CorrectableSourceIdBus : USHORT , UncorrectableSourceIdFun : USHORT , UncorrectableSourceIdDev : USHORT , UncorrectableSourceIdBus : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let CorrectableSourceIdFun : u16 = unsafe { :: std :: mem :: transmute ( CorrectableSourceIdFun ) } ; CorrectableSourceIdFun as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 5u8 , { let CorrectableSourceIdDev : u16 = unsafe { :: std :: mem :: transmute ( CorrectableSourceIdDev ) } ; CorrectableSourceIdDev as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let CorrectableSourceIdBus : u16 = unsafe { :: std :: mem :: transmute ( CorrectableSourceIdBus ) } ; CorrectableSourceIdBus as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 3u8 , { let UncorrectableSourceIdFun : u16 = unsafe { :: std :: mem :: transmute ( UncorrectableSourceIdFun ) } ; UncorrectableSourceIdFun as u64 } ) ; __bindgen_bitfield_unit . set ( 19usize , 5u8 , { let UncorrectableSourceIdDev : u16 = unsafe { :: std :: mem :: transmute ( UncorrectableSourceIdDev ) } ; UncorrectableSourceIdDev as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let UncorrectableSourceIdBus : u16 = unsafe { :: std :: mem :: transmute ( UncorrectableSourceIdBus ) } ; UncorrectableSourceIdBus as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_ERROR_SOURCE_ID = _PCI_EXPRESS_ERROR_SOURCE_ID ; pub type PPCI_EXPRESS_ERROR_SOURCE_ID = * mut _PCI_EXPRESS_ERROR_SOURCE_ID ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS__bindgen_ty_1 { # [ inline ] pub fn TargetAbortOnSplitCompletion ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_TargetAbortOnSplitCompletion ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MasterAbortOnSplitCompletion ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_MasterAbortOnSplitCompletion ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ReceivedTargetAbort ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ReceivedTargetAbort ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ReceivedMasterAbort ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ReceivedMasterAbort ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn RsvdZ ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_RsvdZ ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UnexpectedSplitCompletionError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_UnexpectedSplitCompletionError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UncorrectableSplitCompletion ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_UncorrectableSplitCompletion ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UncorrectableDataError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_UncorrectableDataError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UncorrectableAttributeError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_UncorrectableAttributeError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UncorrectableAddressError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_UncorrectableAddressError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn DelayedTransactionDiscardTimerExpired ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_DelayedTransactionDiscardTimerExpired ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PERRAsserted ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_PERRAsserted ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 1u8 , val as u64 ) } } # [ inline ] pub fn SERRAsserted ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_SERRAsserted ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 1u8 , val as u64 ) } } # [ inline ] pub fn InternalBridgeError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 13usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_InternalBridgeError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 13usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 18u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 18u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( TargetAbortOnSplitCompletion : ULONG , MasterAbortOnSplitCompletion : ULONG , ReceivedTargetAbort : ULONG , ReceivedMasterAbort : ULONG , RsvdZ : ULONG , UnexpectedSplitCompletionError : ULONG , UncorrectableSplitCompletion : ULONG , UncorrectableDataError : ULONG , UncorrectableAttributeError : ULONG , UncorrectableAddressError : ULONG , DelayedTransactionDiscardTimerExpired : ULONG , PERRAsserted : ULONG , SERRAsserted : ULONG , InternalBridgeError : ULONG , Reserved : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let TargetAbortOnSplitCompletion : u32 = unsafe { :: std :: mem :: transmute ( TargetAbortOnSplitCompletion ) } ; TargetAbortOnSplitCompletion as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let MasterAbortOnSplitCompletion : u32 = unsafe { :: std :: mem :: transmute ( MasterAbortOnSplitCompletion ) } ; MasterAbortOnSplitCompletion as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let ReceivedTargetAbort : u32 = unsafe { :: std :: mem :: transmute ( ReceivedTargetAbort ) } ; ReceivedTargetAbort as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let ReceivedMasterAbort : u32 = unsafe { :: std :: mem :: transmute ( ReceivedMasterAbort ) } ; ReceivedMasterAbort as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let RsvdZ : u32 = unsafe { :: std :: mem :: transmute ( RsvdZ ) } ; RsvdZ as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let UnexpectedSplitCompletionError : u32 = unsafe { :: std :: mem :: transmute ( UnexpectedSplitCompletionError ) } ; UnexpectedSplitCompletionError as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let UncorrectableSplitCompletion : u32 = unsafe { :: std :: mem :: transmute ( UncorrectableSplitCompletion ) } ; UncorrectableSplitCompletion as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let UncorrectableDataError : u32 = unsafe { :: std :: mem :: transmute ( UncorrectableDataError ) } ; UncorrectableDataError as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let UncorrectableAttributeError : u32 = unsafe { :: std :: mem :: transmute ( UncorrectableAttributeError ) } ; UncorrectableAttributeError as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let UncorrectableAddressError : u32 = unsafe { :: std :: mem :: transmute ( UncorrectableAddressError ) } ; UncorrectableAddressError as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 1u8 , { let DelayedTransactionDiscardTimerExpired : u32 = unsafe { :: std :: mem :: transmute ( DelayedTransactionDiscardTimerExpired ) } ; DelayedTransactionDiscardTimerExpired as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 1u8 , { let PERRAsserted : u32 = unsafe { :: std :: mem :: transmute ( PERRAsserted ) } ; PERRAsserted as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 1u8 , { let SERRAsserted : u32 = unsafe { :: std :: mem :: transmute ( SERRAsserted ) } ; SERRAsserted as u64 } ) ; __bindgen_bitfield_unit . set ( 13usize , 1u8 , { let InternalBridgeError : u32 = unsafe { :: std :: mem :: transmute ( InternalBridgeError ) } ; InternalBridgeError as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 18u8 , { let Reserved : u32 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS = _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS ; pub type PPCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS = * mut _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK__bindgen_ty_1 { # [ inline ] pub fn TargetAbortOnSplitCompletion ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_TargetAbortOnSplitCompletion ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MasterAbortOnSplitCompletion ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_MasterAbortOnSplitCompletion ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ReceivedTargetAbort ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ReceivedTargetAbort ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ReceivedMasterAbort ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ReceivedMasterAbort ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn RsvdZ ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_RsvdZ ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UnexpectedSplitCompletionError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_UnexpectedSplitCompletionError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UncorrectableSplitCompletion ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_UncorrectableSplitCompletion ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UncorrectableDataError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_UncorrectableDataError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UncorrectableAttributeError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_UncorrectableAttributeError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UncorrectableAddressError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_UncorrectableAddressError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn DelayedTransactionDiscardTimerExpired ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_DelayedTransactionDiscardTimerExpired ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PERRAsserted ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_PERRAsserted ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 1u8 , val as u64 ) } } # [ inline ] pub fn SERRAsserted ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_SERRAsserted ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 1u8 , val as u64 ) } } # [ inline ] pub fn InternalBridgeError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 13usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_InternalBridgeError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 13usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 18u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 18u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( TargetAbortOnSplitCompletion : ULONG , MasterAbortOnSplitCompletion : ULONG , ReceivedTargetAbort : ULONG , ReceivedMasterAbort : ULONG , RsvdZ : ULONG , UnexpectedSplitCompletionError : ULONG , UncorrectableSplitCompletion : ULONG , UncorrectableDataError : ULONG , UncorrectableAttributeError : ULONG , UncorrectableAddressError : ULONG , DelayedTransactionDiscardTimerExpired : ULONG , PERRAsserted : ULONG , SERRAsserted : ULONG , InternalBridgeError : ULONG , Reserved : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let TargetAbortOnSplitCompletion : u32 = unsafe { :: std :: mem :: transmute ( TargetAbortOnSplitCompletion ) } ; TargetAbortOnSplitCompletion as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let MasterAbortOnSplitCompletion : u32 = unsafe { :: std :: mem :: transmute ( MasterAbortOnSplitCompletion ) } ; MasterAbortOnSplitCompletion as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let ReceivedTargetAbort : u32 = unsafe { :: std :: mem :: transmute ( ReceivedTargetAbort ) } ; ReceivedTargetAbort as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let ReceivedMasterAbort : u32 = unsafe { :: std :: mem :: transmute ( ReceivedMasterAbort ) } ; ReceivedMasterAbort as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let RsvdZ : u32 = unsafe { :: std :: mem :: transmute ( RsvdZ ) } ; RsvdZ as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let UnexpectedSplitCompletionError : u32 = unsafe { :: std :: mem :: transmute ( UnexpectedSplitCompletionError ) } ; UnexpectedSplitCompletionError as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let UncorrectableSplitCompletion : u32 = unsafe { :: std :: mem :: transmute ( UncorrectableSplitCompletion ) } ; UncorrectableSplitCompletion as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let UncorrectableDataError : u32 = unsafe { :: std :: mem :: transmute ( UncorrectableDataError ) } ; UncorrectableDataError as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let UncorrectableAttributeError : u32 = unsafe { :: std :: mem :: transmute ( UncorrectableAttributeError ) } ; UncorrectableAttributeError as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let UncorrectableAddressError : u32 = unsafe { :: std :: mem :: transmute ( UncorrectableAddressError ) } ; UncorrectableAddressError as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 1u8 , { let DelayedTransactionDiscardTimerExpired : u32 = unsafe { :: std :: mem :: transmute ( DelayedTransactionDiscardTimerExpired ) } ; DelayedTransactionDiscardTimerExpired as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 1u8 , { let PERRAsserted : u32 = unsafe { :: std :: mem :: transmute ( PERRAsserted ) } ; PERRAsserted as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 1u8 , { let SERRAsserted : u32 = unsafe { :: std :: mem :: transmute ( SERRAsserted ) } ; SERRAsserted as u64 } ) ; __bindgen_bitfield_unit . set ( 13usize , 1u8 , { let InternalBridgeError : u32 = unsafe { :: std :: mem :: transmute ( InternalBridgeError ) } ; InternalBridgeError as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 18u8 , { let Reserved : u32 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK = _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK ; pub type PPCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK = * mut _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY__bindgen_ty_1 { # [ inline ] pub fn TargetAbortOnSplitCompletion ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_TargetAbortOnSplitCompletion ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MasterAbortOnSplitCompletion ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_MasterAbortOnSplitCompletion ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ReceivedTargetAbort ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ReceivedTargetAbort ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ReceivedMasterAbort ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ReceivedMasterAbort ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn RsvdZ ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_RsvdZ ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UnexpectedSplitCompletionError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_UnexpectedSplitCompletionError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UncorrectableSplitCompletion ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_UncorrectableSplitCompletion ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UncorrectableDataError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_UncorrectableDataError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UncorrectableAttributeError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_UncorrectableAttributeError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UncorrectableAddressError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_UncorrectableAddressError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn DelayedTransactionDiscardTimerExpired ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_DelayedTransactionDiscardTimerExpired ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PERRAsserted ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_PERRAsserted ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 1u8 , val as u64 ) } } # [ inline ] pub fn SERRAsserted ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_SERRAsserted ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 1u8 , val as u64 ) } } # [ inline ] pub fn InternalBridgeError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 13usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_InternalBridgeError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 13usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 18u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 18u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( TargetAbortOnSplitCompletion : ULONG , MasterAbortOnSplitCompletion : ULONG , ReceivedTargetAbort : ULONG , ReceivedMasterAbort : ULONG , RsvdZ : ULONG , UnexpectedSplitCompletionError : ULONG , UncorrectableSplitCompletion : ULONG , UncorrectableDataError : ULONG , UncorrectableAttributeError : ULONG , UncorrectableAddressError : ULONG , DelayedTransactionDiscardTimerExpired : ULONG , PERRAsserted : ULONG , SERRAsserted : ULONG , InternalBridgeError : ULONG , Reserved : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let TargetAbortOnSplitCompletion : u32 = unsafe { :: std :: mem :: transmute ( TargetAbortOnSplitCompletion ) } ; TargetAbortOnSplitCompletion as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let MasterAbortOnSplitCompletion : u32 = unsafe { :: std :: mem :: transmute ( MasterAbortOnSplitCompletion ) } ; MasterAbortOnSplitCompletion as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let ReceivedTargetAbort : u32 = unsafe { :: std :: mem :: transmute ( ReceivedTargetAbort ) } ; ReceivedTargetAbort as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let ReceivedMasterAbort : u32 = unsafe { :: std :: mem :: transmute ( ReceivedMasterAbort ) } ; ReceivedMasterAbort as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let RsvdZ : u32 = unsafe { :: std :: mem :: transmute ( RsvdZ ) } ; RsvdZ as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let UnexpectedSplitCompletionError : u32 = unsafe { :: std :: mem :: transmute ( UnexpectedSplitCompletionError ) } ; UnexpectedSplitCompletionError as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let UncorrectableSplitCompletion : u32 = unsafe { :: std :: mem :: transmute ( UncorrectableSplitCompletion ) } ; UncorrectableSplitCompletion as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let UncorrectableDataError : u32 = unsafe { :: std :: mem :: transmute ( UncorrectableDataError ) } ; UncorrectableDataError as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let UncorrectableAttributeError : u32 = unsafe { :: std :: mem :: transmute ( UncorrectableAttributeError ) } ; UncorrectableAttributeError as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let UncorrectableAddressError : u32 = unsafe { :: std :: mem :: transmute ( UncorrectableAddressError ) } ; UncorrectableAddressError as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 1u8 , { let DelayedTransactionDiscardTimerExpired : u32 = unsafe { :: std :: mem :: transmute ( DelayedTransactionDiscardTimerExpired ) } ; DelayedTransactionDiscardTimerExpired as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 1u8 , { let PERRAsserted : u32 = unsafe { :: std :: mem :: transmute ( PERRAsserted ) } ; PERRAsserted as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 1u8 , { let SERRAsserted : u32 = unsafe { :: std :: mem :: transmute ( SERRAsserted ) } ; SERRAsserted as u64 } ) ; __bindgen_bitfield_unit . set ( 13usize , 1u8 , { let InternalBridgeError : u32 = unsafe { :: std :: mem :: transmute ( InternalBridgeError ) } ; InternalBridgeError as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 18u8 , { let Reserved : u32 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY = _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY ; pub type PPCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY = * mut _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_SEC_AER_CAPABILITIES { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_SEC_AER_CAPABILITIES__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_SEC_AER_CAPABILITIES__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PCI_EXPRESS_SEC_AER_CAPABILITIES__bindgen_ty_1 { # [ inline ] pub fn SecondaryUncorrectableFirstErrorPtr ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_SecondaryUncorrectableFirstErrorPtr ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 5u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 27u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 27u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( SecondaryUncorrectableFirstErrorPtr : ULONG , Reserved : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 5u8 , { let SecondaryUncorrectableFirstErrorPtr : u32 = unsafe { :: std :: mem :: transmute ( SecondaryUncorrectableFirstErrorPtr ) } ; SecondaryUncorrectableFirstErrorPtr as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 27u8 , { let Reserved : u32 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_SEC_AER_CAPABILITIES = _PCI_EXPRESS_SEC_AER_CAPABILITIES ; pub type PPCI_EXPRESS_SEC_AER_CAPABILITIES = * mut _PCI_EXPRESS_SEC_AER_CAPABILITIES ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_AER_CAPABILITY { pub Header : PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER , pub UncorrectableErrorStatus : PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS , pub UncorrectableErrorMask : PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK , pub UncorrectableErrorSeverity : PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY , pub CorrectableErrorStatus : PCI_EXPRESS_CORRECTABLE_ERROR_STATUS , pub CorrectableErrorMask : PCI_EXPRESS_CORRECTABLE_ERROR_MASK , pub CapabilitiesAndControl : PCI_EXPRESS_AER_CAPABILITIES , pub HeaderLog : [ ULONG ; 4usize ] , pub SecUncorrectableErrorStatus : PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS , pub SecUncorrectableErrorMask : PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK , pub SecUncorrectableErrorSeverity : PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY , pub SecCapabilitiesAndControl : PCI_EXPRESS_SEC_AER_CAPABILITIES , pub SecHeaderLog : [ ULONG ; 4usize ] , } pub type PCI_EXPRESS_AER_CAPABILITY = _PCI_EXPRESS_AER_CAPABILITY ; pub type PPCI_EXPRESS_AER_CAPABILITY = * mut _PCI_EXPRESS_AER_CAPABILITY ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_ROOTPORT_AER_CAPABILITY { pub Header : PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER , pub UncorrectableErrorStatus : PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS , pub UncorrectableErrorMask : PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK , pub UncorrectableErrorSeverity : PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY , pub CorrectableErrorStatus : PCI_EXPRESS_CORRECTABLE_ERROR_STATUS , pub CorrectableErrorMask : PCI_EXPRESS_CORRECTABLE_ERROR_MASK , pub CapabilitiesAndControl : PCI_EXPRESS_AER_CAPABILITIES , pub HeaderLog : [ ULONG ; 4usize ] , pub RootErrorCommand : PCI_EXPRESS_ROOT_ERROR_COMMAND , pub RootErrorStatus : PCI_EXPRESS_ROOT_ERROR_STATUS , pub ErrorSourceId : PCI_EXPRESS_ERROR_SOURCE_ID , } pub type PCI_EXPRESS_ROOTPORT_AER_CAPABILITY = _PCI_EXPRESS_ROOTPORT_AER_CAPABILITY ; pub type PPCI_EXPRESS_ROOTPORT_AER_CAPABILITY = * mut _PCI_EXPRESS_ROOTPORT_AER_CAPABILITY ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_BRIDGE_AER_CAPABILITY { pub Header : PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER , pub UncorrectableErrorStatus : PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS , pub UncorrectableErrorMask : PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK , pub UncorrectableErrorSeverity : PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY , pub CorrectableErrorStatus : PCI_EXPRESS_CORRECTABLE_ERROR_STATUS , pub CorrectableErrorMask : PCI_EXPRESS_CORRECTABLE_ERROR_MASK , pub CapabilitiesAndControl : PCI_EXPRESS_AER_CAPABILITIES , pub HeaderLog : [ ULONG ; 4usize ] , pub SecUncorrectableErrorStatus : PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS , pub SecUncorrectableErrorMask : PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK , pub SecUncorrectableErrorSeverity : PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY , pub SecCapabilitiesAndControl : PCI_EXPRESS_SEC_AER_CAPABILITIES , pub SecHeaderLog : [ ULONG ; 4usize ] , } pub type PCI_EXPRESS_BRIDGE_AER_CAPABILITY = _PCI_EXPRESS_BRIDGE_AER_CAPABILITY ; pub type PPCI_EXPRESS_BRIDGE_AER_CAPABILITY = * mut _PCI_EXPRESS_BRIDGE_AER_CAPABILITY ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_ACS_CAPABILITY_REGISTER { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_ACS_CAPABILITY_REGISTER__bindgen_ty_1 > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : u16 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_ACS_CAPABILITY_REGISTER__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl _PCI_EXPRESS_ACS_CAPABILITY_REGISTER__bindgen_ty_1 { # [ inline ] pub fn SourceValidation ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_SourceValidation ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn TranslationBlocking ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_TranslationBlocking ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn RequestRedirect ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_RequestRedirect ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn CompletionRedirect ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_CompletionRedirect ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UpstreamForwarding ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_UpstreamForwarding ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn EgressControl ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_EgressControl ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn DirectTranslation ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_DirectTranslation ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn EgressControlVectorSize ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u16 ) } } # [ inline ] pub fn set_EgressControlVectorSize ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( SourceValidation : USHORT , TranslationBlocking : USHORT , RequestRedirect : USHORT , CompletionRedirect : USHORT , UpstreamForwarding : USHORT , EgressControl : USHORT , DirectTranslation : USHORT , Reserved : USHORT , EgressControlVectorSize : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let SourceValidation : u16 = unsafe { :: std :: mem :: transmute ( SourceValidation ) } ; SourceValidation as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let TranslationBlocking : u16 = unsafe { :: std :: mem :: transmute ( TranslationBlocking ) } ; TranslationBlocking as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let RequestRedirect : u16 = unsafe { :: std :: mem :: transmute ( RequestRedirect ) } ; RequestRedirect as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let CompletionRedirect : u16 = unsafe { :: std :: mem :: transmute ( CompletionRedirect ) } ; CompletionRedirect as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let UpstreamForwarding : u16 = unsafe { :: std :: mem :: transmute ( UpstreamForwarding ) } ; UpstreamForwarding as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let EgressControl : u16 = unsafe { :: std :: mem :: transmute ( EgressControl ) } ; EgressControl as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let DirectTranslation : u16 = unsafe { :: std :: mem :: transmute ( DirectTranslation ) } ; DirectTranslation as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let Reserved : u16 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let EgressControlVectorSize : u16 = unsafe { :: std :: mem :: transmute ( EgressControlVectorSize ) } ; EgressControlVectorSize as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_ACS_CAPABILITY_REGISTER = _PCI_EXPRESS_ACS_CAPABILITY_REGISTER ; pub type PPCI_EXPRESS_ACS_CAPABILITY_REGISTER = * mut _PCI_EXPRESS_ACS_CAPABILITY_REGISTER ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_ACS_CONTROL { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_ACS_CONTROL__bindgen_ty_1 > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : u16 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_ACS_CONTROL__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl _PCI_EXPRESS_ACS_CONTROL__bindgen_ty_1 { # [ inline ] pub fn SourceValidation ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_SourceValidation ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn TranslationBlocking ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_TranslationBlocking ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn RequestRedirect ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_RequestRedirect ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn CompletionRedirect ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_CompletionRedirect ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UpstreamForwarding ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_UpstreamForwarding ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn EgressControl ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_EgressControl ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn DirectTranslation ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_DirectTranslation ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 9u8 ) as u16 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 9u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( SourceValidation : USHORT , TranslationBlocking : USHORT , RequestRedirect : USHORT , CompletionRedirect : USHORT , UpstreamForwarding : USHORT , EgressControl : USHORT , DirectTranslation : USHORT , Reserved : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let SourceValidation : u16 = unsafe { :: std :: mem :: transmute ( SourceValidation ) } ; SourceValidation as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let TranslationBlocking : u16 = unsafe { :: std :: mem :: transmute ( TranslationBlocking ) } ; TranslationBlocking as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let RequestRedirect : u16 = unsafe { :: std :: mem :: transmute ( RequestRedirect ) } ; RequestRedirect as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let CompletionRedirect : u16 = unsafe { :: std :: mem :: transmute ( CompletionRedirect ) } ; CompletionRedirect as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let UpstreamForwarding : u16 = unsafe { :: std :: mem :: transmute ( UpstreamForwarding ) } ; UpstreamForwarding as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let EgressControl : u16 = unsafe { :: std :: mem :: transmute ( EgressControl ) } ; EgressControl as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let DirectTranslation : u16 = unsafe { :: std :: mem :: transmute ( DirectTranslation ) } ; DirectTranslation as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 9u8 , { let Reserved : u16 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_ACS_CONTROL = _PCI_EXPRESS_ACS_CONTROL ; pub type PPCI_EXPRESS_ACS_CONTROL = * mut _PCI_EXPRESS_ACS_CONTROL ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_ACS_CAPABILITY { pub Header : PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER , pub Capability : PCI_EXPRESS_ACS_CAPABILITY_REGISTER , pub Control : PCI_EXPRESS_ACS_CONTROL , pub EgressControl : [ ULONG ; 1usize ] , } pub type PCI_EXPRESS_ACS_CAPABILITY = _PCI_EXPRESS_ACS_CAPABILITY ; pub type PPCI_EXPRESS_ACS_CAPABILITY = * mut _PCI_EXPRESS_ACS_CAPABILITY ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_SRIOV_CAPS { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_SRIOV_CAPS__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_SRIOV_CAPS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PCI_EXPRESS_SRIOV_CAPS__bindgen_ty_1 { # [ inline ] pub fn VFMigrationCapable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_VFMigrationCapable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved1 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 20u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved1 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 20u8 , val as u64 ) } } # [ inline ] pub fn VFMigrationInterruptNumber ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 21usize , 11u8 ) as u32 ) } } # [ inline ] pub fn set_VFMigrationInterruptNumber ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 21usize , 11u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( VFMigrationCapable : ULONG , Reserved1 : ULONG , VFMigrationInterruptNumber : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let VFMigrationCapable : u32 = unsafe { :: std :: mem :: transmute ( VFMigrationCapable ) } ; VFMigrationCapable as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 20u8 , { let Reserved1 : u32 = unsafe { :: std :: mem :: transmute ( Reserved1 ) } ; Reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 21usize , 11u8 , { let VFMigrationInterruptNumber : u32 = unsafe { :: std :: mem :: transmute ( VFMigrationInterruptNumber ) } ; VFMigrationInterruptNumber as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_SRIOV_CAPS = _PCI_EXPRESS_SRIOV_CAPS ; pub type PPCI_EXPRESS_SRIOV_CAPS = * mut _PCI_EXPRESS_SRIOV_CAPS ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_SRIOV_CONTROL { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_SRIOV_CONTROL__bindgen_ty_1 > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : u16 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_SRIOV_CONTROL__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl _PCI_EXPRESS_SRIOV_CONTROL__bindgen_ty_1 { # [ inline ] pub fn VFEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_VFEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn VFMigrationEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_VFMigrationEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn VFMigrationInterruptEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_VFMigrationInterruptEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn VFMemorySpaceEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_VFMemorySpaceEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ARICapableHierarchy ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_ARICapableHierarchy ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved1 ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 11u8 ) as u16 ) } } # [ inline ] pub fn set_Reserved1 ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 11u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( VFEnable : USHORT , VFMigrationEnable : USHORT , VFMigrationInterruptEnable : USHORT , VFMemorySpaceEnable : USHORT , ARICapableHierarchy : USHORT , Reserved1 : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let VFEnable : u16 = unsafe { :: std :: mem :: transmute ( VFEnable ) } ; VFEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let VFMigrationEnable : u16 = unsafe { :: std :: mem :: transmute ( VFMigrationEnable ) } ; VFMigrationEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let VFMigrationInterruptEnable : u16 = unsafe { :: std :: mem :: transmute ( VFMigrationInterruptEnable ) } ; VFMigrationInterruptEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let VFMemorySpaceEnable : u16 = unsafe { :: std :: mem :: transmute ( VFMemorySpaceEnable ) } ; VFMemorySpaceEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let ARICapableHierarchy : u16 = unsafe { :: std :: mem :: transmute ( ARICapableHierarchy ) } ; ARICapableHierarchy as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 11u8 , { let Reserved1 : u16 = unsafe { :: std :: mem :: transmute ( Reserved1 ) } ; Reserved1 as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_SRIOV_CONTROL = _PCI_EXPRESS_SRIOV_CONTROL ; pub type PPCI_EXPRESS_SRIOV_CONTROL = * mut _PCI_EXPRESS_SRIOV_CONTROL ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_SRIOV_STATUS { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_SRIOV_STATUS__bindgen_ty_1 > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : u16 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_SRIOV_STATUS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl _PCI_EXPRESS_SRIOV_STATUS__bindgen_ty_1 { # [ inline ] pub fn VFMigrationStatus ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_VFMigrationStatus ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved1 ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 15u8 ) as u16 ) } } # [ inline ] pub fn set_Reserved1 ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 15u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( VFMigrationStatus : USHORT , Reserved1 : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let VFMigrationStatus : u16 = unsafe { :: std :: mem :: transmute ( VFMigrationStatus ) } ; VFMigrationStatus as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 15u8 , { let Reserved1 : u16 = unsafe { :: std :: mem :: transmute ( Reserved1 ) } ; Reserved1 as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_SRIOV_STATUS = _PCI_EXPRESS_SRIOV_STATUS ; pub type PPCI_EXPRESS_SRIOV_STATUS = * mut _PCI_EXPRESS_SRIOV_STATUS ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY__bindgen_ty_1 { # [ inline ] pub fn VFMigrationStateBIR ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_VFMigrationStateBIR ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn VFMigrationStateOffset ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 29u8 ) as u32 ) } } # [ inline ] pub fn set_VFMigrationStateOffset ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 29u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( VFMigrationStateBIR : ULONG , VFMigrationStateOffset : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let VFMigrationStateBIR : u32 = unsafe { :: std :: mem :: transmute ( VFMigrationStateBIR ) } ; VFMigrationStateBIR as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 29u8 , { let VFMigrationStateOffset : u32 = unsafe { :: std :: mem :: transmute ( VFMigrationStateOffset ) } ; VFMigrationStateOffset as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY = _PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY ; pub type PPCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY = * mut _PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_SRIOV_CAPABILITY { pub Header : PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER , pub SRIOVCapabilities : PCI_EXPRESS_SRIOV_CAPS , pub SRIOVControl : PCI_EXPRESS_SRIOV_CONTROL , pub SRIOVStatus : PCI_EXPRESS_SRIOV_STATUS , pub InitialVFs : USHORT , pub TotalVFs : USHORT , pub NumVFs : USHORT , pub FunctionDependencyLink : UCHAR , pub RsvdP1 : UCHAR , pub FirstVFOffset : USHORT , pub VFStride : USHORT , pub RsvdP2 : USHORT , pub VFDeviceId : USHORT , pub SupportedPageSizes : ULONG , pub SystemPageSize : ULONG , pub BaseAddresses : [ ULONG ; 6usize ] , pub VFMigrationStateArrayOffset : PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY , } pub type PCI_EXPRESS_SRIOV_CAPABILITY = _PCI_EXPRESS_SRIOV_CAPABILITY ; pub type PPCI_EXPRESS_SRIOV_CAPABILITY = * mut _PCI_EXPRESS_SRIOV_CAPABILITY ; # [ repr ( C ) ] pub struct _PCI_DEVICE_PRESENCE_PARAMETERS { pub Size : ULONG , pub Flags : ULONG , pub VendorID : USHORT , pub DeviceID : USHORT , pub RevisionID : UCHAR , pub SubVendorID : USHORT , pub SubSystemID : USHORT , pub BaseClass : UCHAR , pub SubClass : UCHAR , pub ProgIf : UCHAR , } pub type PCI_DEVICE_PRESENCE_PARAMETERS = _PCI_DEVICE_PRESENCE_PARAMETERS ; pub type PPCI_DEVICE_PRESENCE_PARAMETERS = * mut _PCI_DEVICE_PRESENCE_PARAMETERS ; pub type PCI_IS_DEVICE_PRESENT = :: std :: option :: Option < unsafe extern "C" fn ( VendorID : USHORT , DeviceID : USHORT , RevisionID : UCHAR , SubVendorID : USHORT , SubSystemID : USHORT , Flags : ULONG ) -> BOOLEAN > ; pub type PPCI_IS_DEVICE_PRESENT = PCI_IS_DEVICE_PRESENT ; pub type PCI_IS_DEVICE_PRESENT_EX = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , Parameters : PPCI_DEVICE_PRESENCE_PARAMETERS ) -> BOOLEAN > ; pub type PPCI_IS_DEVICE_PRESENT_EX = PCI_IS_DEVICE_PRESENT_EX ; # [ repr ( C ) ] pub struct _PCI_DEVICE_PRESENT_INTERFACE { pub Size : USHORT , pub Version : USHORT , pub Context : PVOID , pub InterfaceReference : PINTERFACE_REFERENCE , pub InterfaceDereference : PINTERFACE_DEREFERENCE , pub IsDevicePresent : PPCI_IS_DEVICE_PRESENT , pub IsDevicePresentEx : PPCI_IS_DEVICE_PRESENT_EX , } pub type PCI_DEVICE_PRESENT_INTERFACE = _PCI_DEVICE_PRESENT_INTERFACE ; pub type PPCI_DEVICE_PRESENT_INTERFACE = * mut _PCI_DEVICE_PRESENT_INTERFACE ; pub type PCI_EXPRESS_ENTER_LINK_QUIESCENT_MODE = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID ) -> NTSTATUS > ; pub type PPCI_EXPRESS_ENTER_LINK_QUIESCENT_MODE = PCI_EXPRESS_ENTER_LINK_QUIESCENT_MODE ; pub type PCI_EXPRESS_EXIT_LINK_QUIESCENT_MODE = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID ) -> NTSTATUS > ; pub type PPCI_EXPRESS_EXIT_LINK_QUIESCENT_MODE = PCI_EXPRESS_EXIT_LINK_QUIESCENT_MODE ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_LINK_QUIESCENT_INTERFACE { pub Size : USHORT , pub Version : USHORT , pub Context : PVOID , pub InterfaceReference : PINTERFACE_REFERENCE , pub InterfaceDereference : PINTERFACE_DEREFERENCE , pub PciExpressEnterLinkQuiescentMode : PPCI_EXPRESS_ENTER_LINK_QUIESCENT_MODE , pub PciExpressExitLinkQuiescentMode : PPCI_EXPRESS_EXIT_LINK_QUIESCENT_MODE , } pub type PCI_EXPRESS_LINK_QUIESCENT_INTERFACE = _PCI_EXPRESS_LINK_QUIESCENT_INTERFACE ; pub type PPCI_EXPRESS_LINK_QUIESCENT_INTERFACE = * mut _PCI_EXPRESS_LINK_QUIESCENT_INTERFACE ; pub type PPCI_EXPRESS_ROOT_PORT_READ_CONFIG_SPACE = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , Buffer : PVOID , Offset : ULONG , Length : ULONG ) -> ULONG > ; pub type PPCI_EXPRESS_ROOT_PORT_WRITE_CONFIG_SPACE = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , Buffer : PVOID , Offset : ULONG , Length : ULONG ) -> ULONG > ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_ROOT_PORT_INTERFACE { pub Size : USHORT , pub Version : USHORT , pub Context : PVOID , pub InterfaceReference : PINTERFACE_REFERENCE , pub InterfaceDereference : PINTERFACE_DEREFERENCE , pub ReadConfigSpace : PPCI_EXPRESS_ROOT_PORT_READ_CONFIG_SPACE , pub WriteConfigSpace : PPCI_EXPRESS_ROOT_PORT_WRITE_CONFIG_SPACE , } pub type PCI_EXPRESS_ROOT_PORT_INTERFACE = _PCI_EXPRESS_ROOT_PORT_INTERFACE ; pub type PPCI_EXPRESS_ROOT_PORT_INTERFACE = * mut _PCI_EXPRESS_ROOT_PORT_INTERFACE ; pub type PCI_MSIX_SET_ENTRY = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , TableEntry : ULONG , MessageNumber : ULONG ) -> NTSTATUS > ; pub type PPCI_MSIX_SET_ENTRY = PCI_MSIX_SET_ENTRY ; pub type PCI_MSIX_MASKUNMASK_ENTRY = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , TableEntry : ULONG ) -> NTSTATUS > ; pub type PPCI_MSIX_MASKUNMASK_ENTRY = PCI_MSIX_MASKUNMASK_ENTRY ; pub type PCI_MSIX_GET_ENTRY = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , TableEntry : ULONG , MessageNumber : PULONG , Masked : PBOOLEAN ) -> NTSTATUS > ; pub type PPCI_MSIX_GET_ENTRY = PCI_MSIX_GET_ENTRY ; pub type PCI_MSIX_GET_TABLE_SIZE = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , TableSize : PULONG ) -> NTSTATUS > ; pub type PPCI_MSIX_GET_TABLE_SIZE = PCI_MSIX_GET_TABLE_SIZE ; # [ repr ( C ) ] pub struct _PCI_MSIX_TABLE_CONFIG_INTERFACE { pub Size : USHORT , pub Version : USHORT , pub Context : PVOID , pub InterfaceReference : PINTERFACE_REFERENCE , pub InterfaceDereference : PINTERFACE_DEREFERENCE , pub SetTableEntry : PPCI_MSIX_SET_ENTRY , pub MaskTableEntry : PPCI_MSIX_MASKUNMASK_ENTRY , pub UnmaskTableEntry : PPCI_MSIX_MASKUNMASK_ENTRY , pub GetTableEntry : PPCI_MSIX_GET_ENTRY , pub GetTableSize : PPCI_MSIX_GET_TABLE_SIZE , } pub type PCI_MSIX_TABLE_CONFIG_INTERFACE = _PCI_MSIX_TABLE_CONFIG_INTERFACE ; pub type PPCI_MSIX_TABLE_CONFIG_INTERFACE = * mut _PCI_MSIX_TABLE_CONFIG_INTERFACE ; extern "C" { pub fn ZwCreateFile ( FileHandle : PHANDLE , DesiredAccess : ACCESS_MASK , ObjectAttributes : POBJECT_ATTRIBUTES , IoStatusBlock : PIO_STATUS_BLOCK , AllocationSize : PLARGE_INTEGER , FileAttributes : ULONG , ShareAccess : ULONG , CreateDisposition : ULONG , CreateOptions : ULONG , EaBuffer : PVOID , EaLength : ULONG ) -> NTSTATUS ; } extern "C" { pub fn ZwOpenFile ( FileHandle : PHANDLE , DesiredAccess : ACCESS_MASK , ObjectAttributes : POBJECT_ATTRIBUTES , IoStatusBlock : PIO_STATUS_BLOCK , ShareAccess : ULONG , OpenOptions : ULONG ) -> NTSTATUS ; } extern "C" { pub fn ZwLoadDriver ( DriverServiceName : PUNICODE_STRING ) -> NTSTATUS ; } extern "C" { pub fn ZwUnloadDriver ( DriverServiceName : PUNICODE_STRING ) -> NTSTATUS ; } extern "C" { pub fn ZwQueryInformationFile ( FileHandle : HANDLE , IoStatusBlock : PIO_STATUS_BLOCK , FileInformation : PVOID , Length : ULONG , FileInformationClass : FILE_INFORMATION_CLASS ) -> NTSTATUS ; } extern "C" { pub fn ZwSetInformationFile ( FileHandle : HANDLE , IoStatusBlock : PIO_STATUS_BLOCK , FileInformation : PVOID , Length : ULONG , FileInformationClass : FILE_INFORMATION_CLASS ) -> NTSTATUS ; } extern "C" { pub fn ZwReadFile ( FileHandle : HANDLE , Event : HANDLE , ApcRoutine : PIO_APC_ROUTINE , ApcContext : PVOID , IoStatusBlock : PIO_STATUS_BLOCK , Buffer : PVOID , Length : ULONG , ByteOffset : PLARGE_INTEGER , Key : PULONG ) -> NTSTATUS ; } extern "C" { pub fn ZwWriteFile ( FileHandle : HANDLE , Event : HANDLE , ApcRoutine : PIO_APC_ROUTINE , ApcContext : PVOID , IoStatusBlock : PIO_STATUS_BLOCK , Buffer : PVOID , Length : ULONG , ByteOffset : PLARGE_INTEGER , Key : PULONG ) -> NTSTATUS ; } extern "C" { pub fn ZwClose ( Handle : HANDLE ) -> NTSTATUS ; } extern "C" { pub fn ZwCreateDirectoryObject ( DirectoryHandle : PHANDLE , DesiredAccess : ACCESS_MASK , ObjectAttributes : POBJECT_ATTRIBUTES ) -> NTSTATUS ; } extern "C" { pub fn ZwMakeTemporaryObject ( Handle : HANDLE ) -> NTSTATUS ; } extern "C" { pub fn ZwCreateSection ( SectionHandle : PHANDLE , DesiredAccess : ACCESS_MASK , ObjectAttributes : POBJECT_ATTRIBUTES , MaximumSize : PLARGE_INTEGER , SectionPageProtection : ULONG , AllocationAttributes : ULONG , FileHandle : HANDLE ) -> NTSTATUS ; } extern "C" { pub fn ZwOpenSection ( SectionHandle : PHANDLE , DesiredAccess : ACCESS_MASK , ObjectAttributes : POBJECT_ATTRIBUTES ) -> NTSTATUS ; } extern "C" { pub fn ZwMapViewOfSection ( SectionHandle : HANDLE , ProcessHandle : HANDLE , BaseAddress : * mut PVOID , ZeroBits : ULONG_PTR , CommitSize : SIZE_T , SectionOffset : PLARGE_INTEGER , ViewSize : PSIZE_T , InheritDisposition : SECTION_INHERIT , AllocationType : ULONG , Win32Protect : ULONG ) -> NTSTATUS ; } extern "C" { pub fn ZwUnmapViewOfSection ( ProcessHandle : HANDLE , BaseAddress : PVOID ) -> NTSTATUS ; } extern "C" { pub fn ZwCreateKey ( KeyHandle : PHANDLE , DesiredAccess : ACCESS_MASK , ObjectAttributes : POBJECT_ATTRIBUTES , TitleIndex : ULONG , Class : PUNICODE_STRING , CreateOptions : ULONG , Disposition : PULONG ) -> NTSTATUS ; } extern "C" { pub fn ZwCreateKeyTransacted ( KeyHandle : PHANDLE , DesiredAccess : ACCESS_MASK , ObjectAttributes : POBJECT_ATTRIBUTES , TitleIndex : ULONG , Class : PUNICODE_STRING , CreateOptions : ULONG , TransactionHandle : HANDLE , Disposition : PULONG ) -> NTSTATUS ; } extern "C" { pub fn ZwCreateRegistryTransaction ( TransactionHandle : PHANDLE , DesiredAccess : ACCESS_MASK , ObjectAttributes : POBJECT_ATTRIBUTES , CreateOptions : ULONG ) -> NTSTATUS ; } extern "C" { pub fn NtOpenRegistryTransaction ( TransactionHandle : PHANDLE , DesiredAccess : ACCESS_MASK , ObjectAttributes : POBJECT_ATTRIBUTES ) -> NTSTATUS ; } extern "C" { pub fn ZwCommitRegistryTransaction ( TransactionHandle : HANDLE , Flags : ULONG ) -> NTSTATUS ; } extern "C" { pub fn NtRollbackRegistryTransaction ( TransactionHandle : HANDLE , Flags : ULONG ) -> NTSTATUS ; } extern "C" { pub fn ZwOpenKey ( KeyHandle : PHANDLE , DesiredAccess : ACCESS_MASK , ObjectAttributes : POBJECT_ATTRIBUTES ) -> NTSTATUS ; } extern "C" { pub fn ZwOpenKeyEx ( KeyHandle : PHANDLE , DesiredAccess : ACCESS_MASK , ObjectAttributes : POBJECT_ATTRIBUTES , OpenOptions : ULONG ) -> NTSTATUS ; } extern "C" { pub fn ZwOpenKeyTransacted ( KeyHandle : PHANDLE , DesiredAccess : ACCESS_MASK , ObjectAttributes : POBJECT_ATTRIBUTES , TransactionHandle : HANDLE ) -> NTSTATUS ; } extern "C" { pub fn ZwOpenKeyTransactedEx ( KeyHandle : PHANDLE , DesiredAccess : ACCESS_MASK , ObjectAttributes : POBJECT_ATTRIBUTES , OpenOptions : ULONG , TransactionHandle : HANDLE ) -> NTSTATUS ; } extern "C" { pub fn ZwDeleteKey ( KeyHandle : HANDLE ) -> NTSTATUS ; } extern "C" { pub fn ZwDeleteValueKey ( KeyHandle : HANDLE , ValueName : PUNICODE_STRING ) -> NTSTATUS ; } extern "C" { pub fn ZwEnumerateKey ( KeyHandle : HANDLE , Index : ULONG , KeyInformationClass : KEY_INFORMATION_CLASS , KeyInformation : PVOID , Length : ULONG , ResultLength : PULONG ) -> NTSTATUS ; } extern "C" { pub fn ZwEnumerateValueKey ( KeyHandle : HANDLE , Index : ULONG , KeyValueInformationClass : KEY_VALUE_INFORMATION_CLASS , KeyValueInformation : PVOID , Length : ULONG , ResultLength : PULONG ) -> NTSTATUS ; } extern "C" { pub fn ZwFlushKey ( KeyHandle : HANDLE ) -> NTSTATUS ; } extern "C" { pub fn ZwQueryKey ( KeyHandle : HANDLE , KeyInformationClass : KEY_INFORMATION_CLASS , KeyInformation : PVOID , Length : ULONG , ResultLength : PULONG ) -> NTSTATUS ; } extern "C" { pub fn ZwQueryValueKey ( KeyHandle : HANDLE , ValueName : PUNICODE_STRING , KeyValueInformationClass : KEY_VALUE_INFORMATION_CLASS , KeyValueInformation : PVOID , Length : ULONG , ResultLength : PULONG ) -> NTSTATUS ; } extern "C" { pub fn ZwRenameKey ( KeyHandle : HANDLE , NewName : PUNICODE_STRING ) -> NTSTATUS ; } extern "C" { pub fn ZwSaveKey ( KeyHandle : HANDLE , FileHandle : HANDLE ) -> NTSTATUS ; } extern "C" { pub fn ZwSaveKeyEx ( KeyHandle : HANDLE , FileHandle : HANDLE , Format : ULONG ) -> NTSTATUS ; } extern "C" { pub fn ZwRestoreKey ( KeyHandle : HANDLE , FileHandle : HANDLE , Flags : ULONG ) -> NTSTATUS ; } extern "C" { pub fn ZwSetInformationKey ( KeyHandle : HANDLE , KeySetInformationClass : KEY_SET_INFORMATION_CLASS , KeySetInformation : PVOID , KeySetInformationLength : ULONG ) -> NTSTATUS ; } extern "C" { pub fn ZwSetValueKey ( KeyHandle : HANDLE , ValueName : PUNICODE_STRING , TitleIndex : ULONG , Type : ULONG , Data : PVOID , DataSize : ULONG ) -> NTSTATUS ; } extern "C" { pub fn ZwOpenSymbolicLinkObject ( LinkHandle : PHANDLE , DesiredAccess : ACCESS_MASK , ObjectAttributes : POBJECT_ATTRIBUTES ) -> NTSTATUS ; } extern "C" { pub fn ZwQuerySymbolicLinkObject ( LinkHandle : HANDLE , LinkTarget : PUNICODE_STRING , ReturnedLength : PULONG ) -> NTSTATUS ; } extern "C" { pub fn ZwCreateTransactionManager ( TmHandle : PHANDLE , DesiredAccess : ACCESS_MASK , ObjectAttributes : POBJECT_ATTRIBUTES , LogFileName : PUNICODE_STRING , CreateOptions : ULONG , CommitStrength : ULONG ) -> NTSTATUS ; } extern "C" { pub fn ZwOpenTransactionManager ( TmHandle : PHANDLE , DesiredAccess : ACCESS_MASK , ObjectAttributes : POBJECT_ATTRIBUTES , LogFileName : PUNICODE_STRING , TmIdentity : LPGUID , OpenOptions : ULONG ) -> NTSTATUS ; } extern "C" { pub fn ZwRollforwardTransactionManager ( TransactionManagerHandle : HANDLE , TmVirtualClock : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn ZwRecoverTransactionManager ( TransactionManagerHandle : HANDLE ) -> NTSTATUS ; } extern "C" { pub fn ZwQueryInformationTransactionManager ( TransactionManagerHandle : HANDLE , TransactionManagerInformationClass : TRANSACTIONMANAGER_INFORMATION_CLASS , TransactionManagerInformation : PVOID , TransactionManagerInformationLength : ULONG , ReturnLength : PULONG ) -> NTSTATUS ; } extern "C" { pub fn ZwSetInformationTransactionManager ( TmHandle : HANDLE , TransactionManagerInformationClass : TRANSACTIONMANAGER_INFORMATION_CLASS , TransactionManagerInformation : PVOID , TransactionManagerInformationLength : ULONG ) -> NTSTATUS ; } extern "C" { pub fn ZwEnumerateTransactionObject ( RootObjectHandle : HANDLE , QueryType : KTMOBJECT_TYPE , ObjectCursor : PKTMOBJECT_CURSOR , ObjectCursorLength : ULONG , ReturnLength : PULONG ) -> NTSTATUS ; } extern "C" { pub fn ZwCreateTransaction ( TransactionHandle : PHANDLE , DesiredAccess : ACCESS_MASK , ObjectAttributes : POBJECT_ATTRIBUTES , Uow : LPGUID , TmHandle : HANDLE , CreateOptions : ULONG , IsolationLevel : ULONG , IsolationFlags : ULONG , Timeout : PLARGE_INTEGER , Description : PUNICODE_STRING ) -> NTSTATUS ; } extern "C" { pub fn ZwOpenTransaction ( TransactionHandle : PHANDLE , DesiredAccess : ACCESS_MASK , ObjectAttributes : POBJECT_ATTRIBUTES , Uow : LPGUID , TmHandle : HANDLE ) -> NTSTATUS ; } extern "C" { pub fn ZwQueryInformationTransaction ( TransactionHandle : HANDLE , TransactionInformationClass : TRANSACTION_INFORMATION_CLASS , TransactionInformation : PVOID , TransactionInformationLength : ULONG , ReturnLength : PULONG ) -> NTSTATUS ; } extern "C" { pub fn ZwSetInformationTransaction ( TransactionHandle : HANDLE , TransactionInformationClass : TRANSACTION_INFORMATION_CLASS , TransactionInformation : PVOID , TransactionInformationLength : ULONG ) -> NTSTATUS ; } extern "C" { pub fn ZwCommitTransaction ( TransactionHandle : HANDLE , Wait : BOOLEAN ) -> NTSTATUS ; } extern "C" { pub fn ZwRollbackTransaction ( TransactionHandle : HANDLE , Wait : BOOLEAN ) -> NTSTATUS ; } extern "C" { pub fn ZwCreateResourceManager ( ResourceManagerHandle : PHANDLE , DesiredAccess : ACCESS_MASK , TmHandle : HANDLE , ResourceManagerGuid : LPGUID , ObjectAttributes : POBJECT_ATTRIBUTES , CreateOptions : ULONG , Description : PUNICODE_STRING ) -> NTSTATUS ; } extern "C" { pub fn ZwOpenResourceManager ( ResourceManagerHandle : PHANDLE , DesiredAccess : ACCESS_MASK , TmHandle : HANDLE , ResourceManagerGuid : LPGUID , ObjectAttributes : POBJECT_ATTRIBUTES ) -> NTSTATUS ; } extern "C" { pub fn ZwRecoverResourceManager ( ResourceManagerHandle : HANDLE ) -> NTSTATUS ; } extern "C" { pub fn ZwGetNotificationResourceManager ( ResourceManagerHandle : HANDLE , TransactionNotification : PTRANSACTION_NOTIFICATION , NotificationLength : ULONG , Timeout : PLARGE_INTEGER , ReturnLength : PULONG , Asynchronous : ULONG , AsynchronousContext : ULONG_PTR ) -> NTSTATUS ; } extern "C" { pub fn ZwQueryInformationResourceManager ( ResourceManagerHandle : HANDLE , ResourceManagerInformationClass : RESOURCEMANAGER_INFORMATION_CLASS , ResourceManagerInformation : PVOID , ResourceManagerInformationLength : ULONG , ReturnLength : PULONG ) -> NTSTATUS ; } extern "C" { pub fn ZwSetInformationResourceManager ( ResourceManagerHandle : HANDLE , ResourceManagerInformationClass : RESOURCEMANAGER_INFORMATION_CLASS , ResourceManagerInformation : PVOID , ResourceManagerInformationLength : ULONG ) -> NTSTATUS ; } extern "C" { pub fn ZwCreateEnlistment ( EnlistmentHandle : PHANDLE , DesiredAccess : ACCESS_MASK , ResourceManagerHandle : HANDLE , TransactionHandle : HANDLE , ObjectAttributes : POBJECT_ATTRIBUTES , CreateOptions : ULONG , NotificationMask : NOTIFICATION_MASK , EnlistmentKey : PVOID ) -> NTSTATUS ; } extern "C" { pub fn ZwOpenEnlistment ( EnlistmentHandle : PHANDLE , DesiredAccess : ACCESS_MASK , RmHandle : HANDLE , EnlistmentGuid : LPGUID , ObjectAttributes : POBJECT_ATTRIBUTES ) -> NTSTATUS ; } extern "C" { pub fn ZwQueryInformationEnlistment ( EnlistmentHandle : HANDLE , EnlistmentInformationClass : ENLISTMENT_INFORMATION_CLASS , EnlistmentInformation : PVOID , EnlistmentInformationLength : ULONG , ReturnLength : PULONG ) -> NTSTATUS ; } extern "C" { pub fn ZwSetInformationEnlistment ( EnlistmentHandle : HANDLE , EnlistmentInformationClass : ENLISTMENT_INFORMATION_CLASS , EnlistmentInformation : PVOID , EnlistmentInformationLength : ULONG ) -> NTSTATUS ; } extern "C" { pub fn ZwRecoverEnlistment ( EnlistmentHandle : HANDLE , EnlistmentKey : PVOID ) -> NTSTATUS ; } extern "C" { pub fn ZwPrePrepareEnlistment ( EnlistmentHandle : HANDLE , TmVirtualClock : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn ZwPrepareEnlistment ( EnlistmentHandle : HANDLE , TmVirtualClock : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn ZwCommitEnlistment ( EnlistmentHandle : HANDLE , TmVirtualClock : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn ZwRollbackEnlistment ( EnlistmentHandle : HANDLE , TmVirtualClock : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn ZwPrePrepareComplete ( EnlistmentHandle : HANDLE , TmVirtualClock : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn ZwPrepareComplete ( EnlistmentHandle : HANDLE , TmVirtualClock : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn ZwCommitComplete ( EnlistmentHandle : HANDLE , TmVirtualClock : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn ZwReadOnlyEnlistment ( EnlistmentHandle : HANDLE , TmVirtualClock : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn ZwRollbackComplete ( EnlistmentHandle : HANDLE , TmVirtualClock : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn ZwSinglePhaseReject ( EnlistmentHandle : HANDLE , TmVirtualClock : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn ZwOpenEvent ( EventHandle : PHANDLE , DesiredAccess : ACCESS_MASK , ObjectAttributes : POBJECT_ATTRIBUTES ) -> NTSTATUS ; } extern "C" { pub fn ZwQueryInformationByName ( ObjectAttributes : POBJECT_ATTRIBUTES , IoStatusBlock : PIO_STATUS_BLOCK , FileInformation : PVOID , Length : ULONG , FileInformationClass : FILE_INFORMATION_CLASS ) -> NTSTATUS ; } extern "C" { pub fn ZwQueryFullAttributesFile ( ObjectAttributes : POBJECT_ATTRIBUTES , FileInformation : PFILE_NETWORK_OPEN_INFORMATION ) -> NTSTATUS ; } pub type CLFS_CONTAINER_ID = ULONG ; pub type PCLFS_CONTAINER_ID = * mut CLFS_CONTAINER_ID ; pub type PPCLFS_CONTAINER_ID = * mut * mut CLFS_CONTAINER_ID ; # [ repr ( C ) ] pub struct _CLS_LSN { pub Internal : ULONGLONG , } pub type CLS_LSN = _CLS_LSN ; pub type PCLS_LSN = * mut _CLS_LSN ; pub type PPCLS_LSN = * mut * mut _CLS_LSN ; pub type CLFS_LSN = CLS_LSN ; pub type PCLFS_LSN = * mut CLFS_LSN ; pub type PPCLFS_LSN = * mut * mut CLFS_LSN ; extern "C" { # [ link_name = "\u{1}CLFS_LSN_INVALID" ] pub static mut CLFS_LSN_INVALID : CLFS_LSN ; } extern "C" { # [ link_name = "\u{1}CLFS_LSN_NULL" ] pub static mut CLFS_LSN_NULL : CLFS_LSN ; } pub type CLS_RECORD_TYPE = UCHAR ; pub type PCLS_RECORD_TYPE = * mut UCHAR ; pub type PPCLS_RECORD_TYPE = * mut * mut UCHAR ; pub type CLFS_RECORD_TYPE = CLS_RECORD_TYPE ; pub type PCLFS_RECORD_TYPE = * mut CLS_RECORD_TYPE ; pub type PPCLFS_RECORD_TYPE = * mut * mut CLS_RECORD_TYPE ; pub const _CLS_CONTEXT_MODE_ClsContextNone : _CLS_CONTEXT_MODE = 0 ; pub const _CLS_CONTEXT_MODE_ClsContextUndoNext : _CLS_CONTEXT_MODE = 1 ; pub const _CLS_CONTEXT_MODE_ClsContextPrevious : _CLS_CONTEXT_MODE = 2 ; pub const _CLS_CONTEXT_MODE_ClsContextForward : _CLS_CONTEXT_MODE = 3 ; pub type _CLS_CONTEXT_MODE = i32 ; pub use self :: _CLS_CONTEXT_MODE as CLS_CONTEXT_MODE ; pub type PCLS_CONTEXT_MODE = * mut _CLS_CONTEXT_MODE ; pub type PPCLS_CONTEXT_MODE = * mut * mut _CLS_CONTEXT_MODE ; pub const _CLFS_CONTEXT_MODE_ClfsContextNone : _CLFS_CONTEXT_MODE = 0 ; pub const _CLFS_CONTEXT_MODE_ClfsContextUndoNext : _CLFS_CONTEXT_MODE = 1 ; pub const _CLFS_CONTEXT_MODE_ClfsContextPrevious : _CLFS_CONTEXT_MODE = 2 ; pub const _CLFS_CONTEXT_MODE_ClfsContextForward : _CLFS_CONTEXT_MODE = 3 ; pub type _CLFS_CONTEXT_MODE = i32 ; pub use self :: _CLFS_CONTEXT_MODE as CLFS_CONTEXT_MODE ; pub type PCLFS_CONTEXT_MODE = * mut _CLFS_CONTEXT_MODE ; pub type PPCLFS_CONTEXT_MODE = * mut * mut _CLFS_CONTEXT_MODE ; # [ repr ( C ) ] pub struct _CLFS_NODE_ID { pub cType : ULONG , pub cbNode : ULONG , } pub type CLFS_NODE_ID = _CLFS_NODE_ID ; pub type PCLFS_NODE_ID = * mut _CLFS_NODE_ID ; # [ repr ( C ) ] pub struct _CLS_WRITE_ENTRY { pub Buffer : PVOID , pub ByteLength : ULONG , } pub type CLS_WRITE_ENTRY = _CLS_WRITE_ENTRY ; pub type PCLS_WRITE_ENTRY = * mut _CLS_WRITE_ENTRY ; pub type PPCLS_WRITE_ENTRY = * mut * mut _CLS_WRITE_ENTRY ; pub type CLFS_WRITE_ENTRY = CLS_WRITE_ENTRY ; pub type PCLFS_WRITE_ENTRY = * mut CLFS_WRITE_ENTRY ; pub type PPCLFS_WRITE_ENTRY = * mut * mut CLFS_WRITE_ENTRY ; pub type CLFS_LOG_ID = GUID ; # [ repr ( C ) ] pub struct _CLS_INFORMATION { pub TotalAvailable : LONGLONG , pub CurrentAvailable : LONGLONG , pub TotalReservation : LONGLONG , pub BaseFileSize : ULONGLONG , pub ContainerSize : ULONGLONG , pub TotalContainers : ULONG , pub FreeContainers : ULONG , pub TotalClients : ULONG , pub Attributes : ULONG , pub FlushThreshold : ULONG , pub SectorSize : ULONG , pub MinArchiveTailLsn : CLS_LSN , pub BaseLsn : CLS_LSN , pub LastFlushedLsn : CLS_LSN , pub LastLsn : CLS_LSN , pub RestartLsn : CLS_LSN , pub Identity : GUID , } pub type CLS_INFORMATION = _CLS_INFORMATION ; pub type PCLS_INFORMATION = * mut _CLS_INFORMATION ; pub type PPCLS_INFORMATION = * mut _CLS_INFORMATION ; pub type CLFS_INFORMATION = CLS_INFORMATION ; pub type PCLFS_INFORMATION = * mut CLFS_INFORMATION ; pub type PPCLFS_INFORMATION = * mut CLFS_INFORMATION ; # [ repr ( C ) ] pub struct _CLFS_LOG_NAME_INFORMATION { pub NameLengthInBytes : USHORT , pub Name : [ WCHAR ; 1usize ] , } pub type CLFS_LOG_NAME_INFORMATION = _CLFS_LOG_NAME_INFORMATION ; pub type PCLFS_LOG_NAME_INFORMATION = * mut _CLFS_LOG_NAME_INFORMATION ; pub type PPCLFS_LOG_NAME_INFORMATION = * mut * mut _CLFS_LOG_NAME_INFORMATION ; # [ repr ( C ) ] pub struct _CLFS_STREAM_ID_INFORMATION { pub StreamIdentifier : UCHAR , } pub type CLFS_STREAM_ID_INFORMATION = _CLFS_STREAM_ID_INFORMATION ; pub type PCLFS_STREAM_ID_INFORMATION = * mut _CLFS_STREAM_ID_INFORMATION ; pub type PPCLFS_STREAM_ID_INFORMATION = * mut * mut _CLFS_STREAM_ID_INFORMATION ; # [ repr ( C ) ] pub struct _CLFS_PHYSICAL_LSN_INFORMATION { pub StreamIdentifier : UCHAR , pub VirtualLsn : CLFS_LSN , pub PhysicalLsn : CLFS_LSN , } pub type CLFS_PHYSICAL_LSN_INFORMATION = _CLFS_PHYSICAL_LSN_INFORMATION ; pub type PCLFS_PHYSICAL_LSN_INFORMATION = * mut _CLFS_PHYSICAL_LSN_INFORMATION ; pub type CLS_CONTAINER_STATE = UINT32 ; pub type PCLS_CONTAINER_STATE = * mut UINT32 ; pub type PPCLS_CONTAINER_STATE = * mut UINT32 ; pub type CLFS_CONTAINER_STATE = CLS_CONTAINER_STATE ; pub type PCLFS_CONTAINER_STATE = * mut CLS_CONTAINER_STATE ; pub type PPCLFS_CONTAINER_STATE = * mut CLS_CONTAINER_STATE ; # [ repr ( C ) ] pub struct _CLS_CONTAINER_INFORMATION { pub FileAttributes : ULONG , pub CreationTime : ULONGLONG , pub LastAccessTime : ULONGLONG , pub LastWriteTime : ULONGLONG , pub ContainerSize : LONGLONG , pub FileNameActualLength : ULONG , pub FileNameLength : ULONG , pub FileName : [ WCHAR ; 256usize ] , pub State : CLFS_CONTAINER_STATE , pub PhysicalContainerId : CLFS_CONTAINER_ID , pub LogicalContainerId : CLFS_CONTAINER_ID , } pub type CLS_CONTAINER_INFORMATION = _CLS_CONTAINER_INFORMATION ; pub type PCLS_CONTAINER_INFORMATION = * mut _CLS_CONTAINER_INFORMATION ; pub type PPCLS_CONTAINER_INFORMATION = * mut * mut _CLS_CONTAINER_INFORMATION ; pub type CLFS_CONTAINER_INFORMATION = CLS_CONTAINER_INFORMATION ; pub type PCLFS_CONTAINER_INFORMATION = * mut CLFS_CONTAINER_INFORMATION ; pub type PPCLFS_CONTAINER_INFORMATION = * mut * mut CLFS_CONTAINER_INFORMATION ; pub const _CLS_LOG_INFORMATION_CLASS_ClfsLogBasicInformation : _CLS_LOG_INFORMATION_CLASS = 0 ; pub const _CLS_LOG_INFORMATION_CLASS_ClfsLogBasicInformationPhysical : _CLS_LOG_INFORMATION_CLASS = 1 ; pub const _CLS_LOG_INFORMATION_CLASS_ClfsLogPhysicalNameInformation : _CLS_LOG_INFORMATION_CLASS = 2 ; pub const _CLS_LOG_INFORMATION_CLASS_ClfsLogStreamIdentifierInformation : _CLS_LOG_INFORMATION_CLASS = 3 ; pub const _CLS_LOG_INFORMATION_CLASS_ClfsLogSystemMarkingInformation : _CLS_LOG_INFORMATION_CLASS = 4 ; pub const _CLS_LOG_INFORMATION_CLASS_ClfsLogPhysicalLsnInformation : _CLS_LOG_INFORMATION_CLASS = 5 ; pub type _CLS_LOG_INFORMATION_CLASS = i32 ; pub use self :: _CLS_LOG_INFORMATION_CLASS as CLS_LOG_INFORMATION_CLASS ; pub type PCLS_LOG_INFORMATION_CLASS = * mut _CLS_LOG_INFORMATION_CLASS ; pub type PPCLS_LOG_INFORMATION_CLASS = * mut * mut _CLS_LOG_INFORMATION_CLASS ; pub use self :: CLS_LOG_INFORMATION_CLASS as CLFS_LOG_INFORMATION_CLASS ; pub type PCLFS_LOG_INFORMATION_CLASS = * mut CLFS_LOG_INFORMATION_CLASS ; pub type PPCLFS_LOG_INFORMATION_CLASS = * mut * mut CLFS_LOG_INFORMATION_CLASS ; pub const _CLS_IOSTATS_CLASS_ClsIoStatsDefault : _CLS_IOSTATS_CLASS = 0 ; pub const _CLS_IOSTATS_CLASS_ClsIoStatsMax : _CLS_IOSTATS_CLASS = 65535 ; pub type _CLS_IOSTATS_CLASS = i32 ; pub use self :: _CLS_IOSTATS_CLASS as CLS_IOSTATS_CLASS ; pub type PCLS_IOSTATS_CLASS = * mut _CLS_IOSTATS_CLASS ; pub type PPCLS_IOSTATS_CLASS = * mut * mut _CLS_IOSTATS_CLASS ; pub const _CLFS_IOSTATS_CLASS_ClfsIoStatsDefault : _CLFS_IOSTATS_CLASS = 0 ; pub const _CLFS_IOSTATS_CLASS_ClfsIoStatsMax : _CLFS_IOSTATS_CLASS = 65535 ; pub type _CLFS_IOSTATS_CLASS = i32 ; pub use self :: _CLFS_IOSTATS_CLASS as CLFS_IOSTATS_CLASS ; pub type PCLFS_IOSTATS_CLASS = * mut _CLFS_IOSTATS_CLASS ; pub type PPCLFS_IOSTATS_CLASS = * mut * mut _CLFS_IOSTATS_CLASS ; # [ repr ( C ) ] pub struct _CLS_IO_STATISTICS_HEADER { pub ubMajorVersion : UCHAR , pub ubMinorVersion : UCHAR , pub eStatsClass : CLFS_IOSTATS_CLASS , pub cbLength : USHORT , pub coffData : ULONG , } pub type CLS_IO_STATISTICS_HEADER = _CLS_IO_STATISTICS_HEADER ; pub type PCLS_IO_STATISTICS_HEADER = * mut _CLS_IO_STATISTICS_HEADER ; pub type PPCLS_IO_STATISTICS_HEADER = * mut * mut _CLS_IO_STATISTICS_HEADER ; pub type CLFS_IO_STATISTICS_HEADER = CLS_IO_STATISTICS_HEADER ; pub type PCLFS_IO_STATISTICS_HEADER = * mut CLFS_IO_STATISTICS_HEADER ; pub type PPCLFS_IO_STATISTICS_HEADER = * mut * mut CLFS_IO_STATISTICS_HEADER ; # [ repr ( C ) ] pub struct _CLS_IO_STATISTICS { pub hdrIoStats : CLS_IO_STATISTICS_HEADER , pub cFlush : ULONGLONG , pub cbFlush : ULONGLONG , pub cMetaFlush : ULONGLONG , pub cbMetaFlush : ULONGLONG , } pub type CLS_IO_STATISTICS = _CLS_IO_STATISTICS ; pub type PCLS_IO_STATISTICS = * mut _CLS_IO_STATISTICS ; pub type PPCLS_IO_STATISTICS = * mut * mut _CLS_IO_STATISTICS ; pub type CLFS_IO_STATISTICS = CLS_IO_STATISTICS ; pub type PCLFS_IO_STATISTICS = * mut CLFS_IO_STATISTICS ; pub type PPCLFS_IO_STATISTICS = * mut * mut CLFS_IO_STATISTICS ; pub type CLFS_SCAN_MODE = UCHAR ; pub type PCLFS_SCAN_MODE = * mut UCHAR ; pub type LOG_FILE_OBJECT = FILE_OBJECT ; pub type PLOG_FILE_OBJECT = * mut FILE_OBJECT ; pub type PPLOG_FILE_OBJECT = * mut * mut FILE_OBJECT ; # [ repr ( C ) ] pub struct _CLS_SCAN_CONTEXT { pub cidNode : CLFS_NODE_ID , pub plfoLog : PLOG_FILE_OBJECT , pub cIndex : ULONG , pub __bindgen_padding_0 : u32 , pub cContainers : ULONG , pub __bindgen_padding_1 : u32 , pub cContainersReturned : ULONG , pub __bindgen_padding_2 : [ u8 ; 4usize ] , pub eScanMode : CLFS_SCAN_MODE , pub pinfoContainer : PCLS_CONTAINER_INFORMATION , } pub type CLS_SCAN_CONTEXT = _CLS_SCAN_CONTEXT ; pub type PCLS_SCAN_CONTEXT = * mut _CLS_SCAN_CONTEXT ; pub type PPCLS_SCAN_CONTEXT = * mut * mut _CLS_SCAN_CONTEXT ; pub type CLFS_SCAN_CONTEXT = CLS_SCAN_CONTEXT ; pub type PCLFS_SCAN_CONTEXT = * mut CLFS_SCAN_CONTEXT ; pub type PPCLFS_SCAN_CONTEXT = * mut * mut CLFS_SCAN_CONTEXT ; # [ repr ( C ) ] pub struct _CLS_ARCHIVE_DESCRIPTOR { pub coffLow : ULONGLONG , pub coffHigh : ULONGLONG , pub infoContainer : CLS_CONTAINER_INFORMATION , } pub type CLS_ARCHIVE_DESCRIPTOR = _CLS_ARCHIVE_DESCRIPTOR ; pub type PCLS_ARCHIVE_DESCRIPTOR = * mut _CLS_ARCHIVE_DESCRIPTOR ; pub type PPCLS_ARCHIVE_DESCRIPTOR = * mut * mut _CLS_ARCHIVE_DESCRIPTOR ; pub type CLFS_ARCHIVE_DESCRIPTOR = CLS_ARCHIVE_DESCRIPTOR ; pub type PCLFS_ARCHIVE_DESCRIPTOR = * mut CLFS_ARCHIVE_DESCRIPTOR ; pub type PPCLFS_ARCHIVE_DESCRIPTOR = * mut * mut CLFS_ARCHIVE_DESCRIPTOR ; pub type CLFS_BLOCK_ALLOCATION = :: std :: option :: Option < unsafe extern "C" fn ( cbBufferLength : ULONG , pvUserContext : PVOID ) -> PVOID > ; pub type CLFS_BLOCK_DEALLOCATION = :: std :: option :: Option < unsafe extern "C" fn ( pvBuffer : PVOID , pvUserContext : PVOID ) > ; pub const _CLFS_LOG_ARCHIVE_MODE_ClfsLogArchiveEnabled : _CLFS_LOG_ARCHIVE_MODE = 1 ; pub const _CLFS_LOG_ARCHIVE_MODE_ClfsLogArchiveDisabled : _CLFS_LOG_ARCHIVE_MODE = 2 ; pub type _CLFS_LOG_ARCHIVE_MODE = i32 ; pub use self :: _CLFS_LOG_ARCHIVE_MODE as CLFS_LOG_ARCHIVE_MODE ; pub type PCLFS_LOG_ARCHIVE_MODE = * mut _CLFS_LOG_ARCHIVE_MODE ; extern "C" { pub fn ClfsLsnEqual ( plsn1 : * const CLFS_LSN , plsn2 : * const CLFS_LSN ) -> BOOLEAN ; } extern "C" { pub fn ClfsLsnLess ( plsn1 : * const CLFS_LSN , plsn2 : * const CLFS_LSN ) -> BOOLEAN ; } extern "C" { pub fn ClfsLsnGreater ( plsn1 : * const CLFS_LSN , plsn2 : * const CLFS_LSN ) -> BOOLEAN ; } extern "C" { pub fn ClfsLsnNull ( plsn : * const CLFS_LSN ) -> BOOLEAN ; } extern "C" { pub fn ClfsLsnContainer ( plsn : * const CLFS_LSN ) -> CLFS_CONTAINER_ID ; } extern "C" { pub fn ClfsLsnCreate ( cidContainer : CLFS_CONTAINER_ID , offBlock : ULONG , cRecord : ULONG ) -> CLFS_LSN ; } extern "C" { pub fn ClfsLsnBlockOffset ( plsn : * const CLFS_LSN ) -> ULONG ; } extern "C" { pub fn ClfsLsnRecordSequence ( plsn : * const CLFS_LSN ) -> ULONG ; } extern "C" { pub fn ClfsLsnInvalid ( plsn : * const CLFS_LSN ) -> BOOLEAN ; } extern "C" { pub fn ClfsLsnIncrement ( plsn : PCLFS_LSN ) -> CLFS_LSN ; } pub const _CLFS_MGMT_POLICY_TYPE_ClfsMgmtPolicyMaximumSize : _CLFS_MGMT_POLICY_TYPE = 0 ; pub const _CLFS_MGMT_POLICY_TYPE_ClfsMgmtPolicyMinimumSize : _CLFS_MGMT_POLICY_TYPE = 1 ; pub const _CLFS_MGMT_POLICY_TYPE_ClfsMgmtPolicyNewContainerSize : _CLFS_MGMT_POLICY_TYPE = 2 ; pub const _CLFS_MGMT_POLICY_TYPE_ClfsMgmtPolicyGrowthRate : _CLFS_MGMT_POLICY_TYPE = 3 ; pub const _CLFS_MGMT_POLICY_TYPE_ClfsMgmtPolicyLogTail : _CLFS_MGMT_POLICY_TYPE = 4 ; pub const _CLFS_MGMT_POLICY_TYPE_ClfsMgmtPolicyAutoShrink : _CLFS_MGMT_POLICY_TYPE = 5 ; pub const _CLFS_MGMT_POLICY_TYPE_ClfsMgmtPolicyAutoGrow : _CLFS_MGMT_POLICY_TYPE = 6 ; pub const _CLFS_MGMT_POLICY_TYPE_ClfsMgmtPolicyNewContainerPrefix : _CLFS_MGMT_POLICY_TYPE = 7 ; pub const _CLFS_MGMT_POLICY_TYPE_ClfsMgmtPolicyNewContainerSuffix : _CLFS_MGMT_POLICY_TYPE = 8 ; pub const _CLFS_MGMT_POLICY_TYPE_ClfsMgmtPolicyNewContainerExtension : _CLFS_MGMT_POLICY_TYPE = 9 ; pub const _CLFS_MGMT_POLICY_TYPE_ClfsMgmtPolicyInvalid : _CLFS_MGMT_POLICY_TYPE = 10 ; pub type _CLFS_MGMT_POLICY_TYPE = i32 ; pub use self :: _CLFS_MGMT_POLICY_TYPE as CLFS_MGMT_POLICY_TYPE ; pub type PCLFS_MGMT_POLICY_TYPE = * mut _CLFS_MGMT_POLICY_TYPE ; # [ repr ( C ) ] pub struct _CLFS_MGMT_POLICY { pub Version : ULONG , pub LengthInBytes : ULONG , pub PolicyFlags : ULONG , pub PolicyType : CLFS_MGMT_POLICY_TYPE , pub PolicyParameters : _CLFS_MGMT_POLICY__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _CLFS_MGMT_POLICY__bindgen_ty_1 { pub MaximumSize : __BindgenUnionField < _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_1 > , pub MinimumSize : __BindgenUnionField < _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_2 > , pub NewContainerSize : __BindgenUnionField < _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_3 > , pub GrowthRate : __BindgenUnionField < _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_4 > , pub LogTail : __BindgenUnionField < _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_5 > , pub AutoShrink : __BindgenUnionField < _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_6 > , pub AutoGrow : __BindgenUnionField < _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_7 > , pub NewContainerPrefix : __BindgenUnionField < _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_8 > , pub NewContainerSuffix : __BindgenUnionField < _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_9 > , pub NewContainerExtension : __BindgenUnionField < _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_10 > , pub bindgen_union_field : u64 , } # [ repr ( C ) ] pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_1 { pub Containers : ULONG , } # [ repr ( C ) ] pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_2 { pub Containers : ULONG , } # [ repr ( C ) ] pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_3 { pub SizeInBytes : ULONG , } # [ repr ( C ) ] pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_4 { pub AbsoluteGrowthInContainers : ULONG , pub RelativeGrowthPercentage : ULONG , } # [ repr ( C ) ] pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_5 { pub MinimumAvailablePercentage : ULONG , pub MinimumAvailableContainers : ULONG , } # [ repr ( C ) ] pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_6 { pub Percentage : ULONG , } # [ repr ( C ) ] pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_7 { pub Enabled : ULONG , } # [ repr ( C ) ] pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_8 { pub PrefixLengthInBytes : USHORT , pub PrefixString : [ WCHAR ; 1usize ] , } # [ repr ( C ) ] pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_9 { pub NextContainerSuffix : ULONGLONG , } # [ repr ( C ) ] pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_10 { pub ExtensionLengthInBytes : USHORT , pub ExtensionString : [ WCHAR ; 1usize ] , } pub type CLFS_MGMT_POLICY = _CLFS_MGMT_POLICY ; pub type PCLFS_MGMT_POLICY = * mut _CLFS_MGMT_POLICY ; pub const _CLFS_MGMT_NOTIFICATION_TYPE_ClfsMgmtAdvanceTailNotification : _CLFS_MGMT_NOTIFICATION_TYPE = 0 ; pub const _CLFS_MGMT_NOTIFICATION_TYPE_ClfsMgmtLogFullHandlerNotification : _CLFS_MGMT_NOTIFICATION_TYPE = 1 ; pub const _CLFS_MGMT_NOTIFICATION_TYPE_ClfsMgmtLogUnpinnedNotification : _CLFS_MGMT_NOTIFICATION_TYPE = 2 ; pub const _CLFS_MGMT_NOTIFICATION_TYPE_ClfsMgmtLogWriteNotification : _CLFS_MGMT_NOTIFICATION_TYPE = 3 ; pub type _CLFS_MGMT_NOTIFICATION_TYPE = i32 ; pub use self :: _CLFS_MGMT_NOTIFICATION_TYPE as CLFS_MGMT_NOTIFICATION_TYPE ; pub type PCLFS_MGMT_NOTIFICATION_TYPE = * mut _CLFS_MGMT_NOTIFICATION_TYPE ; # [ repr ( C ) ] pub struct _CLFS_MGMT_NOTIFICATION { pub Notification : CLFS_MGMT_NOTIFICATION_TYPE , pub Lsn : CLFS_LSN , pub LogIsPinned : USHORT , } pub type CLFS_MGMT_NOTIFICATION = _CLFS_MGMT_NOTIFICATION ; pub type PCLFS_MGMT_NOTIFICATION = * mut _CLFS_MGMT_NOTIFICATION ; pub type PCLFS_CLIENT_ADVANCE_TAIL_CALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( LogFile : PLOG_FILE_OBJECT , TargetLsn : PCLFS_LSN , ClientData : PVOID ) -> NTSTATUS > ; pub type PCLFS_CLIENT_LFF_HANDLER_COMPLETE_CALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( LogFile : PLOG_FILE_OBJECT , OperationStatus : NTSTATUS , LogIsPinned : BOOLEAN , ClientData : PVOID ) > ; pub type PCLFS_CLIENT_LOG_UNPINNED_CALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( LogFile : PLOG_FILE_OBJECT , ClientData : PVOID ) > ; pub type PCLFS_SET_LOG_SIZE_COMPLETE_CALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( LogFile : PLOG_FILE_OBJECT , OperationStatus : NTSTATUS , ClientData : PVOID ) > ; # [ repr ( C ) ] pub struct _CLFS_MGMT_CLIENT_REGISTRATION { pub Version : ULONG , pub AdvanceTailCallback : PCLFS_CLIENT_ADVANCE_TAIL_CALLBACK , pub AdvanceTailCallbackData : PVOID , pub LogGrowthCompleteCallback : PCLFS_CLIENT_LFF_HANDLER_COMPLETE_CALLBACK , pub LogGrowthCompleteCallbackData : PVOID , pub LogUnpinnedCallback : PCLFS_CLIENT_LOG_UNPINNED_CALLBACK , pub LogUnpinnedCallbackData : PVOID , } pub type CLFS_MGMT_CLIENT_REGISTRATION = _CLFS_MGMT_CLIENT_REGISTRATION ; pub type PCLFS_MGMT_CLIENT_REGISTRATION = * mut _CLFS_MGMT_CLIENT_REGISTRATION ; pub type CLFS_MGMT_CLIENT = PVOID ; pub type PCLFS_MGMT_CLIENT = * mut PVOID ; extern "C" { pub fn ClfsMgmtRegisterManagedClient ( LogFile : PLOG_FILE_OBJECT , RegistrationData : PCLFS_MGMT_CLIENT_REGISTRATION , ClientCookie : PCLFS_MGMT_CLIENT ) -> NTSTATUS ; } extern "C" { pub fn ClfsMgmtDeregisterManagedClient ( ClientCookie : CLFS_MGMT_CLIENT ) -> NTSTATUS ; } extern "C" { pub fn ClfsMgmtTailAdvanceFailure ( Client : CLFS_MGMT_CLIENT , Reason : NTSTATUS ) -> NTSTATUS ; } extern "C" { pub fn ClfsMgmtHandleLogFileFull ( Client : CLFS_MGMT_CLIENT ) -> NTSTATUS ; } extern "C" { pub fn ClfsMgmtInstallPolicy ( LogFile : PLOG_FILE_OBJECT , Policy : PCLFS_MGMT_POLICY , PolicyLength : ULONG ) -> NTSTATUS ; } extern "C" { pub fn ClfsMgmtQueryPolicy ( LogFile : PLOG_FILE_OBJECT , PolicyType : CLFS_MGMT_POLICY_TYPE , Policy : PCLFS_MGMT_POLICY , PolicyLength : PULONG ) -> NTSTATUS ; } extern "C" { pub fn ClfsMgmtRemovePolicy ( LogFile : PLOG_FILE_OBJECT , PolicyType : CLFS_MGMT_POLICY_TYPE ) -> NTSTATUS ; } extern "C" { pub fn ClfsMgmtSetLogFileSize ( LogFile : PLOG_FILE_OBJECT , NewSizeInContainers : PULONGLONG , ResultingSizeInContainers : PULONGLONG , CompletionRoutine : PCLFS_SET_LOG_SIZE_COMPLETE_CALLBACK , CompletionRoutineData : PVOID ) -> NTSTATUS ; } extern "C" { pub fn ClfsMgmtSetLogFileSizeAsClient ( LogFile : PLOG_FILE_OBJECT , ClientCookie : PCLFS_MGMT_CLIENT , NewSizeInContainers : PULONGLONG , ResultingSizeInContainers : PULONGLONG , CompletionRoutine : PCLFS_SET_LOG_SIZE_COMPLETE_CALLBACK , CompletionRoutineData : PVOID ) -> NTSTATUS ; } extern "C" { pub fn ClfsInitialize ( ) -> NTSTATUS ; } extern "C" { pub fn ClfsFinalize ( ) ; } extern "C" { pub fn ClfsCreateLogFile ( pplfoLog : PPLOG_FILE_OBJECT , puszLogFileName : PUNICODE_STRING , fDesiredAccess : ACCESS_MASK , dwShareMode : ULONG , psdLogFile : PSECURITY_DESCRIPTOR , fCreateDisposition : ULONG , fCreateOptions : ULONG , fFlagsAndAttributes : ULONG , fLogOptionFlag : ULONG , pvContext : PVOID , cbContext : ULONG ) -> NTSTATUS ; } extern "C" { pub fn ClfsDeleteLogByPointer ( plfoLog : PLOG_FILE_OBJECT ) -> NTSTATUS ; } extern "C" { pub fn ClfsDeleteLogFile ( puszLogFileName : PUNICODE_STRING , pvReserved : PVOID , fLogOptionFlag : ULONG , pvContext : PVOID , cbContext : ULONG ) -> NTSTATUS ; } extern "C" { pub fn ClfsAddLogContainer ( plfoLog : PLOG_FILE_OBJECT , pcbContainer : PULONGLONG , puszContainerPath : PUNICODE_STRING ) -> NTSTATUS ; } extern "C" { pub fn ClfsAddLogContainerSet ( plfoLog : PLOG_FILE_OBJECT , cContainers : USHORT , pcbContainer : PULONGLONG , rguszContainerPath : PUNICODE_STRING ) -> NTSTATUS ; } extern "C" { pub fn ClfsRemoveLogContainer ( plfoLog : PLOG_FILE_OBJECT , puszContainerPath : PUNICODE_STRING , fForce : BOOLEAN ) -> NTSTATUS ; } extern "C" { pub fn ClfsRemoveLogContainerSet ( plfoLog : PLOG_FILE_OBJECT , cContainers : USHORT , rgwszContainerPath : PUNICODE_STRING , fForce : BOOLEAN ) -> NTSTATUS ; } extern "C" { pub fn ClfsSetArchiveTail ( plfoLog : PLOG_FILE_OBJECT , plsnArchiveTail : PCLFS_LSN ) -> NTSTATUS ; } extern "C" { pub fn ClfsSetEndOfLog ( plfoLog : PLOG_FILE_OBJECT , plsnEnd : PCLFS_LSN ) -> NTSTATUS ; } extern "C" { pub fn ClfsCreateScanContext ( plfoLog : PLOG_FILE_OBJECT , cFromContainer : ULONG , cContainers : ULONG , eScanMode : CLFS_SCAN_MODE , pcxScan : PCLFS_SCAN_CONTEXT ) -> NTSTATUS ; } extern "C" { pub fn ClfsScanLogContainers ( pcxScan : PCLFS_SCAN_CONTEXT , eScanMode : CLFS_SCAN_MODE ) -> NTSTATUS ; } extern "C" { pub fn ClfsGetContainerName ( plfoLog : PLOG_FILE_OBJECT , cidLogicalContainer : CLFS_CONTAINER_ID , puszContainerName : PUNICODE_STRING , pcActualLenContainerName : PULONG ) -> NTSTATUS ; } extern "C" { pub fn ClfsGetLogFileInformation ( plfoLog : PLOG_FILE_OBJECT , pinfoBuffer : PCLFS_INFORMATION , pcbInfoBuffer : PULONG ) -> NTSTATUS ; } extern "C" { pub fn ClfsQueryLogFileInformation ( plfoLog : PLOG_FILE_OBJECT , eInformationClass : CLFS_LOG_INFORMATION_CLASS , pinfoInputBuffer : PVOID , cbinfoInputBuffer : ULONG , pinfoBuffer : PVOID , pcbInfoBuffer : PULONG ) -> NTSTATUS ; } extern "C" { pub fn ClfsSetLogFileInformation ( plfoLog : PLOG_FILE_OBJECT , eInformationClass : CLFS_LOG_INFORMATION_CLASS , pinfoBuffer : PVOID , cbBuffer : ULONG ) -> NTSTATUS ; } extern "C" { pub fn ClfsReadRestartArea ( pvMarshalContext : PVOID , ppvRestartBuffer : * mut PVOID , pcbRestartBuffer : PULONG , plsn : PCLFS_LSN , ppvReadContext : * mut PVOID ) -> NTSTATUS ; } extern "C" { pub fn ClfsReadPreviousRestartArea ( pvReadContext : PVOID , ppvRestartBuffer : * mut PVOID , pcbRestartBuffer : PULONG , plsnRestart : PCLFS_LSN ) -> NTSTATUS ; } extern "C" { pub fn ClfsWriteRestartArea ( pvMarshalContext : PVOID , pvRestartBuffer : PVOID , cbRestartBuffer : ULONG , plsnBase : PCLFS_LSN , fFlags : ULONG , pcbWritten : PULONG , plsnNext : PCLFS_LSN ) -> NTSTATUS ; } extern "C" { pub fn ClfsAdvanceLogBase ( pvMarshalContext : PVOID , plsnBase : PCLFS_LSN , fFlags : ULONG ) -> NTSTATUS ; } extern "C" { pub fn ClfsCloseAndResetLogFile ( plfoLog : PLOG_FILE_OBJECT ) -> NTSTATUS ; } extern "C" { pub fn ClfsCloseLogFileObject ( plfoLog : PLOG_FILE_OBJECT ) -> NTSTATUS ; } extern "C" { pub fn ClfsCreateMarshallingArea ( plfoLog : PLOG_FILE_OBJECT , ePoolType : POOL_TYPE , pfnAllocBuffer : PALLOCATE_FUNCTION , pfnFreeBuffer : PFREE_FUNCTION , cbMarshallingBuffer : ULONG , cMaxWriteBuffers : ULONG , cMaxReadBuffers : ULONG , ppvMarshalContext : * mut PVOID ) -> NTSTATUS ; } extern "C" { pub fn ClfsDeleteMarshallingArea ( pvMarshalContext : PVOID ) -> NTSTATUS ; } extern "C" { pub fn ClfsReserveAndAppendLog ( pvMarshalContext : PVOID , rgWriteEntries : PCLFS_WRITE_ENTRY , cWriteEntries : ULONG , plsnUndoNext : PCLFS_LSN , plsnPrevious : PCLFS_LSN , cReserveRecords : ULONG , rgcbReservation : PLONGLONG , fFlags : ULONG , plsn : PCLFS_LSN ) -> NTSTATUS ; } extern "C" { pub fn ClfsReserveAndAppendLogAligned ( pvMarshalContext : PVOID , rgWriteEntries : PCLFS_WRITE_ENTRY , cWriteEntries : ULONG , cbEntryAlignment : ULONG , plsnUndoNext : PCLFS_LSN , plsnPrevious : PCLFS_LSN , cReserveRecords : ULONG , rgcbReservation : PLONGLONG , fFlags : ULONG , plsn : PCLFS_LSN ) -> NTSTATUS ; } extern "C" { pub fn ClfsAlignReservedLog ( pvMarshalContext : PVOID , cRecords : ULONG , rgcbReservation : * mut LONGLONG , pcbAlignReservation : PLONGLONG ) -> NTSTATUS ; } extern "C" { pub fn ClfsAllocReservedLog ( pvMarshalContext : PVOID , cRecords : ULONG , pcbAdjustment : PLONGLONG ) -> NTSTATUS ; } extern "C" { pub fn ClfsFreeReservedLog ( pvMarshalContext : PVOID , cRecords : ULONG , pcbAdjustment : PLONGLONG ) -> NTSTATUS ; } extern "C" { pub fn ClfsFlushBuffers ( pvMarshalContext : PVOID ) -> NTSTATUS ; } extern "C" { pub fn ClfsFlushToLsn ( pvMarshalContext : PVOID , plsnFlush : PCLFS_LSN , plsnLastFlushed : PCLFS_LSN ) -> NTSTATUS ; } extern "C" { pub fn ClfsReadLogRecord ( pvMarshalContext : PVOID , plsnFirst : PCLFS_LSN , peContextMode : CLFS_CONTEXT_MODE , ppvReadBuffer : * mut PVOID , pcbReadBuffer : PULONG , peRecordType : PCLFS_RECORD_TYPE , plsnUndoNext : PCLFS_LSN , plsnPrevious : PCLFS_LSN , ppvReadContext : * mut PVOID ) -> NTSTATUS ; } extern "C" { pub fn ClfsReadNextLogRecord ( pvReadContext : PVOID , ppvBuffer : * mut PVOID , pcbBuffer : PULONG , peRecordType : PCLFS_RECORD_TYPE , plsnUser : PCLFS_LSN , plsnUndoNext : PCLFS_LSN , plsnPrevious : PCLFS_LSN , plsnRecord : PCLFS_LSN ) -> NTSTATUS ; } extern "C" { pub fn ClfsTerminateReadLog ( pvCursorContext : PVOID ) -> NTSTATUS ; } extern "C" { pub fn ClfsGetLastLsn ( plfoLog : PLOG_FILE_OBJECT , plsnLast : PCLFS_LSN ) -> NTSTATUS ; } extern "C" { pub fn ClfsGetIoStatistics ( plfoLog : PLOG_FILE_OBJECT , pvStatsBuffer : PVOID , cbStatsBuffer : ULONG , eStatsClass : CLFS_IOSTATS_CLASS , pcbStatsWritten : PULONG ) -> NTSTATUS ; } extern "C" { pub fn ClfsLaterLsn ( plsn : PCLFS_LSN ) -> CLFS_LSN ; } extern "C" { pub fn ClfsEarlierLsn ( plsn : PCLFS_LSN ) -> CLFS_LSN ; } extern "C" { pub fn ClfsLsnDifference ( plsnStart : PCLFS_LSN , plsnFinish : PCLFS_LSN , cbContainer : ULONG , cbMaxBlock : ULONG , pcbDifference : PLONGLONG ) -> NTSTATUS ; } extern "C" { pub fn ClfsValidTopLevelContext ( pirpTopLevelContext : PIRP ) -> BOOLEAN ; } # [ repr ( C ) ] pub struct _KTRANSACTION { _unused : [ u8 ; 0 ] , } pub type KTRANSACTION = _KTRANSACTION ; pub type PKTRANSACTION = * mut _KTRANSACTION ; pub type PRKTRANSACTION = * mut _KTRANSACTION ; # [ repr ( C ) ] pub struct _KENLISTMENT { _unused : [ u8 ; 0 ] , } pub type KENLISTMENT = _KENLISTMENT ; pub type PKENLISTMENT = * mut _KENLISTMENT ; pub type PRKENLISTMENT = * mut _KENLISTMENT ; # [ repr ( C ) ] pub struct _KRESOURCEMANAGER { _unused : [ u8 ; 0 ] , } pub type KRESOURCEMANAGER = _KRESOURCEMANAGER ; pub type PKRESOURCEMANAGER = * mut _KRESOURCEMANAGER ; pub type PRKRESOURCEMANAGER = * mut _KRESOURCEMANAGER ; # [ repr ( C ) ] pub struct _KTM { _unused : [ u8 ; 0 ] , } pub type KTM = _KTM ; pub type PKTM = * mut _KTM ; pub type PRKTM = * mut _KTM ; pub type PGUID = * mut GUID ; pub type PTM_RM_NOTIFICATION = :: std :: option :: Option < unsafe extern "C" fn ( EnlistmentObject : PKENLISTMENT , RMContext : PVOID , TransactionContext : PVOID , TransactionNotification : ULONG , TmVirtualClock : PLARGE_INTEGER , ArgumentLength : ULONG , Argument : PVOID ) -> NTSTATUS > ; pub type KCRM_PROTOCOL_ID = GUID ; pub type PKCRM_PROTOCOL_ID = * mut GUID ; pub type PTM_PROPAGATE_ROUTINE = :: std :: option :: Option < unsafe extern "C" fn ( PropagationCookie : PVOID , CallbackData : PVOID , PropagationStatus : NTSTATUS , TransactionGuid : GUID ) -> NTSTATUS > ; extern "C" { pub fn TmInitializeTransactionManager ( TransactionManager : PRKTM , LogFileName : PCUNICODE_STRING , TmId : PGUID , CreateOptions : ULONG ) -> NTSTATUS ; } extern "C" { pub fn TmRenameTransactionManager ( LogFileName : PUNICODE_STRING , ExistingTransactionManagerGuid : LPGUID ) -> NTSTATUS ; } extern "C" { pub fn TmRecoverTransactionManager ( Tm : PKTM , TargetVirtualClock : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn TmCommitTransaction ( Transaction : PKTRANSACTION , Wait : BOOLEAN ) -> NTSTATUS ; } extern "C" { pub fn TmRollbackTransaction ( Transaction : PKTRANSACTION , Wait : BOOLEAN ) -> NTSTATUS ; } extern "C" { pub fn TmCreateEnlistment ( EnlistmentHandle : PHANDLE , PreviousMode : KPROCESSOR_MODE , DesiredAccess : ACCESS_MASK , ObjectAttributes : POBJECT_ATTRIBUTES , ResourceManager : PRKRESOURCEMANAGER , Transaction : PKTRANSACTION , CreateOptions : ULONG , NotificationMask : NOTIFICATION_MASK , EnlistmentKey : PVOID ) -> NTSTATUS ; } extern "C" { pub fn TmRecoverEnlistment ( Enlistment : PKENLISTMENT , EnlistmentKey : PVOID ) -> NTSTATUS ; } extern "C" { pub fn TmPrePrepareEnlistment ( Enlistment : PKENLISTMENT , TmVirtualClock : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn TmPrepareEnlistment ( Enlistment : PKENLISTMENT , TmVirtualClock : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn TmCommitEnlistment ( Enlistment : PKENLISTMENT , TmVirtualClock : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn TmRollbackEnlistment ( Enlistment : PKENLISTMENT , TmVirtualClock : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn TmPrePrepareComplete ( Enlistment : PKENLISTMENT , TmVirtualClock : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn TmPrepareComplete ( Enlistment : PKENLISTMENT , TmVirtualClock : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn TmReadOnlyEnlistment ( Enlistment : PKENLISTMENT , TmVirtualClock : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn TmCommitComplete ( Enlistment : PKENLISTMENT , TmVirtualClock : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn TmRollbackComplete ( Enlistment : PKENLISTMENT , TmVirtualClock : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn TmReferenceEnlistmentKey ( Enlistment : PKENLISTMENT , Key : * mut PVOID ) -> NTSTATUS ; } extern "C" { pub fn TmDereferenceEnlistmentKey ( Enlistment : PKENLISTMENT , LastReference : PBOOLEAN ) -> NTSTATUS ; } extern "C" { pub fn TmSinglePhaseReject ( Enlistment : PKENLISTMENT , TmVirtualClock : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn TmRequestOutcomeEnlistment ( Enlistment : PKENLISTMENT , TmVirtualClock : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn TmEnableCallbacks ( ResourceManager : PKRESOURCEMANAGER , CallbackRoutine : PTM_RM_NOTIFICATION , RMKey : PVOID ) -> NTSTATUS ; } extern "C" { pub fn TmRecoverResourceManager ( ResourceManager : PKRESOURCEMANAGER ) -> NTSTATUS ; } extern "C" { pub fn TmPropagationComplete ( ResourceManager : PKRESOURCEMANAGER , RequestCookie : ULONG , BufferLength : ULONG , Buffer : PVOID ) -> NTSTATUS ; } extern "C" { pub fn TmPropagationFailed ( ResourceManager : PKRESOURCEMANAGER , RequestCookie : ULONG , Status : NTSTATUS ) -> NTSTATUS ; } extern "C" { pub fn TmGetTransactionId ( Transaction : PKTRANSACTION , TransactionId : PUOW ) ; } extern "C" { pub fn TmIsTransactionActive ( Transaction : PKTRANSACTION ) -> BOOLEAN ; } # [ repr ( C ) ] pub struct _PCW_INSTANCE { _unused : [ u8 ; 0 ] , } pub type PPCW_INSTANCE = * mut _PCW_INSTANCE ; # [ repr ( C ) ] pub struct _PCW_REGISTRATION { _unused : [ u8 ; 0 ] , } pub type PPCW_REGISTRATION = * mut _PCW_REGISTRATION ; # [ repr ( C ) ] pub struct _PCW_BUFFER { _unused : [ u8 ; 0 ] , } pub type PPCW_BUFFER = * mut _PCW_BUFFER ; # [ repr ( C ) ] pub struct _PCW_COUNTER_DESCRIPTOR { pub Id : USHORT , pub StructIndex : USHORT , pub Offset : USHORT , pub Size : USHORT , } pub type PCW_COUNTER_DESCRIPTOR = _PCW_COUNTER_DESCRIPTOR ; pub type PPCW_COUNTER_DESCRIPTOR = * mut _PCW_COUNTER_DESCRIPTOR ; # [ repr ( C ) ] pub struct _PCW_DATA { pub Data : * const :: std :: os :: raw :: c_void , pub Size : ULONG , } pub type PCW_DATA = _PCW_DATA ; pub type PPCW_DATA = * mut _PCW_DATA ; # [ repr ( C ) ] pub struct _PCW_COUNTER_INFORMATION { pub CounterMask : ULONG64 , pub InstanceMask : PCUNICODE_STRING , } pub type PCW_COUNTER_INFORMATION = _PCW_COUNTER_INFORMATION ; pub type PPCW_COUNTER_INFORMATION = * mut _PCW_COUNTER_INFORMATION ; # [ repr ( C ) ] pub struct _PCW_MASK_INFORMATION { pub CounterMask : ULONG64 , pub InstanceMask : PCUNICODE_STRING , pub InstanceId : ULONG , pub CollectMultiple : BOOLEAN , pub Buffer : PPCW_BUFFER , pub CancelEvent : PKEVENT , } pub type PCW_MASK_INFORMATION = _PCW_MASK_INFORMATION ; pub type PPCW_MASK_INFORMATION = * mut _PCW_MASK_INFORMATION ; # [ repr ( C ) ] pub struct _PCW_CALLBACK_INFORMATION { pub AddCounter : __BindgenUnionField < PCW_COUNTER_INFORMATION > , pub RemoveCounter : __BindgenUnionField < PCW_COUNTER_INFORMATION > , pub EnumerateInstances : __BindgenUnionField < PCW_MASK_INFORMATION > , pub CollectData : __BindgenUnionField < PCW_MASK_INFORMATION > , pub bindgen_union_field : [ u64 ; 5usize ] , } pub type PCW_CALLBACK_INFORMATION = _PCW_CALLBACK_INFORMATION ; pub type PPCW_CALLBACK_INFORMATION = * mut _PCW_CALLBACK_INFORMATION ; pub const _PCW_CALLBACK_TYPE_PcwCallbackAddCounter : _PCW_CALLBACK_TYPE = 0 ; pub const _PCW_CALLBACK_TYPE_PcwCallbackRemoveCounter : _PCW_CALLBACK_TYPE = 1 ; pub const _PCW_CALLBACK_TYPE_PcwCallbackEnumerateInstances : _PCW_CALLBACK_TYPE = 2 ; pub const _PCW_CALLBACK_TYPE_PcwCallbackCollectData : _PCW_CALLBACK_TYPE = 3 ; pub type _PCW_CALLBACK_TYPE = i32 ; pub use self :: _PCW_CALLBACK_TYPE as PCW_CALLBACK_TYPE ; pub type PPCW_CALLBACK_TYPE = * mut _PCW_CALLBACK_TYPE ; pub type PPCW_CALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( ) -> NTSTATUS > ; # [ repr ( C ) ] pub struct _PCW_REGISTRATION_INFORMATION { pub Version : ULONG , pub Name : PCUNICODE_STRING , pub CounterCount : ULONG , pub Counters : PPCW_COUNTER_DESCRIPTOR , pub Callback : PPCW_CALLBACK , pub CallbackContext : PVOID , } pub type PCW_REGISTRATION_INFORMATION = _PCW_REGISTRATION_INFORMATION ; pub type PPCW_REGISTRATION_INFORMATION = * mut _PCW_REGISTRATION_INFORMATION ; extern "C" { pub fn PcwRegister ( Registration : * mut PPCW_REGISTRATION , Info : PPCW_REGISTRATION_INFORMATION ) -> NTSTATUS ; } extern "C" { pub fn PcwUnregister ( Registration : PPCW_REGISTRATION ) ; } extern "C" { pub fn PcwCreateInstance ( Instance : * mut PPCW_INSTANCE , Registration : PPCW_REGISTRATION , Name : PCUNICODE_STRING , Count : ULONG , Data : PPCW_DATA ) -> NTSTATUS ; } extern "C" { pub fn PcwCloseInstance ( Instance : PPCW_INSTANCE ) ; } extern "C" { pub fn PcwAddInstance ( Buffer : PPCW_BUFFER , Name : PCUNICODE_STRING , Id : ULONG , Count : ULONG , Data : PPCW_DATA ) -> NTSTATUS ; } extern "C" { pub fn VslCreateSecureSection ( Handle : PHANDLE , TargetProcess : PEPROCESS , Mdl : PMDL , DevicePageProtection : ULONG , Attributes : ULONG ) -> NTSTATUS ; } extern "C" { pub fn VslDeleteSecureSection ( GlobalHandle : HANDLE ) -> NTSTATUS ; } pub const _DRIVER_RUNTIME_INIT_FLAGS_DrvRtPoolNxOptIn : _DRIVER_RUNTIME_INIT_FLAGS = 1 ; pub const _DRIVER_RUNTIME_INIT_FLAGS_LastDrvRtFlag : _DRIVER_RUNTIME_INIT_FLAGS = 2 ; pub type _DRIVER_RUNTIME_INIT_FLAGS = i32 ; pub use self :: _DRIVER_RUNTIME_INIT_FLAGS as DRIVER_RUNTIME_INIT_FLAGS ; pub type PDRIVER_RUNTIME_INIT_FLAGS = * mut _DRIVER_RUNTIME_INIT_FLAGS ; pub type PCDRIVER_RUNTIME_INIT_FLAGS = * const _DRIVER_RUNTIME_INIT_FLAGS ; extern "C" { # [ link_name = "\u{1}CmKeyObjectType" ] pub static mut CmKeyObjectType : * mut POBJECT_TYPE ; } extern "C" { # [ link_name = "\u{1}IoFileObjectType" ] pub static mut IoFileObjectType : * mut POBJECT_TYPE ; } extern "C" { # [ link_name = "\u{1}ExEventObjectType" ] pub static mut ExEventObjectType : * mut POBJECT_TYPE ; } extern "C" { # [ link_name = "\u{1}ExSemaphoreObjectType" ] pub static mut ExSemaphoreObjectType : * mut POBJECT_TYPE ; } extern "C" { # [ link_name = "\u{1}TmTransactionManagerObjectType" ] pub static mut TmTransactionManagerObjectType : * mut POBJECT_TYPE ; } extern "C" { # [ link_name = "\u{1}TmResourceManagerObjectType" ] pub static mut TmResourceManagerObjectType : * mut POBJECT_TYPE ; } extern "C" { # [ link_name = "\u{1}TmEnlistmentObjectType" ] pub static mut TmEnlistmentObjectType : * mut POBJECT_TYPE ; } extern "C" { # [ link_name = "\u{1}TmTransactionObjectType" ] pub static mut TmTransactionObjectType : * mut POBJECT_TYPE ; } extern "C" { # [ link_name = "\u{1}PsProcessType" ] pub static mut PsProcessType : * mut POBJECT_TYPE ; } extern "C" { # [ link_name = "\u{1}PsThreadType" ] pub static mut PsThreadType : * mut POBJECT_TYPE ; } extern "C" { # [ link_name = "\u{1}PsJobType" ] pub static mut PsJobType : * mut POBJECT_TYPE ; } extern "C" { # [ link_name = "\u{1}SeTokenObjectType" ] pub static mut SeTokenObjectType : * mut POBJECT_TYPE ; } extern "C" { # [ link_name = "\u{1}ExDesktopObjectType" ] pub static mut ExDesktopObjectType : * mut POBJECT_TYPE ; } # [ repr ( C ) ] pub struct _BUS_HANDLER { _unused : [ u8 ; 0 ] , } pub type PBUS_HANDLER = * mut _BUS_HANDLER ; # [ repr ( C ) ] pub struct _DEVICE_HANDLER_OBJECT { _unused : [ u8 ; 0 ] , } pub type PDEVICE_HANDLER_OBJECT = * mut _DEVICE_HANDLER_OBJECT ; # [ repr ( C ) ] pub struct _EJOB { _unused : [ u8 ; 0 ] , } pub type PEJOB = * mut _EJOB ; pub type PESILO = * mut _EJOB ; # [ repr ( C ) ] pub struct _SILO_MONITOR { _unused : [ u8 ; 0 ] , } pub type PSILO_MONITOR = * mut _SILO_MONITOR ; # [ repr ( C ) ] pub struct _PEB { _unused : [ u8 ; 0 ] , } pub type PPEB = * mut _PEB ; # [ repr ( C ) ] pub struct _IMAGE_NT_HEADERS { _unused : [ u8 ; 0 ] , } pub type PIMAGE_NT_HEADERS32 = * mut _IMAGE_NT_HEADERS ; # [ repr ( C ) ] pub struct _IMAGE_NT_HEADERS64 { _unused : [ u8 ; 0 ] , } pub type PIMAGE_NT_HEADERS64 = * mut _IMAGE_NT_HEADERS64 ; pub type PIMAGE_NT_HEADERS = PIMAGE_NT_HEADERS64 ; extern "C" { # [ link_name = "\u{1}PsSiloContextPagedType" ] pub static mut PsSiloContextPagedType : * mut POBJECT_TYPE ; } extern "C" { # [ link_name = "\u{1}PsSiloContextNonPagedType" ] pub static mut PsSiloContextNonPagedType : * mut POBJECT_TYPE ; } # [ repr ( C ) ] pub struct _FLOATING_SAVE_AREA { pub ControlWord : ULONG , pub StatusWord : ULONG , pub TagWord : ULONG , pub ErrorOffset : ULONG , pub ErrorSelector : ULONG , pub DataOffset : ULONG , pub DataSelector : ULONG , pub RegisterArea : [ UCHAR ; 80usize ] , pub Spare0 : ULONG , } pub type FLOATING_SAVE_AREA = _FLOATING_SAVE_AREA ; pub type PFLOATING_SAVE_AREA = * mut FLOATING_SAVE_AREA ; # [ repr ( C ) ] pub struct _CONTEXT { pub ContextFlags : ULONG , pub Dr0 : ULONG , pub Dr1 : ULONG , pub Dr2 : ULONG , pub Dr3 : ULONG , pub Dr6 : ULONG , pub Dr7 : ULONG , pub FloatSave : FLOATING_SAVE_AREA , pub SegGs : ULONG , pub SegFs : ULONG , pub SegEs : ULONG , pub SegDs : ULONG , pub Edi : ULONG , pub Esi : ULONG , pub Ebx : ULONG , pub Edx : ULONG , pub Ecx : ULONG , pub Eax : ULONG , pub Ebp : ULONG , pub Eip : ULONG , pub SegCs : ULONG , pub EFlags : ULONG , pub Esp : ULONG , pub SegSs : ULONG , pub ExtendedRegisters : [ UCHAR ; 512usize ] , } pub type CONTEXT = _CONTEXT ; # [ repr ( C ) ] pub struct _ARM64_NT_NEON128 { pub __bindgen_anon_1 : __BindgenUnionField < _ARM64_NT_NEON128__bindgen_ty_1 > , pub D : __BindgenUnionField < [ f64 ; 2usize ] > , pub S : __BindgenUnionField < [ f32 ; 4usize ] > , pub H : __BindgenUnionField < [ USHORT ; 8usize ] > , pub B : __BindgenUnionField < [ UCHAR ; 16usize ] > , pub bindgen_union_field : [ u64 ; 2usize ] , } # [ repr ( C ) ] pub struct _ARM64_NT_NEON128__bindgen_ty_1 { pub Low : ULONGLONG , pub High : LONGLONG , } pub type ARM64_NT_NEON128 = _ARM64_NT_NEON128 ; pub type PARM64_NT_NEON128 = * mut _ARM64_NT_NEON128 ; # [ repr ( C ) ] pub struct _ARM64_NT_CONTEXT { pub ContextFlags : ULONG , pub Cpsr : ULONG , pub __bindgen_anon_1 : _ARM64_NT_CONTEXT__bindgen_ty_1 , pub Sp : ULONG64 , pub Pc : ULONG64 , pub V : [ ARM64_NT_NEON128 ; 32usize ] , pub Fpcr : ULONG , pub Fpsr : ULONG , pub Bcr : [ ULONG ; 8usize ] , pub Bvr : [ ULONG64 ; 8usize ] , pub Wcr : [ ULONG ; 2usize ] , pub Wvr : [ ULONG64 ; 2usize ] , } # [ repr ( C ) ] pub struct _ARM64_NT_CONTEXT__bindgen_ty_1 { pub __bindgen_anon_1 : __BindgenUnionField < _ARM64_NT_CONTEXT__bindgen_ty_1__bindgen_ty_1 > , pub X : __BindgenUnionField < [ ULONG64 ; 31usize ] > , pub bindgen_union_field : [ u64 ; 31usize ] , } # [ repr ( C ) ] pub struct _ARM64_NT_CONTEXT__bindgen_ty_1__bindgen_ty_1 { pub X0 : ULONG64 , pub X1 : ULONG64 , pub X2 : ULONG64 , pub X3 : ULONG64 , pub X4 : ULONG64 , pub X5 : ULONG64 , pub X6 : ULONG64 , pub X7 : ULONG64 , pub X8 : ULONG64 , pub X9 : ULONG64 , pub X10 : ULONG64 , pub X11 : ULONG64 , pub X12 : ULONG64 , pub X13 : ULONG64 , pub X14 : ULONG64 , pub X15 : ULONG64 , pub X16 : ULONG64 , pub X17 : ULONG64 , pub X18 : ULONG64 , pub X19 : ULONG64 , pub X20 : ULONG64 , pub X21 : ULONG64 , pub X22 : ULONG64 , pub X23 : ULONG64 , pub X24 : ULONG64 , pub X25 : ULONG64 , pub X26 : ULONG64 , pub X27 : ULONG64 , pub X28 : ULONG64 , pub Fp : ULONG64 , pub Lr : ULONG64 , } pub type ARM64_NT_CONTEXT = _ARM64_NT_CONTEXT ; pub type PARM64_NT_CONTEXT = * mut _ARM64_NT_CONTEXT ; pub const WELL_KNOWN_SID_TYPE_WinNullSid : WELL_KNOWN_SID_TYPE = 0 ; pub const WELL_KNOWN_SID_TYPE_WinWorldSid : WELL_KNOWN_SID_TYPE = 1 ; pub const WELL_KNOWN_SID_TYPE_WinLocalSid : WELL_KNOWN_SID_TYPE = 2 ; pub const WELL_KNOWN_SID_TYPE_WinCreatorOwnerSid : WELL_KNOWN_SID_TYPE = 3 ; pub const WELL_KNOWN_SID_TYPE_WinCreatorGroupSid : WELL_KNOWN_SID_TYPE = 4 ; pub const WELL_KNOWN_SID_TYPE_WinCreatorOwnerServerSid : WELL_KNOWN_SID_TYPE = 5 ; pub const WELL_KNOWN_SID_TYPE_WinCreatorGroupServerSid : WELL_KNOWN_SID_TYPE = 6 ; pub const WELL_KNOWN_SID_TYPE_WinNtAuthoritySid : WELL_KNOWN_SID_TYPE = 7 ; pub const WELL_KNOWN_SID_TYPE_WinDialupSid : WELL_KNOWN_SID_TYPE = 8 ; pub const WELL_KNOWN_SID_TYPE_WinNetworkSid : WELL_KNOWN_SID_TYPE = 9 ; pub const WELL_KNOWN_SID_TYPE_WinBatchSid : WELL_KNOWN_SID_TYPE = 10 ; pub const WELL_KNOWN_SID_TYPE_WinInteractiveSid : WELL_KNOWN_SID_TYPE = 11 ; pub const WELL_KNOWN_SID_TYPE_WinServiceSid : WELL_KNOWN_SID_TYPE = 12 ; pub const WELL_KNOWN_SID_TYPE_WinAnonymousSid : WELL_KNOWN_SID_TYPE = 13 ; pub const WELL_KNOWN_SID_TYPE_WinProxySid : WELL_KNOWN_SID_TYPE = 14 ; pub const WELL_KNOWN_SID_TYPE_WinEnterpriseControllersSid : WELL_KNOWN_SID_TYPE = 15 ; pub const WELL_KNOWN_SID_TYPE_WinSelfSid : WELL_KNOWN_SID_TYPE = 16 ; pub const WELL_KNOWN_SID_TYPE_WinAuthenticatedUserSid : WELL_KNOWN_SID_TYPE = 17 ; pub const WELL_KNOWN_SID_TYPE_WinRestrictedCodeSid : WELL_KNOWN_SID_TYPE = 18 ; pub const WELL_KNOWN_SID_TYPE_WinTerminalServerSid : WELL_KNOWN_SID_TYPE = 19 ; pub const WELL_KNOWN_SID_TYPE_WinRemoteLogonIdSid : WELL_KNOWN_SID_TYPE = 20 ; pub const WELL_KNOWN_SID_TYPE_WinLogonIdsSid : WELL_KNOWN_SID_TYPE = 21 ; pub const WELL_KNOWN_SID_TYPE_WinLocalSystemSid : WELL_KNOWN_SID_TYPE = 22 ; pub const WELL_KNOWN_SID_TYPE_WinLocalServiceSid : WELL_KNOWN_SID_TYPE = 23 ; pub const WELL_KNOWN_SID_TYPE_WinNetworkServiceSid : WELL_KNOWN_SID_TYPE = 24 ; pub const WELL_KNOWN_SID_TYPE_WinBuiltinDomainSid : WELL_KNOWN_SID_TYPE = 25 ; pub const WELL_KNOWN_SID_TYPE_WinBuiltinAdministratorsSid : WELL_KNOWN_SID_TYPE = 26 ; pub const WELL_KNOWN_SID_TYPE_WinBuiltinUsersSid : WELL_KNOWN_SID_TYPE = 27 ; pub const WELL_KNOWN_SID_TYPE_WinBuiltinGuestsSid : WELL_KNOWN_SID_TYPE = 28 ; pub const WELL_KNOWN_SID_TYPE_WinBuiltinPowerUsersSid : WELL_KNOWN_SID_TYPE = 29 ; pub const WELL_KNOWN_SID_TYPE_WinBuiltinAccountOperatorsSid : WELL_KNOWN_SID_TYPE = 30 ; pub const WELL_KNOWN_SID_TYPE_WinBuiltinSystemOperatorsSid : WELL_KNOWN_SID_TYPE = 31 ; pub const WELL_KNOWN_SID_TYPE_WinBuiltinPrintOperatorsSid : WELL_KNOWN_SID_TYPE = 32 ; pub const WELL_KNOWN_SID_TYPE_WinBuiltinBackupOperatorsSid : WELL_KNOWN_SID_TYPE = 33 ; pub const WELL_KNOWN_SID_TYPE_WinBuiltinReplicatorSid : WELL_KNOWN_SID_TYPE = 34 ; pub const WELL_KNOWN_SID_TYPE_WinBuiltinPreWindows2000CompatibleAccessSid : WELL_KNOWN_SID_TYPE = 35 ; pub const WELL_KNOWN_SID_TYPE_WinBuiltinRemoteDesktopUsersSid : WELL_KNOWN_SID_TYPE = 36 ; pub const WELL_KNOWN_SID_TYPE_WinBuiltinNetworkConfigurationOperatorsSid : WELL_KNOWN_SID_TYPE = 37 ; pub const WELL_KNOWN_SID_TYPE_WinAccountAdministratorSid : WELL_KNOWN_SID_TYPE = 38 ; pub const WELL_KNOWN_SID_TYPE_WinAccountGuestSid : WELL_KNOWN_SID_TYPE = 39 ; pub const WELL_KNOWN_SID_TYPE_WinAccountKrbtgtSid : WELL_KNOWN_SID_TYPE = 40 ; pub const WELL_KNOWN_SID_TYPE_WinAccountDomainAdminsSid : WELL_KNOWN_SID_TYPE = 41 ; pub const WELL_KNOWN_SID_TYPE_WinAccountDomainUsersSid : WELL_KNOWN_SID_TYPE = 42 ; pub const WELL_KNOWN_SID_TYPE_WinAccountDomainGuestsSid : WELL_KNOWN_SID_TYPE = 43 ; pub const WELL_KNOWN_SID_TYPE_WinAccountComputersSid : WELL_KNOWN_SID_TYPE = 44 ; pub const WELL_KNOWN_SID_TYPE_WinAccountControllersSid : WELL_KNOWN_SID_TYPE = 45 ; pub const WELL_KNOWN_SID_TYPE_WinAccountCertAdminsSid : WELL_KNOWN_SID_TYPE = 46 ; pub const WELL_KNOWN_SID_TYPE_WinAccountSchemaAdminsSid : WELL_KNOWN_SID_TYPE = 47 ; pub const WELL_KNOWN_SID_TYPE_WinAccountEnterpriseAdminsSid : WELL_KNOWN_SID_TYPE = 48 ; pub const WELL_KNOWN_SID_TYPE_WinAccountPolicyAdminsSid : WELL_KNOWN_SID_TYPE = 49 ; pub const WELL_KNOWN_SID_TYPE_WinAccountRasAndIasServersSid : WELL_KNOWN_SID_TYPE = 50 ; pub const WELL_KNOWN_SID_TYPE_WinNTLMAuthenticationSid : WELL_KNOWN_SID_TYPE = 51 ; pub const WELL_KNOWN_SID_TYPE_WinDigestAuthenticationSid : WELL_KNOWN_SID_TYPE = 52 ; pub const WELL_KNOWN_SID_TYPE_WinSChannelAuthenticationSid : WELL_KNOWN_SID_TYPE = 53 ; pub const WELL_KNOWN_SID_TYPE_WinThisOrganizationSid : WELL_KNOWN_SID_TYPE = 54 ; pub const WELL_KNOWN_SID_TYPE_WinOtherOrganizationSid : WELL_KNOWN_SID_TYPE = 55 ; pub const WELL_KNOWN_SID_TYPE_WinBuiltinIncomingForestTrustBuildersSid : WELL_KNOWN_SID_TYPE = 56 ; pub const WELL_KNOWN_SID_TYPE_WinBuiltinPerfMonitoringUsersSid : WELL_KNOWN_SID_TYPE = 57 ; pub const WELL_KNOWN_SID_TYPE_WinBuiltinPerfLoggingUsersSid : WELL_KNOWN_SID_TYPE = 58 ; pub const WELL_KNOWN_SID_TYPE_WinBuiltinAuthorizationAccessSid : WELL_KNOWN_SID_TYPE = 59 ; pub const WELL_KNOWN_SID_TYPE_WinBuiltinTerminalServerLicenseServersSid : WELL_KNOWN_SID_TYPE = 60 ; pub const WELL_KNOWN_SID_TYPE_WinBuiltinDCOMUsersSid : WELL_KNOWN_SID_TYPE = 61 ; pub const WELL_KNOWN_SID_TYPE_WinBuiltinIUsersSid : WELL_KNOWN_SID_TYPE = 62 ; pub const WELL_KNOWN_SID_TYPE_WinIUserSid : WELL_KNOWN_SID_TYPE = 63 ; pub const WELL_KNOWN_SID_TYPE_WinBuiltinCryptoOperatorsSid : WELL_KNOWN_SID_TYPE = 64 ; pub const WELL_KNOWN_SID_TYPE_WinUntrustedLabelSid : WELL_KNOWN_SID_TYPE = 65 ; pub const WELL_KNOWN_SID_TYPE_WinLowLabelSid : WELL_KNOWN_SID_TYPE = 66 ; pub const WELL_KNOWN_SID_TYPE_WinMediumLabelSid : WELL_KNOWN_SID_TYPE = 67 ; pub const WELL_KNOWN_SID_TYPE_WinHighLabelSid : WELL_KNOWN_SID_TYPE = 68 ; pub const WELL_KNOWN_SID_TYPE_WinSystemLabelSid : WELL_KNOWN_SID_TYPE = 69 ; pub const WELL_KNOWN_SID_TYPE_WinWriteRestrictedCodeSid : WELL_KNOWN_SID_TYPE = 70 ; pub const WELL_KNOWN_SID_TYPE_WinCreatorOwnerRightsSid : WELL_KNOWN_SID_TYPE = 71 ; pub const WELL_KNOWN_SID_TYPE_WinCacheablePrincipalsGroupSid : WELL_KNOWN_SID_TYPE = 72 ; pub const WELL_KNOWN_SID_TYPE_WinNonCacheablePrincipalsGroupSid : WELL_KNOWN_SID_TYPE = 73 ; pub const WELL_KNOWN_SID_TYPE_WinEnterpriseReadonlyControllersSid : WELL_KNOWN_SID_TYPE = 74 ; pub const WELL_KNOWN_SID_TYPE_WinAccountReadonlyControllersSid : WELL_KNOWN_SID_TYPE = 75 ; pub const WELL_KNOWN_SID_TYPE_WinBuiltinEventLogReadersGroup : WELL_KNOWN_SID_TYPE = 76 ; pub const WELL_KNOWN_SID_TYPE_WinNewEnterpriseReadonlyControllersSid : WELL_KNOWN_SID_TYPE = 77 ; pub const WELL_KNOWN_SID_TYPE_WinBuiltinCertSvcDComAccessGroup : WELL_KNOWN_SID_TYPE = 78 ; pub const WELL_KNOWN_SID_TYPE_WinMediumPlusLabelSid : WELL_KNOWN_SID_TYPE = 79 ; pub const WELL_KNOWN_SID_TYPE_WinLocalLogonSid : WELL_KNOWN_SID_TYPE = 80 ; pub const WELL_KNOWN_SID_TYPE_WinConsoleLogonSid : WELL_KNOWN_SID_TYPE = 81 ; pub const WELL_KNOWN_SID_TYPE_WinThisOrganizationCertificateSid : WELL_KNOWN_SID_TYPE = 82 ; pub const WELL_KNOWN_SID_TYPE_WinApplicationPackageAuthoritySid : WELL_KNOWN_SID_TYPE = 83 ; pub const WELL_KNOWN_SID_TYPE_WinBuiltinAnyPackageSid : WELL_KNOWN_SID_TYPE = 84 ; pub const WELL_KNOWN_SID_TYPE_WinCapabilityInternetClientSid : WELL_KNOWN_SID_TYPE = 85 ; pub const WELL_KNOWN_SID_TYPE_WinCapabilityInternetClientServerSid : WELL_KNOWN_SID_TYPE = 86 ; pub const WELL_KNOWN_SID_TYPE_WinCapabilityPrivateNetworkClientServerSid : WELL_KNOWN_SID_TYPE = 87 ; pub const WELL_KNOWN_SID_TYPE_WinCapabilityPicturesLibrarySid : WELL_KNOWN_SID_TYPE = 88 ; pub const WELL_KNOWN_SID_TYPE_WinCapabilityVideosLibrarySid : WELL_KNOWN_SID_TYPE = 89 ; pub const WELL_KNOWN_SID_TYPE_WinCapabilityMusicLibrarySid : WELL_KNOWN_SID_TYPE = 90 ; pub const WELL_KNOWN_SID_TYPE_WinCapabilityDocumentsLibrarySid : WELL_KNOWN_SID_TYPE = 91 ; pub const WELL_KNOWN_SID_TYPE_WinCapabilitySharedUserCertificatesSid : WELL_KNOWN_SID_TYPE = 92 ; pub const WELL_KNOWN_SID_TYPE_WinCapabilityEnterpriseAuthenticationSid : WELL_KNOWN_SID_TYPE = 93 ; pub const WELL_KNOWN_SID_TYPE_WinCapabilityRemovableStorageSid : WELL_KNOWN_SID_TYPE = 94 ; pub const WELL_KNOWN_SID_TYPE_WinBuiltinRDSRemoteAccessServersSid : WELL_KNOWN_SID_TYPE = 95 ; pub const WELL_KNOWN_SID_TYPE_WinBuiltinRDSEndpointServersSid : WELL_KNOWN_SID_TYPE = 96 ; pub const WELL_KNOWN_SID_TYPE_WinBuiltinRDSManagementServersSid : WELL_KNOWN_SID_TYPE = 97 ; pub const WELL_KNOWN_SID_TYPE_WinUserModeDriversSid : WELL_KNOWN_SID_TYPE = 98 ; pub const WELL_KNOWN_SID_TYPE_WinBuiltinHyperVAdminsSid : WELL_KNOWN_SID_TYPE = 99 ; pub const WELL_KNOWN_SID_TYPE_WinAccountCloneableControllersSid : WELL_KNOWN_SID_TYPE = 100 ; pub const WELL_KNOWN_SID_TYPE_WinBuiltinAccessControlAssistanceOperatorsSid : WELL_KNOWN_SID_TYPE = 101 ; pub const WELL_KNOWN_SID_TYPE_WinBuiltinRemoteManagementUsersSid : WELL_KNOWN_SID_TYPE = 102 ; pub const WELL_KNOWN_SID_TYPE_WinAuthenticationAuthorityAssertedSid : WELL_KNOWN_SID_TYPE = 103 ; pub const WELL_KNOWN_SID_TYPE_WinAuthenticationServiceAssertedSid : WELL_KNOWN_SID_TYPE = 104 ; pub const WELL_KNOWN_SID_TYPE_WinLocalAccountSid : WELL_KNOWN_SID_TYPE = 105 ; pub const WELL_KNOWN_SID_TYPE_WinLocalAccountAndAdministratorSid : WELL_KNOWN_SID_TYPE = 106 ; pub const WELL_KNOWN_SID_TYPE_WinAccountProtectedUsersSid : WELL_KNOWN_SID_TYPE = 107 ; pub const WELL_KNOWN_SID_TYPE_WinCapabilityAppointmentsSid : WELL_KNOWN_SID_TYPE = 108 ; pub const WELL_KNOWN_SID_TYPE_WinCapabilityContactsSid : WELL_KNOWN_SID_TYPE = 109 ; pub const WELL_KNOWN_SID_TYPE_WinAccountDefaultSystemManagedSid : WELL_KNOWN_SID_TYPE = 110 ; pub const WELL_KNOWN_SID_TYPE_WinBuiltinDefaultSystemManagedGroupSid : WELL_KNOWN_SID_TYPE = 111 ; pub const WELL_KNOWN_SID_TYPE_WinBuiltinStorageReplicaAdminsSid : WELL_KNOWN_SID_TYPE = 112 ; pub const WELL_KNOWN_SID_TYPE_WinAccountKeyAdminsSid : WELL_KNOWN_SID_TYPE = 113 ; pub const WELL_KNOWN_SID_TYPE_WinAccountEnterpriseKeyAdminsSid : WELL_KNOWN_SID_TYPE = 114 ; pub const WELL_KNOWN_SID_TYPE_WinAuthenticationKeyTrustSid : WELL_KNOWN_SID_TYPE = 115 ; pub const WELL_KNOWN_SID_TYPE_WinAuthenticationKeyPropertyMFASid : WELL_KNOWN_SID_TYPE = 116 ; pub const WELL_KNOWN_SID_TYPE_WinAuthenticationKeyPropertyAttestationSid : WELL_KNOWN_SID_TYPE = 117 ; pub const WELL_KNOWN_SID_TYPE_WinAuthenticationFreshKeyAuthSid : WELL_KNOWN_SID_TYPE = 118 ; pub type WELL_KNOWN_SID_TYPE = i32 ; pub type SE_SIGNING_LEVEL = UCHAR ; pub type PSE_SIGNING_LEVEL = * mut UCHAR ; pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignatureNone : _SE_IMAGE_SIGNATURE_TYPE = 0 ; pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignatureEmbedded : _SE_IMAGE_SIGNATURE_TYPE = 1 ; pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignatureCache : _SE_IMAGE_SIGNATURE_TYPE = 2 ; pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignatureCatalogCached : _SE_IMAGE_SIGNATURE_TYPE = 3 ; pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignatureCatalogNotCached : _SE_IMAGE_SIGNATURE_TYPE = 4 ; pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignatureCatalogHint : _SE_IMAGE_SIGNATURE_TYPE = 5 ; pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignaturePackageCatalog : _SE_IMAGE_SIGNATURE_TYPE = 6 ; pub type _SE_IMAGE_SIGNATURE_TYPE = i32 ; pub use self :: _SE_IMAGE_SIGNATURE_TYPE as SE_IMAGE_SIGNATURE_TYPE ; pub type PSE_IMAGE_SIGNATURE_TYPE = * mut _SE_IMAGE_SIGNATURE_TYPE ; # [ repr ( C ) ] pub struct _RTL_RUN_ONCE { pub Ptr : __BindgenUnionField < PVOID > , pub bindgen_union_field : u64 , } pub type RTL_RUN_ONCE = _RTL_RUN_ONCE ; pub type PRTL_RUN_ONCE = * mut _RTL_RUN_ONCE ; pub type PRTL_RUN_ONCE_INIT_FN = :: std :: option :: Option < unsafe extern "C" fn ( ) -> ULONG > ; extern "C" { pub fn RtlRunOnceInitialize ( RunOnce : PRTL_RUN_ONCE ) ; } extern "C" { pub fn RtlRunOnceExecuteOnce ( RunOnce : PRTL_RUN_ONCE , InitFn : PRTL_RUN_ONCE_INIT_FN , Parameter : PVOID , Context : * mut PVOID ) -> NTSTATUS ; } extern "C" { pub fn RtlRunOnceBeginInitialize ( RunOnce : PRTL_RUN_ONCE , Flags : ULONG , Context : * mut PVOID ) -> NTSTATUS ; } extern "C" { pub fn RtlRunOnceComplete ( RunOnce : PRTL_RUN_ONCE , Flags : ULONG , Context : PVOID ) -> NTSTATUS ; } pub const _TABLE_SEARCH_RESULT_TableEmptyTree : _TABLE_SEARCH_RESULT = 0 ; pub const _TABLE_SEARCH_RESULT_TableFoundNode : _TABLE_SEARCH_RESULT = 1 ; pub const _TABLE_SEARCH_RESULT_TableInsertAsLeft : _TABLE_SEARCH_RESULT = 2 ; pub const _TABLE_SEARCH_RESULT_TableInsertAsRight : _TABLE_SEARCH_RESULT = 3 ; pub type _TABLE_SEARCH_RESULT = i32 ; pub use self :: _TABLE_SEARCH_RESULT as TABLE_SEARCH_RESULT ; pub const _RTL_GENERIC_COMPARE_RESULTS_GenericLessThan : _RTL_GENERIC_COMPARE_RESULTS = 0 ; pub const _RTL_GENERIC_COMPARE_RESULTS_GenericGreaterThan : _RTL_GENERIC_COMPARE_RESULTS = 1 ; pub const _RTL_GENERIC_COMPARE_RESULTS_GenericEqual : _RTL_GENERIC_COMPARE_RESULTS = 2 ; pub type _RTL_GENERIC_COMPARE_RESULTS = i32 ; pub use self :: _RTL_GENERIC_COMPARE_RESULTS as RTL_GENERIC_COMPARE_RESULTS ; pub type PRTL_AVL_COMPARE_ROUTINE = :: std :: option :: Option < unsafe extern "C" fn ( ) -> RTL_GENERIC_COMPARE_RESULTS > ; pub type PRTL_AVL_ALLOCATE_ROUTINE = :: std :: option :: Option < unsafe extern "C" fn ( ) -> PVOID > ; pub type PRTL_AVL_FREE_ROUTINE = :: std :: option :: Option < unsafe extern "C" fn ( ) > ; pub type PRTL_AVL_MATCH_FUNCTION = :: std :: option :: Option < unsafe extern "C" fn ( ) -> NTSTATUS > ; # [ repr ( C ) ] pub struct _RTL_BALANCED_LINKS { pub Parent : * mut _RTL_BALANCED_LINKS , pub LeftChild : * mut _RTL_BALANCED_LINKS , pub RightChild : * mut _RTL_BALANCED_LINKS , pub Balance : CHAR , pub Reserved : [ UCHAR ; 3usize ] , } pub type RTL_BALANCED_LINKS = _RTL_BALANCED_LINKS ; pub type PRTL_BALANCED_LINKS = * mut RTL_BALANCED_LINKS ; # [ repr ( C ) ] pub struct _RTL_AVL_TABLE { pub BalancedRoot : RTL_BALANCED_LINKS , pub OrderedPointer : PVOID , pub WhichOrderedElement : ULONG , pub NumberGenericTableElements : ULONG , pub DepthOfTree : ULONG , pub RestartKey : PRTL_BALANCED_LINKS , pub DeleteCount : ULONG , pub CompareRoutine : PRTL_AVL_COMPARE_ROUTINE , pub AllocateRoutine : PRTL_AVL_ALLOCATE_ROUTINE , pub FreeRoutine : PRTL_AVL_FREE_ROUTINE , pub TableContext : PVOID , } pub type RTL_AVL_TABLE = _RTL_AVL_TABLE ; pub type PRTL_AVL_TABLE = * mut RTL_AVL_TABLE ; extern "C" { pub fn RtlInitializeGenericTableAvl ( Table : PRTL_AVL_TABLE , CompareRoutine : PRTL_AVL_COMPARE_ROUTINE , AllocateRoutine : PRTL_AVL_ALLOCATE_ROUTINE , FreeRoutine : PRTL_AVL_FREE_ROUTINE , TableContext : PVOID ) ; } extern "C" { pub fn RtlInsertElementGenericTableAvl ( Table : PRTL_AVL_TABLE , Buffer : PVOID , BufferSize : CLONG , NewElement : PBOOLEAN ) -> PVOID ; } extern "C" { pub fn RtlInsertElementGenericTableFullAvl ( Table : PRTL_AVL_TABLE , Buffer : PVOID , BufferSize : CLONG , NewElement : PBOOLEAN , NodeOrParent : PVOID , SearchResult : TABLE_SEARCH_RESULT ) -> PVOID ; } extern "C" { pub fn RtlDeleteElementGenericTableAvl ( Table : PRTL_AVL_TABLE , Buffer : PVOID ) -> BOOLEAN ; } extern "C" { pub fn RtlDeleteElementGenericTableAvlEx ( Table : PRTL_AVL_TABLE , NodeOrParent : PVOID ) ; } extern "C" { pub fn RtlLookupElementGenericTableAvl ( Table : PRTL_AVL_TABLE , Buffer : PVOID ) -> PVOID ; } extern "C" { pub fn RtlLookupElementGenericTableFullAvl ( Table : PRTL_AVL_TABLE , Buffer : PVOID , NodeOrParent : * mut PVOID , SearchResult : * mut TABLE_SEARCH_RESULT ) -> PVOID ; } extern "C" { pub fn RtlEnumerateGenericTableAvl ( Table : PRTL_AVL_TABLE , Restart : BOOLEAN ) -> PVOID ; } extern "C" { pub fn RtlEnumerateGenericTableWithoutSplayingAvl ( Table : PRTL_AVL_TABLE , RestartKey : * mut PVOID ) -> PVOID ; } extern "C" { pub fn RtlLookupFirstMatchingElementGenericTableAvl ( Table : PRTL_AVL_TABLE , Buffer : PVOID , RestartKey : * mut PVOID ) -> PVOID ; } extern "C" { pub fn RtlEnumerateGenericTableLikeADirectory ( Table : PRTL_AVL_TABLE , MatchFunction : PRTL_AVL_MATCH_FUNCTION , MatchData : PVOID , NextFlag : ULONG , RestartKey : * mut PVOID , DeleteCount : PULONG , Buffer : PVOID ) -> PVOID ; } extern "C" { pub fn RtlGetElementGenericTableAvl ( Table : PRTL_AVL_TABLE , I : ULONG ) -> PVOID ; } extern "C" { pub fn RtlNumberGenericTableElementsAvl ( Table : PRTL_AVL_TABLE ) -> ULONG ; } extern "C" { pub fn RtlIsGenericTableEmptyAvl ( Table : PRTL_AVL_TABLE ) -> BOOLEAN ; } # [ repr ( C ) ] pub struct _RTL_SPLAY_LINKS { pub Parent : * mut _RTL_SPLAY_LINKS , pub LeftChild : * mut _RTL_SPLAY_LINKS , pub RightChild : * mut _RTL_SPLAY_LINKS , } pub type RTL_SPLAY_LINKS = _RTL_SPLAY_LINKS ; pub type PRTL_SPLAY_LINKS = * mut RTL_SPLAY_LINKS ; extern "C" { pub fn RtlSplay ( Links : PRTL_SPLAY_LINKS ) -> PRTL_SPLAY_LINKS ; } extern "C" { pub fn RtlDelete ( Links : PRTL_SPLAY_LINKS ) -> PRTL_SPLAY_LINKS ; } extern "C" { pub fn RtlDeleteNoSplay ( Links : PRTL_SPLAY_LINKS , Root : * mut PRTL_SPLAY_LINKS ) ; } extern "C" { pub fn RtlSubtreeSuccessor ( Links : PRTL_SPLAY_LINKS ) -> PRTL_SPLAY_LINKS ; } extern "C" { pub fn RtlSubtreePredecessor ( Links : PRTL_SPLAY_LINKS ) -> PRTL_SPLAY_LINKS ; } extern "C" { pub fn RtlRealSuccessor ( Links : PRTL_SPLAY_LINKS ) -> PRTL_SPLAY_LINKS ; } extern "C" { pub fn RtlRealPredecessor ( Links : PRTL_SPLAY_LINKS ) -> PRTL_SPLAY_LINKS ; } pub type PRTL_GENERIC_COMPARE_ROUTINE = :: std :: option :: Option < unsafe extern "C" fn ( ) -> RTL_GENERIC_COMPARE_RESULTS > ; pub type PRTL_GENERIC_ALLOCATE_ROUTINE = :: std :: option :: Option < unsafe extern "C" fn ( ) -> PVOID > ; pub type PRTL_GENERIC_FREE_ROUTINE = :: std :: option :: Option < unsafe extern "C" fn ( ) > ; # [ repr ( C ) ] pub struct _RTL_GENERIC_TABLE { pub TableRoot : PRTL_SPLAY_LINKS , pub InsertOrderList : LIST_ENTRY , pub OrderedPointer : PLIST_ENTRY , pub WhichOrderedElement : ULONG , pub NumberGenericTableElements : ULONG , pub CompareRoutine : PRTL_GENERIC_COMPARE_ROUTINE , pub AllocateRoutine : PRTL_GENERIC_ALLOCATE_ROUTINE , pub FreeRoutine : PRTL_GENERIC_FREE_ROUTINE , pub TableContext : PVOID , } pub type RTL_GENERIC_TABLE = _RTL_GENERIC_TABLE ; pub type PRTL_GENERIC_TABLE = * mut RTL_GENERIC_TABLE ; extern "C" { pub fn RtlInitializeGenericTable ( Table : PRTL_GENERIC_TABLE , CompareRoutine : PRTL_GENERIC_COMPARE_ROUTINE , AllocateRoutine : PRTL_GENERIC_ALLOCATE_ROUTINE , FreeRoutine : PRTL_GENERIC_FREE_ROUTINE , TableContext : PVOID ) ; } extern "C" { pub fn RtlInsertElementGenericTable ( Table : PRTL_GENERIC_TABLE , Buffer : PVOID , BufferSize : CLONG , NewElement : PBOOLEAN ) -> PVOID ; } extern "C" { pub fn RtlInsertElementGenericTableFull ( Table : PRTL_GENERIC_TABLE , Buffer : PVOID , BufferSize : CLONG , NewElement : PBOOLEAN , NodeOrParent : PVOID , SearchResult : TABLE_SEARCH_RESULT ) -> PVOID ; } extern "C" { pub fn RtlDeleteElementGenericTable ( Table : PRTL_GENERIC_TABLE , Buffer : PVOID ) -> BOOLEAN ; } extern "C" { pub fn RtlLookupElementGenericTable ( Table : PRTL_GENERIC_TABLE , Buffer : PVOID ) -> PVOID ; } extern "C" { pub fn RtlLookupElementGenericTableFull ( Table : PRTL_GENERIC_TABLE , Buffer : PVOID , NodeOrParent : * mut PVOID , SearchResult : * mut TABLE_SEARCH_RESULT ) -> PVOID ; } extern "C" { pub fn RtlEnumerateGenericTable ( Table : PRTL_GENERIC_TABLE , Restart : BOOLEAN ) -> PVOID ; } extern "C" { pub fn RtlEnumerateGenericTableWithoutSplaying ( Table : PRTL_GENERIC_TABLE , RestartKey : * mut PVOID ) -> PVOID ; } extern "C" { pub fn RtlGetElementGenericTable ( Table : PRTL_GENERIC_TABLE , I : ULONG ) -> PVOID ; } extern "C" { pub fn RtlNumberGenericTableElements ( Table : PRTL_GENERIC_TABLE ) -> ULONG ; } extern "C" { pub fn RtlIsGenericTableEmpty ( Table : PRTL_GENERIC_TABLE ) -> BOOLEAN ; } # [ repr ( C ) ] pub struct _RTL_DYNAMIC_HASH_TABLE_ENTRY { pub Linkage : LIST_ENTRY , pub Signature : ULONG_PTR , } pub type RTL_DYNAMIC_HASH_TABLE_ENTRY = _RTL_DYNAMIC_HASH_TABLE_ENTRY ; pub type PRTL_DYNAMIC_HASH_TABLE_ENTRY = * mut _RTL_DYNAMIC_HASH_TABLE_ENTRY ; # [ repr ( C ) ] pub struct _RTL_DYNAMIC_HASH_TABLE_CONTEXT { pub ChainHead : PLIST_ENTRY , pub PrevLinkage : PLIST_ENTRY , pub Signature : ULONG_PTR , } pub type RTL_DYNAMIC_HASH_TABLE_CONTEXT = _RTL_DYNAMIC_HASH_TABLE_CONTEXT ; pub type PRTL_DYNAMIC_HASH_TABLE_CONTEXT = * mut _RTL_DYNAMIC_HASH_TABLE_CONTEXT ; # [ repr ( C ) ] pub struct _RTL_DYNAMIC_HASH_TABLE_ENUMERATOR { pub __bindgen_anon_1 : _RTL_DYNAMIC_HASH_TABLE_ENUMERATOR__bindgen_ty_1 , pub ChainHead : PLIST_ENTRY , pub BucketIndex : ULONG , } # [ repr ( C ) ] pub struct _RTL_DYNAMIC_HASH_TABLE_ENUMERATOR__bindgen_ty_1 { pub HashEntry : __BindgenUnionField < RTL_DYNAMIC_HASH_TABLE_ENTRY > , pub CurEntry : __BindgenUnionField < PLIST_ENTRY > , pub bindgen_union_field : [ u64 ; 3usize ] , } pub type RTL_DYNAMIC_HASH_TABLE_ENUMERATOR = _RTL_DYNAMIC_HASH_TABLE_ENUMERATOR ; pub type PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR = * mut _RTL_DYNAMIC_HASH_TABLE_ENUMERATOR ; # [ repr ( C ) ] pub struct _RTL_DYNAMIC_HASH_TABLE { pub Flags : ULONG , pub Shift : ULONG , pub TableSize : ULONG , pub Pivot : ULONG , pub DivisorMask : ULONG , pub NumEntries : ULONG , pub NonEmptyBuckets : ULONG , pub NumEnumerators : ULONG , pub Directory : PVOID , } pub type RTL_DYNAMIC_HASH_TABLE = _RTL_DYNAMIC_HASH_TABLE ; pub type PRTL_DYNAMIC_HASH_TABLE = * mut _RTL_DYNAMIC_HASH_TABLE ; extern "C" { pub fn RtlCreateHashTable ( HashTable : * mut PRTL_DYNAMIC_HASH_TABLE , Shift : ULONG , Flags : ULONG ) -> BOOLEAN ; } extern "C" { pub fn RtlCreateHashTableEx ( HashTable : * mut PRTL_DYNAMIC_HASH_TABLE , InitialSize : ULONG , Shift : ULONG , Flags : ULONG ) -> BOOLEAN ; } extern "C" { pub fn RtlDeleteHashTable ( HashTable : PRTL_DYNAMIC_HASH_TABLE ) ; } extern "C" { pub fn RtlInsertEntryHashTable ( HashTable : PRTL_DYNAMIC_HASH_TABLE , Entry : PRTL_DYNAMIC_HASH_TABLE_ENTRY , Signature : ULONG_PTR , Context : PRTL_DYNAMIC_HASH_TABLE_CONTEXT ) -> BOOLEAN ; } extern "C" { pub fn RtlRemoveEntryHashTable ( HashTable : PRTL_DYNAMIC_HASH_TABLE , Entry : PRTL_DYNAMIC_HASH_TABLE_ENTRY , Context : PRTL_DYNAMIC_HASH_TABLE_CONTEXT ) -> BOOLEAN ; } extern "C" { pub fn RtlLookupEntryHashTable ( HashTable : PRTL_DYNAMIC_HASH_TABLE , Signature : ULONG_PTR , Context : PRTL_DYNAMIC_HASH_TABLE_CONTEXT ) -> PRTL_DYNAMIC_HASH_TABLE_ENTRY ; } extern "C" { pub fn RtlGetNextEntryHashTable ( HashTable : PRTL_DYNAMIC_HASH_TABLE , Context : PRTL_DYNAMIC_HASH_TABLE_CONTEXT ) -> PRTL_DYNAMIC_HASH_TABLE_ENTRY ; } extern "C" { pub fn RtlInitEnumerationHashTable ( HashTable : PRTL_DYNAMIC_HASH_TABLE , Enumerator : PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR ) -> BOOLEAN ; } extern "C" { pub fn RtlEnumerateEntryHashTable ( HashTable : PRTL_DYNAMIC_HASH_TABLE , Enumerator : PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR ) -> PRTL_DYNAMIC_HASH_TABLE_ENTRY ; } extern "C" { pub fn RtlEndEnumerationHashTable ( HashTable : PRTL_DYNAMIC_HASH_TABLE , Enumerator : PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR ) ; } extern "C" { pub fn RtlInitWeakEnumerationHashTable ( HashTable : PRTL_DYNAMIC_HASH_TABLE , Enumerator : PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR ) -> BOOLEAN ; } extern "C" { pub fn RtlWeaklyEnumerateEntryHashTable ( HashTable : PRTL_DYNAMIC_HASH_TABLE , Enumerator : PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR ) -> PRTL_DYNAMIC_HASH_TABLE_ENTRY ; } extern "C" { pub fn RtlEndWeakEnumerationHashTable ( HashTable : PRTL_DYNAMIC_HASH_TABLE , Enumerator : PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR ) ; } extern "C" { pub fn RtlInitStrongEnumerationHashTable ( HashTable : PRTL_DYNAMIC_HASH_TABLE , Enumerator : PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR ) -> BOOLEAN ; } extern "C" { pub fn RtlStronglyEnumerateEntryHashTable ( HashTable : PRTL_DYNAMIC_HASH_TABLE , Enumerator : PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR ) -> PRTL_DYNAMIC_HASH_TABLE_ENTRY ; } extern "C" { pub fn RtlEndStrongEnumerationHashTable ( HashTable : PRTL_DYNAMIC_HASH_TABLE , Enumerator : PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR ) ; } extern "C" { pub fn RtlExpandHashTable ( HashTable : PRTL_DYNAMIC_HASH_TABLE ) -> BOOLEAN ; } extern "C" { pub fn RtlContractHashTable ( HashTable : PRTL_DYNAMIC_HASH_TABLE ) -> BOOLEAN ; } extern "C" { pub fn _ReturnAddress ( ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn RtlWalkFrameChain ( Callers : * mut PVOID , Count : ULONG , Flags : ULONG ) -> ULONG ; } extern "C" { pub fn RtlGetEnabledExtendedFeatures ( FeatureMask : ULONG64 ) -> ULONG64 ; } extern "C" { pub fn RtlCharToInteger ( String : PCSZ , Base : ULONG , Value : PULONG ) -> NTSTATUS ; } extern "C" { pub fn RtlCopyString ( DestinationString : PSTRING , SourceString : * const STRING ) ; } extern "C" { pub fn RtlUpperChar ( Character : CHAR ) -> CHAR ; } extern "C" { pub fn RtlCompareString ( String1 : * const STRING , String2 : * const STRING , CaseInSensitive : BOOLEAN ) -> LONG ; } extern "C" { pub fn RtlEqualString ( String1 : * const STRING , String2 : * const STRING , CaseInSensitive : BOOLEAN ) -> BOOLEAN ; } extern "C" { pub fn RtlUpperString ( DestinationString : PSTRING , SourceString : * const STRING ) ; } extern "C" { pub fn RtlPrefixUnicodeString ( String1 : PCUNICODE_STRING , String2 : PCUNICODE_STRING , CaseInSensitive : BOOLEAN ) -> BOOLEAN ; } extern "C" { pub fn RtlSuffixUnicodeString ( String1 : PCUNICODE_STRING , String2 : PCUNICODE_STRING , CaseInSensitive : BOOLEAN ) -> BOOLEAN ; } extern "C" { pub fn RtlUpcaseUnicodeString ( DestinationString : PUNICODE_STRING , SourceString : PCUNICODE_STRING , AllocateDestinationString : BOOLEAN ) -> NTSTATUS ; } extern "C" { pub fn RtlLargeIntegerDivide ( Dividend : LARGE_INTEGER , Divisor : LARGE_INTEGER , Remainder : PLARGE_INTEGER ) -> LARGE_INTEGER ; } extern "C" { pub fn RtlMapGenericMask ( AccessMask : PACCESS_MASK , GenericMapping : PGENERIC_MAPPING ) ; } extern "C" { pub fn RtlVolumeDeviceToDosName ( VolumeDeviceObject : PVOID , DosName : PUNICODE_STRING ) -> NTSTATUS ; } extern "C" { pub fn DbgPrompt ( Prompt : PCCH , Response : PCH , Length : ULONG ) -> ULONG ; } extern "C" { pub fn RtlGetProductInfo ( OSMajorVersion : ULONG , OSMinorVersion : ULONG , SpMajorVersion : ULONG , SpMinorVersion : ULONG , ReturnedProductType : PULONG ) -> BOOLEAN ; } extern "C" { pub fn RtlGetActiveConsoleId ( ) -> ULONG ; } extern "C" { pub fn RtlGetConsoleSessionForegroundProcessId ( ) -> ULONGLONG ; } extern "C" { pub fn RtlGetSuiteMask ( ) -> ULONG ; } extern "C" { pub fn RtlIsMultiSessionSku ( ) -> BOOLEAN ; } extern "C" { pub fn RtlIsStateSeparationEnabled ( ) -> BOOLEAN ; } extern "C" { pub fn RtlIsMultiUsersInSessionSku ( ) -> BOOLEAN ; } extern "C" { pub fn RtlGetNtProductType ( NtProductType : PNT_PRODUCT_TYPE ) -> BOOLEAN ; } extern "C" { pub fn RtlGetNtSystemRoot ( ) -> PCWSTR ; } # [ repr ( C ) ] pub struct CORRELATION_VECTOR { pub Version : CHAR , pub Vector : [ CHAR ; 129usize ] , } pub type PCORRELATION_VECTOR = * mut CORRELATION_VECTOR ; extern "C" { pub fn RtlInitializeCorrelationVector ( CorrelationVector : PCORRELATION_VECTOR , Version : :: std :: os :: raw :: c_int , Guid : * const GUID ) -> NTSTATUS ; } extern "C" { pub fn RtlIncrementCorrelationVector ( CorrelationVector : PCORRELATION_VECTOR ) -> NTSTATUS ; } extern "C" { pub fn RtlExtendCorrelationVector ( CorrelationVector : PCORRELATION_VECTOR ) -> NTSTATUS ; } extern "C" { pub fn RtlValidateCorrelationVector ( Vector : PCORRELATION_VECTOR ) -> NTSTATUS ; } # [ repr ( C ) ] pub struct _FILE_ALIGNMENT_INFORMATION { pub AlignmentRequirement : ULONG , } pub type FILE_ALIGNMENT_INFORMATION = _FILE_ALIGNMENT_INFORMATION ; pub type PFILE_ALIGNMENT_INFORMATION = * mut _FILE_ALIGNMENT_INFORMATION ; # [ repr ( C ) ] pub struct _FILE_NAME_INFORMATION { pub FileNameLength : ULONG , pub FileName : [ WCHAR ; 1usize ] , } pub type FILE_NAME_INFORMATION = _FILE_NAME_INFORMATION ; pub type PFILE_NAME_INFORMATION = * mut _FILE_NAME_INFORMATION ; # [ repr ( C ) ] pub struct _FILE_ATTRIBUTE_TAG_INFORMATION { pub FileAttributes : ULONG , pub ReparseTag : ULONG , } pub type FILE_ATTRIBUTE_TAG_INFORMATION = _FILE_ATTRIBUTE_TAG_INFORMATION ; pub type PFILE_ATTRIBUTE_TAG_INFORMATION = * mut _FILE_ATTRIBUTE_TAG_INFORMATION ; # [ repr ( C ) ] pub struct _FILE_DISPOSITION_INFORMATION { pub DeleteFile : BOOLEAN , } pub type FILE_DISPOSITION_INFORMATION = _FILE_DISPOSITION_INFORMATION ; pub type PFILE_DISPOSITION_INFORMATION = * mut _FILE_DISPOSITION_INFORMATION ; # [ repr ( C ) ] pub struct _FILE_DISPOSITION_INFORMATION_EX { pub Flags : ULONG , } pub type FILE_DISPOSITION_INFORMATION_EX = _FILE_DISPOSITION_INFORMATION_EX ; pub type PFILE_DISPOSITION_INFORMATION_EX = * mut _FILE_DISPOSITION_INFORMATION_EX ; # [ repr ( C ) ] pub struct _FILE_END_OF_FILE_INFORMATION { pub EndOfFile : LARGE_INTEGER , } pub type FILE_END_OF_FILE_INFORMATION = _FILE_END_OF_FILE_INFORMATION ; pub type PFILE_END_OF_FILE_INFORMATION = * mut _FILE_END_OF_FILE_INFORMATION ; # [ repr ( C ) ] pub struct _FILE_VALID_DATA_LENGTH_INFORMATION { pub ValidDataLength : LARGE_INTEGER , } pub type FILE_VALID_DATA_LENGTH_INFORMATION = _FILE_VALID_DATA_LENGTH_INFORMATION ; pub type PFILE_VALID_DATA_LENGTH_INFORMATION = * mut _FILE_VALID_DATA_LENGTH_INFORMATION ; # [ repr ( C ) ] pub struct _FILE_FS_LABEL_INFORMATION { pub VolumeLabelLength : ULONG , pub VolumeLabel : [ WCHAR ; 1usize ] , } pub type FILE_FS_LABEL_INFORMATION = _FILE_FS_LABEL_INFORMATION ; pub type PFILE_FS_LABEL_INFORMATION = * mut _FILE_FS_LABEL_INFORMATION ; # [ repr ( C ) ] pub struct _FILE_FS_VOLUME_INFORMATION { pub VolumeCreationTime : LARGE_INTEGER , pub VolumeSerialNumber : ULONG , pub VolumeLabelLength : ULONG , pub SupportsObjects : BOOLEAN , pub VolumeLabel : [ WCHAR ; 1usize ] , } pub type FILE_FS_VOLUME_INFORMATION = _FILE_FS_VOLUME_INFORMATION ; pub type PFILE_FS_VOLUME_INFORMATION = * mut _FILE_FS_VOLUME_INFORMATION ; # [ repr ( C ) ] pub struct _FILE_FS_SIZE_INFORMATION { pub TotalAllocationUnits : LARGE_INTEGER , pub AvailableAllocationUnits : LARGE_INTEGER , pub SectorsPerAllocationUnit : ULONG , pub BytesPerSector : ULONG , } pub type FILE_FS_SIZE_INFORMATION = _FILE_FS_SIZE_INFORMATION ; pub type PFILE_FS_SIZE_INFORMATION = * mut _FILE_FS_SIZE_INFORMATION ; # [ repr ( C ) ] pub struct _FILE_FS_FULL_SIZE_INFORMATION { pub TotalAllocationUnits : LARGE_INTEGER , pub CallerAvailableAllocationUnits : LARGE_INTEGER , pub ActualAvailableAllocationUnits : LARGE_INTEGER , pub SectorsPerAllocationUnit : ULONG , pub BytesPerSector : ULONG , } pub type FILE_FS_FULL_SIZE_INFORMATION = _FILE_FS_FULL_SIZE_INFORMATION ; pub type PFILE_FS_FULL_SIZE_INFORMATION = * mut _FILE_FS_FULL_SIZE_INFORMATION ; # [ repr ( C ) ] pub struct _FILE_FS_METADATA_SIZE_INFORMATION { pub TotalMetadataAllocationUnits : LARGE_INTEGER , pub SectorsPerAllocationUnit : ULONG , pub BytesPerSector : ULONG , } pub type FILE_FS_METADATA_SIZE_INFORMATION = _FILE_FS_METADATA_SIZE_INFORMATION ; pub type PFILE_FS_METADATA_SIZE_INFORMATION = * mut _FILE_FS_METADATA_SIZE_INFORMATION ; # [ repr ( C ) ] pub struct _FILE_FS_SECTOR_SIZE_INFORMATION { pub LogicalBytesPerSector : ULONG , pub PhysicalBytesPerSectorForAtomicity : ULONG , pub PhysicalBytesPerSectorForPerformance : ULONG , pub FileSystemEffectivePhysicalBytesPerSectorForAtomicity : ULONG , pub Flags : ULONG , pub ByteOffsetForSectorAlignment : ULONG , pub ByteOffsetForPartitionAlignment : ULONG , } pub type FILE_FS_SECTOR_SIZE_INFORMATION = _FILE_FS_SECTOR_SIZE_INFORMATION ; pub type PFILE_FS_SECTOR_SIZE_INFORMATION = * mut _FILE_FS_SECTOR_SIZE_INFORMATION ; # [ repr ( C ) ] pub struct _FILE_FS_OBJECTID_INFORMATION { pub ObjectId : [ UCHAR ; 16usize ] , pub ExtendedInfo : [ UCHAR ; 48usize ] , } pub type FILE_FS_OBJECTID_INFORMATION = _FILE_FS_OBJECTID_INFORMATION ; pub type PFILE_FS_OBJECTID_INFORMATION = * mut _FILE_FS_OBJECTID_INFORMATION ; pub const _BUS_DATA_TYPE_ConfigurationSpaceUndefined : _BUS_DATA_TYPE = -1 ; pub const _BUS_DATA_TYPE_Cmos : _BUS_DATA_TYPE = 0 ; pub const _BUS_DATA_TYPE_EisaConfiguration : _BUS_DATA_TYPE = 1 ; pub const _BUS_DATA_TYPE_Pos : _BUS_DATA_TYPE = 2 ; pub const _BUS_DATA_TYPE_CbusConfiguration : _BUS_DATA_TYPE = 3 ; pub const _BUS_DATA_TYPE_PCIConfiguration : _BUS_DATA_TYPE = 4 ; pub const _BUS_DATA_TYPE_VMEConfiguration : _BUS_DATA_TYPE = 5 ; pub const _BUS_DATA_TYPE_NuBusConfiguration : _BUS_DATA_TYPE = 6 ; pub const _BUS_DATA_TYPE_PCMCIAConfiguration : _BUS_DATA_TYPE = 7 ; pub const _BUS_DATA_TYPE_MPIConfiguration : _BUS_DATA_TYPE = 8 ; pub const _BUS_DATA_TYPE_MPSAConfiguration : _BUS_DATA_TYPE = 9 ; pub const _BUS_DATA_TYPE_PNPISAConfiguration : _BUS_DATA_TYPE = 10 ; pub const _BUS_DATA_TYPE_SgiInternalConfiguration : _BUS_DATA_TYPE = 11 ; pub const _BUS_DATA_TYPE_MaximumBusDataType : _BUS_DATA_TYPE = 12 ; pub type _BUS_DATA_TYPE = i32 ; pub use self :: _BUS_DATA_TYPE as BUS_DATA_TYPE ; pub type PBUS_DATA_TYPE = * mut _BUS_DATA_TYPE ; # [ repr ( C ) ] pub struct _KEY_NAME_INFORMATION { pub NameLength : ULONG , pub Name : [ WCHAR ; 1usize ] , } pub type KEY_NAME_INFORMATION = _KEY_NAME_INFORMATION ; pub type PKEY_NAME_INFORMATION = * mut _KEY_NAME_INFORMATION ; # [ repr ( C ) ] pub struct _KEY_CACHED_INFORMATION { pub LastWriteTime : LARGE_INTEGER , pub TitleIndex : ULONG , pub SubKeys : ULONG , pub MaxNameLen : ULONG , pub Values : ULONG , pub MaxValueNameLen : ULONG , pub MaxValueDataLen : ULONG , pub NameLength : ULONG , } pub type KEY_CACHED_INFORMATION = _KEY_CACHED_INFORMATION ; pub type PKEY_CACHED_INFORMATION = * mut _KEY_CACHED_INFORMATION ; # [ repr ( C ) ] pub struct _KEY_VIRTUALIZATION_INFORMATION { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _KEY_VIRTUALIZATION_INFORMATION { # [ inline ] pub fn VirtualizationCandidate ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_VirtualizationCandidate ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn VirtualizationEnabled ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_VirtualizationEnabled ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn VirtualTarget ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_VirtualTarget ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn VirtualStore ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_VirtualStore ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn VirtualSource ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_VirtualSource ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 27u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 27u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( VirtualizationCandidate : ULONG , VirtualizationEnabled : ULONG , VirtualTarget : ULONG , VirtualStore : ULONG , VirtualSource : ULONG , Reserved : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let VirtualizationCandidate : u32 = unsafe { :: std :: mem :: transmute ( VirtualizationCandidate ) } ; VirtualizationCandidate as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let VirtualizationEnabled : u32 = unsafe { :: std :: mem :: transmute ( VirtualizationEnabled ) } ; VirtualizationEnabled as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let VirtualTarget : u32 = unsafe { :: std :: mem :: transmute ( VirtualTarget ) } ; VirtualTarget as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let VirtualStore : u32 = unsafe { :: std :: mem :: transmute ( VirtualStore ) } ; VirtualStore as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let VirtualSource : u32 = unsafe { :: std :: mem :: transmute ( VirtualSource ) } ; VirtualSource as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 27u8 , { let Reserved : u32 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type KEY_VIRTUALIZATION_INFORMATION = _KEY_VIRTUALIZATION_INFORMATION ; pub type PKEY_VIRTUALIZATION_INFORMATION = * mut _KEY_VIRTUALIZATION_INFORMATION ; # [ repr ( C ) ] pub struct _KEY_LAYER_INFORMATION { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _KEY_LAYER_INFORMATION { # [ inline ] pub fn IsTombstone ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_IsTombstone ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn IsSupersedeLocal ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_IsSupersedeLocal ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn IsSupersedeTree ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_IsSupersedeTree ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ClassIsInherited ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ClassIsInherited ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 28u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 28u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( IsTombstone : ULONG , IsSupersedeLocal : ULONG , IsSupersedeTree : ULONG , ClassIsInherited : ULONG , Reserved : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let IsTombstone : u32 = unsafe { :: std :: mem :: transmute ( IsTombstone ) } ; IsTombstone as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let IsSupersedeLocal : u32 = unsafe { :: std :: mem :: transmute ( IsSupersedeLocal ) } ; IsSupersedeLocal as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let IsSupersedeTree : u32 = unsafe { :: std :: mem :: transmute ( IsSupersedeTree ) } ; IsSupersedeTree as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let ClassIsInherited : u32 = unsafe { :: std :: mem :: transmute ( ClassIsInherited ) } ; ClassIsInherited as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 28u8 , { let Reserved : u32 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type KEY_LAYER_INFORMATION = _KEY_LAYER_INFORMATION ; pub type PKEY_LAYER_INFORMATION = * mut _KEY_LAYER_INFORMATION ; # [ repr ( C ) ] pub struct _EXCEPTION_REGISTRATION_RECORD { pub Next : * mut _EXCEPTION_REGISTRATION_RECORD , pub Handler : PEXCEPTION_ROUTINE , } pub type EXCEPTION_REGISTRATION_RECORD = _EXCEPTION_REGISTRATION_RECORD ; pub type PEXCEPTION_REGISTRATION_RECORD = * mut EXCEPTION_REGISTRATION_RECORD ; # [ repr ( C ) ] pub struct _NT_TIB { pub ExceptionList : * mut _EXCEPTION_REGISTRATION_RECORD , pub StackBase : PVOID , pub StackLimit : PVOID , pub SubSystemTib : PVOID , pub __bindgen_anon_1 : _NT_TIB__bindgen_ty_1 , pub ArbitraryUserPointer : PVOID , pub Self_ : * mut _NT_TIB , } # [ repr ( C ) ] pub struct _NT_TIB__bindgen_ty_1 { pub FiberData : __BindgenUnionField < PVOID > , pub Version : __BindgenUnionField < ULONG > , pub bindgen_union_field : u64 , } pub type NT_TIB = _NT_TIB ; pub type PNT_TIB = * mut NT_TIB ; # [ repr ( C ) ] pub struct _NT_TIB32 { pub ExceptionList : ULONG , pub StackBase : ULONG , pub StackLimit : ULONG , pub SubSystemTib : ULONG , pub __bindgen_anon_1 : _NT_TIB32__bindgen_ty_1 , pub ArbitraryUserPointer : ULONG , pub Self_ : ULONG , } # [ repr ( C ) ] pub struct _NT_TIB32__bindgen_ty_1 { pub FiberData : __BindgenUnionField < ULONG > , pub Version : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } pub type NT_TIB32 = _NT_TIB32 ; pub type PNT_TIB32 = * mut _NT_TIB32 ; # [ repr ( C ) ] pub struct _NT_TIB64 { pub ExceptionList : ULONG64 , pub StackBase : ULONG64 , pub StackLimit : ULONG64 , pub SubSystemTib : ULONG64 , pub __bindgen_anon_1 : _NT_TIB64__bindgen_ty_1 , pub ArbitraryUserPointer : ULONG64 , pub Self_ : ULONG64 , } # [ repr ( C ) ] pub struct _NT_TIB64__bindgen_ty_1 { pub FiberData : __BindgenUnionField < ULONG64 > , pub Version : __BindgenUnionField < ULONG > , pub bindgen_union_field : u64 , } pub type NT_TIB64 = _NT_TIB64 ; pub type PNT_TIB64 = * mut _NT_TIB64 ; pub const _PROCESSINFOCLASS_ProcessBasicInformation : _PROCESSINFOCLASS = 0 ; pub const _PROCESSINFOCLASS_ProcessQuotaLimits : _PROCESSINFOCLASS = 1 ; pub const _PROCESSINFOCLASS_ProcessIoCounters : _PROCESSINFOCLASS = 2 ; pub const _PROCESSINFOCLASS_ProcessVmCounters : _PROCESSINFOCLASS = 3 ; pub const _PROCESSINFOCLASS_ProcessTimes : _PROCESSINFOCLASS = 4 ; pub const _PROCESSINFOCLASS_ProcessBasePriority : _PROCESSINFOCLASS = 5 ; pub const _PROCESSINFOCLASS_ProcessRaisePriority : _PROCESSINFOCLASS = 6 ; pub const _PROCESSINFOCLASS_ProcessDebugPort : _PROCESSINFOCLASS = 7 ; pub const _PROCESSINFOCLASS_ProcessExceptionPort : _PROCESSINFOCLASS = 8 ; pub const _PROCESSINFOCLASS_ProcessAccessToken : _PROCESSINFOCLASS = 9 ; pub const _PROCESSINFOCLASS_ProcessLdtInformation : _PROCESSINFOCLASS = 10 ; pub const _PROCESSINFOCLASS_ProcessLdtSize : _PROCESSINFOCLASS = 11 ; pub const _PROCESSINFOCLASS_ProcessDefaultHardErrorMode : _PROCESSINFOCLASS = 12 ; pub const _PROCESSINFOCLASS_ProcessIoPortHandlers : _PROCESSINFOCLASS = 13 ; pub const _PROCESSINFOCLASS_ProcessPooledUsageAndLimits : _PROCESSINFOCLASS = 14 ; pub const _PROCESSINFOCLASS_ProcessWorkingSetWatch : _PROCESSINFOCLASS = 15 ; pub const _PROCESSINFOCLASS_ProcessUserModeIOPL : _PROCESSINFOCLASS = 16 ; pub const _PROCESSINFOCLASS_ProcessEnableAlignmentFaultFixup : _PROCESSINFOCLASS = 17 ; pub const _PROCESSINFOCLASS_ProcessPriorityClass : _PROCESSINFOCLASS = 18 ; pub const _PROCESSINFOCLASS_ProcessWx86Information : _PROCESSINFOCLASS = 19 ; pub const _PROCESSINFOCLASS_ProcessHandleCount : _PROCESSINFOCLASS = 20 ; pub const _PROCESSINFOCLASS_ProcessAffinityMask : _PROCESSINFOCLASS = 21 ; pub const _PROCESSINFOCLASS_ProcessPriorityBoost : _PROCESSINFOCLASS = 22 ; pub const _PROCESSINFOCLASS_ProcessDeviceMap : _PROCESSINFOCLASS = 23 ; pub const _PROCESSINFOCLASS_ProcessSessionInformation : _PROCESSINFOCLASS = 24 ; pub const _PROCESSINFOCLASS_ProcessForegroundInformation : _PROCESSINFOCLASS = 25 ; pub const _PROCESSINFOCLASS_ProcessWow64Information : _PROCESSINFOCLASS = 26 ; pub const _PROCESSINFOCLASS_ProcessImageFileName : _PROCESSINFOCLASS = 27 ; pub const _PROCESSINFOCLASS_ProcessLUIDDeviceMapsEnabled : _PROCESSINFOCLASS = 28 ; pub const _PROCESSINFOCLASS_ProcessBreakOnTermination : _PROCESSINFOCLASS = 29 ; pub const _PROCESSINFOCLASS_ProcessDebugObjectHandle : _PROCESSINFOCLASS = 30 ; pub const _PROCESSINFOCLASS_ProcessDebugFlags : _PROCESSINFOCLASS = 31 ; pub const _PROCESSINFOCLASS_ProcessHandleTracing : _PROCESSINFOCLASS = 32 ; pub const _PROCESSINFOCLASS_ProcessIoPriority : _PROCESSINFOCLASS = 33 ; pub const _PROCESSINFOCLASS_ProcessExecuteFlags : _PROCESSINFOCLASS = 34 ; pub const _PROCESSINFOCLASS_ProcessTlsInformation : _PROCESSINFOCLASS = 35 ; pub const _PROCESSINFOCLASS_ProcessCookie : _PROCESSINFOCLASS = 36 ; pub const _PROCESSINFOCLASS_ProcessImageInformation : _PROCESSINFOCLASS = 37 ; pub const _PROCESSINFOCLASS_ProcessCycleTime : _PROCESSINFOCLASS = 38 ; pub const _PROCESSINFOCLASS_ProcessPagePriority : _PROCESSINFOCLASS = 39 ; pub const _PROCESSINFOCLASS_ProcessInstrumentationCallback : _PROCESSINFOCLASS = 40 ; pub const _PROCESSINFOCLASS_ProcessThreadStackAllocation : _PROCESSINFOCLASS = 41 ; pub const _PROCESSINFOCLASS_ProcessWorkingSetWatchEx : _PROCESSINFOCLASS = 42 ; pub const _PROCESSINFOCLASS_ProcessImageFileNameWin32 : _PROCESSINFOCLASS = 43 ; pub const _PROCESSINFOCLASS_ProcessImageFileMapping : _PROCESSINFOCLASS = 44 ; pub const _PROCESSINFOCLASS_ProcessAffinityUpdateMode : _PROCESSINFOCLASS = 45 ; pub const _PROCESSINFOCLASS_ProcessMemoryAllocationMode : _PROCESSINFOCLASS = 46 ; pub const _PROCESSINFOCLASS_ProcessGroupInformation : _PROCESSINFOCLASS = 47 ; pub const _PROCESSINFOCLASS_ProcessTokenVirtualizationEnabled : _PROCESSINFOCLASS = 48 ; pub const _PROCESSINFOCLASS_ProcessOwnerInformation : _PROCESSINFOCLASS = 49 ; pub const _PROCESSINFOCLASS_ProcessWindowInformation : _PROCESSINFOCLASS = 50 ; pub const _PROCESSINFOCLASS_ProcessHandleInformation : _PROCESSINFOCLASS = 51 ; pub const _PROCESSINFOCLASS_ProcessMitigationPolicy : _PROCESSINFOCLASS = 52 ; pub const _PROCESSINFOCLASS_ProcessDynamicFunctionTableInformation : _PROCESSINFOCLASS = 53 ; pub const _PROCESSINFOCLASS_ProcessHandleCheckingMode : _PROCESSINFOCLASS = 54 ; pub const _PROCESSINFOCLASS_ProcessKeepAliveCount : _PROCESSINFOCLASS = 55 ; pub const _PROCESSINFOCLASS_ProcessRevokeFileHandles : _PROCESSINFOCLASS = 56 ; pub const _PROCESSINFOCLASS_ProcessWorkingSetControl : _PROCESSINFOCLASS = 57 ; pub const _PROCESSINFOCLASS_ProcessHandleTable : _PROCESSINFOCLASS = 58 ; pub const _PROCESSINFOCLASS_ProcessCheckStackExtentsMode : _PROCESSINFOCLASS = 59 ; pub const _PROCESSINFOCLASS_ProcessCommandLineInformation : _PROCESSINFOCLASS = 60 ; pub const _PROCESSINFOCLASS_ProcessProtectionInformation : _PROCESSINFOCLASS = 61 ; pub const _PROCESSINFOCLASS_ProcessMemoryExhaustion : _PROCESSINFOCLASS = 62 ; pub const _PROCESSINFOCLASS_ProcessFaultInformation : _PROCESSINFOCLASS = 63 ; pub const _PROCESSINFOCLASS_ProcessTelemetryIdInformation : _PROCESSINFOCLASS = 64 ; pub const _PROCESSINFOCLASS_ProcessCommitReleaseInformation : _PROCESSINFOCLASS = 65 ; pub const _PROCESSINFOCLASS_ProcessReserved1Information : _PROCESSINFOCLASS = 66 ; pub const _PROCESSINFOCLASS_ProcessReserved2Information : _PROCESSINFOCLASS = 67 ; pub const _PROCESSINFOCLASS_ProcessSubsystemProcess : _PROCESSINFOCLASS = 68 ; pub const _PROCESSINFOCLASS_ProcessInPrivate : _PROCESSINFOCLASS = 70 ; pub const _PROCESSINFOCLASS_ProcessRaiseUMExceptionOnInvalidHandleClose : _PROCESSINFOCLASS = 71 ; pub const _PROCESSINFOCLASS_ProcessSubsystemInformation : _PROCESSINFOCLASS = 75 ; pub const _PROCESSINFOCLASS_ProcessWin32kSyscallFilterInformation : _PROCESSINFOCLASS = 79 ; pub const _PROCESSINFOCLASS_ProcessEnergyTrackingState : _PROCESSINFOCLASS = 82 ; pub const _PROCESSINFOCLASS_MaxProcessInfoClass : _PROCESSINFOCLASS = 83 ; pub type _PROCESSINFOCLASS = i32 ; pub use self :: _PROCESSINFOCLASS as PROCESSINFOCLASS ; pub const _THREADINFOCLASS_ThreadBasicInformation : _THREADINFOCLASS = 0 ; pub const _THREADINFOCLASS_ThreadTimes : _THREADINFOCLASS = 1 ; pub const _THREADINFOCLASS_ThreadPriority : _THREADINFOCLASS = 2 ; pub const _THREADINFOCLASS_ThreadBasePriority : _THREADINFOCLASS = 3 ; pub const _THREADINFOCLASS_ThreadAffinityMask : _THREADINFOCLASS = 4 ; pub const _THREADINFOCLASS_ThreadImpersonationToken : _THREADINFOCLASS = 5 ; pub const _THREADINFOCLASS_ThreadDescriptorTableEntry : _THREADINFOCLASS = 6 ; pub const _THREADINFOCLASS_ThreadEnableAlignmentFaultFixup : _THREADINFOCLASS = 7 ; pub const _THREADINFOCLASS_ThreadEventPair_Reusable : _THREADINFOCLASS = 8 ; pub const _THREADINFOCLASS_ThreadQuerySetWin32StartAddress : _THREADINFOCLASS = 9 ; pub const _THREADINFOCLASS_ThreadZeroTlsCell : _THREADINFOCLASS = 10 ; pub const _THREADINFOCLASS_ThreadPerformanceCount : _THREADINFOCLASS = 11 ; pub const _THREADINFOCLASS_ThreadAmILastThread : _THREADINFOCLASS = 12 ; pub const _THREADINFOCLASS_ThreadIdealProcessor : _THREADINFOCLASS = 13 ; pub const _THREADINFOCLASS_ThreadPriorityBoost : _THREADINFOCLASS = 14 ; pub const _THREADINFOCLASS_ThreadSetTlsArrayAddress : _THREADINFOCLASS = 15 ; pub const _THREADINFOCLASS_ThreadIsIoPending : _THREADINFOCLASS = 16 ; pub const _THREADINFOCLASS_ThreadHideFromDebugger : _THREADINFOCLASS = 17 ; pub const _THREADINFOCLASS_ThreadBreakOnTermination : _THREADINFOCLASS = 18 ; pub const _THREADINFOCLASS_ThreadSwitchLegacyState : _THREADINFOCLASS = 19 ; pub const _THREADINFOCLASS_ThreadIsTerminated : _THREADINFOCLASS = 20 ; pub const _THREADINFOCLASS_ThreadLastSystemCall : _THREADINFOCLASS = 21 ; pub const _THREADINFOCLASS_ThreadIoPriority : _THREADINFOCLASS = 22 ; pub const _THREADINFOCLASS_ThreadCycleTime : _THREADINFOCLASS = 23 ; pub const _THREADINFOCLASS_ThreadPagePriority : _THREADINFOCLASS = 24 ; pub const _THREADINFOCLASS_ThreadActualBasePriority : _THREADINFOCLASS = 25 ; pub const _THREADINFOCLASS_ThreadTebInformation : _THREADINFOCLASS = 26 ; pub const _THREADINFOCLASS_ThreadCSwitchMon : _THREADINFOCLASS = 27 ; pub const _THREADINFOCLASS_ThreadCSwitchPmu : _THREADINFOCLASS = 28 ; pub const _THREADINFOCLASS_ThreadWow64Context : _THREADINFOCLASS = 29 ; pub const _THREADINFOCLASS_ThreadGroupInformation : _THREADINFOCLASS = 30 ; pub const _THREADINFOCLASS_ThreadUmsInformation : _THREADINFOCLASS = 31 ; pub const _THREADINFOCLASS_ThreadCounterProfiling : _THREADINFOCLASS = 32 ; pub const _THREADINFOCLASS_ThreadIdealProcessorEx : _THREADINFOCLASS = 33 ; pub const _THREADINFOCLASS_ThreadCpuAccountingInformation : _THREADINFOCLASS = 34 ; pub const _THREADINFOCLASS_ThreadSuspendCount : _THREADINFOCLASS = 35 ; pub const _THREADINFOCLASS_ThreadActualGroupAffinity : _THREADINFOCLASS = 41 ; pub const _THREADINFOCLASS_ThreadDynamicCodePolicyInfo : _THREADINFOCLASS = 42 ; pub const _THREADINFOCLASS_ThreadSubsystemInformation : _THREADINFOCLASS = 45 ; pub const _THREADINFOCLASS_MaxThreadInfoClass : _THREADINFOCLASS = 50 ; pub type _THREADINFOCLASS = i32 ; pub use self :: _THREADINFOCLASS as THREADINFOCLASS ; # [ repr ( C ) ] pub struct _PAGE_PRIORITY_INFORMATION { pub PagePriority : ULONG , } pub type PAGE_PRIORITY_INFORMATION = _PAGE_PRIORITY_INFORMATION ; pub type PPAGE_PRIORITY_INFORMATION = * mut _PAGE_PRIORITY_INFORMATION ; # [ repr ( C ) ] pub struct _PROCESS_WS_WATCH_INFORMATION { pub FaultingPc : PVOID , pub FaultingVa : PVOID , } pub type PROCESS_WS_WATCH_INFORMATION = _PROCESS_WS_WATCH_INFORMATION ; pub type PPROCESS_WS_WATCH_INFORMATION = * mut _PROCESS_WS_WATCH_INFORMATION ; # [ repr ( C ) ] pub struct _PROCESS_BASIC_INFORMATION { pub ExitStatus : NTSTATUS , pub PebBaseAddress : PPEB , pub AffinityMask : ULONG_PTR , pub BasePriority : KPRIORITY , pub UniqueProcessId : ULONG_PTR , pub InheritedFromUniqueProcessId : ULONG_PTR , } pub type PROCESS_BASIC_INFORMATION = _PROCESS_BASIC_INFORMATION ; pub type PPROCESS_BASIC_INFORMATION = * mut _PROCESS_BASIC_INFORMATION ; # [ repr ( C ) ] pub struct _PROCESS_EXTENDED_BASIC_INFORMATION { pub Size : SIZE_T , pub BasicInfo : PROCESS_BASIC_INFORMATION , pub __bindgen_anon_1 : _PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_1 { pub Flags : __BindgenUnionField < ULONG > , pub __bindgen_anon_1 : __BindgenUnionField < _PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn IsProtectedProcess ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_IsProtectedProcess ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn IsWow64Process ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_IsWow64Process ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn IsProcessDeleting ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_IsProcessDeleting ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn IsCrossSessionCreate ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_IsCrossSessionCreate ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn IsFrozen ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_IsFrozen ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn IsBackground ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_IsBackground ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn IsStronglyNamed ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_IsStronglyNamed ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn IsSecureProcess ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_IsSecureProcess ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn IsSubsystemProcess ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_IsSubsystemProcess ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn SpareBits ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 23u8 ) as u32 ) } } # [ inline ] pub fn set_SpareBits ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 23u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( IsProtectedProcess : ULONG , IsWow64Process : ULONG , IsProcessDeleting : ULONG , IsCrossSessionCreate : ULONG , IsFrozen : ULONG , IsBackground : ULONG , IsStronglyNamed : ULONG , IsSecureProcess : ULONG , IsSubsystemProcess : ULONG , SpareBits : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let IsProtectedProcess : u32 = unsafe { :: std :: mem :: transmute ( IsProtectedProcess ) } ; IsProtectedProcess as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let IsWow64Process : u32 = unsafe { :: std :: mem :: transmute ( IsWow64Process ) } ; IsWow64Process as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let IsProcessDeleting : u32 = unsafe { :: std :: mem :: transmute ( IsProcessDeleting ) } ; IsProcessDeleting as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let IsCrossSessionCreate : u32 = unsafe { :: std :: mem :: transmute ( IsCrossSessionCreate ) } ; IsCrossSessionCreate as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let IsFrozen : u32 = unsafe { :: std :: mem :: transmute ( IsFrozen ) } ; IsFrozen as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let IsBackground : u32 = unsafe { :: std :: mem :: transmute ( IsBackground ) } ; IsBackground as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let IsStronglyNamed : u32 = unsafe { :: std :: mem :: transmute ( IsStronglyNamed ) } ; IsStronglyNamed as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let IsSecureProcess : u32 = unsafe { :: std :: mem :: transmute ( IsSecureProcess ) } ; IsSecureProcess as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let IsSubsystemProcess : u32 = unsafe { :: std :: mem :: transmute ( IsSubsystemProcess ) } ; IsSubsystemProcess as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 23u8 , { let SpareBits : u32 = unsafe { :: std :: mem :: transmute ( SpareBits ) } ; SpareBits as u64 } ) ; __bindgen_bitfield_unit } } pub type PROCESS_EXTENDED_BASIC_INFORMATION = _PROCESS_EXTENDED_BASIC_INFORMATION ; pub type PPROCESS_EXTENDED_BASIC_INFORMATION = * mut _PROCESS_EXTENDED_BASIC_INFORMATION ; # [ repr ( C ) ] pub struct _PROCESS_DEVICEMAP_INFORMATION { pub __bindgen_anon_1 : _PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1 { pub Set : __BindgenUnionField < _PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1__bindgen_ty_1 > , pub Query : __BindgenUnionField < _PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1__bindgen_ty_2 > , pub bindgen_union_field : [ u64 ; 5usize ] , } # [ repr ( C ) ] pub struct _PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1__bindgen_ty_1 { pub DirectoryHandle : HANDLE , } # [ repr ( C ) ] pub struct _PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1__bindgen_ty_2 { pub DriveMap : ULONG , pub DriveType : [ UCHAR ; 32usize ] , } pub type PROCESS_DEVICEMAP_INFORMATION = _PROCESS_DEVICEMAP_INFORMATION ; pub type PPROCESS_DEVICEMAP_INFORMATION = * mut _PROCESS_DEVICEMAP_INFORMATION ; # [ repr ( C ) ] pub struct _PROCESS_DEVICEMAP_INFORMATION_EX { pub __bindgen_anon_1 : _PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1 , pub Flags : ULONG , } # [ repr ( C ) ] pub struct _PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1 { pub Set : __BindgenUnionField < _PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1__bindgen_ty_1 > , pub Query : __BindgenUnionField < _PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1__bindgen_ty_2 > , pub bindgen_union_field : [ u64 ; 5usize ] , } # [ repr ( C ) ] pub struct _PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1__bindgen_ty_1 { pub DirectoryHandle : HANDLE , } # [ repr ( C ) ] pub struct _PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1__bindgen_ty_2 { pub DriveMap : ULONG , pub DriveType : [ UCHAR ; 32usize ] , } pub type PROCESS_DEVICEMAP_INFORMATION_EX = _PROCESS_DEVICEMAP_INFORMATION_EX ; pub type PPROCESS_DEVICEMAP_INFORMATION_EX = * mut _PROCESS_DEVICEMAP_INFORMATION_EX ; # [ repr ( C ) ] pub struct _PROCESS_SESSION_INFORMATION { pub SessionId : ULONG , } pub type PROCESS_SESSION_INFORMATION = _PROCESS_SESSION_INFORMATION ; pub type PPROCESS_SESSION_INFORMATION = * mut _PROCESS_SESSION_INFORMATION ; # [ repr ( C ) ] pub struct _PROCESS_HANDLE_TRACING_ENABLE { pub Flags : ULONG , } pub type PROCESS_HANDLE_TRACING_ENABLE = _PROCESS_HANDLE_TRACING_ENABLE ; pub type PPROCESS_HANDLE_TRACING_ENABLE = * mut _PROCESS_HANDLE_TRACING_ENABLE ; # [ repr ( C ) ] pub struct _PROCESS_HANDLE_TRACING_ENABLE_EX { pub Flags : ULONG , pub TotalSlots : ULONG , } pub type PROCESS_HANDLE_TRACING_ENABLE_EX = _PROCESS_HANDLE_TRACING_ENABLE_EX ; pub type PPROCESS_HANDLE_TRACING_ENABLE_EX = * mut _PROCESS_HANDLE_TRACING_ENABLE_EX ; # [ repr ( C ) ] pub struct _PROCESS_HANDLE_TRACING_ENTRY { pub Handle : HANDLE , pub ClientId : CLIENT_ID , pub Type : ULONG , pub Stacks : [ PVOID ; 16usize ] , } pub type PROCESS_HANDLE_TRACING_ENTRY = _PROCESS_HANDLE_TRACING_ENTRY ; pub type PPROCESS_HANDLE_TRACING_ENTRY = * mut _PROCESS_HANDLE_TRACING_ENTRY ; # [ repr ( C ) ] pub struct _PROCESS_HANDLE_TRACING_QUERY { pub Handle : HANDLE , pub TotalTraces : ULONG , pub HandleTrace : [ PROCESS_HANDLE_TRACING_ENTRY ; 1usize ] , } pub type PROCESS_HANDLE_TRACING_QUERY = _PROCESS_HANDLE_TRACING_QUERY ; pub type PPROCESS_HANDLE_TRACING_QUERY = * mut _PROCESS_HANDLE_TRACING_QUERY ; # [ repr ( C ) ] pub struct _QUOTA_LIMITS { pub PagedPoolLimit : SIZE_T , pub NonPagedPoolLimit : SIZE_T , pub MinimumWorkingSetSize : SIZE_T , pub MaximumWorkingSetSize : SIZE_T , pub PagefileLimit : SIZE_T , pub TimeLimit : LARGE_INTEGER , } pub type QUOTA_LIMITS = _QUOTA_LIMITS ; pub type PQUOTA_LIMITS = * mut _QUOTA_LIMITS ; # [ repr ( C ) ] pub struct _RATE_QUOTA_LIMIT { pub RateData : __BindgenUnionField < ULONG > , pub __bindgen_anon_1 : __BindgenUnionField < _RATE_QUOTA_LIMIT__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _RATE_QUOTA_LIMIT__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _RATE_QUOTA_LIMIT__bindgen_ty_1 { # [ inline ] pub fn RatePercent ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 7u8 ) as u32 ) } } # [ inline ] pub fn set_RatePercent ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 7u8 , val as u64 ) } } # [ inline ] pub fn Reserved0 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 25u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved0 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 25u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( RatePercent : ULONG , Reserved0 : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 7u8 , { let RatePercent : u32 = unsafe { :: std :: mem :: transmute ( RatePercent ) } ; RatePercent as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 25u8 , { let Reserved0 : u32 = unsafe { :: std :: mem :: transmute ( Reserved0 ) } ; Reserved0 as u64 } ) ; __bindgen_bitfield_unit } } pub type RATE_QUOTA_LIMIT = _RATE_QUOTA_LIMIT ; pub type PRATE_QUOTA_LIMIT = * mut _RATE_QUOTA_LIMIT ; # [ repr ( C ) ] pub struct _QUOTA_LIMITS_EX { pub PagedPoolLimit : SIZE_T , pub NonPagedPoolLimit : SIZE_T , pub MinimumWorkingSetSize : SIZE_T , pub MaximumWorkingSetSize : SIZE_T , pub PagefileLimit : SIZE_T , pub TimeLimit : LARGE_INTEGER , pub WorkingSetLimit : SIZE_T , pub Reserved2 : SIZE_T , pub Reserved3 : SIZE_T , pub Reserved4 : SIZE_T , pub Flags : ULONG , pub CpuRateLimit : RATE_QUOTA_LIMIT , } pub type QUOTA_LIMITS_EX = _QUOTA_LIMITS_EX ; pub type PQUOTA_LIMITS_EX = * mut _QUOTA_LIMITS_EX ; # [ repr ( C ) ] pub struct _IO_COUNTERS { pub ReadOperationCount : ULONGLONG , pub WriteOperationCount : ULONGLONG , pub OtherOperationCount : ULONGLONG , pub ReadTransferCount : ULONGLONG , pub WriteTransferCount : ULONGLONG , pub OtherTransferCount : ULONGLONG , } pub type IO_COUNTERS = _IO_COUNTERS ; pub type PIO_COUNTERS = * mut IO_COUNTERS ; # [ repr ( C ) ] pub struct _VM_COUNTERS { pub PeakVirtualSize : SIZE_T , pub VirtualSize : SIZE_T , pub PageFaultCount : ULONG , pub PeakWorkingSetSize : SIZE_T , pub WorkingSetSize : SIZE_T , pub QuotaPeakPagedPoolUsage : SIZE_T , pub QuotaPagedPoolUsage : SIZE_T , pub QuotaPeakNonPagedPoolUsage : SIZE_T , pub QuotaNonPagedPoolUsage : SIZE_T , pub PagefileUsage : SIZE_T , pub PeakPagefileUsage : SIZE_T , } pub type VM_COUNTERS = _VM_COUNTERS ; pub type PVM_COUNTERS = * mut VM_COUNTERS ; # [ repr ( C ) ] pub struct _VM_COUNTERS_EX { pub PeakVirtualSize : SIZE_T , pub VirtualSize : SIZE_T , pub PageFaultCount : ULONG , pub PeakWorkingSetSize : SIZE_T , pub WorkingSetSize : SIZE_T , pub QuotaPeakPagedPoolUsage : SIZE_T , pub QuotaPagedPoolUsage : SIZE_T , pub QuotaPeakNonPagedPoolUsage : SIZE_T , pub QuotaNonPagedPoolUsage : SIZE_T , pub PagefileUsage : SIZE_T , pub PeakPagefileUsage : SIZE_T , pub PrivateUsage : SIZE_T , } pub type VM_COUNTERS_EX = _VM_COUNTERS_EX ; pub type PVM_COUNTERS_EX = * mut VM_COUNTERS_EX ; # [ repr ( C ) ] pub struct _VM_COUNTERS_EX2 { pub CountersEx : VM_COUNTERS_EX , pub PrivateWorkingSetSize : SIZE_T , pub SharedCommitUsage : ULONGLONG , } pub type VM_COUNTERS_EX2 = _VM_COUNTERS_EX2 ; pub type PVM_COUNTERS_EX2 = * mut _VM_COUNTERS_EX2 ; pub const _HARDWARE_COUNTER_TYPE_PMCCounter : _HARDWARE_COUNTER_TYPE = 0 ; pub const _HARDWARE_COUNTER_TYPE_MaxHardwareCounterType : _HARDWARE_COUNTER_TYPE = 1 ; pub type _HARDWARE_COUNTER_TYPE = i32 ; pub use self :: _HARDWARE_COUNTER_TYPE as HARDWARE_COUNTER_TYPE ; pub type PHARDWARE_COUNTER_TYPE = * mut _HARDWARE_COUNTER_TYPE ; # [ repr ( C ) ] pub struct _HARDWARE_COUNTER { pub Type : HARDWARE_COUNTER_TYPE , pub Reserved : ULONG , pub Index : ULONG64 , } pub type HARDWARE_COUNTER = _HARDWARE_COUNTER ; pub type PHARDWARE_COUNTER = * mut _HARDWARE_COUNTER ; pub const _PROCESS_MITIGATION_POLICY_ProcessDEPPolicy : _PROCESS_MITIGATION_POLICY = 0 ; pub const _PROCESS_MITIGATION_POLICY_ProcessASLRPolicy : _PROCESS_MITIGATION_POLICY = 1 ; pub const _PROCESS_MITIGATION_POLICY_ProcessDynamicCodePolicy : _PROCESS_MITIGATION_POLICY = 2 ; pub const _PROCESS_MITIGATION_POLICY_ProcessStrictHandleCheckPolicy : _PROCESS_MITIGATION_POLICY = 3 ; pub const _PROCESS_MITIGATION_POLICY_ProcessSystemCallDisablePolicy : _PROCESS_MITIGATION_POLICY = 4 ; pub const _PROCESS_MITIGATION_POLICY_ProcessMitigationOptionsMask : _PROCESS_MITIGATION_POLICY = 5 ; pub const _PROCESS_MITIGATION_POLICY_ProcessExtensionPointDisablePolicy : _PROCESS_MITIGATION_POLICY = 6 ; pub const _PROCESS_MITIGATION_POLICY_ProcessControlFlowGuardPolicy : _PROCESS_MITIGATION_POLICY = 7 ; pub const _PROCESS_MITIGATION_POLICY_ProcessSignaturePolicy : _PROCESS_MITIGATION_POLICY = 8 ; pub const _PROCESS_MITIGATION_POLICY_ProcessFontDisablePolicy : _PROCESS_MITIGATION_POLICY = 9 ; pub const _PROCESS_MITIGATION_POLICY_ProcessImageLoadPolicy : _PROCESS_MITIGATION_POLICY = 10 ; pub const _PROCESS_MITIGATION_POLICY_ProcessSystemCallFilterPolicy : _PROCESS_MITIGATION_POLICY = 11 ; pub const _PROCESS_MITIGATION_POLICY_ProcessPayloadRestrictionPolicy : _PROCESS_MITIGATION_POLICY = 12 ; pub const _PROCESS_MITIGATION_POLICY_ProcessChildProcessPolicy : _PROCESS_MITIGATION_POLICY = 13 ; pub const _PROCESS_MITIGATION_POLICY_MaxProcessMitigationPolicy : _PROCESS_MITIGATION_POLICY = 14 ; pub type _PROCESS_MITIGATION_POLICY = i32 ; pub use self :: _PROCESS_MITIGATION_POLICY as PROCESS_MITIGATION_POLICY ; pub type PPROCESS_MITIGATION_POLICY = * mut _PROCESS_MITIGATION_POLICY ; # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_ASLR_POLICY { pub __bindgen_anon_1 : _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1 { pub Flags : __BindgenUnionField < ULONG > , pub __bindgen_anon_1 : __BindgenUnionField < _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn EnableBottomUpRandomization ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_EnableBottomUpRandomization ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn EnableForceRelocateImages ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_EnableForceRelocateImages ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn EnableHighEntropy ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_EnableHighEntropy ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn DisallowStrippedImages ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_DisallowStrippedImages ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ReservedFlags ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 28u8 ) as u32 ) } } # [ inline ] pub fn set_ReservedFlags ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 28u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( EnableBottomUpRandomization : ULONG , EnableForceRelocateImages : ULONG , EnableHighEntropy : ULONG , DisallowStrippedImages : ULONG , ReservedFlags : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let EnableBottomUpRandomization : u32 = unsafe { :: std :: mem :: transmute ( EnableBottomUpRandomization ) } ; EnableBottomUpRandomization as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let EnableForceRelocateImages : u32 = unsafe { :: std :: mem :: transmute ( EnableForceRelocateImages ) } ; EnableForceRelocateImages as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let EnableHighEntropy : u32 = unsafe { :: std :: mem :: transmute ( EnableHighEntropy ) } ; EnableHighEntropy as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let DisallowStrippedImages : u32 = unsafe { :: std :: mem :: transmute ( DisallowStrippedImages ) } ; DisallowStrippedImages as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 28u8 , { let ReservedFlags : u32 = unsafe { :: std :: mem :: transmute ( ReservedFlags ) } ; ReservedFlags as u64 } ) ; __bindgen_bitfield_unit } } pub type PROCESS_MITIGATION_ASLR_POLICY = _PROCESS_MITIGATION_ASLR_POLICY ; pub type PPROCESS_MITIGATION_ASLR_POLICY = * mut _PROCESS_MITIGATION_ASLR_POLICY ; # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_DEP_POLICY { pub __bindgen_anon_1 : _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1 , pub Permanent : BOOLEAN , } # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1 { pub Flags : __BindgenUnionField < ULONG > , pub __bindgen_anon_1 : __BindgenUnionField < _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn Enable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Enable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn DisableAtlThunkEmulation ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_DisableAtlThunkEmulation ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ReservedFlags ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 30u8 ) as u32 ) } } # [ inline ] pub fn set_ReservedFlags ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 30u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Enable : ULONG , DisableAtlThunkEmulation : ULONG , ReservedFlags : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let Enable : u32 = unsafe { :: std :: mem :: transmute ( Enable ) } ; Enable as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let DisableAtlThunkEmulation : u32 = unsafe { :: std :: mem :: transmute ( DisableAtlThunkEmulation ) } ; DisableAtlThunkEmulation as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 30u8 , { let ReservedFlags : u32 = unsafe { :: std :: mem :: transmute ( ReservedFlags ) } ; ReservedFlags as u64 } ) ; __bindgen_bitfield_unit } } pub type PROCESS_MITIGATION_DEP_POLICY = _PROCESS_MITIGATION_DEP_POLICY ; pub type PPROCESS_MITIGATION_DEP_POLICY = * mut _PROCESS_MITIGATION_DEP_POLICY ; # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY { pub __bindgen_anon_1 : _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1 { pub Flags : __BindgenUnionField < ULONG > , pub __bindgen_anon_1 : __BindgenUnionField < _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn RaiseExceptionOnInvalidHandleReference ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_RaiseExceptionOnInvalidHandleReference ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn HandleExceptionsPermanentlyEnabled ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_HandleExceptionsPermanentlyEnabled ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ReservedFlags ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 30u8 ) as u32 ) } } # [ inline ] pub fn set_ReservedFlags ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 30u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( RaiseExceptionOnInvalidHandleReference : ULONG , HandleExceptionsPermanentlyEnabled : ULONG , ReservedFlags : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let RaiseExceptionOnInvalidHandleReference : u32 = unsafe { :: std :: mem :: transmute ( RaiseExceptionOnInvalidHandleReference ) } ; RaiseExceptionOnInvalidHandleReference as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let HandleExceptionsPermanentlyEnabled : u32 = unsafe { :: std :: mem :: transmute ( HandleExceptionsPermanentlyEnabled ) } ; HandleExceptionsPermanentlyEnabled as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 30u8 , { let ReservedFlags : u32 = unsafe { :: std :: mem :: transmute ( ReservedFlags ) } ; ReservedFlags as u64 } ) ; __bindgen_bitfield_unit } } pub type PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY = _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY ; pub type PPROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY = * mut _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY ; # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY { pub __bindgen_anon_1 : _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1 { pub Flags : __BindgenUnionField < ULONG > , pub __bindgen_anon_1 : __BindgenUnionField < _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn DisallowWin32kSystemCalls ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_DisallowWin32kSystemCalls ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AuditDisallowWin32kSystemCalls ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AuditDisallowWin32kSystemCalls ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ReservedFlags ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 30u8 ) as u32 ) } } # [ inline ] pub fn set_ReservedFlags ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 30u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( DisallowWin32kSystemCalls : ULONG , AuditDisallowWin32kSystemCalls : ULONG , ReservedFlags : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let DisallowWin32kSystemCalls : u32 = unsafe { :: std :: mem :: transmute ( DisallowWin32kSystemCalls ) } ; DisallowWin32kSystemCalls as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let AuditDisallowWin32kSystemCalls : u32 = unsafe { :: std :: mem :: transmute ( AuditDisallowWin32kSystemCalls ) } ; AuditDisallowWin32kSystemCalls as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 30u8 , { let ReservedFlags : u32 = unsafe { :: std :: mem :: transmute ( ReservedFlags ) } ; ReservedFlags as u64 } ) ; __bindgen_bitfield_unit } } pub type PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY = _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY ; pub type PPROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY = * mut _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY ; # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY { pub __bindgen_anon_1 : _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1 { pub Flags : __BindgenUnionField < ULONG > , pub __bindgen_anon_1 : __BindgenUnionField < _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn DisableExtensionPoints ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_DisableExtensionPoints ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ReservedFlags ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 31u8 ) as u32 ) } } # [ inline ] pub fn set_ReservedFlags ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 31u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( DisableExtensionPoints : ULONG , ReservedFlags : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let DisableExtensionPoints : u32 = unsafe { :: std :: mem :: transmute ( DisableExtensionPoints ) } ; DisableExtensionPoints as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 31u8 , { let ReservedFlags : u32 = unsafe { :: std :: mem :: transmute ( ReservedFlags ) } ; ReservedFlags as u64 } ) ; __bindgen_bitfield_unit } } pub type PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY = _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY ; pub type PPROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY = * mut _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY ; # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY { pub __bindgen_anon_1 : _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1 { pub Flags : __BindgenUnionField < ULONG > , pub __bindgen_anon_1 : __BindgenUnionField < _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn ProhibitDynamicCode ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ProhibitDynamicCode ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AllowThreadOptOut ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AllowThreadOptOut ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AllowRemoteDowngrade ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AllowRemoteDowngrade ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AuditProhibitDynamicCode ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AuditProhibitDynamicCode ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ReservedFlags ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 28u8 ) as u32 ) } } # [ inline ] pub fn set_ReservedFlags ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 28u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ProhibitDynamicCode : ULONG , AllowThreadOptOut : ULONG , AllowRemoteDowngrade : ULONG , AuditProhibitDynamicCode : ULONG , ReservedFlags : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let ProhibitDynamicCode : u32 = unsafe { :: std :: mem :: transmute ( ProhibitDynamicCode ) } ; ProhibitDynamicCode as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let AllowThreadOptOut : u32 = unsafe { :: std :: mem :: transmute ( AllowThreadOptOut ) } ; AllowThreadOptOut as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let AllowRemoteDowngrade : u32 = unsafe { :: std :: mem :: transmute ( AllowRemoteDowngrade ) } ; AllowRemoteDowngrade as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let AuditProhibitDynamicCode : u32 = unsafe { :: std :: mem :: transmute ( AuditProhibitDynamicCode ) } ; AuditProhibitDynamicCode as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 28u8 , { let ReservedFlags : u32 = unsafe { :: std :: mem :: transmute ( ReservedFlags ) } ; ReservedFlags as u64 } ) ; __bindgen_bitfield_unit } } pub type PROCESS_MITIGATION_DYNAMIC_CODE_POLICY = _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY ; pub type PPROCESS_MITIGATION_DYNAMIC_CODE_POLICY = * mut _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY ; # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY { pub __bindgen_anon_1 : _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1 { pub Flags : __BindgenUnionField < ULONG > , pub __bindgen_anon_1 : __BindgenUnionField < _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn EnableControlFlowGuard ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_EnableControlFlowGuard ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn EnableExportSuppression ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_EnableExportSuppression ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn StrictMode ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_StrictMode ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ReservedFlags ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 29u8 ) as u32 ) } } # [ inline ] pub fn set_ReservedFlags ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 29u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( EnableControlFlowGuard : ULONG , EnableExportSuppression : ULONG , StrictMode : ULONG , ReservedFlags : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let EnableControlFlowGuard : u32 = unsafe { :: std :: mem :: transmute ( EnableControlFlowGuard ) } ; EnableControlFlowGuard as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let EnableExportSuppression : u32 = unsafe { :: std :: mem :: transmute ( EnableExportSuppression ) } ; EnableExportSuppression as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let StrictMode : u32 = unsafe { :: std :: mem :: transmute ( StrictMode ) } ; StrictMode as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 29u8 , { let ReservedFlags : u32 = unsafe { :: std :: mem :: transmute ( ReservedFlags ) } ; ReservedFlags as u64 } ) ; __bindgen_bitfield_unit } } pub type PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY = _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY ; pub type PPROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY = * mut _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY ; # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY { pub __bindgen_anon_1 : _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1 { pub Flags : __BindgenUnionField < ULONG > , pub __bindgen_anon_1 : __BindgenUnionField < _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn MicrosoftSignedOnly ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_MicrosoftSignedOnly ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn StoreSignedOnly ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_StoreSignedOnly ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MitigationOptIn ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_MitigationOptIn ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AuditMicrosoftSignedOnly ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AuditMicrosoftSignedOnly ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AuditStoreSignedOnly ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AuditStoreSignedOnly ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ReservedFlags ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 27u8 ) as u32 ) } } # [ inline ] pub fn set_ReservedFlags ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 27u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( MicrosoftSignedOnly : ULONG , StoreSignedOnly : ULONG , MitigationOptIn : ULONG , AuditMicrosoftSignedOnly : ULONG , AuditStoreSignedOnly : ULONG , ReservedFlags : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let MicrosoftSignedOnly : u32 = unsafe { :: std :: mem :: transmute ( MicrosoftSignedOnly ) } ; MicrosoftSignedOnly as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let StoreSignedOnly : u32 = unsafe { :: std :: mem :: transmute ( StoreSignedOnly ) } ; StoreSignedOnly as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let MitigationOptIn : u32 = unsafe { :: std :: mem :: transmute ( MitigationOptIn ) } ; MitigationOptIn as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let AuditMicrosoftSignedOnly : u32 = unsafe { :: std :: mem :: transmute ( AuditMicrosoftSignedOnly ) } ; AuditMicrosoftSignedOnly as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let AuditStoreSignedOnly : u32 = unsafe { :: std :: mem :: transmute ( AuditStoreSignedOnly ) } ; AuditStoreSignedOnly as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 27u8 , { let ReservedFlags : u32 = unsafe { :: std :: mem :: transmute ( ReservedFlags ) } ; ReservedFlags as u64 } ) ; __bindgen_bitfield_unit } } pub type PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY = _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY ; pub type PPROCESS_MITIGATION_BINARY_SIGNATURE_POLICY = * mut _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY ; # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_FONT_DISABLE_POLICY { pub __bindgen_anon_1 : _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1 { pub Flags : __BindgenUnionField < ULONG > , pub __bindgen_anon_1 : __BindgenUnionField < _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn DisableNonSystemFonts ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_DisableNonSystemFonts ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AuditNonSystemFontLoading ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AuditNonSystemFontLoading ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ReservedFlags ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 30u8 ) as u32 ) } } # [ inline ] pub fn set_ReservedFlags ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 30u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( DisableNonSystemFonts : ULONG , AuditNonSystemFontLoading : ULONG , ReservedFlags : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let DisableNonSystemFonts : u32 = unsafe { :: std :: mem :: transmute ( DisableNonSystemFonts ) } ; DisableNonSystemFonts as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let AuditNonSystemFontLoading : u32 = unsafe { :: std :: mem :: transmute ( AuditNonSystemFontLoading ) } ; AuditNonSystemFontLoading as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 30u8 , { let ReservedFlags : u32 = unsafe { :: std :: mem :: transmute ( ReservedFlags ) } ; ReservedFlags as u64 } ) ; __bindgen_bitfield_unit } } pub type PROCESS_MITIGATION_FONT_DISABLE_POLICY = _PROCESS_MITIGATION_FONT_DISABLE_POLICY ; pub type PPROCESS_MITIGATION_FONT_DISABLE_POLICY = * mut _PROCESS_MITIGATION_FONT_DISABLE_POLICY ; # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_IMAGE_LOAD_POLICY { pub __bindgen_anon_1 : _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1 { pub Flags : __BindgenUnionField < ULONG > , pub __bindgen_anon_1 : __BindgenUnionField < _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn NoRemoteImages ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_NoRemoteImages ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn NoLowMandatoryLabelImages ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_NoLowMandatoryLabelImages ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PreferSystem32Images ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_PreferSystem32Images ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AuditNoRemoteImages ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AuditNoRemoteImages ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AuditNoLowMandatoryLabelImages ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AuditNoLowMandatoryLabelImages ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ReservedFlags ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 27u8 ) as u32 ) } } # [ inline ] pub fn set_ReservedFlags ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 27u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( NoRemoteImages : ULONG , NoLowMandatoryLabelImages : ULONG , PreferSystem32Images : ULONG , AuditNoRemoteImages : ULONG , AuditNoLowMandatoryLabelImages : ULONG , ReservedFlags : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let NoRemoteImages : u32 = unsafe { :: std :: mem :: transmute ( NoRemoteImages ) } ; NoRemoteImages as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let NoLowMandatoryLabelImages : u32 = unsafe { :: std :: mem :: transmute ( NoLowMandatoryLabelImages ) } ; NoLowMandatoryLabelImages as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let PreferSystem32Images : u32 = unsafe { :: std :: mem :: transmute ( PreferSystem32Images ) } ; PreferSystem32Images as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let AuditNoRemoteImages : u32 = unsafe { :: std :: mem :: transmute ( AuditNoRemoteImages ) } ; AuditNoRemoteImages as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let AuditNoLowMandatoryLabelImages : u32 = unsafe { :: std :: mem :: transmute ( AuditNoLowMandatoryLabelImages ) } ; AuditNoLowMandatoryLabelImages as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 27u8 , { let ReservedFlags : u32 = unsafe { :: std :: mem :: transmute ( ReservedFlags ) } ; ReservedFlags as u64 } ) ; __bindgen_bitfield_unit } } pub type PROCESS_MITIGATION_IMAGE_LOAD_POLICY = _PROCESS_MITIGATION_IMAGE_LOAD_POLICY ; pub type PPROCESS_MITIGATION_IMAGE_LOAD_POLICY = * mut _PROCESS_MITIGATION_IMAGE_LOAD_POLICY ; # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY { pub __bindgen_anon_1 : _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1 { pub Flags : __BindgenUnionField < ULONG > , pub __bindgen_anon_1 : __BindgenUnionField < _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn FilterId ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_FilterId ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn ReservedFlags ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 28u8 ) as u32 ) } } # [ inline ] pub fn set_ReservedFlags ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 28u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( FilterId : ULONG , ReservedFlags : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let FilterId : u32 = unsafe { :: std :: mem :: transmute ( FilterId ) } ; FilterId as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 28u8 , { let ReservedFlags : u32 = unsafe { :: std :: mem :: transmute ( ReservedFlags ) } ; ReservedFlags as u64 } ) ; __bindgen_bitfield_unit } } pub type PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY = _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY ; pub type PPROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY = * mut _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY ; # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY { pub __bindgen_anon_1 : _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1 { pub Flags : __BindgenUnionField < ULONG > , pub __bindgen_anon_1 : __BindgenUnionField < _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn EnableExportAddressFilter ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_EnableExportAddressFilter ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AuditExportAddressFilter ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AuditExportAddressFilter ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn EnableExportAddressFilterPlus ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_EnableExportAddressFilterPlus ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AuditExportAddressFilterPlus ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AuditExportAddressFilterPlus ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn EnableImportAddressFilter ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_EnableImportAddressFilter ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AuditImportAddressFilter ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AuditImportAddressFilter ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn EnableRopStackPivot ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_EnableRopStackPivot ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AuditRopStackPivot ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AuditRopStackPivot ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn EnableRopCallerCheck ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_EnableRopCallerCheck ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AuditRopCallerCheck ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AuditRopCallerCheck ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn EnableRopSimExec ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_EnableRopSimExec ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AuditRopSimExec ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AuditRopSimExec ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ReservedFlags ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 20u8 ) as u32 ) } } # [ inline ] pub fn set_ReservedFlags ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 20u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( EnableExportAddressFilter : ULONG , AuditExportAddressFilter : ULONG , EnableExportAddressFilterPlus : ULONG , AuditExportAddressFilterPlus : ULONG , EnableImportAddressFilter : ULONG , AuditImportAddressFilter : ULONG , EnableRopStackPivot : ULONG , AuditRopStackPivot : ULONG , EnableRopCallerCheck : ULONG , AuditRopCallerCheck : ULONG , EnableRopSimExec : ULONG , AuditRopSimExec : ULONG , ReservedFlags : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let EnableExportAddressFilter : u32 = unsafe { :: std :: mem :: transmute ( EnableExportAddressFilter ) } ; EnableExportAddressFilter as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let AuditExportAddressFilter : u32 = unsafe { :: std :: mem :: transmute ( AuditExportAddressFilter ) } ; AuditExportAddressFilter as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let EnableExportAddressFilterPlus : u32 = unsafe { :: std :: mem :: transmute ( EnableExportAddressFilterPlus ) } ; EnableExportAddressFilterPlus as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let AuditExportAddressFilterPlus : u32 = unsafe { :: std :: mem :: transmute ( AuditExportAddressFilterPlus ) } ; AuditExportAddressFilterPlus as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let EnableImportAddressFilter : u32 = unsafe { :: std :: mem :: transmute ( EnableImportAddressFilter ) } ; EnableImportAddressFilter as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let AuditImportAddressFilter : u32 = unsafe { :: std :: mem :: transmute ( AuditImportAddressFilter ) } ; AuditImportAddressFilter as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let EnableRopStackPivot : u32 = unsafe { :: std :: mem :: transmute ( EnableRopStackPivot ) } ; EnableRopStackPivot as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let AuditRopStackPivot : u32 = unsafe { :: std :: mem :: transmute ( AuditRopStackPivot ) } ; AuditRopStackPivot as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let EnableRopCallerCheck : u32 = unsafe { :: std :: mem :: transmute ( EnableRopCallerCheck ) } ; EnableRopCallerCheck as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let AuditRopCallerCheck : u32 = unsafe { :: std :: mem :: transmute ( AuditRopCallerCheck ) } ; AuditRopCallerCheck as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 1u8 , { let EnableRopSimExec : u32 = unsafe { :: std :: mem :: transmute ( EnableRopSimExec ) } ; EnableRopSimExec as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 1u8 , { let AuditRopSimExec : u32 = unsafe { :: std :: mem :: transmute ( AuditRopSimExec ) } ; AuditRopSimExec as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 20u8 , { let ReservedFlags : u32 = unsafe { :: std :: mem :: transmute ( ReservedFlags ) } ; ReservedFlags as u64 } ) ; __bindgen_bitfield_unit } } pub type PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY = _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY ; pub type PPROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY = * mut _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY ; # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_CHILD_PROCESS_POLICY { pub __bindgen_anon_1 : _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1 { pub Flags : __BindgenUnionField < ULONG > , pub __bindgen_anon_1 : __BindgenUnionField < _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn NoChildProcessCreation ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_NoChildProcessCreation ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AuditNoChildProcessCreation ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AuditNoChildProcessCreation ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AllowSecureProcessCreation ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AllowSecureProcessCreation ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ReservedFlags ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 29u8 ) as u32 ) } } # [ inline ] pub fn set_ReservedFlags ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 29u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( NoChildProcessCreation : ULONG , AuditNoChildProcessCreation : ULONG , AllowSecureProcessCreation : ULONG , ReservedFlags : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let NoChildProcessCreation : u32 = unsafe { :: std :: mem :: transmute ( NoChildProcessCreation ) } ; NoChildProcessCreation as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let AuditNoChildProcessCreation : u32 = unsafe { :: std :: mem :: transmute ( AuditNoChildProcessCreation ) } ; AuditNoChildProcessCreation as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let AllowSecureProcessCreation : u32 = unsafe { :: std :: mem :: transmute ( AllowSecureProcessCreation ) } ; AllowSecureProcessCreation as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 29u8 , { let ReservedFlags : u32 = unsafe { :: std :: mem :: transmute ( ReservedFlags ) } ; ReservedFlags as u64 } ) ; __bindgen_bitfield_unit } } pub type PROCESS_MITIGATION_CHILD_PROCESS_POLICY = _PROCESS_MITIGATION_CHILD_PROCESS_POLICY ; pub type PPROCESS_MITIGATION_CHILD_PROCESS_POLICY = * mut _PROCESS_MITIGATION_CHILD_PROCESS_POLICY ; # [ repr ( C ) ] pub struct _PROCESS_KEEPALIVE_COUNT_INFORMATION { pub WakeCount : ULONG , pub NoWakeCount : ULONG , } pub type PROCESS_KEEPALIVE_COUNT_INFORMATION = _PROCESS_KEEPALIVE_COUNT_INFORMATION ; pub type PPROCESS_KEEPALIVE_COUNT_INFORMATION = * mut _PROCESS_KEEPALIVE_COUNT_INFORMATION ; # [ repr ( C ) ] pub struct _PROCESS_REVOKE_FILE_HANDLES_INFORMATION { pub TargetDevicePath : UNICODE_STRING , } pub type PROCESS_REVOKE_FILE_HANDLES_INFORMATION = _PROCESS_REVOKE_FILE_HANDLES_INFORMATION ; pub type PPROCESS_REVOKE_FILE_HANDLES_INFORMATION = * mut _PROCESS_REVOKE_FILE_HANDLES_INFORMATION ; # [ repr ( C ) ] pub struct _PROCESS_READWRITEVM_LOGGING_INFORMATION { pub Flags : __BindgenUnionField < UCHAR > , pub __bindgen_anon_1 : __BindgenUnionField < _PROCESS_READWRITEVM_LOGGING_INFORMATION__bindgen_ty_1 > , pub bindgen_union_field : u8 , } # [ repr ( C , packed ) ] pub struct _PROCESS_READWRITEVM_LOGGING_INFORMATION__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl _PROCESS_READWRITEVM_LOGGING_INFORMATION__bindgen_ty_1 { # [ inline ] pub fn EnableReadVmLogging ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_EnableReadVmLogging ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn EnableWriteVmLogging ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_EnableWriteVmLogging ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Unused ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_Unused ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 6u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( EnableReadVmLogging : UCHAR , EnableWriteVmLogging : UCHAR , Unused : UCHAR ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let EnableReadVmLogging : u8 = unsafe { :: std :: mem :: transmute ( EnableReadVmLogging ) } ; EnableReadVmLogging as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let EnableWriteVmLogging : u8 = unsafe { :: std :: mem :: transmute ( EnableWriteVmLogging ) } ; EnableWriteVmLogging as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 6u8 , { let Unused : u8 = unsafe { :: std :: mem :: transmute ( Unused ) } ; Unused as u64 } ) ; __bindgen_bitfield_unit } } pub type PROCESS_READWRITEVM_LOGGING_INFORMATION = _PROCESS_READWRITEVM_LOGGING_INFORMATION ; pub type PPROCESS_READWRITEVM_LOGGING_INFORMATION = * mut _PROCESS_READWRITEVM_LOGGING_INFORMATION ; # [ repr ( C ) ] pub struct _POOLED_USAGE_AND_LIMITS { pub PeakPagedPoolUsage : SIZE_T , pub PagedPoolUsage : SIZE_T , pub PagedPoolLimit : SIZE_T , pub PeakNonPagedPoolUsage : SIZE_T , pub NonPagedPoolUsage : SIZE_T , pub NonPagedPoolLimit : SIZE_T , pub PeakPagefileUsage : SIZE_T , pub PagefileUsage : SIZE_T , pub PagefileLimit : SIZE_T , } pub type POOLED_USAGE_AND_LIMITS = _POOLED_USAGE_AND_LIMITS ; pub type PPOOLED_USAGE_AND_LIMITS = * mut POOLED_USAGE_AND_LIMITS ; # [ repr ( C ) ] pub struct _PROCESS_ACCESS_TOKEN { pub Token : HANDLE , pub Thread : HANDLE , } pub type PROCESS_ACCESS_TOKEN = _PROCESS_ACCESS_TOKEN ; pub type PPROCESS_ACCESS_TOKEN = * mut _PROCESS_ACCESS_TOKEN ; # [ repr ( C ) ] pub struct _PROCESS_EXCEPTION_PORT { pub ExceptionPortHandle : HANDLE , pub StateFlags : ULONG , } pub type PROCESS_EXCEPTION_PORT = _PROCESS_EXCEPTION_PORT ; pub type PPROCESS_EXCEPTION_PORT = * mut _PROCESS_EXCEPTION_PORT ; # [ repr ( C ) ] pub struct _KERNEL_USER_TIMES { pub CreateTime : LARGE_INTEGER , pub ExitTime : LARGE_INTEGER , pub KernelTime : LARGE_INTEGER , pub UserTime : LARGE_INTEGER , } pub type KERNEL_USER_TIMES = _KERNEL_USER_TIMES ; pub type PKERNEL_USER_TIMES = * mut KERNEL_USER_TIMES ; pub const _SUBSYSTEM_INFORMATION_TYPE_SubsystemInformationTypeWin32 : _SUBSYSTEM_INFORMATION_TYPE = 0 ; pub const _SUBSYSTEM_INFORMATION_TYPE_SubsystemInformationTypeWSL : _SUBSYSTEM_INFORMATION_TYPE = 1 ; pub const _SUBSYSTEM_INFORMATION_TYPE_MaxSubsystemInformationType : _SUBSYSTEM_INFORMATION_TYPE = 2 ; pub type _SUBSYSTEM_INFORMATION_TYPE = i32 ; pub use self :: _SUBSYSTEM_INFORMATION_TYPE as SUBSYSTEM_INFORMATION_TYPE ; pub type PSUBSYSTEM_INFORMATION_TYPE = * mut _SUBSYSTEM_INFORMATION_TYPE ; # [ repr ( C ) ] pub struct _POWER_THROTTLING_PROCESS_STATE { pub Version : ULONG , pub ControlMask : ULONG , pub StateMask : ULONG , } pub type POWER_THROTTLING_PROCESS_STATE = _POWER_THROTTLING_PROCESS_STATE ; pub type PPOWER_THROTTLING_PROCESS_STATE = * mut _POWER_THROTTLING_PROCESS_STATE ; # [ repr ( C ) ] pub struct _POWER_THROTTLING_THREAD_STATE { pub Version : ULONG , pub ControlMask : ULONG , pub StateMask : ULONG , } pub type POWER_THROTTLING_THREAD_STATE = _POWER_THROTTLING_THREAD_STATE ; pub type PPOWER_THROTTLING_THREAD_STATE = * mut _POWER_THROTTLING_THREAD_STATE ; extern "C" { pub fn NtOpenProcess ( ProcessHandle : PHANDLE , DesiredAccess : ACCESS_MASK , ObjectAttributes : POBJECT_ATTRIBUTES , ClientId : PCLIENT_ID ) -> NTSTATUS ; } extern "C" { pub fn KeRaiseIrqlToSynchLevel ( ) -> KIRQL ; } # [ repr ( C ) ] pub struct _KPCR { pub __bindgen_anon_1 : _KPCR__bindgen_ty_1 , pub SelfPcr : * mut _KPCR , pub Prcb : * mut _KPRCB , pub Irql : KIRQL , pub IRR : ULONG , pub IrrActive : ULONG , pub IDR : ULONG , pub KdVersionBlock : PVOID , pub IDT : * mut _KIDTENTRY , pub GDT : * mut _KGDTENTRY , pub TSS : * mut _KTSS , pub MajorVersion : USHORT , pub MinorVersion : USHORT , pub SetMember : KAFFINITY , pub StallScaleFactor : ULONG , pub SpareUnused : UCHAR , pub Number : UCHAR , pub Spare0 : UCHAR , pub SecondLevelCacheAssociativity : UCHAR , pub VdmAlert : ULONG , pub KernelReserved : [ ULONG ; 14usize ] , pub SecondLevelCacheSize : ULONG , pub HalReserved : [ ULONG ; 16usize ] , } # [ repr ( C ) ] pub struct _KPCR__bindgen_ty_1 { pub NtTib : __BindgenUnionField < NT_TIB > , pub __bindgen_anon_1 : __BindgenUnionField < _KPCR__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : [ u64 ; 7usize ] , } # [ repr ( C ) ] pub struct _KPCR__bindgen_ty_1__bindgen_ty_1 { pub Used_ExceptionList : * mut _EXCEPTION_REGISTRATION_RECORD , pub Used_StackBase : PVOID , pub MxCsr : ULONG , pub TssCopy : PVOID , pub ContextSwitches : ULONG , pub SetMemberCopy : KAFFINITY , pub Used_Self : PVOID , } pub type KPCR = _KPCR ; pub type PKPCR = * mut _KPCR ; extern "C" { # [ link_name = "\u{1}MmHighestUserAddress" ] pub static mut MmHighestUserAddress : PVOID ; } extern "C" { # [ link_name = "\u{1}MmSystemRangeStart" ] pub static mut MmSystemRangeStart : PVOID ; } extern "C" { # [ link_name = "\u{1}MmUserProbeAddress" ] pub static mut MmUserProbeAddress : ULONG ; } pub const _INTERLOCKED_RESULT_ResultNegative : _INTERLOCKED_RESULT = 32768 ; pub const _INTERLOCKED_RESULT_ResultZero : _INTERLOCKED_RESULT = 16384 ; pub const _INTERLOCKED_RESULT_ResultPositive : _INTERLOCKED_RESULT = 0 ; pub type _INTERLOCKED_RESULT = i32 ; pub use self :: _INTERLOCKED_RESULT as INTERLOCKED_RESULT ; extern "C" { pub fn Exfi386InterlockedIncrementLong ( Addend : * mut LONG ) -> INTERLOCKED_RESULT ; } extern "C" { pub fn Exfi386InterlockedDecrementLong ( Addend : * mut LONG ) -> INTERLOCKED_RESULT ; } extern "C" { pub fn Exfi386InterlockedExchangeUlong ( Target : * mut ULONG , Value : ULONG ) -> ULONG ; } pub const _SYSTEM_FIRMWARE_TABLE_ACTION_SystemFirmwareTable_Enumerate : _SYSTEM_FIRMWARE_TABLE_ACTION = 0 ; pub const _SYSTEM_FIRMWARE_TABLE_ACTION_SystemFirmwareTable_Get : _SYSTEM_FIRMWARE_TABLE_ACTION = 1 ; pub type _SYSTEM_FIRMWARE_TABLE_ACTION = i32 ; pub use self :: _SYSTEM_FIRMWARE_TABLE_ACTION as SYSTEM_FIRMWARE_TABLE_ACTION ; # [ repr ( C ) ] pub struct _SYSTEM_FIRMWARE_TABLE_INFORMATION { pub ProviderSignature : ULONG , pub Action : SYSTEM_FIRMWARE_TABLE_ACTION , pub TableID : ULONG , pub TableBufferLength : ULONG , pub TableBuffer : [ UCHAR ; 1usize ] , } pub type SYSTEM_FIRMWARE_TABLE_INFORMATION = _SYSTEM_FIRMWARE_TABLE_INFORMATION ; pub type PSYSTEM_FIRMWARE_TABLE_INFORMATION = * mut _SYSTEM_FIRMWARE_TABLE_INFORMATION ; pub type PFNFTH = :: std :: option :: Option < unsafe extern "C" fn ( SystemFirmwareTableInfo : PSYSTEM_FIRMWARE_TABLE_INFORMATION ) -> NTSTATUS > ; # [ repr ( C ) ] pub struct _SYSTEM_FIRMWARE_TABLE_HANDLER { pub ProviderSignature : ULONG , pub Register : BOOLEAN , pub FirmwareTableHandler : PFNFTH , pub DriverObject : PVOID , } pub type SYSTEM_FIRMWARE_TABLE_HANDLER = _SYSTEM_FIRMWARE_TABLE_HANDLER ; pub type PSYSTEM_FIRMWARE_TABLE_HANDLER = * mut _SYSTEM_FIRMWARE_TABLE_HANDLER ; pub type PTIMER_APC_ROUTINE = :: std :: option :: Option < unsafe extern "C" fn ( TimerContext : PVOID , TimerLowValue : ULONG , TimerHighValue : LONG ) > ; pub const _TIMER_SET_INFORMATION_CLASS_TimerSetCoalescableTimer : _TIMER_SET_INFORMATION_CLASS = 0 ; pub const _TIMER_SET_INFORMATION_CLASS_MaxTimerInfoClass : _TIMER_SET_INFORMATION_CLASS = 1 ; pub type _TIMER_SET_INFORMATION_CLASS = i32 ; pub use self :: _TIMER_SET_INFORMATION_CLASS as TIMER_SET_INFORMATION_CLASS ; # [ repr ( C ) ] pub struct _TIMER_SET_COALESCABLE_TIMER_INFO { pub DueTime : LARGE_INTEGER , pub TimerApcRoutine : PTIMER_APC_ROUTINE , pub TimerContext : PVOID , pub WakeContext : * mut _COUNTED_REASON_CONTEXT , pub Period : ULONG , pub TolerableDelay : ULONG , pub PreviousState : PBOOLEAN , } pub type TIMER_SET_COALESCABLE_TIMER_INFO = _TIMER_SET_COALESCABLE_TIMER_INFO ; pub type PTIMER_SET_COALESCABLE_TIMER_INFO = * mut _TIMER_SET_COALESCABLE_TIMER_INFO ; pub type PDRIVER_VERIFIER_THUNK_ROUTINE = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID ) -> ULONG_PTR > ; # [ repr ( C ) ] pub struct _DRIVER_VERIFIER_THUNK_PAIRS { pub PristineRoutine : PDRIVER_VERIFIER_THUNK_ROUTINE , pub NewRoutine : PDRIVER_VERIFIER_THUNK_ROUTINE , } pub type DRIVER_VERIFIER_THUNK_PAIRS = _DRIVER_VERIFIER_THUNK_PAIRS ; pub type PDRIVER_VERIFIER_THUNK_PAIRS = * mut _DRIVER_VERIFIER_THUNK_PAIRS ; # [ repr ( C ) ] pub struct _XSTATE_FEATURE { pub Offset : ULONG , pub Size : ULONG , } pub type XSTATE_FEATURE = _XSTATE_FEATURE ; pub type PXSTATE_FEATURE = * mut _XSTATE_FEATURE ; # [ repr ( C ) ] pub struct _XSTATE_CONFIGURATION { pub EnabledFeatures : ULONG64 , pub EnabledVolatileFeatures : ULONG64 , pub Size : ULONG , pub __bindgen_anon_1 : _XSTATE_CONFIGURATION__bindgen_ty_1 , pub Features : [ XSTATE_FEATURE ; 64usize ] , pub EnabledSupervisorFeatures : ULONG64 , pub AlignedFeatures : ULONG64 , pub AllFeatureSize : ULONG , pub AllFeatures : [ ULONG ; 64usize ] , } # [ repr ( C ) ] pub struct _XSTATE_CONFIGURATION__bindgen_ty_1 { pub ControlFlags : __BindgenUnionField < ULONG > , pub __bindgen_anon_1 : __BindgenUnionField < _XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub __bindgen_padding_0 : [ u8 ; 3usize ] , pub __bindgen_align : [ u32 ; 0usize ] , } impl _XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn OptimizedSave ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_OptimizedSave ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn CompactionEnabled ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_CompactionEnabled ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( OptimizedSave : ULONG , CompactionEnabled : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let OptimizedSave : u32 = unsafe { :: std :: mem :: transmute ( OptimizedSave ) } ; OptimizedSave as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let CompactionEnabled : u32 = unsafe { :: std :: mem :: transmute ( CompactionEnabled ) } ; CompactionEnabled as u64 } ) ; __bindgen_bitfield_unit } } pub type XSTATE_CONFIGURATION = _XSTATE_CONFIGURATION ; pub type PXSTATE_CONFIGURATION = * mut _XSTATE_CONFIGURATION ; # [ repr ( C ) ] pub struct _KUSER_SHARED_DATA { pub TickCountLowDeprecated : ULONG , pub TickCountMultiplier : ULONG , pub InterruptTime : KSYSTEM_TIME , pub SystemTime : KSYSTEM_TIME , pub TimeZoneBias : KSYSTEM_TIME , pub ImageNumberLow : USHORT , pub ImageNumberHigh : USHORT , pub NtSystemRoot : [ WCHAR ; 260usize ] , pub MaxStackTraceDepth : ULONG , pub CryptoExponent : ULONG , pub TimeZoneId : ULONG , pub LargePageMinimum : ULONG , pub AitSamplingValue : ULONG , pub AppCompatFlag : ULONG , pub RNGSeedVersion : ULONGLONG , pub GlobalValidationRunlevel : ULONG , pub TimeZoneBiasStamp : LONG , pub NtBuildNumber : ULONG , pub NtProductType : NT_PRODUCT_TYPE , pub ProductTypeIsValid : BOOLEAN , pub Reserved0 : [ BOOLEAN ; 1usize ] , pub NativeProcessorArchitecture : USHORT , pub NtMajorVersion : ULONG , pub NtMinorVersion : ULONG , pub ProcessorFeatures : [ BOOLEAN ; 64usize ] , pub Reserved1 : ULONG , pub Reserved3 : ULONG , pub TimeSlip : ULONG , pub AlternativeArchitecture : ALTERNATIVE_ARCHITECTURE_TYPE , pub BootId : ULONG , pub SystemExpirationDate : LARGE_INTEGER , pub SuiteMask : ULONG , pub KdDebuggerEnabled : BOOLEAN , pub __bindgen_anon_1 : _KUSER_SHARED_DATA__bindgen_ty_1 , pub Reserved6 : [ UCHAR ; 2usize ] , pub ActiveConsoleId : ULONG , pub DismountCount : ULONG , pub ComPlusPackage : ULONG , pub LastSystemRITEventTickCount : ULONG , pub NumberOfPhysicalPages : ULONG , pub SafeBootMode : BOOLEAN , pub VirtualizationFlags : UCHAR , pub Reserved12 : [ UCHAR ; 2usize ] , pub __bindgen_anon_2 : _KUSER_SHARED_DATA__bindgen_ty_2 , pub DataFlagsPad : [ ULONG ; 1usize ] , pub TestRetInstruction : ULONGLONG , pub QpcFrequency : LONGLONG , pub SystemCall : ULONG , pub SystemCallPad0 : ULONG , pub SystemCallPad : [ ULONGLONG ; 2usize ] , pub __bindgen_anon_3 : _KUSER_SHARED_DATA__bindgen_ty_3 , pub Cookie : ULONG , pub CookiePad : [ ULONG ; 1usize ] , pub ConsoleSessionForegroundProcessId : LONGLONG , pub TimeUpdateLock : ULONGLONG , pub BaselineSystemTimeQpc : ULONGLONG , pub BaselineInterruptTimeQpc : ULONGLONG , pub QpcSystemTimeIncrement : ULONGLONG , pub QpcInterruptTimeIncrement : ULONGLONG , pub QpcSystemTimeIncrementShift : UCHAR , pub QpcInterruptTimeIncrementShift : UCHAR , pub UnparkedProcessorCount : USHORT , pub EnclaveFeatureMask : [ ULONG ; 4usize ] , pub TelemetryCoverageRound : ULONG , pub UserModeGlobalLogger : [ USHORT ; 16usize ] , pub ImageFileExecutionOptions : ULONG , pub LangGenerationCount : ULONG , pub Reserved4 : ULONGLONG , pub InterruptTimeBias : ULONGLONG , pub QpcBias : ULONGLONG , pub ActiveProcessorCount : ULONG , pub ActiveGroupCount : UCHAR , pub Reserved9 : UCHAR , pub __bindgen_anon_4 : _KUSER_SHARED_DATA__bindgen_ty_4 , pub TimeZoneBiasEffectiveStart : LARGE_INTEGER , pub TimeZoneBiasEffectiveEnd : LARGE_INTEGER , pub XState : XSTATE_CONFIGURATION , } # [ repr ( C ) ] pub struct _KUSER_SHARED_DATA__bindgen_ty_1 { pub MitigationPolicies : __BindgenUnionField < UCHAR > , pub __bindgen_anon_1 : __BindgenUnionField < _KUSER_SHARED_DATA__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : u8 , } # [ repr ( C , packed ) ] pub struct _KUSER_SHARED_DATA__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl _KUSER_SHARED_DATA__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn NXSupportPolicy ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_NXSupportPolicy ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 2u8 , val as u64 ) } } # [ inline ] pub fn SEHValidationPolicy ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_SEHValidationPolicy ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 2u8 , val as u64 ) } } # [ inline ] pub fn CurDirDevicesSkippedForDlls ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_CurDirDevicesSkippedForDlls ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 2u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 2u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( NXSupportPolicy : UCHAR , SEHValidationPolicy : UCHAR , CurDirDevicesSkippedForDlls : UCHAR , Reserved : UCHAR ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 2u8 , { let NXSupportPolicy : u8 = unsafe { :: std :: mem :: transmute ( NXSupportPolicy ) } ; NXSupportPolicy as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 2u8 , { let SEHValidationPolicy : u8 = unsafe { :: std :: mem :: transmute ( SEHValidationPolicy ) } ; SEHValidationPolicy as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 2u8 , { let CurDirDevicesSkippedForDlls : u8 = unsafe { :: std :: mem :: transmute ( CurDirDevicesSkippedForDlls ) } ; CurDirDevicesSkippedForDlls as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 2u8 , { let Reserved : u8 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] pub struct _KUSER_SHARED_DATA__bindgen_ty_2 { pub SharedDataFlags : __BindgenUnionField < ULONG > , pub __bindgen_anon_1 : __BindgenUnionField < _KUSER_SHARED_DATA__bindgen_ty_2__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _KUSER_SHARED_DATA__bindgen_ty_2__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _KUSER_SHARED_DATA__bindgen_ty_2__bindgen_ty_1 { # [ inline ] pub fn DbgErrorPortPresent ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_DbgErrorPortPresent ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn DbgElevationEnabled ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_DbgElevationEnabled ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn DbgVirtEnabled ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_DbgVirtEnabled ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn DbgInstallerDetectEnabled ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_DbgInstallerDetectEnabled ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn DbgLkgEnabled ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_DbgLkgEnabled ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn DbgDynProcessorEnabled ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_DbgDynProcessorEnabled ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn DbgConsoleBrokerEnabled ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_DbgConsoleBrokerEnabled ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn DbgSecureBootEnabled ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_DbgSecureBootEnabled ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn DbgMultiSessionSku ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_DbgMultiSessionSku ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn DbgMultiUsersInSessionSku ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_DbgMultiUsersInSessionSku ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn DbgStateSeparationEnabled ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_DbgStateSeparationEnabled ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 1u8 , val as u64 ) } } # [ inline ] pub fn SpareBits ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 21u8 ) as u32 ) } } # [ inline ] pub fn set_SpareBits ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 21u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( DbgErrorPortPresent : ULONG , DbgElevationEnabled : ULONG , DbgVirtEnabled : ULONG , DbgInstallerDetectEnabled : ULONG , DbgLkgEnabled : ULONG , DbgDynProcessorEnabled : ULONG , DbgConsoleBrokerEnabled : ULONG , DbgSecureBootEnabled : ULONG , DbgMultiSessionSku : ULONG , DbgMultiUsersInSessionSku : ULONG , DbgStateSeparationEnabled : ULONG , SpareBits : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let DbgErrorPortPresent : u32 = unsafe { :: std :: mem :: transmute ( DbgErrorPortPresent ) } ; DbgErrorPortPresent as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let DbgElevationEnabled : u32 = unsafe { :: std :: mem :: transmute ( DbgElevationEnabled ) } ; DbgElevationEnabled as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let DbgVirtEnabled : u32 = unsafe { :: std :: mem :: transmute ( DbgVirtEnabled ) } ; DbgVirtEnabled as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let DbgInstallerDetectEnabled : u32 = unsafe { :: std :: mem :: transmute ( DbgInstallerDetectEnabled ) } ; DbgInstallerDetectEnabled as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let DbgLkgEnabled : u32 = unsafe { :: std :: mem :: transmute ( DbgLkgEnabled ) } ; DbgLkgEnabled as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let DbgDynProcessorEnabled : u32 = unsafe { :: std :: mem :: transmute ( DbgDynProcessorEnabled ) } ; DbgDynProcessorEnabled as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let DbgConsoleBrokerEnabled : u32 = unsafe { :: std :: mem :: transmute ( DbgConsoleBrokerEnabled ) } ; DbgConsoleBrokerEnabled as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let DbgSecureBootEnabled : u32 = unsafe { :: std :: mem :: transmute ( DbgSecureBootEnabled ) } ; DbgSecureBootEnabled as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let DbgMultiSessionSku : u32 = unsafe { :: std :: mem :: transmute ( DbgMultiSessionSku ) } ; DbgMultiSessionSku as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let DbgMultiUsersInSessionSku : u32 = unsafe { :: std :: mem :: transmute ( DbgMultiUsersInSessionSku ) } ; DbgMultiUsersInSessionSku as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 1u8 , { let DbgStateSeparationEnabled : u32 = unsafe { :: std :: mem :: transmute ( DbgStateSeparationEnabled ) } ; DbgStateSeparationEnabled as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 21u8 , { let SpareBits : u32 = unsafe { :: std :: mem :: transmute ( SpareBits ) } ; SpareBits as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] pub struct _KUSER_SHARED_DATA__bindgen_ty_3 { pub TickCount : __BindgenUnionField < KSYSTEM_TIME > , pub TickCountQuad : __BindgenUnionField < ULONG64 > , pub __bindgen_anon_1 : __BindgenUnionField < _KUSER_SHARED_DATA__bindgen_ty_3__bindgen_ty_1 > , pub bindgen_union_field : [ u64 ; 2usize ] , } # [ repr ( C ) ] pub struct _KUSER_SHARED_DATA__bindgen_ty_3__bindgen_ty_1 { pub ReservedTickCountOverlay : [ ULONG ; 3usize ] , pub TickCountPad : [ ULONG ; 1usize ] , } # [ repr ( C ) ] pub struct _KUSER_SHARED_DATA__bindgen_ty_4 { pub QpcData : __BindgenUnionField < USHORT > , pub __bindgen_anon_1 : __BindgenUnionField < _KUSER_SHARED_DATA__bindgen_ty_4__bindgen_ty_1 > , pub bindgen_union_field : u16 , } # [ repr ( C ) ] pub struct _KUSER_SHARED_DATA__bindgen_ty_4__bindgen_ty_1 { pub QpcBypassEnabled : UCHAR , pub QpcShift : UCHAR , } pub type KUSER_SHARED_DATA = _KUSER_SHARED_DATA ; pub type PKUSER_SHARED_DATA = * mut _KUSER_SHARED_DATA ; # [ repr ( C ) ] pub struct _CM_PCCARD_DEVICE_DATA { pub Flags : UCHAR , pub ErrorCode : UCHAR , pub Reserved : USHORT , pub BusData : ULONG , pub DeviceId : ULONG , pub LegacyBaseAddress : ULONG , pub IRQMap : [ UCHAR ; 16usize ] , } pub type CM_PCCARD_DEVICE_DATA = _CM_PCCARD_DEVICE_DATA ; pub type PCM_PCCARD_DEVICE_DATA = * mut _CM_PCCARD_DEVICE_DATA ; pub const _CONFIGURATION_TYPE_ArcSystem : _CONFIGURATION_TYPE = 0 ; pub const _CONFIGURATION_TYPE_CentralProcessor : _CONFIGURATION_TYPE = 1 ; pub const _CONFIGURATION_TYPE_FloatingPointProcessor : _CONFIGURATION_TYPE = 2 ; pub const _CONFIGURATION_TYPE_PrimaryIcache : _CONFIGURATION_TYPE = 3 ; pub const _CONFIGURATION_TYPE_PrimaryDcache : _CONFIGURATION_TYPE = 4 ; pub const _CONFIGURATION_TYPE_SecondaryIcache : _CONFIGURATION_TYPE = 5 ; pub const _CONFIGURATION_TYPE_SecondaryDcache : _CONFIGURATION_TYPE = 6 ; pub const _CONFIGURATION_TYPE_SecondaryCache : _CONFIGURATION_TYPE = 7 ; pub const _CONFIGURATION_TYPE_EisaAdapter : _CONFIGURATION_TYPE = 8 ; pub const _CONFIGURATION_TYPE_TcAdapter : _CONFIGURATION_TYPE = 9 ; pub const _CONFIGURATION_TYPE_ScsiAdapter : _CONFIGURATION_TYPE = 10 ; pub const _CONFIGURATION_TYPE_DtiAdapter : _CONFIGURATION_TYPE = 11 ; pub const _CONFIGURATION_TYPE_MultiFunctionAdapter : _CONFIGURATION_TYPE = 12 ; pub const _CONFIGURATION_TYPE_DiskController : _CONFIGURATION_TYPE = 13 ; pub const _CONFIGURATION_TYPE_TapeController : _CONFIGURATION_TYPE = 14 ; pub const _CONFIGURATION_TYPE_CdromController : _CONFIGURATION_TYPE = 15 ; pub const _CONFIGURATION_TYPE_WormController : _CONFIGURATION_TYPE = 16 ; pub const _CONFIGURATION_TYPE_SerialController : _CONFIGURATION_TYPE = 17 ; pub const _CONFIGURATION_TYPE_NetworkController : _CONFIGURATION_TYPE = 18 ; pub const _CONFIGURATION_TYPE_DisplayController : _CONFIGURATION_TYPE = 19 ; pub const _CONFIGURATION_TYPE_ParallelController : _CONFIGURATION_TYPE = 20 ; pub const _CONFIGURATION_TYPE_PointerController : _CONFIGURATION_TYPE = 21 ; pub const _CONFIGURATION_TYPE_KeyboardController : _CONFIGURATION_TYPE = 22 ; pub const _CONFIGURATION_TYPE_AudioController : _CONFIGURATION_TYPE = 23 ; pub const _CONFIGURATION_TYPE_OtherController : _CONFIGURATION_TYPE = 24 ; pub const _CONFIGURATION_TYPE_DiskPeripheral : _CONFIGURATION_TYPE = 25 ; pub const _CONFIGURATION_TYPE_FloppyDiskPeripheral : _CONFIGURATION_TYPE = 26 ; pub const _CONFIGURATION_TYPE_TapePeripheral : _CONFIGURATION_TYPE = 27 ; pub const _CONFIGURATION_TYPE_ModemPeripheral : _CONFIGURATION_TYPE = 28 ; pub const _CONFIGURATION_TYPE_MonitorPeripheral : _CONFIGURATION_TYPE = 29 ; pub const _CONFIGURATION_TYPE_PrinterPeripheral : _CONFIGURATION_TYPE = 30 ; pub const _CONFIGURATION_TYPE_PointerPeripheral : _CONFIGURATION_TYPE = 31 ; pub const _CONFIGURATION_TYPE_KeyboardPeripheral : _CONFIGURATION_TYPE = 32 ; pub const _CONFIGURATION_TYPE_TerminalPeripheral : _CONFIGURATION_TYPE = 33 ; pub const _CONFIGURATION_TYPE_OtherPeripheral : _CONFIGURATION_TYPE = 34 ; pub const _CONFIGURATION_TYPE_LinePeripheral : _CONFIGURATION_TYPE = 35 ; pub const _CONFIGURATION_TYPE_NetworkPeripheral : _CONFIGURATION_TYPE = 36 ; pub const _CONFIGURATION_TYPE_SystemMemory : _CONFIGURATION_TYPE = 37 ; pub const _CONFIGURATION_TYPE_DockingInformation : _CONFIGURATION_TYPE = 38 ; pub const _CONFIGURATION_TYPE_RealModeIrqRoutingTable : _CONFIGURATION_TYPE = 39 ; pub const _CONFIGURATION_TYPE_RealModePCIEnumeration : _CONFIGURATION_TYPE = 40 ; pub const _CONFIGURATION_TYPE_MaximumType : _CONFIGURATION_TYPE = 41 ; pub type _CONFIGURATION_TYPE = i32 ; pub use self :: _CONFIGURATION_TYPE as CONFIGURATION_TYPE ; pub type PCONFIGURATION_TYPE = * mut _CONFIGURATION_TYPE ; extern "C" { pub fn KePulseEvent ( Event : PRKEVENT , Increment : KPRIORITY , Wait : BOOLEAN ) -> LONG ; } pub type PEXPAND_STACK_CALLOUT = :: std :: option :: Option < unsafe extern "C" fn ( ) > ; extern "C" { pub fn KeExpandKernelStackAndCallout ( Callout : PEXPAND_STACK_CALLOUT , Parameter : PVOID , Size : SIZE_T ) -> NTSTATUS ; } extern "C" { pub fn KeExpandKernelStackAndCalloutEx ( Callout : PEXPAND_STACK_CALLOUT , Parameter : PVOID , Size : SIZE_T , Wait : BOOLEAN , Context : PVOID ) -> NTSTATUS ; } extern "C" { pub fn KeSetBasePriorityThread ( Thread : PKTHREAD , Increment : LONG ) -> LONG ; } extern "C" { pub fn KeBugCheck ( BugCheckCode : ULONG ) ; } extern "C" { pub fn KeInvalidateAllCaches ( ) -> BOOLEAN ; } extern "C" { pub fn KeInvalidateRangeAllCaches ( BaseAddress : PVOID , Length : ULONG ) ; } extern "C" { pub fn KeSetHardwareCounterConfiguration ( CounterArray : PHARDWARE_COUNTER , Count : ULONG ) -> NTSTATUS ; } extern "C" { pub fn KeQueryHardwareCounterConfiguration ( CounterArray : PHARDWARE_COUNTER , MaximumCount : ULONG , Count : PULONG ) -> NTSTATUS ; } extern "C" { pub fn ExRaiseDatatypeMisalignment ( ) ; } extern "C" { pub fn ExRaiseAccessViolation ( ) ; } # [ repr ( C ) ] pub struct _ZONE_SEGMENT_HEADER { pub SegmentList : SINGLE_LIST_ENTRY , pub Reserved : PVOID , } pub type ZONE_SEGMENT_HEADER = _ZONE_SEGMENT_HEADER ; pub type PZONE_SEGMENT_HEADER = * mut _ZONE_SEGMENT_HEADER ; # [ repr ( C ) ] pub struct _ZONE_HEADER { pub FreeList : SINGLE_LIST_ENTRY , pub SegmentList : SINGLE_LIST_ENTRY , pub BlockSize : ULONG , pub TotalSegmentSize : ULONG , } pub type ZONE_HEADER = _ZONE_HEADER ; pub type PZONE_HEADER = * mut _ZONE_HEADER ; extern "C" { pub fn ExInitializeZone ( Zone : PZONE_HEADER , BlockSize : ULONG , InitialSegment : PVOID , InitialSegmentSize : ULONG ) -> NTSTATUS ; } extern "C" { pub fn ExExtendZone ( Zone : PZONE_HEADER , Segment : PVOID , SegmentSize : ULONG ) -> NTSTATUS ; } extern "C" { pub fn ExInterlockedExtendZone ( Zone : PZONE_HEADER , Segment : PVOID , SegmentSize : ULONG , Lock : PKSPIN_LOCK ) -> NTSTATUS ; } pub type UUID = GUID ; extern "C" { pub fn ExUuidCreate ( Uuid : * mut UUID ) -> NTSTATUS ; } extern "C" { pub fn MmIsThisAnNtAsSystem ( ) -> BOOLEAN ; } extern "C" { pub fn MmMapUserAddressesToPage ( BaseAddress : PVOID , NumberOfBytes : SIZE_T , PageAddress : PVOID ) -> NTSTATUS ; } # [ repr ( C ) ] pub struct _PHYSICAL_MEMORY_RANGE { pub BaseAddress : PHYSICAL_ADDRESS , pub NumberOfBytes : LARGE_INTEGER , } pub type PHYSICAL_MEMORY_RANGE = _PHYSICAL_MEMORY_RANGE ; pub type PPHYSICAL_MEMORY_RANGE = * mut _PHYSICAL_MEMORY_RANGE ; extern "C" { pub fn MmAddPhysicalMemory ( StartAddress : PPHYSICAL_ADDRESS , NumberOfBytes : PLARGE_INTEGER ) -> NTSTATUS ; } pub type PMM_ROTATE_COPY_CALLBACK_FUNCTION = :: std :: option :: Option < unsafe extern "C" fn ( DestinationMdl : PMDL , SourceMdl : PMDL , Context : PVOID ) -> NTSTATUS > ; pub const _MM_ROTATE_DIRECTION_MmToFrameBuffer : _MM_ROTATE_DIRECTION = 0 ; pub const _MM_ROTATE_DIRECTION_MmToFrameBufferNoCopy : _MM_ROTATE_DIRECTION = 1 ; pub const _MM_ROTATE_DIRECTION_MmToRegularMemory : _MM_ROTATE_DIRECTION = 2 ; pub const _MM_ROTATE_DIRECTION_MmToRegularMemoryNoCopy : _MM_ROTATE_DIRECTION = 3 ; pub const _MM_ROTATE_DIRECTION_MmMaximumRotateDirection : _MM_ROTATE_DIRECTION = 4 ; pub type _MM_ROTATE_DIRECTION = i32 ; pub use self :: _MM_ROTATE_DIRECTION as MM_ROTATE_DIRECTION ; pub type PMM_ROTATE_DIRECTION = * mut _MM_ROTATE_DIRECTION ; extern "C" { pub fn MmRotatePhysicalView ( VirtualAddress : PVOID , NumberOfBytes : PSIZE_T , NewMdl : PMDL , Direction : MM_ROTATE_DIRECTION , CopyFunction : PMM_ROTATE_COPY_CALLBACK_FUNCTION , Context : PVOID ) -> NTSTATUS ; } extern "C" { pub fn MmRemovePhysicalMemory ( StartAddress : PPHYSICAL_ADDRESS , NumberOfBytes : PLARGE_INTEGER ) -> NTSTATUS ; } extern "C" { pub fn MmGetPhysicalMemoryRanges ( ) -> PPHYSICAL_MEMORY_RANGE ; } extern "C" { pub fn MmGetPhysicalMemoryRangesEx ( PartitionObject : PVOID ) -> PPHYSICAL_MEMORY_RANGE ; } extern "C" { pub fn MmMapVideoDisplay ( PhysicalAddress : PHYSICAL_ADDRESS , NumberOfBytes : SIZE_T , CacheType : MEMORY_CACHING_TYPE ) -> PVOID ; } extern "C" { pub fn MmUnmapVideoDisplay ( BaseAddress : PVOID , NumberOfBytes : SIZE_T ) ; } extern "C" { pub fn MmGetPhysicalAddress ( BaseAddress : PVOID ) -> PHYSICAL_ADDRESS ; } extern "C" { pub fn MmGetCacheAttribute ( PhysicalAddress : PHYSICAL_ADDRESS , CacheType : * mut MEMORY_CACHING_TYPE ) -> NTSTATUS ; } # [ repr ( C ) ] pub struct _MM_COPY_ADDRESS { pub __bindgen_anon_1 : _MM_COPY_ADDRESS__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _MM_COPY_ADDRESS__bindgen_ty_1 { pub VirtualAddress : __BindgenUnionField < PVOID > , pub PhysicalAddress : __BindgenUnionField < PHYSICAL_ADDRESS > , pub bindgen_union_field : u64 , } pub type MM_COPY_ADDRESS = _MM_COPY_ADDRESS ; pub type PMMCOPY_ADDRESS = * mut _MM_COPY_ADDRESS ; extern "C" { pub fn MmCopyMemory ( TargetAddress : PVOID , SourceAddress : MM_COPY_ADDRESS , NumberOfBytes : SIZE_T , Flags : ULONG , NumberOfBytesTransferred : PSIZE_T ) -> NTSTATUS ; } extern "C" { pub fn MmGetVirtualForPhysical ( PhysicalAddress : PHYSICAL_ADDRESS ) -> PVOID ; } extern "C" { pub fn MmAllocateNonCachedMemory ( NumberOfBytes : SIZE_T ) -> PVOID ; } extern "C" { pub fn MmFreeNonCachedMemory ( BaseAddress : PVOID , NumberOfBytes : SIZE_T ) ; } extern "C" { pub fn MmIsAddressValid ( VirtualAddress : PVOID ) -> BOOLEAN ; } extern "C" { pub fn MmIsNonPagedSystemAddressValid ( VirtualAddress : PVOID ) -> BOOLEAN ; } extern "C" { pub fn MmLockPagableSectionByHandle ( ImageSectionHandle : PVOID ) ; } extern "C" { pub fn MmSecureVirtualMemory ( Address : PVOID , Size : SIZE_T , ProbeMode : ULONG ) -> HANDLE ; } extern "C" { pub fn MmUnsecureVirtualMemory ( SecureHandle : HANDLE ) ; } extern "C" { pub fn MmMapViewInSystemSpaceEx ( Section : PVOID , MappedBase : * mut PVOID , ViewSize : PSIZE_T , SectionOffset : PLARGE_INTEGER , Flags : ULONG_PTR ) -> NTSTATUS ; } extern "C" { pub fn MmMapViewInSystemSpace ( Section : PVOID , MappedBase : * mut PVOID , ViewSize : PSIZE_T ) -> NTSTATUS ; } extern "C" { pub fn MmUnmapViewInSystemSpace ( MappedBase : PVOID ) -> NTSTATUS ; } extern "C" { pub fn MmMapViewInSessionSpaceEx ( Section : PVOID , MappedBase : * mut PVOID , ViewSize : PSIZE_T , SectionOffset : PLARGE_INTEGER , Flags : ULONG_PTR ) -> NTSTATUS ; } extern "C" { pub fn MmMapViewInSessionSpace ( Section : PVOID , MappedBase : * mut PVOID , ViewSize : PSIZE_T ) -> NTSTATUS ; } extern "C" { pub fn MmUnmapViewInSessionSpace ( MappedBase : PVOID ) -> NTSTATUS ; } extern "C" { pub fn MmCreateMirror ( ) -> NTSTATUS ; } extern "C" { pub fn SeSinglePrivilegeCheck ( PrivilegeValue : LUID , PreviousMode : KPROCESSOR_MODE ) -> BOOLEAN ; } extern "C" { # [ link_name = "\u{1}PsInitialSystemProcess" ] pub static mut PsInitialSystemProcess : PEPROCESS ; } # [ repr ( C ) ] pub struct _PS_CREATE_NOTIFY_INFO { pub Size : SIZE_T , pub __bindgen_anon_1 : _PS_CREATE_NOTIFY_INFO__bindgen_ty_1 , pub ParentProcessId : HANDLE , pub CreatingThreadId : CLIENT_ID , pub FileObject : * mut _FILE_OBJECT , pub ImageFileName : PCUNICODE_STRING , pub CommandLine : PCUNICODE_STRING , pub CreationStatus : NTSTATUS , } # [ repr ( C ) ] pub struct _PS_CREATE_NOTIFY_INFO__bindgen_ty_1 { pub Flags : __BindgenUnionField < ULONG > , pub __bindgen_anon_1 : __BindgenUnionField < _PS_CREATE_NOTIFY_INFO__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PS_CREATE_NOTIFY_INFO__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PS_CREATE_NOTIFY_INFO__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn FileOpenNameAvailable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_FileOpenNameAvailable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn IsSubsystemProcess ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_IsSubsystemProcess ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 30u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 30u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( FileOpenNameAvailable : ULONG , IsSubsystemProcess : ULONG , Reserved : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let FileOpenNameAvailable : u32 = unsafe { :: std :: mem :: transmute ( FileOpenNameAvailable ) } ; FileOpenNameAvailable as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let IsSubsystemProcess : u32 = unsafe { :: std :: mem :: transmute ( IsSubsystemProcess ) } ; IsSubsystemProcess as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 30u8 , { let Reserved : u32 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type PS_CREATE_NOTIFY_INFO = _PS_CREATE_NOTIFY_INFO ; pub type PPS_CREATE_NOTIFY_INFO = * mut _PS_CREATE_NOTIFY_INFO ; pub type PCREATE_PROCESS_NOTIFY_ROUTINE = :: std :: option :: Option < unsafe extern "C" fn ( ParentId : HANDLE , ProcessId : HANDLE , Create : BOOLEAN ) > ; extern "C" { pub fn PsSetCreateProcessNotifyRoutine ( NotifyRoutine : PCREATE_PROCESS_NOTIFY_ROUTINE , Remove : BOOLEAN ) -> NTSTATUS ; } pub type PCREATE_PROCESS_NOTIFY_ROUTINE_EX = :: std :: option :: Option < unsafe extern "C" fn ( Process : PEPROCESS , ProcessId : HANDLE , CreateInfo : PPS_CREATE_NOTIFY_INFO ) > ; extern "C" { pub fn PsSetCreateProcessNotifyRoutineEx ( NotifyRoutine : PCREATE_PROCESS_NOTIFY_ROUTINE_EX , Remove : BOOLEAN ) -> NTSTATUS ; } pub const _PSCREATEPROCESSNOTIFYTYPE_PsCreateProcessNotifySubsystems : _PSCREATEPROCESSNOTIFYTYPE = 0 ; pub type _PSCREATEPROCESSNOTIFYTYPE = i32 ; pub use self :: _PSCREATEPROCESSNOTIFYTYPE as PSCREATEPROCESSNOTIFYTYPE ; extern "C" { pub fn PsSetCreateProcessNotifyRoutineEx2 ( NotifyType : PSCREATEPROCESSNOTIFYTYPE , NotifyInformation : PVOID , Remove : BOOLEAN ) -> NTSTATUS ; } pub type PCREATE_THREAD_NOTIFY_ROUTINE = :: std :: option :: Option < unsafe extern "C" fn ( ProcessId : HANDLE , ThreadId : HANDLE , Create : BOOLEAN ) > ; extern "C" { pub fn PsSetCreateThreadNotifyRoutine ( NotifyRoutine : PCREATE_THREAD_NOTIFY_ROUTINE ) -> NTSTATUS ; } pub const _PSCREATETHREADNOTIFYTYPE_PsCreateThreadNotifyNonSystem : _PSCREATETHREADNOTIFYTYPE = 0 ; pub const _PSCREATETHREADNOTIFYTYPE_PsCreateThreadNotifySubsystems : _PSCREATETHREADNOTIFYTYPE = 1 ; pub type _PSCREATETHREADNOTIFYTYPE = i32 ; pub use self :: _PSCREATETHREADNOTIFYTYPE as PSCREATETHREADNOTIFYTYPE ; extern "C" { pub fn PsSetCreateThreadNotifyRoutineEx ( NotifyType : PSCREATETHREADNOTIFYTYPE , NotifyInformation : PVOID ) -> NTSTATUS ; } extern "C" { pub fn PsRemoveCreateThreadNotifyRoutine ( NotifyRoutine : PCREATE_THREAD_NOTIFY_ROUTINE ) -> NTSTATUS ; } # [ repr ( C ) ] pub struct _IMAGE_INFO { pub __bindgen_anon_1 : _IMAGE_INFO__bindgen_ty_1 , pub ImageBase : PVOID , pub ImageSelector : ULONG , pub ImageSize : SIZE_T , pub ImageSectionNumber : ULONG , } # [ repr ( C ) ] pub struct _IMAGE_INFO__bindgen_ty_1 { pub Properties : __BindgenUnionField < ULONG > , pub __bindgen_anon_1 : __BindgenUnionField < _IMAGE_INFO__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _IMAGE_INFO__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _IMAGE_INFO__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn ImageAddressingMode ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_ImageAddressingMode ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn SystemModeImage ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_SystemModeImage ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ImageMappedToAllPids ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ImageMappedToAllPids ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ExtendedInfoPresent ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ExtendedInfoPresent ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MachineTypeMismatch ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_MachineTypeMismatch ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ImageSignatureLevel ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_ImageSignatureLevel ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 4u8 , val as u64 ) } } # [ inline ] pub fn ImageSignatureType ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_ImageSignatureType ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 3u8 , val as u64 ) } } # [ inline ] pub fn ImagePartialMap ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 19usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ImagePartialMap ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 19usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 20usize , 12u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 20usize , 12u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ImageAddressingMode : ULONG , SystemModeImage : ULONG , ImageMappedToAllPids : ULONG , ExtendedInfoPresent : ULONG , MachineTypeMismatch : ULONG , ImageSignatureLevel : ULONG , ImageSignatureType : ULONG , ImagePartialMap : ULONG , Reserved : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let ImageAddressingMode : u32 = unsafe { :: std :: mem :: transmute ( ImageAddressingMode ) } ; ImageAddressingMode as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let SystemModeImage : u32 = unsafe { :: std :: mem :: transmute ( SystemModeImage ) } ; SystemModeImage as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let ImageMappedToAllPids : u32 = unsafe { :: std :: mem :: transmute ( ImageMappedToAllPids ) } ; ImageMappedToAllPids as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 1u8 , { let ExtendedInfoPresent : u32 = unsafe { :: std :: mem :: transmute ( ExtendedInfoPresent ) } ; ExtendedInfoPresent as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 1u8 , { let MachineTypeMismatch : u32 = unsafe { :: std :: mem :: transmute ( MachineTypeMismatch ) } ; MachineTypeMismatch as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 4u8 , { let ImageSignatureLevel : u32 = unsafe { :: std :: mem :: transmute ( ImageSignatureLevel ) } ; ImageSignatureLevel as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 3u8 , { let ImageSignatureType : u32 = unsafe { :: std :: mem :: transmute ( ImageSignatureType ) } ; ImageSignatureType as u64 } ) ; __bindgen_bitfield_unit . set ( 19usize , 1u8 , { let ImagePartialMap : u32 = unsafe { :: std :: mem :: transmute ( ImagePartialMap ) } ; ImagePartialMap as u64 } ) ; __bindgen_bitfield_unit . set ( 20usize , 12u8 , { let Reserved : u32 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type IMAGE_INFO = _IMAGE_INFO ; pub type PIMAGE_INFO = * mut _IMAGE_INFO ; # [ repr ( C ) ] pub struct _IMAGE_INFO_EX { pub Size : SIZE_T , pub ImageInfo : IMAGE_INFO , pub FileObject : * mut _FILE_OBJECT , } pub type IMAGE_INFO_EX = _IMAGE_INFO_EX ; pub type PIMAGE_INFO_EX = * mut _IMAGE_INFO_EX ; pub type PLOAD_IMAGE_NOTIFY_ROUTINE = :: std :: option :: Option < unsafe extern "C" fn ( FullImageName : PUNICODE_STRING , ProcessId : HANDLE , ImageInfo : PIMAGE_INFO ) > ; extern "C" { pub fn PsSetLoadImageNotifyRoutine ( NotifyRoutine : PLOAD_IMAGE_NOTIFY_ROUTINE ) -> NTSTATUS ; } extern "C" { pub fn PsSetLoadImageNotifyRoutineEx ( NotifyRoutine : PLOAD_IMAGE_NOTIFY_ROUTINE , Flags : ULONG_PTR ) -> NTSTATUS ; } extern "C" { pub fn PsRemoveLoadImageNotifyRoutine ( NotifyRoutine : PLOAD_IMAGE_NOTIFY_ROUTINE ) -> NTSTATUS ; } extern "C" { pub fn PsGetCurrentProcessId ( ) -> HANDLE ; } extern "C" { pub fn PsGetCurrentThreadId ( ) -> HANDLE ; } extern "C" { pub fn PsSetCurrentThreadPrefetching ( Prefetching : BOOLEAN ) -> BOOLEAN ; } extern "C" { pub fn PsIsCurrentThreadPrefetching ( ) -> BOOLEAN ; } extern "C" { pub fn PsGetProcessCreateTimeQuadPart ( Process : PEPROCESS ) -> LONGLONG ; } extern "C" { pub fn PsGetProcessStartKey ( Process : PEPROCESS ) -> ULONGLONG ; } extern "C" { pub fn PsGetProcessExitStatus ( Process : PEPROCESS ) -> NTSTATUS ; } extern "C" { pub fn PsGetThreadExitStatus ( Thread : PETHREAD ) -> NTSTATUS ; } extern "C" { pub fn PsGetProcessId ( Process : PEPROCESS ) -> HANDLE ; } extern "C" { pub fn PsGetThreadId ( Thread : PETHREAD ) -> HANDLE ; } extern "C" { pub fn PsGetThreadProperty ( Thread : PETHREAD , Key : ULONG_PTR , Flags : ULONG ) -> PVOID ; } extern "C" { pub fn PsGetThreadProcessId ( Thread : PETHREAD ) -> HANDLE ; } extern "C" { pub fn PsGetThreadCreateTime ( Thread : PETHREAD ) -> LONGLONG ; } extern "C" { pub fn PsGetCurrentThreadTeb ( ) -> PVOID ; } pub type SILO_CONTEXT_CLEANUP_CALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( SiloContext : PVOID ) > ; pub type SILO_MONITOR_CREATE_CALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( Silo : PESILO ) -> NTSTATUS > ; pub type SILO_MONITOR_TERMINATE_CALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( Silo : PESILO ) > ; # [ repr ( C ) ] pub struct _SILO_MONITOR_REGISTRATION { pub Version : UCHAR , pub MonitorHost : BOOLEAN , pub MonitorExistingSilos : BOOLEAN , pub Reserved : [ UCHAR ; 5usize ] , pub __bindgen_anon_1 : _SILO_MONITOR_REGISTRATION__bindgen_ty_1 , pub CreateCallback : SILO_MONITOR_CREATE_CALLBACK , pub TerminateCallback : SILO_MONITOR_TERMINATE_CALLBACK , } # [ repr ( C ) ] pub struct _SILO_MONITOR_REGISTRATION__bindgen_ty_1 { pub DriverObjectName : __BindgenUnionField < PUNICODE_STRING > , pub ComponentName : __BindgenUnionField < PUNICODE_STRING > , pub bindgen_union_field : u64 , } pub type SILO_MONITOR_REGISTRATION = _SILO_MONITOR_REGISTRATION ; pub type PSILO_MONITOR_REGISTRATION = * mut _SILO_MONITOR_REGISTRATION ; extern "C" { pub fn PsGetJobSilo ( Job : PEJOB , Silo : * mut PESILO ) -> NTSTATUS ; } extern "C" { pub fn PsGetJobServerSilo ( Job : PEJOB , ServerSilo : * mut PESILO ) -> NTSTATUS ; } extern "C" { pub fn PsGetEffectiveServerSilo ( Silo : PESILO ) -> PESILO ; } extern "C" { pub fn PsAttachSiloToCurrentThread ( Silo : PESILO ) -> PESILO ; } extern "C" { pub fn PsDetachSiloFromCurrentThread ( PreviousSilo : PESILO ) ; } extern "C" { pub fn PsIsHostSilo ( Silo : PESILO ) -> BOOLEAN ; } extern "C" { pub fn PsGetHostSilo ( ) -> PESILO ; } extern "C" { pub fn PsGetCurrentSilo ( ) -> PESILO ; } extern "C" { pub fn PsGetCurrentServerSilo ( ) -> PESILO ; } extern "C" { pub fn PsGetCurrentServerSiloName ( ) -> PUNICODE_STRING ; } extern "C" { pub fn PsIsCurrentThreadInServerSilo ( ) -> BOOLEAN ; } extern "C" { pub fn PsAcquireSiloHardReference ( Silo : PESILO ) -> NTSTATUS ; } extern "C" { pub fn PsReleaseSiloHardReference ( Silo : PESILO ) ; } extern "C" { pub fn PsAllocSiloContextSlot ( Reserved : ULONG_PTR , ReturnedContextSlot : * mut ULONG ) -> NTSTATUS ; } extern "C" { pub fn PsFreeSiloContextSlot ( ContextSlot : ULONG ) -> NTSTATUS ; } extern "C" { pub fn PsCreateSiloContext ( Silo : PESILO , Size : ULONG , PoolType : POOL_TYPE , ContextCleanupCallback : SILO_CONTEXT_CLEANUP_CALLBACK , ReturnedSiloContext : * mut PVOID ) -> NTSTATUS ; } extern "C" { pub fn PsInsertSiloContext ( Silo : PESILO , ContextSlot : ULONG , SiloContext : PVOID ) -> NTSTATUS ; } extern "C" { pub fn PsReplaceSiloContext ( Silo : PESILO , ContextSlot : ULONG , NewSiloContext : PVOID , OldSiloContext : * mut PVOID ) -> NTSTATUS ; } extern "C" { pub fn PsGetSiloContext ( Silo : PESILO , ContextSlot : ULONG , ReturnedSiloContext : * mut PVOID ) -> NTSTATUS ; } extern "C" { pub fn PsRemoveSiloContext ( Silo : PESILO , ContextSlot : ULONG , RemovedSiloContext : * mut PVOID ) -> NTSTATUS ; } extern "C" { pub fn PsReferenceSiloContext ( SiloContext : PVOID ) ; } extern "C" { pub fn PsDereferenceSiloContext ( SiloContext : PVOID ) ; } extern "C" { pub fn PsInsertPermanentSiloContext ( Silo : PESILO , ContextSlot : ULONG , SiloContext : PVOID ) -> NTSTATUS ; } extern "C" { pub fn PsMakeSiloContextPermanent ( Silo : PESILO , ContextSlot : ULONG ) -> NTSTATUS ; } extern "C" { pub fn PsGetPermanentSiloContext ( Silo : PESILO , ContextSlot : ULONG , ReturnedSiloContext : * mut PVOID ) -> NTSTATUS ; } extern "C" { pub fn PsRegisterSiloMonitor ( Registration : PSILO_MONITOR_REGISTRATION , ReturnedMonitor : * mut PSILO_MONITOR ) -> NTSTATUS ; } extern "C" { pub fn PsStartSiloMonitor ( Monitor : PSILO_MONITOR ) -> NTSTATUS ; } extern "C" { pub fn PsGetSiloMonitorContextSlot ( Monitor : PSILO_MONITOR ) -> ULONG ; } extern "C" { pub fn PsUnregisterSiloMonitor ( Monitor : PSILO_MONITOR ) ; } extern "C" { pub fn PsGetServerSiloServiceSessionId ( Silo : PESILO ) -> ULONG ; } extern "C" { pub fn PsGetServerSiloActiveConsoleId ( Silo : PESILO ) -> ULONG ; } extern "C" { pub fn PsTerminateServerSilo ( ServerSilo : PESILO , ExitStatus : NTSTATUS ) ; } extern "C" { pub fn PsGetParentSilo ( Job : PEJOB ) -> PESILO ; } pub type PIO_QUERY_DEVICE_ROUTINE = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , PathName : PUNICODE_STRING , BusType : INTERFACE_TYPE , BusNumber : ULONG , BusInformation : * mut PKEY_VALUE_FULL_INFORMATION , ControllerType : CONFIGURATION_TYPE , ControllerNumber : ULONG , ControllerInformation : * mut PKEY_VALUE_FULL_INFORMATION , PeripheralType : CONFIGURATION_TYPE , PeripheralNumber : ULONG , PeripheralInformation : * mut PKEY_VALUE_FULL_INFORMATION ) -> NTSTATUS > ; pub const _IO_QUERY_DEVICE_DATA_FORMAT_IoQueryDeviceIdentifier : _IO_QUERY_DEVICE_DATA_FORMAT = 0 ; pub const _IO_QUERY_DEVICE_DATA_FORMAT_IoQueryDeviceConfigurationData : _IO_QUERY_DEVICE_DATA_FORMAT = 1 ; pub const _IO_QUERY_DEVICE_DATA_FORMAT_IoQueryDeviceComponentInformation : _IO_QUERY_DEVICE_DATA_FORMAT = 2 ; pub const _IO_QUERY_DEVICE_DATA_FORMAT_IoQueryDeviceMaxData : _IO_QUERY_DEVICE_DATA_FORMAT = 3 ; pub type _IO_QUERY_DEVICE_DATA_FORMAT = i32 ; pub use self :: _IO_QUERY_DEVICE_DATA_FORMAT as IO_QUERY_DEVICE_DATA_FORMAT ; pub type PIO_QUERY_DEVICE_DATA_FORMAT = * mut _IO_QUERY_DEVICE_DATA_FORMAT ; pub type DRIVER_REINITIALIZE = :: std :: option :: Option < unsafe extern "C" fn ( DriverObject : * mut _DRIVER_OBJECT , Context : PVOID , Count : ULONG ) > ; pub type PDRIVER_REINITIALIZE = DRIVER_REINITIALIZE ; # [ repr ( C ) ] pub struct _CONTROLLER_OBJECT { pub Type : CSHORT , pub Size : CSHORT , pub ControllerExtension : PVOID , pub DeviceWaitQueue : KDEVICE_QUEUE , pub Spare1 : ULONG , pub Spare2 : LARGE_INTEGER , } pub type CONTROLLER_OBJECT = _CONTROLLER_OBJECT ; pub type PCONTROLLER_OBJECT = * mut _CONTROLLER_OBJECT ; # [ repr ( C ) ] pub struct _CONFIGURATION_INFORMATION { pub DiskCount : ULONG , pub FloppyCount : ULONG , pub CdRomCount : ULONG , pub TapeCount : ULONG , pub ScsiPortCount : ULONG , pub SerialCount : ULONG , pub ParallelCount : ULONG , pub AtDiskPrimaryAddressClaimed : BOOLEAN , pub AtDiskSecondaryAddressClaimed : BOOLEAN , pub Version : ULONG , pub MediumChangerCount : ULONG , } pub type CONFIGURATION_INFORMATION = _CONFIGURATION_INFORMATION ; pub type PCONFIGURATION_INFORMATION = * mut _CONFIGURATION_INFORMATION ; extern "C" { pub fn IoAllocateController ( ControllerObject : PCONTROLLER_OBJECT , DeviceObject : PDEVICE_OBJECT , ExecutionRoutine : PDRIVER_CONTROL , Context : PVOID ) ; } extern "C" { pub fn IoAssignResources ( RegistryPath : PUNICODE_STRING , DriverClassName : PUNICODE_STRING , DriverObject : PDRIVER_OBJECT , DeviceObject : PDEVICE_OBJECT , RequestedResources : PIO_RESOURCE_REQUIREMENTS_LIST , AllocatedResources : * mut PCM_RESOURCE_LIST ) -> NTSTATUS ; } extern "C" { pub fn IoAttachDeviceByPointer ( SourceDevice : PDEVICE_OBJECT , TargetDevice : PDEVICE_OBJECT ) -> NTSTATUS ; } extern "C" { pub fn IoCreateController ( Size : ULONG ) -> PCONTROLLER_OBJECT ; } extern "C" { pub fn IoDeleteController ( ControllerObject : PCONTROLLER_OBJECT ) ; } extern "C" { pub fn IoFreeController ( ControllerObject : PCONTROLLER_OBJECT ) ; } extern "C" { pub fn IoGetConfigurationInformation ( ) -> PCONFIGURATION_INFORMATION ; } extern "C" { pub fn IoGetFileObjectGenericMapping ( ) -> PGENERIC_MAPPING ; } extern "C" { pub fn IoCancelFileOpen ( DeviceObject : PDEVICE_OBJECT , FileObject : PFILE_OBJECT ) ; } extern "C" { pub fn IoMakeAssociatedIrp ( Irp : PIRP , StackSize : CCHAR ) -> PIRP ; } extern "C" { pub fn IoMakeAssociatedIrpEx ( Irp : PIRP , DeviceObject : PDEVICE_OBJECT , StackSize : CCHAR ) -> PIRP ; } extern "C" { pub fn IoQueryDeviceDescription ( BusType : PINTERFACE_TYPE , BusNumber : PULONG , ControllerType : PCONFIGURATION_TYPE , ControllerNumber : PULONG , PeripheralType : PCONFIGURATION_TYPE , PeripheralNumber : PULONG , CalloutRoutine : PIO_QUERY_DEVICE_ROUTINE , Context : PVOID ) -> NTSTATUS ; } extern "C" { pub fn IoRaiseHardError ( Irp : PIRP , Vpb : PVPB , RealDeviceObject : PDEVICE_OBJECT ) ; } extern "C" { pub fn IoRaiseInformationalHardError ( ErrorStatus : NTSTATUS , String : PUNICODE_STRING , Thread : PKTHREAD ) -> BOOLEAN ; } extern "C" { pub fn IoSetThreadHardErrorMode ( EnableHardErrors : BOOLEAN ) -> BOOLEAN ; } extern "C" { pub fn IoRegisterBootDriverReinitialization ( DriverObject : PDRIVER_OBJECT , DriverReinitializationRoutine : PDRIVER_REINITIALIZE , Context : PVOID ) ; } extern "C" { pub fn IoRegisterDriverReinitialization ( DriverObject : PDRIVER_OBJECT , DriverReinitializationRoutine : PDRIVER_REINITIALIZE , Context : PVOID ) ; } extern "C" { pub fn IoReportResourceUsage ( DriverClassName : PUNICODE_STRING , DriverObject : PDRIVER_OBJECT , DriverList : PCM_RESOURCE_LIST , DriverListSize : ULONG , DeviceObject : PDEVICE_OBJECT , DeviceList : PCM_RESOURCE_LIST , DeviceListSize : ULONG , OverrideConflict : BOOLEAN , ConflictDetected : PBOOLEAN ) -> NTSTATUS ; } extern "C" { pub fn IoTranslateBusAddress ( InterfaceType : INTERFACE_TYPE , BusNumber : ULONG , BusAddress : PHYSICAL_ADDRESS , AddressSpace : PULONG , TranslatedAddress : PPHYSICAL_ADDRESS ) -> BOOLEAN ; } extern "C" { pub fn IoSetHardErrorOrVerifyDevice ( Irp : PIRP , DeviceObject : PDEVICE_OBJECT ) ; } extern "C" { pub fn HalExamineMBR ( DeviceObject : PDEVICE_OBJECT , SectorSize : ULONG , MBRTypeIdentifier : ULONG , Buffer : * mut PVOID ) ; } extern "C" { pub fn IoReadPartitionTable ( DeviceObject : PDEVICE_OBJECT , SectorSize : ULONG , ReturnRecognizedPartitions : BOOLEAN , PartitionBuffer : * mut * mut _DRIVE_LAYOUT_INFORMATION ) -> NTSTATUS ; } extern "C" { pub fn IoSetPartitionInformation ( DeviceObject : PDEVICE_OBJECT , SectorSize : ULONG , PartitionNumber : ULONG , PartitionType : ULONG ) -> NTSTATUS ; } extern "C" { pub fn IoWritePartitionTable ( DeviceObject : PDEVICE_OBJECT , SectorSize : ULONG , SectorsPerTrack : ULONG , NumberOfHeads : ULONG , PartitionBuffer : * mut _DRIVE_LAYOUT_INFORMATION ) -> NTSTATUS ; } extern "C" { pub fn IoCreateDisk ( DeviceObject : PDEVICE_OBJECT , Disk : * mut _CREATE_DISK ) -> NTSTATUS ; } extern "C" { pub fn IoReadPartitionTableEx ( DeviceObject : PDEVICE_OBJECT , DriveLayout : * mut * mut _DRIVE_LAYOUT_INFORMATION_EX ) -> NTSTATUS ; } extern "C" { pub fn IoWritePartitionTableEx ( DeviceObject : PDEVICE_OBJECT , DriveLayout : * mut _DRIVE_LAYOUT_INFORMATION_EX ) -> NTSTATUS ; } extern "C" { pub fn IoSetPartitionInformationEx ( DeviceObject : PDEVICE_OBJECT , PartitionNumber : ULONG , PartitionInfo : * mut _SET_PARTITION_INFORMATION_EX ) -> NTSTATUS ; } extern "C" { pub fn IoVerifyPartitionTable ( DeviceObject : PDEVICE_OBJECT , FixErrors : BOOLEAN ) -> NTSTATUS ; } # [ repr ( C ) ] pub struct _DISK_SIGNATURE { pub PartitionStyle : ULONG , pub __bindgen_anon_1 : _DISK_SIGNATURE__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _DISK_SIGNATURE__bindgen_ty_1 { pub Mbr : __BindgenUnionField < _DISK_SIGNATURE__bindgen_ty_1__bindgen_ty_1 > , pub Gpt : __BindgenUnionField < _DISK_SIGNATURE__bindgen_ty_1__bindgen_ty_2 > , pub bindgen_union_field : [ u32 ; 4usize ] , } # [ repr ( C ) ] pub struct _DISK_SIGNATURE__bindgen_ty_1__bindgen_ty_1 { pub Signature : ULONG , pub CheckSum : ULONG , } # [ repr ( C ) ] pub struct _DISK_SIGNATURE__bindgen_ty_1__bindgen_ty_2 { pub DiskId : GUID , } pub type DISK_SIGNATURE = _DISK_SIGNATURE ; pub type PDISK_SIGNATURE = * mut _DISK_SIGNATURE ; extern "C" { pub fn IoReadDiskSignature ( DeviceObject : PDEVICE_OBJECT , BytesPerSector : ULONG , Signature : PDISK_SIGNATURE ) -> NTSTATUS ; } extern "C" { pub fn IoVolumeDeviceToDosName ( VolumeDeviceObject : PVOID , DosName : PUNICODE_STRING ) -> NTSTATUS ; } extern "C" { pub fn IoVolumeDeviceToGuidPath ( VolumeDeviceObject : PVOID , GuidPath : PUNICODE_STRING ) -> NTSTATUS ; } extern "C" { pub fn IoVolumeDeviceToGuid ( VolumeDeviceObject : PVOID , Guid : * mut GUID ) -> NTSTATUS ; } extern "C" { pub fn IoVolumeDeviceNameToGuid ( VolumeDeviceName : PUNICODE_STRING , Guid : * mut GUID ) -> NTSTATUS ; } extern "C" { pub fn IoVolumeDeviceNameToGuidPath ( VolumeDeviceName : PUNICODE_STRING , GuidPath : PUNICODE_STRING ) -> NTSTATUS ; } extern "C" { pub fn IoSetSystemPartition ( VolumeNameString : PUNICODE_STRING ) -> NTSTATUS ; } extern "C" { pub fn IoCreateFileSpecifyDeviceObjectHint ( FileHandle : PHANDLE , DesiredAccess : ACCESS_MASK , ObjectAttributes : POBJECT_ATTRIBUTES , IoStatusBlock : PIO_STATUS_BLOCK , AllocationSize : PLARGE_INTEGER , FileAttributes : ULONG , ShareAccess : ULONG , Disposition : ULONG , CreateOptions : ULONG , EaBuffer : PVOID , EaLength : ULONG , CreateFileType : CREATE_FILE_TYPE , InternalParameters : PVOID , Options : ULONG , DeviceObject : PVOID ) -> NTSTATUS ; } # [ repr ( C ) ] pub struct _IO_FOEXT_SILO_PARAMETERS { pub Length : ULONG , pub __bindgen_anon_1 : _IO_FOEXT_SILO_PARAMETERS__bindgen_ty_1 , pub SiloContext : PESILO , } # [ repr ( C ) ] pub struct _IO_FOEXT_SILO_PARAMETERS__bindgen_ty_1 { pub __bindgen_anon_1 : __BindgenUnionField < _IO_FOEXT_SILO_PARAMETERS__bindgen_ty_1__bindgen_ty_1 > , pub Flags : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _IO_FOEXT_SILO_PARAMETERS__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _IO_FOEXT_SILO_PARAMETERS__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn HasHardReference ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_HasHardReference ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn SpareFlags ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 31u8 ) as u32 ) } } # [ inline ] pub fn set_SpareFlags ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 31u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( HasHardReference : ULONG , SpareFlags : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let HasHardReference : u32 = unsafe { :: std :: mem :: transmute ( HasHardReference ) } ; HasHardReference as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 31u8 , { let SpareFlags : u32 = unsafe { :: std :: mem :: transmute ( SpareFlags ) } ; SpareFlags as u64 } ) ; __bindgen_bitfield_unit } } pub type IO_FOEXT_SILO_PARAMETERS = _IO_FOEXT_SILO_PARAMETERS ; pub type PIO_FOEXT_SILO_PARAMETERS = * mut _IO_FOEXT_SILO_PARAMETERS ; extern "C" { pub fn IoGetSiloParameters ( FileObject : PFILE_OBJECT ) -> PIO_FOEXT_SILO_PARAMETERS ; } extern "C" { pub fn IoGetSilo ( FileObject : PFILE_OBJECT ) -> PESILO ; } # [ repr ( C ) ] pub struct _TXN_PARAMETER_BLOCK { pub Length : USHORT , pub TxFsContext : USHORT , pub TransactionObject : PVOID , } pub type TXN_PARAMETER_BLOCK = _TXN_PARAMETER_BLOCK ; pub type PTXN_PARAMETER_BLOCK = * mut _TXN_PARAMETER_BLOCK ; extern "C" { pub fn IoGetTransactionParameterBlock ( FileObject : PFILE_OBJECT ) -> PTXN_PARAMETER_BLOCK ; } # [ repr ( C ) ] pub struct _CREATE_USER_PROCESS_ECP_CONTEXT { pub Size : USHORT , pub Reserved : USHORT , pub AccessToken : PACCESS_TOKEN , } pub type CREATE_USER_PROCESS_ECP_CONTEXT = _CREATE_USER_PROCESS_ECP_CONTEXT ; pub type PCREATE_USER_PROCESS_ECP_CONTEXT = * mut _CREATE_USER_PROCESS_ECP_CONTEXT ; extern "C" { # [ link_name = "\u{1}GUID_ECP_CREATE_USER_PROCESS" ] pub static mut GUID_ECP_CREATE_USER_PROCESS : GUID ; } # [ repr ( C ) ] pub struct _OPLOCK_KEY_ECP_CONTEXT { _unused : [ u8 ; 0 ] , } pub type POPLOCK_KEY_ECP_CONTEXT = * mut _OPLOCK_KEY_ECP_CONTEXT ; extern "C" { pub fn IoGetOplockKeyContext ( FileObject : PFILE_OBJECT ) -> POPLOCK_KEY_ECP_CONTEXT ; } # [ repr ( C ) ] pub struct _OPLOCK_KEY_CONTEXT { pub Version : USHORT , pub Flags : USHORT , pub ParentOplockKey : GUID , pub TargetOplockKey : GUID , pub Reserved : ULONG , } pub type OPLOCK_KEY_CONTEXT = _OPLOCK_KEY_CONTEXT ; pub type POPLOCK_KEY_CONTEXT = * mut _OPLOCK_KEY_CONTEXT ; extern "C" { pub fn IoGetOplockKeyContextEx ( FileObject : PFILE_OBJECT ) -> POPLOCK_KEY_CONTEXT ; } # [ repr ( C ) ] pub struct _IO_DRIVER_CREATE_CONTEXT { pub Size : CSHORT , pub ExtraCreateParameter : * mut _ECP_LIST , pub DeviceObjectHint : PVOID , pub TxnParameters : PTXN_PARAMETER_BLOCK , pub SiloContext : PESILO , } pub type IO_DRIVER_CREATE_CONTEXT = _IO_DRIVER_CREATE_CONTEXT ; pub type PIO_DRIVER_CREATE_CONTEXT = * mut _IO_DRIVER_CREATE_CONTEXT ; extern "C" { pub fn IoCreateFileEx ( FileHandle : PHANDLE , DesiredAccess : ACCESS_MASK , ObjectAttributes : POBJECT_ATTRIBUTES , IoStatusBlock : PIO_STATUS_BLOCK , AllocationSize : PLARGE_INTEGER , FileAttributes : ULONG , ShareAccess : ULONG , Disposition : ULONG , CreateOptions : ULONG , EaBuffer : PVOID , EaLength : ULONG , CreateFileType : CREATE_FILE_TYPE , InternalParameters : PVOID , Options : ULONG , DriverContext : PIO_DRIVER_CREATE_CONTEXT ) -> NTSTATUS ; } extern "C" { pub fn IoSetIrpExtraCreateParameter ( Irp : PIRP , ExtraCreateParameter : * mut _ECP_LIST ) -> NTSTATUS ; } extern "C" { pub fn IoClearIrpExtraCreateParameter ( Irp : PIRP ) ; } extern "C" { pub fn IoGetIrpExtraCreateParameter ( Irp : PIRP , ExtraCreateParameter : * mut * mut _ECP_LIST ) -> NTSTATUS ; } extern "C" { pub fn IoQueryInformationByName ( ObjectAttributes : POBJECT_ATTRIBUTES , IoStatusBlock : PIO_STATUS_BLOCK , FileInformation : PVOID , Length : ULONG , FileInformationClass : FILE_INFORMATION_CLASS , Options : ULONG , DriverContext : PIO_DRIVER_CREATE_CONTEXT ) -> NTSTATUS ; } extern "C" { pub fn IoAttachDeviceToDeviceStackSafe ( SourceDevice : PDEVICE_OBJECT , TargetDevice : PDEVICE_OBJECT , AttachedToDeviceObject : * mut PDEVICE_OBJECT ) -> NTSTATUS ; } extern "C" { pub fn IoIsFileOriginRemote ( FileObject : PFILE_OBJECT ) -> BOOLEAN ; } extern "C" { pub fn IoSetFileOrigin ( FileObject : PFILE_OBJECT , Remote : BOOLEAN ) -> NTSTATUS ; } extern "C" { pub fn IoIsFileObjectIgnoringSharing ( FileObject : PFILE_OBJECT ) -> BOOLEAN ; } extern "C" { pub fn IoSetFileObjectIgnoreSharing ( FileObject : PFILE_OBJECT ) -> NTSTATUS ; } extern "C" { pub fn IoGetPagingIoPriority ( Irp : PIRP ) -> IO_PAGING_PRIORITY ; } pub const _BDCB_CALLBACK_TYPE_BdCbStatusUpdate : _BDCB_CALLBACK_TYPE = 0 ; pub const _BDCB_CALLBACK_TYPE_BdCbInitializeImage : _BDCB_CALLBACK_TYPE = 1 ; pub type _BDCB_CALLBACK_TYPE = i32 ; pub use self :: _BDCB_CALLBACK_TYPE as BDCB_CALLBACK_TYPE ; pub type PBDCB_CALLBACK_TYPE = * mut _BDCB_CALLBACK_TYPE ; pub const _BDCB_CLASSIFICATION_BdCbClassificationUnknownImage : _BDCB_CLASSIFICATION = 0 ; pub const _BDCB_CLASSIFICATION_BdCbClassificationKnownGoodImage : _BDCB_CLASSIFICATION = 1 ; pub const _BDCB_CLASSIFICATION_BdCbClassificationKnownBadImage : _BDCB_CLASSIFICATION = 2 ; pub const _BDCB_CLASSIFICATION_BdCbClassificationKnownBadImageBootCritical : _BDCB_CLASSIFICATION = 3 ; pub const _BDCB_CLASSIFICATION_BdCbClassificationEnd : _BDCB_CLASSIFICATION = 4 ; pub type _BDCB_CLASSIFICATION = i32 ; pub use self :: _BDCB_CLASSIFICATION as BDCB_CLASSIFICATION ; pub type PBDCB_CLASSIFICATION = * mut _BDCB_CLASSIFICATION ; pub const _BDCB_STATUS_UPDATE_TYPE_BdCbStatusPrepareForDependencyLoad : _BDCB_STATUS_UPDATE_TYPE = 0 ; pub const _BDCB_STATUS_UPDATE_TYPE_BdCbStatusPrepareForDriverLoad : _BDCB_STATUS_UPDATE_TYPE = 1 ; pub const _BDCB_STATUS_UPDATE_TYPE_BdCbStatusPrepareForUnload : _BDCB_STATUS_UPDATE_TYPE = 2 ; pub type _BDCB_STATUS_UPDATE_TYPE = i32 ; pub use self :: _BDCB_STATUS_UPDATE_TYPE as BDCB_STATUS_UPDATE_TYPE ; pub type PBDCB_STATUS_UPDATE_TYPE = * mut _BDCB_STATUS_UPDATE_TYPE ; # [ repr ( C ) ] pub struct _BDCB_STATUS_UPDATE_CONTEXT { pub StatusType : BDCB_STATUS_UPDATE_TYPE , } pub type BDCB_STATUS_UPDATE_CONTEXT = _BDCB_STATUS_UPDATE_CONTEXT ; pub type PBDCB_STATUS_UPDATE_CONTEXT = * mut _BDCB_STATUS_UPDATE_CONTEXT ; # [ repr ( C ) ] pub struct _BDCB_IMAGE_INFORMATION { pub Classification : BDCB_CLASSIFICATION , pub ImageFlags : ULONG , pub ImageName : UNICODE_STRING , pub RegistryPath : UNICODE_STRING , pub CertificatePublisher : UNICODE_STRING , pub CertificateIssuer : UNICODE_STRING , pub ImageHash : PVOID , pub CertificateThumbprint : PVOID , pub ImageHashAlgorithm : ULONG , pub ThumbprintHashAlgorithm : ULONG , pub ImageHashLength : ULONG , pub CertificateThumbprintLength : ULONG , } pub type BDCB_IMAGE_INFORMATION = _BDCB_IMAGE_INFORMATION ; pub type BOOT_DRIVER_CALLBACK_FUNCTION = :: std :: option :: Option < unsafe extern "C" fn ( CallbackContext : PVOID , Classification : BDCB_CALLBACK_TYPE , ImageInformation : PBDCB_IMAGE_INFORMATION ) > ; pub type PBOOT_DRIVER_CALLBACK_FUNCTION = BOOT_DRIVER_CALLBACK_FUNCTION ; extern "C" { pub fn IoRegisterBootDriverCallback ( CallbackFunction : PBOOT_DRIVER_CALLBACK_FUNCTION , CallbackContext : PVOID ) -> PVOID ; } extern "C" { pub fn IoUnregisterBootDriverCallback ( CallbackHandle : PVOID ) ; } extern "C" { pub fn IoGetActivityIdIrp ( Irp : PIRP , Guid : LPGUID ) -> NTSTATUS ; } extern "C" { pub fn IoSetActivityIdIrp ( Irp : PIRP , Guid : LPCGUID ) -> NTSTATUS ; } extern "C" { pub fn IoPropagateActivityIdToThread ( Irp : PIRP , PropagatedId : LPGUID , OriginalId : * mut LPCGUID ) -> NTSTATUS ; } extern "C" { pub fn IoSetActivityIdThread ( ActivityId : LPCGUID ) -> LPCGUID ; } extern "C" { pub fn IoClearActivityIdThread ( OriginalId : LPCGUID ) ; } extern "C" { pub fn IoGetActivityIdThread ( ) -> LPCGUID ; } extern "C" { pub fn IoTransferActivityId ( ActivityId : LPCGUID , RelatedActivityId : LPCGUID ) ; } extern "C" { pub fn IoGetFsZeroingOffset ( Irp : PIRP , ZeroingOffset : PULONG ) -> NTSTATUS ; } extern "C" { pub fn IoSetFsZeroingOffsetRequired ( Irp : PIRP ) -> NTSTATUS ; } extern "C" { pub fn IoSetFsZeroingOffset ( Irp : PIRP , ZeroingOffset : ULONG ) -> NTSTATUS ; } extern "C" { pub fn IoIsValidIrpStatus ( Status : NTSTATUS ) -> LOGICAL ; } extern "C" { pub fn IoIncrementKeepAliveCount ( FileObject : PFILE_OBJECT , Process : PEPROCESS ) -> NTSTATUS ; } extern "C" { pub fn IoDecrementKeepAliveCount ( FileObject : PFILE_OBJECT , Process : PEPROCESS ) -> NTSTATUS ; } extern "C" { pub fn IoGetInitiatorProcess ( FileObject : PFILE_OBJECT ) -> PEPROCESS ; } extern "C" { pub fn IoSetMasterIrpStatus ( MasterIrp : PIRP , Status : NTSTATUS ) ; } extern "C" { pub fn IoQueryFullDriverPath ( DriverObject : PDRIVER_OBJECT , FullPath : PUNICODE_STRING ) -> NTSTATUS ; } # [ repr ( C ) ] pub struct _AGP_TARGET_BUS_INTERFACE_STANDARD { pub Size : USHORT , pub Version : USHORT , pub Context : PVOID , pub InterfaceReference : PINTERFACE_REFERENCE , pub InterfaceDereference : PINTERFACE_DEREFERENCE , pub SetBusData : PGET_SET_DEVICE_DATA , pub GetBusData : PGET_SET_DEVICE_DATA , pub CapabilityID : UCHAR , } pub type AGP_TARGET_BUS_INTERFACE_STANDARD = _AGP_TARGET_BUS_INTERFACE_STANDARD ; pub type PAGP_TARGET_BUS_INTERFACE_STANDARD = * mut _AGP_TARGET_BUS_INTERFACE_STANDARD ; extern "C" { pub fn IoReportDetectedDevice ( DriverObject : PDRIVER_OBJECT , LegacyBusType : INTERFACE_TYPE , BusNumber : ULONG , SlotNumber : ULONG , ResourceList : PCM_RESOURCE_LIST , ResourceRequirements : PIO_RESOURCE_REQUIREMENTS_LIST , ResourceAssigned : BOOLEAN , DeviceObject : * mut PDEVICE_OBJECT ) -> NTSTATUS ; } extern "C" { pub fn IoReportRootDevice ( DriverObject : PDRIVER_OBJECT ) -> NTSTATUS ; } pub type PGET_LOCATION_STRING = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , LocationStrings : * mut PZZWSTR ) -> NTSTATUS > ; # [ repr ( C ) ] pub struct _PNP_LOCATION_INTERFACE { pub Size : USHORT , pub Version : USHORT , pub Context : PVOID , pub InterfaceReference : PINTERFACE_REFERENCE , pub InterfaceDereference : PINTERFACE_DEREFERENCE , pub GetLocationString : PGET_LOCATION_STRING , } pub type PNP_LOCATION_INTERFACE = _PNP_LOCATION_INTERFACE ; pub type PPNP_LOCATION_INTERFACE = * mut _PNP_LOCATION_INTERFACE ; pub const _ARBITER_ACTION_ArbiterActionTestAllocation : _ARBITER_ACTION = 0 ; pub const _ARBITER_ACTION_ArbiterActionRetestAllocation : _ARBITER_ACTION = 1 ; pub const _ARBITER_ACTION_ArbiterActionCommitAllocation : _ARBITER_ACTION = 2 ; pub const _ARBITER_ACTION_ArbiterActionRollbackAllocation : _ARBITER_ACTION = 3 ; pub const _ARBITER_ACTION_ArbiterActionQueryAllocatedResources : _ARBITER_ACTION = 4 ; pub const _ARBITER_ACTION_ArbiterActionWriteReservedResources : _ARBITER_ACTION = 5 ; pub const _ARBITER_ACTION_ArbiterActionQueryConflict : _ARBITER_ACTION = 6 ; pub const _ARBITER_ACTION_ArbiterActionQueryArbitrate : _ARBITER_ACTION = 7 ; pub const _ARBITER_ACTION_ArbiterActionAddReserved : _ARBITER_ACTION = 8 ; pub const _ARBITER_ACTION_ArbiterActionBootAllocation : _ARBITER_ACTION = 9 ; pub type _ARBITER_ACTION = i32 ; pub use self :: _ARBITER_ACTION as ARBITER_ACTION ; pub type PARBITER_ACTION = * mut _ARBITER_ACTION ; # [ repr ( C ) ] pub struct _ARBITER_CONFLICT_INFO { pub OwningObject : PDEVICE_OBJECT , pub Start : ULONGLONG , pub End : ULONGLONG , } pub type ARBITER_CONFLICT_INFO = _ARBITER_CONFLICT_INFO ; pub type PARBITER_CONFLICT_INFO = * mut _ARBITER_CONFLICT_INFO ; # [ repr ( C ) ] pub struct _ARBITER_TEST_ALLOCATION_PARAMETERS { pub ArbitrationList : PLIST_ENTRY , pub AllocateFromCount : ULONG , pub AllocateFrom : PCM_PARTIAL_RESOURCE_DESCRIPTOR , } pub type ARBITER_TEST_ALLOCATION_PARAMETERS = _ARBITER_TEST_ALLOCATION_PARAMETERS ; pub type PARBITER_TEST_ALLOCATION_PARAMETERS = * mut _ARBITER_TEST_ALLOCATION_PARAMETERS ; # [ repr ( C ) ] pub struct _ARBITER_RETEST_ALLOCATION_PARAMETERS { pub ArbitrationList : PLIST_ENTRY , pub AllocateFromCount : ULONG , pub AllocateFrom : PCM_PARTIAL_RESOURCE_DESCRIPTOR , } pub type ARBITER_RETEST_ALLOCATION_PARAMETERS = _ARBITER_RETEST_ALLOCATION_PARAMETERS ; pub type PARBITER_RETEST_ALLOCATION_PARAMETERS = * mut _ARBITER_RETEST_ALLOCATION_PARAMETERS ; # [ repr ( C ) ] pub struct _ARBITER_BOOT_ALLOCATION_PARAMETERS { pub ArbitrationList : PLIST_ENTRY , } pub type ARBITER_BOOT_ALLOCATION_PARAMETERS = _ARBITER_BOOT_ALLOCATION_PARAMETERS ; pub type PARBITER_BOOT_ALLOCATION_PARAMETERS = * mut _ARBITER_BOOT_ALLOCATION_PARAMETERS ; # [ repr ( C ) ] pub struct _ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS { pub AllocatedResources : * mut PCM_PARTIAL_RESOURCE_LIST , } pub type ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS = _ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS ; pub type PARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS = * mut _ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS ; # [ repr ( C ) ] pub struct _ARBITER_QUERY_CONFLICT_PARAMETERS { pub PhysicalDeviceObject : PDEVICE_OBJECT , pub ConflictingResource : PIO_RESOURCE_DESCRIPTOR , pub ConflictCount : PULONG , pub Conflicts : * mut PARBITER_CONFLICT_INFO , } pub type ARBITER_QUERY_CONFLICT_PARAMETERS = _ARBITER_QUERY_CONFLICT_PARAMETERS ; pub type PARBITER_QUERY_CONFLICT_PARAMETERS = * mut _ARBITER_QUERY_CONFLICT_PARAMETERS ; # [ repr ( C ) ] pub struct _ARBITER_QUERY_ARBITRATE_PARAMETERS { pub ArbitrationList : PLIST_ENTRY , } pub type ARBITER_QUERY_ARBITRATE_PARAMETERS = _ARBITER_QUERY_ARBITRATE_PARAMETERS ; pub type PARBITER_QUERY_ARBITRATE_PARAMETERS = * mut _ARBITER_QUERY_ARBITRATE_PARAMETERS ; # [ repr ( C ) ] pub struct _ARBITER_ADD_RESERVED_PARAMETERS { pub ReserveDevice : PDEVICE_OBJECT , } pub type ARBITER_ADD_RESERVED_PARAMETERS = _ARBITER_ADD_RESERVED_PARAMETERS ; pub type PARBITER_ADD_RESERVED_PARAMETERS = * mut _ARBITER_ADD_RESERVED_PARAMETERS ; # [ repr ( C ) ] pub struct _ARBITER_PARAMETERS { pub Parameters : _ARBITER_PARAMETERS__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _ARBITER_PARAMETERS__bindgen_ty_1 { pub TestAllocation : __BindgenUnionField < ARBITER_TEST_ALLOCATION_PARAMETERS > , pub RetestAllocation : __BindgenUnionField < ARBITER_RETEST_ALLOCATION_PARAMETERS > , pub BootAllocation : __BindgenUnionField < ARBITER_BOOT_ALLOCATION_PARAMETERS > , pub QueryAllocatedResources : __BindgenUnionField < ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS > , pub QueryConflict : __BindgenUnionField < ARBITER_QUERY_CONFLICT_PARAMETERS > , pub QueryArbitrate : __BindgenUnionField < ARBITER_QUERY_ARBITRATE_PARAMETERS > , pub AddReserved : __BindgenUnionField < ARBITER_ADD_RESERVED_PARAMETERS > , pub bindgen_union_field : [ u64 ; 4usize ] , } pub type ARBITER_PARAMETERS = _ARBITER_PARAMETERS ; pub type PARBITER_PARAMETERS = * mut _ARBITER_PARAMETERS ; pub const _ARBITER_REQUEST_SOURCE_ArbiterRequestUndefined : _ARBITER_REQUEST_SOURCE = -1 ; pub const _ARBITER_REQUEST_SOURCE_ArbiterRequestLegacyReported : _ARBITER_REQUEST_SOURCE = 0 ; pub const _ARBITER_REQUEST_SOURCE_ArbiterRequestHalReported : _ARBITER_REQUEST_SOURCE = 1 ; pub const _ARBITER_REQUEST_SOURCE_ArbiterRequestLegacyAssigned : _ARBITER_REQUEST_SOURCE = 2 ; pub const _ARBITER_REQUEST_SOURCE_ArbiterRequestPnpDetected : _ARBITER_REQUEST_SOURCE = 3 ; pub const _ARBITER_REQUEST_SOURCE_ArbiterRequestPnpEnumerated : _ARBITER_REQUEST_SOURCE = 4 ; pub type _ARBITER_REQUEST_SOURCE = i32 ; pub use self :: _ARBITER_REQUEST_SOURCE as ARBITER_REQUEST_SOURCE ; pub const _ARBITER_RESULT_ArbiterResultUndefined : _ARBITER_RESULT = -1 ; pub const _ARBITER_RESULT_ArbiterResultSuccess : _ARBITER_RESULT = 0 ; pub const _ARBITER_RESULT_ArbiterResultExternalConflict : _ARBITER_RESULT = 1 ; pub const _ARBITER_RESULT_ArbiterResultNullRequest : _ARBITER_RESULT = 2 ; pub type _ARBITER_RESULT = i32 ; pub use self :: _ARBITER_RESULT as ARBITER_RESULT ; extern "C" { pub fn IoReportResourceForDetection ( DriverObject : PDRIVER_OBJECT , DriverList : PCM_RESOURCE_LIST , DriverListSize : ULONG , DeviceObject : PDEVICE_OBJECT , DeviceList : PCM_RESOURCE_LIST , DeviceListSize : ULONG , ConflictDetected : PBOOLEAN ) -> NTSTATUS ; } # [ repr ( C ) ] pub struct _ARBITER_LIST_ENTRY { pub ListEntry : LIST_ENTRY , pub AlternativeCount : ULONG , pub Alternatives : PIO_RESOURCE_DESCRIPTOR , pub PhysicalDeviceObject : PDEVICE_OBJECT , pub RequestSource : ARBITER_REQUEST_SOURCE , pub Flags : ULONG , pub WorkSpace : LONG_PTR , pub InterfaceType : INTERFACE_TYPE , pub SlotNumber : ULONG , pub BusNumber : ULONG , pub Assignment : PCM_PARTIAL_RESOURCE_DESCRIPTOR , pub SelectedAlternative : PIO_RESOURCE_DESCRIPTOR , pub Result : ARBITER_RESULT , } pub type ARBITER_LIST_ENTRY = _ARBITER_LIST_ENTRY ; pub type PARBITER_LIST_ENTRY = * mut _ARBITER_LIST_ENTRY ; pub type PARBITER_HANDLER = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , Action : ARBITER_ACTION , Parameters : PARBITER_PARAMETERS ) -> NTSTATUS > ; # [ repr ( C ) ] pub struct _ARBITER_INTERFACE { pub Size : USHORT , pub Version : USHORT , pub Context : PVOID , pub InterfaceReference : PINTERFACE_REFERENCE , pub InterfaceDereference : PINTERFACE_DEREFERENCE , pub ArbiterHandler : PARBITER_HANDLER , pub Flags : ULONG , } pub type ARBITER_INTERFACE = _ARBITER_INTERFACE ; pub type PARBITER_INTERFACE = * mut _ARBITER_INTERFACE ; pub const _RESOURCE_TRANSLATION_DIRECTION_TranslateChildToParent : _RESOURCE_TRANSLATION_DIRECTION = 0 ; pub const _RESOURCE_TRANSLATION_DIRECTION_TranslateParentToChild : _RESOURCE_TRANSLATION_DIRECTION = 1 ; pub type _RESOURCE_TRANSLATION_DIRECTION = i32 ; pub use self :: _RESOURCE_TRANSLATION_DIRECTION as RESOURCE_TRANSLATION_DIRECTION ; pub type PTRANSLATE_RESOURCE_HANDLER = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , Source : PCM_PARTIAL_RESOURCE_DESCRIPTOR , Direction : RESOURCE_TRANSLATION_DIRECTION , AlternativesCount : ULONG , Alternatives : * mut IO_RESOURCE_DESCRIPTOR , PhysicalDeviceObject : PDEVICE_OBJECT , Target : PCM_PARTIAL_RESOURCE_DESCRIPTOR ) -> NTSTATUS > ; pub type PTRANSLATE_RESOURCE_REQUIREMENTS_HANDLER = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , Source : PIO_RESOURCE_DESCRIPTOR , PhysicalDeviceObject : PDEVICE_OBJECT , TargetCount : PULONG , Target : * mut PIO_RESOURCE_DESCRIPTOR ) -> NTSTATUS > ; # [ repr ( C ) ] pub struct _TRANSLATOR_INTERFACE { pub Size : USHORT , pub Version : USHORT , pub Context : PVOID , pub InterfaceReference : PINTERFACE_REFERENCE , pub InterfaceDereference : PINTERFACE_DEREFERENCE , pub TranslateResources : PTRANSLATE_RESOURCE_HANDLER , pub TranslateResourceRequirements : PTRANSLATE_RESOURCE_REQUIREMENTS_HANDLER , } pub type TRANSLATOR_INTERFACE = _TRANSLATOR_INTERFACE ; pub type PTRANSLATOR_INTERFACE = * mut _TRANSLATOR_INTERFACE ; pub type PHAL_RESET_DISPLAY_PARAMETERS = :: std :: option :: Option < unsafe extern "C" fn ( Columns : ULONG , Rows : ULONG ) -> BOOLEAN > ; extern "C" { pub fn HalAcquireDisplayOwnership ( ResetDisplayParameters : PHAL_RESET_DISPLAY_PARAMETERS ) ; } extern "C" { pub fn HalSetBusDataByOffset ( BusDataType : BUS_DATA_TYPE , BusNumber : ULONG , SlotNumber : ULONG , Buffer : PVOID , Offset : ULONG , Length : ULONG ) -> ULONG ; } extern "C" { pub fn HalTranslateBusAddress ( InterfaceType : INTERFACE_TYPE , BusNumber : ULONG , BusAddress : PHYSICAL_ADDRESS , AddressSpace : PULONG , TranslatedAddress : PPHYSICAL_ADDRESS ) -> BOOLEAN ; } extern "C" { pub fn HalAllocateCrashDumpRegisters ( AdapterObject : PADAPTER_OBJECT , NumberOfMapRegisters : PULONG ) -> PVOID ; } pub const _HAL_DMA_CRASH_DUMP_REGISTER_TYPE_HalDmaCrashDumpRegisterSet1 : _HAL_DMA_CRASH_DUMP_REGISTER_TYPE = 0 ; pub const _HAL_DMA_CRASH_DUMP_REGISTER_TYPE_HalDmaCrashDumpRegisterSet2 : _HAL_DMA_CRASH_DUMP_REGISTER_TYPE = 1 ; pub const _HAL_DMA_CRASH_DUMP_REGISTER_TYPE_HalDmaCrashDumpRegisterSetMax : _HAL_DMA_CRASH_DUMP_REGISTER_TYPE = 2 ; pub type _HAL_DMA_CRASH_DUMP_REGISTER_TYPE = i32 ; pub use self :: _HAL_DMA_CRASH_DUMP_REGISTER_TYPE as HAL_DMA_CRASH_DUMP_REGISTER_TYPE ; pub type PHAL_DMA_CRASH_DUMP_REGISTER_TYPE = * mut _HAL_DMA_CRASH_DUMP_REGISTER_TYPE ; extern "C" { pub fn HalDmaAllocateCrashDumpRegistersEx ( Adapter : PADAPTER_OBJECT , NumberOfMapRegisters : ULONG , Type : HAL_DMA_CRASH_DUMP_REGISTER_TYPE , MapRegisterBase : * mut PVOID , MapRegistersAvailable : PULONG ) -> NTSTATUS ; } extern "C" { pub fn HalDmaFreeCrashDumpRegistersEx ( Adapter : PADAPTER_OBJECT , Type : HAL_DMA_CRASH_DUMP_REGISTER_TYPE ) -> NTSTATUS ; } extern "C" { pub fn HalGetBusDataByOffset ( BusDataType : BUS_DATA_TYPE , BusNumber : ULONG , SlotNumber : ULONG , Buffer : PVOID , Offset : ULONG , Length : ULONG ) -> ULONG ; } extern "C" { pub fn HalGetAdapter ( DeviceDescription : PDEVICE_DESCRIPTION , NumberOfMapRegisters : PULONG ) -> PADAPTER_OBJECT ; } pub type pHalHandlerForBus = :: std :: option :: Option < unsafe extern "C" fn ( InterfaceType : INTERFACE_TYPE , BusNumber : ULONG ) -> PBUS_HANDLER > ; pub type pHalReferenceBusHandler = :: std :: option :: Option < unsafe extern "C" fn ( BusHandler : PBUS_HANDLER ) > ; pub const _HAL_QUERY_INFORMATION_CLASS_HalInstalledBusInformation : _HAL_QUERY_INFORMATION_CLASS = 0 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalProfileSourceInformation : _HAL_QUERY_INFORMATION_CLASS = 1 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalInformationClassUnused1 : _HAL_QUERY_INFORMATION_CLASS = 2 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalPowerInformation : _HAL_QUERY_INFORMATION_CLASS = 3 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalProcessorSpeedInformation : _HAL_QUERY_INFORMATION_CLASS = 4 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalCallbackInformation : _HAL_QUERY_INFORMATION_CLASS = 5 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalMapRegisterInformation : _HAL_QUERY_INFORMATION_CLASS = 6 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalMcaLogInformation : _HAL_QUERY_INFORMATION_CLASS = 7 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalFrameBufferCachingInformation : _HAL_QUERY_INFORMATION_CLASS = 8 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalDisplayBiosInformation : _HAL_QUERY_INFORMATION_CLASS = 9 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalProcessorFeatureInformation : _HAL_QUERY_INFORMATION_CLASS = 10 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalNumaTopologyInterface : _HAL_QUERY_INFORMATION_CLASS = 11 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalErrorInformation : _HAL_QUERY_INFORMATION_CLASS = 12 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalCmcLogInformation : _HAL_QUERY_INFORMATION_CLASS = 13 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalCpeLogInformation : _HAL_QUERY_INFORMATION_CLASS = 14 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalQueryMcaInterface : _HAL_QUERY_INFORMATION_CLASS = 15 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalQueryAMLIIllegalIOPortAddresses : _HAL_QUERY_INFORMATION_CLASS = 16 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalQueryMaxHotPlugMemoryAddress : _HAL_QUERY_INFORMATION_CLASS = 17 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalPartitionIpiInterface : _HAL_QUERY_INFORMATION_CLASS = 18 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalPlatformInformation : _HAL_QUERY_INFORMATION_CLASS = 19 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalQueryProfileSourceList : _HAL_QUERY_INFORMATION_CLASS = 20 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalInitLogInformation : _HAL_QUERY_INFORMATION_CLASS = 21 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalFrequencyInformation : _HAL_QUERY_INFORMATION_CLASS = 22 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalProcessorBrandString : _HAL_QUERY_INFORMATION_CLASS = 23 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalHypervisorInformation : _HAL_QUERY_INFORMATION_CLASS = 24 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalPlatformTimerInformation : _HAL_QUERY_INFORMATION_CLASS = 25 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalAcpiAuditInformation : _HAL_QUERY_INFORMATION_CLASS = 26 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalIrtInformation : _HAL_QUERY_INFORMATION_CLASS = 27 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalSecondaryInterruptInformation : _HAL_QUERY_INFORMATION_CLASS = 28 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalParkingPageInformation : _HAL_QUERY_INFORMATION_CLASS = 29 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalNumaRangeTableInformation : _HAL_QUERY_INFORMATION_CLASS = 30 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalChannelTopologyInformation : _HAL_QUERY_INFORMATION_CLASS = 31 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalExternalCacheInformation : _HAL_QUERY_INFORMATION_CLASS = 32 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalQueryDebuggerInformation : _HAL_QUERY_INFORMATION_CLASS = 33 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalFwBootPerformanceInformation : _HAL_QUERY_INFORMATION_CLASS = 34 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalFwS3PerformanceInformation : _HAL_QUERY_INFORMATION_CLASS = 35 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalGetChannelPowerInformation : _HAL_QUERY_INFORMATION_CLASS = 36 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalQueryStateElementInformation : _HAL_QUERY_INFORMATION_CLASS = 37 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalPsciInformation : _HAL_QUERY_INFORMATION_CLASS = 38 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalInterruptControllerInformation : _HAL_QUERY_INFORMATION_CLASS = 39 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalQueryIommuReservedRegionInformation : _HAL_QUERY_INFORMATION_CLASS = 40 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalQueryArmErrataInformation : _HAL_QUERY_INFORMATION_CLASS = 41 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalQueryProcessorEfficiencyInformation : _HAL_QUERY_INFORMATION_CLASS = 42 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalQueryAcpiWakeAlarmSystemPowerStateInformation : _HAL_QUERY_INFORMATION_CLASS = 43 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalQueryProfileNumberOfCounters : _HAL_QUERY_INFORMATION_CLASS = 44 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalQueryHyperlaunchEntrypoint : _HAL_QUERY_INFORMATION_CLASS = 45 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalHardwareWatchdogInformation : _HAL_QUERY_INFORMATION_CLASS = 46 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalDmaRemappingInformation : _HAL_QUERY_INFORMATION_CLASS = 47 ; pub const _HAL_QUERY_INFORMATION_CLASS_HalQueryRuntimeServicesBlockInformation : _HAL_QUERY_INFORMATION_CLASS = 48 ; pub type _HAL_QUERY_INFORMATION_CLASS = i32 ; pub use self :: _HAL_QUERY_INFORMATION_CLASS as HAL_QUERY_INFORMATION_CLASS ; pub type PHAL_QUERY_INFORMATION_CLASS = * mut _HAL_QUERY_INFORMATION_CLASS ; pub const _HAL_SET_INFORMATION_CLASS_HalProfileSourceInterval : _HAL_SET_INFORMATION_CLASS = 0 ; pub const _HAL_SET_INFORMATION_CLASS_HalProfileSourceInterruptHandler : _HAL_SET_INFORMATION_CLASS = 1 ; pub const _HAL_SET_INFORMATION_CLASS_HalMcaRegisterDriver : _HAL_SET_INFORMATION_CLASS = 2 ; pub const _HAL_SET_INFORMATION_CLASS_HalKernelErrorHandler : _HAL_SET_INFORMATION_CLASS = 3 ; pub const _HAL_SET_INFORMATION_CLASS_HalCmcRegisterDriver : _HAL_SET_INFORMATION_CLASS = 4 ; pub const _HAL_SET_INFORMATION_CLASS_HalCpeRegisterDriver : _HAL_SET_INFORMATION_CLASS = 5 ; pub const _HAL_SET_INFORMATION_CLASS_HalMcaLog : _HAL_SET_INFORMATION_CLASS = 6 ; pub const _HAL_SET_INFORMATION_CLASS_HalCmcLog : _HAL_SET_INFORMATION_CLASS = 7 ; pub const _HAL_SET_INFORMATION_CLASS_HalCpeLog : _HAL_SET_INFORMATION_CLASS = 8 ; pub const _HAL_SET_INFORMATION_CLASS_HalGenerateCmcInterrupt : _HAL_SET_INFORMATION_CLASS = 9 ; pub const _HAL_SET_INFORMATION_CLASS_HalProfileSourceTimerHandler : _HAL_SET_INFORMATION_CLASS = 10 ; pub const _HAL_SET_INFORMATION_CLASS_HalEnlightenment : _HAL_SET_INFORMATION_CLASS = 11 ; pub const _HAL_SET_INFORMATION_CLASS_HalProfileDpgoSourceInterruptHandler : _HAL_SET_INFORMATION_CLASS = 12 ; pub const _HAL_SET_INFORMATION_CLASS_HalRegisterSecondaryInterruptInterface : _HAL_SET_INFORMATION_CLASS = 13 ; pub const _HAL_SET_INFORMATION_CLASS_HalSetChannelPowerInformation : _HAL_SET_INFORMATION_CLASS = 14 ; pub const _HAL_SET_INFORMATION_CLASS_HalI386ExceptionChainTerminatorInformation : _HAL_SET_INFORMATION_CLASS = 15 ; pub const _HAL_SET_INFORMATION_CLASS_HalSetResetParkDisposition : _HAL_SET_INFORMATION_CLASS = 16 ; pub const _HAL_SET_INFORMATION_CLASS_HalSetPsciSuspendMode : _HAL_SET_INFORMATION_CLASS = 17 ; pub const _HAL_SET_INFORMATION_CLASS_HalSetHvciEnabled : _HAL_SET_INFORMATION_CLASS = 18 ; pub const _HAL_SET_INFORMATION_CLASS_HalSetProcessorTraceInterruptHandler : _HAL_SET_INFORMATION_CLASS = 19 ; pub type _HAL_SET_INFORMATION_CLASS = i32 ; pub use self :: _HAL_SET_INFORMATION_CLASS as HAL_SET_INFORMATION_CLASS ; pub type PHAL_SET_INFORMATION_CLASS = * mut _HAL_SET_INFORMATION_CLASS ; pub type pHalQuerySystemInformation = :: std :: option :: Option < unsafe extern "C" fn ( InformationClass : HAL_QUERY_INFORMATION_CLASS , BufferSize : ULONG , Buffer : PVOID , ReturnedLength : PULONG ) -> NTSTATUS > ; pub type pHalSetSystemInformation = :: std :: option :: Option < unsafe extern "C" fn ( InformationClass : HAL_SET_INFORMATION_CLASS , BufferSize : ULONG , Buffer : PVOID ) -> NTSTATUS > ; pub type pHalExamineMBR = :: std :: option :: Option < unsafe extern "C" fn ( DeviceObject : PDEVICE_OBJECT , SectorSize : ULONG , MBRTypeIdentifier : ULONG , Buffer : * mut PVOID ) > ; pub type pHalIoReadPartitionTable = :: std :: option :: Option < unsafe extern "C" fn ( DeviceObject : PDEVICE_OBJECT , SectorSize : ULONG , ReturnRecognizedPartitions : BOOLEAN , PartitionBuffer : * mut * mut _DRIVE_LAYOUT_INFORMATION ) -> NTSTATUS > ; pub type pHalIoSetPartitionInformation = :: std :: option :: Option < unsafe extern "C" fn ( DeviceObject : PDEVICE_OBJECT , SectorSize : ULONG , PartitionNumber : ULONG , PartitionType : ULONG ) -> NTSTATUS > ; pub type pHalIoWritePartitionTable = :: std :: option :: Option < unsafe extern "C" fn ( DeviceObject : PDEVICE_OBJECT , SectorSize : ULONG , SectorsPerTrack : ULONG , NumberOfHeads : ULONG , PartitionBuffer : * mut _DRIVE_LAYOUT_INFORMATION ) -> NTSTATUS > ; pub type pHalQueryBusSlots = :: std :: option :: Option < unsafe extern "C" fn ( BusHandler : PBUS_HANDLER , BufferSize : ULONG , SlotNumbers : PULONG , ReturnedLength : PULONG ) -> NTSTATUS > ; pub type pHalInitPnpDriver = :: std :: option :: Option < unsafe extern "C" fn ( ) -> NTSTATUS > ; # [ repr ( C ) ] pub struct _PM_DISPATCH_TABLE { pub Signature : ULONG , pub Version : ULONG , pub Function : [ PVOID ; 1usize ] , } pub type PM_DISPATCH_TABLE = _PM_DISPATCH_TABLE ; pub type PPM_DISPATCH_TABLE = * mut _PM_DISPATCH_TABLE ; pub type pHalInitPowerManagement = :: std :: option :: Option < unsafe extern "C" fn ( PmDriverDispatchTable : PPM_DISPATCH_TABLE , PmHalDispatchTable : * mut PPM_DISPATCH_TABLE ) -> NTSTATUS > ; pub type pHalGetDmaAdapter = :: std :: option :: Option < unsafe extern "C" fn ( PhysicalDeviceObject : PVOID , DeviceDescriptor : * mut _DEVICE_DESCRIPTION , NumberOfMapRegisters : PULONG ) -> * mut _DMA_ADAPTER > ; pub type pHalGetInterruptTranslator = :: std :: option :: Option < unsafe extern "C" fn ( ParentInterfaceType : INTERFACE_TYPE , ParentBusNumber : ULONG , BridgeInterfaceType : INTERFACE_TYPE , Size : USHORT , Version : USHORT , Translator : PTRANSLATOR_INTERFACE , BridgeBusNumber : PULONG ) -> NTSTATUS > ; pub type pHalTranslateBusAddress = :: std :: option :: Option < unsafe extern "C" fn ( InterfaceType : INTERFACE_TYPE , BusNumber : ULONG , BusAddress : PHYSICAL_ADDRESS , AddressSpace : PULONG , TranslatedAddress : PPHYSICAL_ADDRESS ) -> BOOLEAN > ; pub type pHalAssignSlotResources = :: std :: option :: Option < unsafe extern "C" fn ( RegistryPath : PUNICODE_STRING , DriverClassName : PUNICODE_STRING , DriverObject : PDRIVER_OBJECT , DeviceObject : PDEVICE_OBJECT , BusType : INTERFACE_TYPE , BusNumber : ULONG , SlotNumber : ULONG , AllocatedResources : * mut PCM_RESOURCE_LIST ) -> NTSTATUS > ; pub type pHalHaltSystem = :: std :: option :: Option < unsafe extern "C" fn ( ) > ; pub type pHalResetDisplay = :: std :: option :: Option < unsafe extern "C" fn ( ) -> BOOLEAN > ; # [ repr ( C ) ] pub struct _MAP_REGISTER_ENTRY { pub MapRegister : PVOID , pub WriteToDevice : BOOLEAN , } pub type MAP_REGISTER_ENTRY = _MAP_REGISTER_ENTRY ; pub type PMAP_REGISTER_ENTRY = * mut _MAP_REGISTER_ENTRY ; pub type pHalVectorToIDTEntry = :: std :: option :: Option < unsafe extern "C" fn ( Vector : ULONG ) -> UCHAR > ; pub type pHalFindBusAddressTranslation = :: std :: option :: Option < unsafe extern "C" fn ( BusAddress : PHYSICAL_ADDRESS , AddressSpace : PULONG , TranslatedAddress : PPHYSICAL_ADDRESS , Context : PULONG_PTR , NextBus : BOOLEAN ) -> BOOLEAN > ; pub type pHalStartMirroring = :: std :: option :: Option < unsafe extern "C" fn ( ) -> NTSTATUS > ; pub type pHalEndMirroring = :: std :: option :: Option < unsafe extern "C" fn ( PassNumber : ULONG ) -> NTSTATUS > ; pub type pHalMirrorPhysicalMemory = :: std :: option :: Option < unsafe extern "C" fn ( PhysicalAddress : PHYSICAL_ADDRESS , NumberOfBytes : LARGE_INTEGER ) -> NTSTATUS > ; pub type pHalMirrorVerify = :: std :: option :: Option < unsafe extern "C" fn ( PhysicalAddress : PHYSICAL_ADDRESS , NumberOfBytes : LARGE_INTEGER ) -> NTSTATUS > ; # [ repr ( C ) ] pub struct DEBUG_DEVICE_ADDRESS { pub Type : UCHAR , pub Valid : BOOLEAN , pub __bindgen_anon_1 : DEBUG_DEVICE_ADDRESS__bindgen_ty_1 , pub TranslatedAddress : PUCHAR , pub Length : ULONG , } # [ repr ( C ) ] pub struct DEBUG_DEVICE_ADDRESS__bindgen_ty_1 { pub Reserved : __BindgenUnionField < [ UCHAR ; 2usize ] > , pub __bindgen_anon_1 : __BindgenUnionField < DEBUG_DEVICE_ADDRESS__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : [ u8 ; 2usize ] , } # [ repr ( C ) ] pub struct DEBUG_DEVICE_ADDRESS__bindgen_ty_1__bindgen_ty_1 { pub BitWidth : UCHAR , pub AccessSize : UCHAR , } pub type PDEBUG_DEVICE_ADDRESS = * mut DEBUG_DEVICE_ADDRESS ; # [ repr ( C ) ] pub struct DEBUG_MEMORY_REQUIREMENTS { pub Start : PHYSICAL_ADDRESS , pub MaxEnd : PHYSICAL_ADDRESS , pub VirtualAddress : PVOID , pub Length : ULONG , pub Cached : BOOLEAN , pub Aligned : BOOLEAN , } pub type PDEBUG_MEMORY_REQUIREMENTS = * mut DEBUG_MEMORY_REQUIREMENTS ; pub const KD_NAMESPACE_ENUM_KdNameSpacePCI : KD_NAMESPACE_ENUM = 0 ; pub const KD_NAMESPACE_ENUM_KdNameSpaceACPI : KD_NAMESPACE_ENUM = 1 ; pub const KD_NAMESPACE_ENUM_KdNameSpaceAny : KD_NAMESPACE_ENUM = 2 ; pub const KD_NAMESPACE_ENUM_KdNameSpaceNone : KD_NAMESPACE_ENUM = 3 ; pub const KD_NAMESPACE_ENUM_KdNameSpaceMax : KD_NAMESPACE_ENUM = 4 ; pub type KD_NAMESPACE_ENUM = i32 ; pub type PKD_NAMESPACE_ENUM = * mut KD_NAMESPACE_ENUM ; pub const KD_CALLBACK_ACTION_KdConfigureDeviceAndContinue : KD_CALLBACK_ACTION = 0 ; pub const KD_CALLBACK_ACTION_KdSkipDeviceAndContinue : KD_CALLBACK_ACTION = 1 ; pub const KD_CALLBACK_ACTION_KdConfigureDeviceAndStop : KD_CALLBACK_ACTION = 2 ; pub const KD_CALLBACK_ACTION_KdSkipDeviceAndStop : KD_CALLBACK_ACTION = 3 ; pub type KD_CALLBACK_ACTION = i32 ; pub type PKD_CALLBACK_ACTION = * mut KD_CALLBACK_ACTION ; # [ repr ( C ) ] pub struct _DEBUG_TRANSPORT_DATA { pub HwContextSize : ULONG , pub UseSerialFraming : BOOLEAN , } pub type DEBUG_TRANSPORT_DATA = _DEBUG_TRANSPORT_DATA ; pub type PDEBUG_TRANSPORT_DATA = * mut _DEBUG_TRANSPORT_DATA ; # [ repr ( C ) ] pub struct _DEBUG_DEVICE_DESCRIPTOR { pub Bus : ULONG , pub Slot : ULONG , pub Segment : USHORT , pub VendorID : USHORT , pub DeviceID : USHORT , pub BaseClass : UCHAR , pub SubClass : UCHAR , pub ProgIf : UCHAR , pub __bindgen_anon_1 : _DEBUG_DEVICE_DESCRIPTOR__bindgen_ty_1 , pub Initialized : BOOLEAN , pub Configured : BOOLEAN , pub BaseAddress : [ DEBUG_DEVICE_ADDRESS ; 6usize ] , pub Memory : DEBUG_MEMORY_REQUIREMENTS , pub PortType : USHORT , pub PortSubtype : USHORT , pub OemData : PVOID , pub OemDataLength : ULONG , pub NameSpace : KD_NAMESPACE_ENUM , pub NameSpacePath : PWCHAR , pub NameSpacePathLength : ULONG , pub TransportType : ULONG , pub TransportData : DEBUG_TRANSPORT_DATA , } # [ repr ( C ) ] pub struct _DEBUG_DEVICE_DESCRIPTOR__bindgen_ty_1 { pub Flags : __BindgenUnionField < UCHAR > , pub __bindgen_anon_1 : __BindgenUnionField < _DEBUG_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : u8 , } # [ repr ( C , packed ) ] pub struct _DEBUG_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl _DEBUG_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn DbgHalScratchAllocated ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_DbgHalScratchAllocated ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn DbgBarsMapped ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_DbgBarsMapped ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn DbgScratchAllocated ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_DbgScratchAllocated ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( DbgHalScratchAllocated : UCHAR , DbgBarsMapped : UCHAR , DbgScratchAllocated : UCHAR ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let DbgHalScratchAllocated : u8 = unsafe { :: std :: mem :: transmute ( DbgHalScratchAllocated ) } ; DbgHalScratchAllocated as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let DbgBarsMapped : u8 = unsafe { :: std :: mem :: transmute ( DbgBarsMapped ) } ; DbgBarsMapped as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let DbgScratchAllocated : u8 = unsafe { :: std :: mem :: transmute ( DbgScratchAllocated ) } ; DbgScratchAllocated as u64 } ) ; __bindgen_bitfield_unit } } pub type DEBUG_DEVICE_DESCRIPTOR = _DEBUG_DEVICE_DESCRIPTOR ; pub type PDEBUG_DEVICE_DESCRIPTOR = * mut _DEBUG_DEVICE_DESCRIPTOR ; # [ repr ( C ) ] pub struct _PCI_DEBUGGING_DEVICE_IN_USE { pub Segment : USHORT , pub Bus : ULONG , pub Slot : ULONG , } pub type PCI_DEBUGGING_DEVICE_IN_USE = _PCI_DEBUGGING_DEVICE_IN_USE ; pub type PPCI_DEBUGGING_DEVICE_IN_USE = * mut _PCI_DEBUGGING_DEVICE_IN_USE ; # [ repr ( C ) ] pub struct _ACPI_DEBUGGING_DEVICE_IN_USE { pub NameSpacePathLength : ULONG , pub NameSpacePath : [ WCHAR ; 1usize ] , } pub type ACPI_DEBUGGING_DEVICE_IN_USE = _ACPI_DEBUGGING_DEVICE_IN_USE ; pub type PACPI_DEBUGGING_DEVICE_IN_USE = * mut _ACPI_DEBUGGING_DEVICE_IN_USE ; # [ repr ( C ) ] pub struct _DEBUGGING_DEVICE_IN_USE { pub NameSpace : KD_NAMESPACE_ENUM , pub StructureLength : ULONG , pub __bindgen_anon_1 : _DEBUGGING_DEVICE_IN_USE__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _DEBUGGING_DEVICE_IN_USE__bindgen_ty_1 { pub AcpiDevice : __BindgenUnionField < ACPI_DEBUGGING_DEVICE_IN_USE > , pub PciDevice : __BindgenUnionField < PCI_DEBUGGING_DEVICE_IN_USE > , pub bindgen_union_field : [ u32 ; 3usize ] , } pub type DEBUGGING_DEVICE_IN_USE = _DEBUGGING_DEVICE_IN_USE ; pub type PDEBUGGING_DEVICE_IN_USE = * mut _DEBUGGING_DEVICE_IN_USE ; # [ repr ( C ) ] pub struct _DEBUGGING_DEVICE_IN_USE_INFORMATION { pub DeviceCount : ULONG , pub Device : [ DEBUGGING_DEVICE_IN_USE ; 1usize ] , } pub type DEBUGGING_DEVICE_IN_USE_INFORMATION = _DEBUGGING_DEVICE_IN_USE_INFORMATION ; pub type PDEBUGGING_DEVICE_IN_USE_INFORMATION = * mut _DEBUGGING_DEVICE_IN_USE_INFORMATION ; pub type PDEBUG_DEVICE_FOUND_FUNCTION = :: std :: option :: Option < unsafe extern "C" fn ( Device : PDEBUG_DEVICE_DESCRIPTOR ) -> KD_CALLBACK_ACTION > ; pub type pKdEnumerateDebuggingDevices = :: std :: option :: Option < unsafe extern "C" fn ( LoaderBlock : PVOID , Device : PDEBUG_DEVICE_DESCRIPTOR , Callback : PDEBUG_DEVICE_FOUND_FUNCTION ) -> NTSTATUS > ; pub type pKdSetupPciDeviceForDebugging = :: std :: option :: Option < unsafe extern "C" fn ( LoaderBlock : PVOID , PciDevice : PDEBUG_DEVICE_DESCRIPTOR ) -> NTSTATUS > ; pub type pKdReleasePciDeviceForDebugging = :: std :: option :: Option < unsafe extern "C" fn ( PciDevice : PDEBUG_DEVICE_DESCRIPTOR ) -> NTSTATUS > ; pub type pKdSetupIntegratedDeviceForDebugging = :: std :: option :: Option < unsafe extern "C" fn ( LoaderBlock : PVOID , IntegratedDevice : PDEBUG_DEVICE_DESCRIPTOR ) -> NTSTATUS > ; pub type pKdReleaseIntegratedDeviceForDebugging = :: std :: option :: Option < unsafe extern "C" fn ( IntegratedDevice : PDEBUG_DEVICE_DESCRIPTOR ) -> NTSTATUS > ; # [ repr ( C ) ] pub struct _LOADER_PARAMETER_BLOCK { _unused : [ u8 ; 0 ] , } pub type pKdGetAcpiTablePhase0 = :: std :: option :: Option < unsafe extern "C" fn ( LoaderBlock : * mut _LOADER_PARAMETER_BLOCK , Signature : ULONG ) -> PVOID > ; pub type pKdCheckPowerButton = :: std :: option :: Option < unsafe extern "C" fn ( ) > ; pub type pHalEndOfBoot = :: std :: option :: Option < unsafe extern "C" fn ( ) > ; pub type pKdMapPhysicalMemory64 = :: std :: option :: Option < unsafe extern "C" fn ( PhysicalAddress : PHYSICAL_ADDRESS , NumberPages : ULONG , FlushCurrentTLB : BOOLEAN ) -> PVOID > ; pub type pKdUnmapVirtualAddress = :: std :: option :: Option < unsafe extern "C" fn ( VirtualAddress : PVOID , NumberPages : ULONG , FlushCurrentTLB : BOOLEAN ) > ; pub type pKdGetPciDataByOffset = :: std :: option :: Option < unsafe extern "C" fn ( BusNumber : ULONG , SlotNumber : ULONG , Buffer : PVOID , Offset : ULONG , Length : ULONG ) -> ULONG > ; pub type pKdSetPciDataByOffset = :: std :: option :: Option < unsafe extern "C" fn ( BusNumber : ULONG , SlotNumber : ULONG , Buffer : PVOID , Offset : ULONG , Length : ULONG ) -> ULONG > ; pub type pHalGetAcpiTable = :: std :: option :: Option < unsafe extern "C" fn ( Signature : ULONG , OemId : PCSTR , OemTableId : PCSTR ) -> PVOID > ; pub type PCI_ERROR_HANDLER_CALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( ) > ; pub type pHalSetPciErrorHandlerCallback = :: std :: option :: Option < unsafe extern "C" fn ( Callback : PCI_ERROR_HANDLER_CALLBACK ) > ; # [ repr ( C ) ] pub struct HAL_DISPATCH { pub Version : ULONG , pub HalQuerySystemInformation : pHalQuerySystemInformation , pub HalSetSystemInformation : pHalSetSystemInformation , pub HalQueryBusSlots : pHalQueryBusSlots , pub Spare1 : ULONG , pub HalExamineMBR : pHalExamineMBR , pub HalIoReadPartitionTable : pHalIoReadPartitionTable , pub HalIoSetPartitionInformation : pHalIoSetPartitionInformation , pub HalIoWritePartitionTable : pHalIoWritePartitionTable , pub HalReferenceHandlerForBus : pHalHandlerForBus , pub HalReferenceBusHandler : pHalReferenceBusHandler , pub HalDereferenceBusHandler : pHalReferenceBusHandler , pub HalInitPnpDriver : pHalInitPnpDriver , pub HalInitPowerManagement : pHalInitPowerManagement , pub HalGetDmaAdapter : pHalGetDmaAdapter , pub HalGetInterruptTranslator : pHalGetInterruptTranslator , pub HalStartMirroring : pHalStartMirroring , pub HalEndMirroring : pHalEndMirroring , pub HalMirrorPhysicalMemory : pHalMirrorPhysicalMemory , pub HalEndOfBoot : pHalEndOfBoot , pub HalMirrorVerify : pHalMirrorVerify , pub HalGetCachedAcpiTable : pHalGetAcpiTable , pub HalSetPciErrorHandlerCallback : pHalSetPciErrorHandlerCallback , } pub type PHAL_DISPATCH = * mut HAL_DISPATCH ; extern "C" { # [ link_name = "\u{1}HalDispatchTable" ] pub static mut HalDispatchTable : PHAL_DISPATCH ; } # [ repr ( C ) ] pub struct _HAL_BUS_INFORMATION { pub BusType : INTERFACE_TYPE , pub ConfigurationType : BUS_DATA_TYPE , pub BusNumber : ULONG , pub Reserved : ULONG , } pub type HAL_BUS_INFORMATION = _HAL_BUS_INFORMATION ; pub type PHAL_BUS_INFORMATION = * mut _HAL_BUS_INFORMATION ; pub const _HAL_DISPLAY_BIOS_INFORMATION_HalDisplayInt10Bios : _HAL_DISPLAY_BIOS_INFORMATION = 0 ; pub const _HAL_DISPLAY_BIOS_INFORMATION_HalDisplayEmulatedBios : _HAL_DISPLAY_BIOS_INFORMATION = 1 ; pub const _HAL_DISPLAY_BIOS_INFORMATION_HalDisplayNoBios : _HAL_DISPLAY_BIOS_INFORMATION = 2 ; pub type _HAL_DISPLAY_BIOS_INFORMATION = i32 ; pub use self :: _HAL_DISPLAY_BIOS_INFORMATION as HAL_DISPLAY_BIOS_INFORMATION ; pub type PHAL_DISPLAY_BIOS_INFORMATION = * mut _HAL_DISPLAY_BIOS_INFORMATION ; # [ repr ( C ) ] pub struct _HAL_POWER_INFORMATION { pub TBD : ULONG , } pub type HAL_POWER_INFORMATION = _HAL_POWER_INFORMATION ; pub type PHAL_POWER_INFORMATION = * mut _HAL_POWER_INFORMATION ; # [ repr ( C ) ] pub struct _HAL_PROCESSOR_SPEED_INFO { pub ProcessorSpeed : ULONG , } pub type HAL_PROCESSOR_SPEED_INFORMATION = _HAL_PROCESSOR_SPEED_INFO ; pub type PHAL_PROCESSOR_SPEED_INFORMATION = * mut _HAL_PROCESSOR_SPEED_INFO ; # [ repr ( C ) ] pub struct _HAL_CALLBACKS { pub SetSystemInformation : PCALLBACK_OBJECT , pub BusCheck : PCALLBACK_OBJECT , } pub type HAL_CALLBACKS = _HAL_CALLBACKS ; pub type PHAL_CALLBACKS = * mut _HAL_CALLBACKS ; # [ repr ( C ) ] pub struct _HAL_PROCESSOR_FEATURE { pub UsableFeatureBits : ULONG , } pub type HAL_PROCESSOR_FEATURE = _HAL_PROCESSOR_FEATURE ; pub type PHALIOREADWRITEHANDLER = :: std :: option :: Option < unsafe extern "C" fn ( fRead : BOOLEAN , dwAddr : ULONG , dwSize : ULONG , pdwData : PULONG ) -> NTSTATUS > ; # [ repr ( C ) ] pub struct _HAL_AMLI_BAD_IO_ADDRESS_LIST { pub BadAddrBegin : ULONG , pub BadAddrSize : ULONG , pub OSVersionTrigger : ULONG , pub IOHandler : PHALIOREADWRITEHANDLER , } pub type HAL_AMLI_BAD_IO_ADDRESS_LIST = _HAL_AMLI_BAD_IO_ADDRESS_LIST ; pub type PHAL_AMLI_BAD_IO_ADDRESS_LIST = * mut _HAL_AMLI_BAD_IO_ADDRESS_LIST ; pub type PHALMCAINTERFACELOCK = :: std :: option :: Option < unsafe extern "C" fn ( ) > ; pub type PHALMCAINTERFACEUNLOCK = :: std :: option :: Option < unsafe extern "C" fn ( ) > ; pub type PHALMCAINTERFACEREADREGISTER = :: std :: option :: Option < unsafe extern "C" fn ( BankNumber : UCHAR , Exception : PVOID ) -> NTSTATUS > ; # [ repr ( C ) ] pub struct _HAL_MCA_INTERFACE { pub Lock : PHALMCAINTERFACELOCK , pub Unlock : PHALMCAINTERFACEUNLOCK , pub ReadRegister : PHALMCAINTERFACEREADREGISTER , } pub type HAL_MCA_INTERFACE = _HAL_MCA_INTERFACE ; pub const HAL_APIC_DESTINATION_MODE_ApicDestinationModePhysical : HAL_APIC_DESTINATION_MODE = 1 ; pub const HAL_APIC_DESTINATION_MODE_ApicDestinationModeLogicalFlat : HAL_APIC_DESTINATION_MODE = 2 ; pub const HAL_APIC_DESTINATION_MODE_ApicDestinationModeLogicalClustered : HAL_APIC_DESTINATION_MODE = 3 ; pub const HAL_APIC_DESTINATION_MODE_ApicDestinationModeUnknown : HAL_APIC_DESTINATION_MODE = 4 ; pub type HAL_APIC_DESTINATION_MODE = i32 ; pub type PHAL_APIC_DESTINATION_MODE = * mut HAL_APIC_DESTINATION_MODE ; pub type PDRIVER_EXCPTN_CALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , BankLog : PMCA_EXCEPTION ) > ; pub type PDRIVER_MCA_EXCEPTION_CALLBACK = PDRIVER_EXCPTN_CALLBACK ; # [ repr ( C ) ] pub struct _MCA_DRIVER_INFO { pub ExceptionCallback : PDRIVER_MCA_EXCEPTION_CALLBACK , pub DpcCallback : PKDEFERRED_ROUTINE , pub DeviceContext : PVOID , } pub type MCA_DRIVER_INFO = _MCA_DRIVER_INFO ; pub type PMCA_DRIVER_INFO = * mut _MCA_DRIVER_INFO ; # [ repr ( C ) ] pub struct _HAL_ERROR_INFO { pub Version : ULONG , pub InitMaxSize : ULONG , pub McaMaxSize : ULONG , pub McaPreviousEventsCount : ULONG , pub McaCorrectedEventsCount : ULONG , pub McaKernelDeliveryFails : ULONG , pub McaDriverDpcQueueFails : ULONG , pub McaReserved : ULONG , pub CmcMaxSize : ULONG , pub CmcPollingInterval : ULONG , pub CmcInterruptsCount : ULONG , pub CmcKernelDeliveryFails : ULONG , pub CmcDriverDpcQueueFails : ULONG , pub CmcGetStateFails : ULONG , pub CmcClearStateFails : ULONG , pub CmcReserved : ULONG , pub CmcLogId : ULONGLONG , pub CpeMaxSize : ULONG , pub CpePollingInterval : ULONG , pub CpeInterruptsCount : ULONG , pub CpeKernelDeliveryFails : ULONG , pub CpeDriverDpcQueueFails : ULONG , pub CpeGetStateFails : ULONG , pub CpeClearStateFails : ULONG , pub CpeInterruptSources : ULONG , pub CpeLogId : ULONGLONG , pub KernelReserved : [ ULONGLONG ; 4usize ] , } pub type HAL_ERROR_INFO = _HAL_ERROR_INFO ; pub type PHAL_ERROR_INFO = * mut _HAL_ERROR_INFO ; pub type PDRIVER_CMC_EXCEPTION_CALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , CmcLog : PCMC_EXCEPTION ) > ; pub type PDRIVER_CPE_EXCEPTION_CALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , CmcLog : PCPE_EXCEPTION ) > ; # [ repr ( C ) ] pub struct _CMC_DRIVER_INFO { pub ExceptionCallback : PDRIVER_CMC_EXCEPTION_CALLBACK , pub DpcCallback : PKDEFERRED_ROUTINE , pub DeviceContext : PVOID , } pub type CMC_DRIVER_INFO = _CMC_DRIVER_INFO ; pub type PCMC_DRIVER_INFO = * mut _CMC_DRIVER_INFO ; # [ repr ( C ) ] pub struct _CPE_DRIVER_INFO { pub ExceptionCallback : PDRIVER_CPE_EXCEPTION_CALLBACK , pub DpcCallback : PKDEFERRED_ROUTINE , pub DeviceContext : PVOID , } pub type CPE_DRIVER_INFO = _CPE_DRIVER_INFO ; pub type PCPE_DRIVER_INFO = * mut _CPE_DRIVER_INFO ; # [ repr ( C ) ] pub struct _HAL_PLATFORM_INFORMATION { pub PlatformFlags : ULONG , } pub type HAL_PLATFORM_INFORMATION = _HAL_PLATFORM_INFORMATION ; pub type PHAL_PLATFORM_INFORMATION = * mut _HAL_PLATFORM_INFORMATION ; extern "C" { pub fn HalGetScatterGatherList ( DmaAdapter : PADAPTER_OBJECT , DeviceObject : PDEVICE_OBJECT , Mdl : PMDL , CurrentVa : PVOID , Length : ULONG , ExecutionRoutine : PDRIVER_LIST_CONTROL , Context : PVOID , WriteToDevice : BOOLEAN ) -> NTSTATUS ; } extern "C" { pub fn HalPutScatterGatherList ( DmaAdapter : PADAPTER_OBJECT , ScatterGather : PSCATTER_GATHER_LIST , WriteToDevice : BOOLEAN ) ; } extern "C" { pub fn HalPutDmaAdapter ( DmaAdapter : PADAPTER_OBJECT ) ; } pub type PWHEA_ERROR_SOURCE_DESCRIPTOR = * mut _WHEA_ERROR_SOURCE_DESCRIPTOR ; pub type PWHEA_ERROR_RECORD = * mut _WHEA_ERROR_RECORD ; extern "C" { pub fn HalBugCheckSystem ( ErrorSource : PWHEA_ERROR_SOURCE_DESCRIPTOR , ErrorRecord : PWHEA_ERROR_RECORD ) ; } pub const _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE_ResourceTypeSingle : _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE = 0 ; pub const _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE_ResourceTypeRange : _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE = 1 ; pub const _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE_ResourceTypeExtendedCounterConfiguration : _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE = 2 ; pub const _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE_ResourceTypeOverflow : _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE = 3 ; pub const _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE_ResourceTypeMax : _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE = 4 ; pub type _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE = i32 ; pub use self :: _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE as PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE ; # [ repr ( C ) ] pub struct _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR { pub Type : PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE , pub Flags : ULONG , pub u : _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR__bindgen_ty_1 { pub CounterIndex : __BindgenUnionField < ULONG > , pub ExtendedRegisterAddress : __BindgenUnionField < ULONG > , pub Range : __BindgenUnionField < _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : [ u32 ; 2usize ] , } # [ repr ( C ) ] pub struct _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 { pub Begin : ULONG , pub End : ULONG , } pub type PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR = _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR ; pub type PPHYSICAL_COUNTER_RESOURCE_DESCRIPTOR = * mut _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR ; # [ repr ( C ) ] pub struct _PHYSICAL_COUNTER_RESOURCE_LIST { pub Count : ULONG , pub Descriptors : [ PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR ; 1usize ] , } pub type PHYSICAL_COUNTER_RESOURCE_LIST = _PHYSICAL_COUNTER_RESOURCE_LIST ; pub type PPHYSICAL_COUNTER_RESOURCE_LIST = * mut _PHYSICAL_COUNTER_RESOURCE_LIST ; extern "C" { pub fn HalAllocateHardwareCounters ( GroupAffinty : PGROUP_AFFINITY , GroupCount : ULONG , ResourceList : PPHYSICAL_COUNTER_RESOURCE_LIST , CounterSetHandle : PHANDLE ) -> NTSTATUS ; } extern "C" { pub fn HalFreeHardwareCounters ( CounterSetHandle : HANDLE ) -> NTSTATUS ; } extern "C" { pub fn FsRtlIsTotalDeviceFailure ( Status : NTSTATUS ) -> BOOLEAN ; } # [ repr ( C ) ] pub struct _PCI_AGP_CAPABILITY { pub Header : PCI_CAPABILITIES_HEADER , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub AGPStatus : _PCI_AGP_CAPABILITY__PCI_AGP_STATUS , pub AGPCommand : _PCI_AGP_CAPABILITY__PCI_AGP_COMMAND , } # [ repr ( C ) ] pub struct _PCI_AGP_CAPABILITY__PCI_AGP_STATUS { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PCI_AGP_CAPABILITY__PCI_AGP_STATUS { # [ inline ] pub fn Rate ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_Rate ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn Agp3Mode ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Agp3Mode ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn FastWrite ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_FastWrite ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn FourGB ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_FourGB ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn HostTransDisable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_HostTransDisable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Gart64 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Gart64 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ITA_Coherent ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ITA_Coherent ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn SideBandAddressing ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_SideBandAddressing ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn CalibrationCycle ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_CalibrationCycle ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 3u8 , val as u64 ) } } # [ inline ] pub fn AsyncRequestSize ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 13usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_AsyncRequestSize ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 13usize , 3u8 , val as u64 ) } } # [ inline ] pub fn Rsvd1 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Rsvd1 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Isoch ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 17usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Isoch ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 17usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Rsvd2 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 18usize , 6u8 ) as u32 ) } } # [ inline ] pub fn set_Rsvd2 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 18usize , 6u8 , val as u64 ) } } # [ inline ] pub fn RequestQueueDepthMaximum ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_RequestQueueDepthMaximum ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Rate : ULONG , Agp3Mode : ULONG , FastWrite : ULONG , FourGB : ULONG , HostTransDisable : ULONG , Gart64 : ULONG , ITA_Coherent : ULONG , SideBandAddressing : ULONG , CalibrationCycle : ULONG , AsyncRequestSize : ULONG , Rsvd1 : ULONG , Isoch : ULONG , Rsvd2 : ULONG , RequestQueueDepthMaximum : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let Rate : u32 = unsafe { :: std :: mem :: transmute ( Rate ) } ; Rate as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let Agp3Mode : u32 = unsafe { :: std :: mem :: transmute ( Agp3Mode ) } ; Agp3Mode as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let FastWrite : u32 = unsafe { :: std :: mem :: transmute ( FastWrite ) } ; FastWrite as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let FourGB : u32 = unsafe { :: std :: mem :: transmute ( FourGB ) } ; FourGB as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let HostTransDisable : u32 = unsafe { :: std :: mem :: transmute ( HostTransDisable ) } ; HostTransDisable as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let Gart64 : u32 = unsafe { :: std :: mem :: transmute ( Gart64 ) } ; Gart64 as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let ITA_Coherent : u32 = unsafe { :: std :: mem :: transmute ( ITA_Coherent ) } ; ITA_Coherent as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let SideBandAddressing : u32 = unsafe { :: std :: mem :: transmute ( SideBandAddressing ) } ; SideBandAddressing as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 3u8 , { let CalibrationCycle : u32 = unsafe { :: std :: mem :: transmute ( CalibrationCycle ) } ; CalibrationCycle as u64 } ) ; __bindgen_bitfield_unit . set ( 13usize , 3u8 , { let AsyncRequestSize : u32 = unsafe { :: std :: mem :: transmute ( AsyncRequestSize ) } ; AsyncRequestSize as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 1u8 , { let Rsvd1 : u32 = unsafe { :: std :: mem :: transmute ( Rsvd1 ) } ; Rsvd1 as u64 } ) ; __bindgen_bitfield_unit . set ( 17usize , 1u8 , { let Isoch : u32 = unsafe { :: std :: mem :: transmute ( Isoch ) } ; Isoch as u64 } ) ; __bindgen_bitfield_unit . set ( 18usize , 6u8 , { let Rsvd2 : u32 = unsafe { :: std :: mem :: transmute ( Rsvd2 ) } ; Rsvd2 as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let RequestQueueDepthMaximum : u32 = unsafe { :: std :: mem :: transmute ( RequestQueueDepthMaximum ) } ; RequestQueueDepthMaximum as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] pub struct _PCI_AGP_CAPABILITY__PCI_AGP_COMMAND { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PCI_AGP_CAPABILITY__PCI_AGP_COMMAND { # [ inline ] pub fn Rate ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_Rate ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn Rsvd1 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Rsvd1 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn FastWriteEnable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_FastWriteEnable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn FourGBEnable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_FourGBEnable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Rsvd2 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Rsvd2 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Gart64 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Gart64 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AGPEnable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AGPEnable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn SBAEnable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_SBAEnable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn CalibrationCycle ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_CalibrationCycle ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 3u8 , val as u64 ) } } # [ inline ] pub fn AsyncReqSize ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 13usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_AsyncReqSize ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 13usize , 3u8 , val as u64 ) } } # [ inline ] pub fn Rsvd3 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_Rsvd3 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 8u8 , val as u64 ) } } # [ inline ] pub fn RequestQueueDepth ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_RequestQueueDepth ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Rate : ULONG , Rsvd1 : ULONG , FastWriteEnable : ULONG , FourGBEnable : ULONG , Rsvd2 : ULONG , Gart64 : ULONG , AGPEnable : ULONG , SBAEnable : ULONG , CalibrationCycle : ULONG , AsyncReqSize : ULONG , Rsvd3 : ULONG , RequestQueueDepth : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let Rate : u32 = unsafe { :: std :: mem :: transmute ( Rate ) } ; Rate as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let Rsvd1 : u32 = unsafe { :: std :: mem :: transmute ( Rsvd1 ) } ; Rsvd1 as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let FastWriteEnable : u32 = unsafe { :: std :: mem :: transmute ( FastWriteEnable ) } ; FastWriteEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let FourGBEnable : u32 = unsafe { :: std :: mem :: transmute ( FourGBEnable ) } ; FourGBEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let Rsvd2 : u32 = unsafe { :: std :: mem :: transmute ( Rsvd2 ) } ; Rsvd2 as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let Gart64 : u32 = unsafe { :: std :: mem :: transmute ( Gart64 ) } ; Gart64 as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let AGPEnable : u32 = unsafe { :: std :: mem :: transmute ( AGPEnable ) } ; AGPEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let SBAEnable : u32 = unsafe { :: std :: mem :: transmute ( SBAEnable ) } ; SBAEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 3u8 , { let CalibrationCycle : u32 = unsafe { :: std :: mem :: transmute ( CalibrationCycle ) } ; CalibrationCycle as u64 } ) ; __bindgen_bitfield_unit . set ( 13usize , 3u8 , { let AsyncReqSize : u32 = unsafe { :: std :: mem :: transmute ( AsyncReqSize ) } ; AsyncReqSize as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 8u8 , { let Rsvd3 : u32 = unsafe { :: std :: mem :: transmute ( Rsvd3 ) } ; Rsvd3 as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let RequestQueueDepth : u32 = unsafe { :: std :: mem :: transmute ( RequestQueueDepth ) } ; RequestQueueDepth as u64 } ) ; __bindgen_bitfield_unit } } impl _PCI_AGP_CAPABILITY { # [ inline ] pub fn Minor ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u16 ) } } # [ inline ] pub fn set_Minor ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn Major ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u16 ) } } # [ inline ] pub fn set_Major ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn Rsvd1 ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u16 ) } } # [ inline ] pub fn set_Rsvd1 ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Minor : USHORT , Major : USHORT , Rsvd1 : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let Minor : u16 = unsafe { :: std :: mem :: transmute ( Minor ) } ; Minor as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let Major : u16 = unsafe { :: std :: mem :: transmute ( Major ) } ; Major as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let Rsvd1 : u16 = unsafe { :: std :: mem :: transmute ( Rsvd1 ) } ; Rsvd1 as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_AGP_CAPABILITY = _PCI_AGP_CAPABILITY ; pub type PPCI_AGP_CAPABILITY = * mut _PCI_AGP_CAPABILITY ; pub const _EXTENDED_AGP_REGISTER_IsochStatus : _EXTENDED_AGP_REGISTER = 0 ; pub const _EXTENDED_AGP_REGISTER_AgpControl : _EXTENDED_AGP_REGISTER = 1 ; pub const _EXTENDED_AGP_REGISTER_ApertureSize : _EXTENDED_AGP_REGISTER = 2 ; pub const _EXTENDED_AGP_REGISTER_AperturePageSize : _EXTENDED_AGP_REGISTER = 3 ; pub const _EXTENDED_AGP_REGISTER_GartLow : _EXTENDED_AGP_REGISTER = 4 ; pub const _EXTENDED_AGP_REGISTER_GartHigh : _EXTENDED_AGP_REGISTER = 5 ; pub const _EXTENDED_AGP_REGISTER_IsochCommand : _EXTENDED_AGP_REGISTER = 6 ; pub type _EXTENDED_AGP_REGISTER = i32 ; pub use self :: _EXTENDED_AGP_REGISTER as EXTENDED_AGP_REGISTER ; pub type PEXTENDED_AGP_REGISTER = * mut _EXTENDED_AGP_REGISTER ; # [ repr ( C ) ] pub struct _PCI_AGP_ISOCH_STATUS { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PCI_AGP_ISOCH_STATUS { # [ inline ] pub fn ErrorCode ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_ErrorCode ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 2u8 , val as u64 ) } } # [ inline ] pub fn Rsvd1 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Rsvd1 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Isoch_L ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_Isoch_L ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 3u8 , val as u64 ) } } # [ inline ] pub fn Isoch_Y ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_Isoch_Y ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 2u8 , val as u64 ) } } # [ inline ] pub fn Isoch_N ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_Isoch_N ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn Rsvd2 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_Rsvd2 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 16u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ErrorCode : ULONG , Rsvd1 : ULONG , Isoch_L : ULONG , Isoch_Y : ULONG , Isoch_N : ULONG , Rsvd2 : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 2u8 , { let ErrorCode : u32 = unsafe { :: std :: mem :: transmute ( ErrorCode ) } ; ErrorCode as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let Rsvd1 : u32 = unsafe { :: std :: mem :: transmute ( Rsvd1 ) } ; Rsvd1 as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 3u8 , { let Isoch_L : u32 = unsafe { :: std :: mem :: transmute ( Isoch_L ) } ; Isoch_L as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 2u8 , { let Isoch_Y : u32 = unsafe { :: std :: mem :: transmute ( Isoch_Y ) } ; Isoch_Y as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let Isoch_N : u32 = unsafe { :: std :: mem :: transmute ( Isoch_N ) } ; Isoch_N as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 16u8 , { let Rsvd2 : u32 = unsafe { :: std :: mem :: transmute ( Rsvd2 ) } ; Rsvd2 as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_AGP_ISOCH_STATUS = _PCI_AGP_ISOCH_STATUS ; pub type PPCI_AGP_ISOCH_STATUS = * mut _PCI_AGP_ISOCH_STATUS ; # [ repr ( C ) ] pub struct _PCI_AGP_CONTROL { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PCI_AGP_CONTROL { # [ inline ] pub fn Rsvd1 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 7u8 ) as u32 ) } } # [ inline ] pub fn set_Rsvd1 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 7u8 , val as u64 ) } } # [ inline ] pub fn GTLB_Enable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_GTLB_Enable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AP_Enable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AP_Enable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn CAL_Disable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_CAL_Disable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Rsvd2 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 22u8 ) as u32 ) } } # [ inline ] pub fn set_Rsvd2 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 22u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Rsvd1 : ULONG , GTLB_Enable : ULONG , AP_Enable : ULONG , CAL_Disable : ULONG , Rsvd2 : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 7u8 , { let Rsvd1 : u32 = unsafe { :: std :: mem :: transmute ( Rsvd1 ) } ; Rsvd1 as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let GTLB_Enable : u32 = unsafe { :: std :: mem :: transmute ( GTLB_Enable ) } ; GTLB_Enable as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let AP_Enable : u32 = unsafe { :: std :: mem :: transmute ( AP_Enable ) } ; AP_Enable as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let CAL_Disable : u32 = unsafe { :: std :: mem :: transmute ( CAL_Disable ) } ; CAL_Disable as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 22u8 , { let Rsvd2 : u32 = unsafe { :: std :: mem :: transmute ( Rsvd2 ) } ; Rsvd2 as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_AGP_CONTROL = _PCI_AGP_CONTROL ; pub type PPCI_AGP_CONTROL = * mut _PCI_AGP_CONTROL ; # [ repr ( C ) ] pub struct _PCI_AGP_APERTURE_PAGE_SIZE { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl _PCI_AGP_APERTURE_PAGE_SIZE { # [ inline ] pub fn PageSizeMask ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 11u8 ) as u16 ) } } # [ inline ] pub fn set_PageSizeMask ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 11u8 , val as u64 ) } } # [ inline ] pub fn Rsvd1 ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_Rsvd1 ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PageSizeSelect ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 4u8 ) as u16 ) } } # [ inline ] pub fn set_PageSizeSelect ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( PageSizeMask : USHORT , Rsvd1 : USHORT , PageSizeSelect : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 11u8 , { let PageSizeMask : u16 = unsafe { :: std :: mem :: transmute ( PageSizeMask ) } ; PageSizeMask as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 1u8 , { let Rsvd1 : u16 = unsafe { :: std :: mem :: transmute ( Rsvd1 ) } ; Rsvd1 as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 4u8 , { let PageSizeSelect : u16 = unsafe { :: std :: mem :: transmute ( PageSizeSelect ) } ; PageSizeSelect as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_AGP_APERTURE_PAGE_SIZE = _PCI_AGP_APERTURE_PAGE_SIZE ; pub type PPCI_AGP_APERTURE_PAGE_SIZE = * mut _PCI_AGP_APERTURE_PAGE_SIZE ; # [ repr ( C ) ] pub struct _PCI_AGP_ISOCH_COMMAND { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl _PCI_AGP_ISOCH_COMMAND { # [ inline ] pub fn Rsvd1 ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 6u8 ) as u16 ) } } # [ inline ] pub fn set_Rsvd1 ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 6u8 , val as u64 ) } } # [ inline ] pub fn Isoch_Y ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 2u8 ) as u16 ) } } # [ inline ] pub fn set_Isoch_Y ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 2u8 , val as u64 ) } } # [ inline ] pub fn Isoch_N ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u16 ) } } # [ inline ] pub fn set_Isoch_N ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Rsvd1 : USHORT , Isoch_Y : USHORT , Isoch_N : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 6u8 , { let Rsvd1 : u16 = unsafe { :: std :: mem :: transmute ( Rsvd1 ) } ; Rsvd1 as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 2u8 , { let Isoch_Y : u16 = unsafe { :: std :: mem :: transmute ( Isoch_Y ) } ; Isoch_Y as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let Isoch_N : u16 = unsafe { :: std :: mem :: transmute ( Isoch_N ) } ; Isoch_N as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_AGP_ISOCH_COMMAND = _PCI_AGP_ISOCH_COMMAND ; pub type PPCI_AGP_ISOCH_COMMAND = * mut _PCI_AGP_ISOCH_COMMAND ; # [ repr ( C ) ] pub struct PCI_AGP_EXTENDED_CAPABILITY { pub IsochStatus : PCI_AGP_ISOCH_STATUS , pub AgpControl : PCI_AGP_CONTROL , pub ApertureSize : USHORT , pub AperturePageSize : PCI_AGP_APERTURE_PAGE_SIZE , pub GartLow : ULONG , pub GartHigh : ULONG , pub IsochCommand : PCI_AGP_ISOCH_COMMAND , } pub type PPCI_AGP_EXTENDED_CAPABILITY = * mut PCI_AGP_EXTENDED_CAPABILITY ; # [ repr ( C ) ] pub struct _PCIX_BRIDGE_CAPABILITY { pub Header : PCI_CAPABILITIES_HEADER , pub SecondaryStatus : _PCIX_BRIDGE_CAPABILITY__bindgen_ty_1 , pub BridgeStatus : _PCIX_BRIDGE_CAPABILITY__bindgen_ty_2 , pub UpstreamSplitTransactionCapacity : USHORT , pub UpstreamSplitTransactionLimit : USHORT , pub DownstreamSplitTransactionCapacity : USHORT , pub DownstreamSplitTransactionLimit : USHORT , pub EccControlStatus : _PCIX_BRIDGE_CAPABILITY__bindgen_ty_3 , pub EccFirstAddress : ULONG , pub EccSecondAddress : ULONG , pub EccAttribute : ULONG , } # [ repr ( C ) ] pub struct _PCIX_BRIDGE_CAPABILITY__bindgen_ty_1 { pub __bindgen_anon_1 : __BindgenUnionField < _PCIX_BRIDGE_CAPABILITY__bindgen_ty_1__bindgen_ty_1 > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : u16 , } # [ repr ( C ) ] pub struct _PCIX_BRIDGE_CAPABILITY__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl _PCIX_BRIDGE_CAPABILITY__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn Bus64Bit ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_Bus64Bit ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Bus133MHzCapable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_Bus133MHzCapable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn SplitCompletionDiscarded ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_SplitCompletionDiscarded ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UnexpectedSplitCompletion ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_UnexpectedSplitCompletion ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn SplitCompletionOverrun ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_SplitCompletionOverrun ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn SplitRequestDelayed ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_SplitRequestDelayed ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn BusModeFrequency ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 4u8 ) as u16 ) } } # [ inline ] pub fn set_BusModeFrequency ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 4u8 , val as u64 ) } } # [ inline ] pub fn Rsvd ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 2u8 ) as u16 ) } } # [ inline ] pub fn set_Rsvd ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 2u8 , val as u64 ) } } # [ inline ] pub fn Version ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 2u8 ) as u16 ) } } # [ inline ] pub fn set_Version ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 2u8 , val as u64 ) } } # [ inline ] pub fn Bus266MHzCapable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_Bus266MHzCapable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Bus533MHzCapable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 15usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_Bus533MHzCapable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 15usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Bus64Bit : USHORT , Bus133MHzCapable : USHORT , SplitCompletionDiscarded : USHORT , UnexpectedSplitCompletion : USHORT , SplitCompletionOverrun : USHORT , SplitRequestDelayed : USHORT , BusModeFrequency : USHORT , Rsvd : USHORT , Version : USHORT , Bus266MHzCapable : USHORT , Bus533MHzCapable : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let Bus64Bit : u16 = unsafe { :: std :: mem :: transmute ( Bus64Bit ) } ; Bus64Bit as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let Bus133MHzCapable : u16 = unsafe { :: std :: mem :: transmute ( Bus133MHzCapable ) } ; Bus133MHzCapable as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let SplitCompletionDiscarded : u16 = unsafe { :: std :: mem :: transmute ( SplitCompletionDiscarded ) } ; SplitCompletionDiscarded as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let UnexpectedSplitCompletion : u16 = unsafe { :: std :: mem :: transmute ( UnexpectedSplitCompletion ) } ; UnexpectedSplitCompletion as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let SplitCompletionOverrun : u16 = unsafe { :: std :: mem :: transmute ( SplitCompletionOverrun ) } ; SplitCompletionOverrun as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let SplitRequestDelayed : u16 = unsafe { :: std :: mem :: transmute ( SplitRequestDelayed ) } ; SplitRequestDelayed as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 4u8 , { let BusModeFrequency : u16 = unsafe { :: std :: mem :: transmute ( BusModeFrequency ) } ; BusModeFrequency as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 2u8 , { let Rsvd : u16 = unsafe { :: std :: mem :: transmute ( Rsvd ) } ; Rsvd as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 2u8 , { let Version : u16 = unsafe { :: std :: mem :: transmute ( Version ) } ; Version as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 1u8 , { let Bus266MHzCapable : u16 = unsafe { :: std :: mem :: transmute ( Bus266MHzCapable ) } ; Bus266MHzCapable as u64 } ) ; __bindgen_bitfield_unit . set ( 15usize , 1u8 , { let Bus533MHzCapable : u16 = unsafe { :: std :: mem :: transmute ( Bus533MHzCapable ) } ; Bus533MHzCapable as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] pub struct _PCIX_BRIDGE_CAPABILITY__bindgen_ty_2 { pub __bindgen_anon_1 : __BindgenUnionField < _PCIX_BRIDGE_CAPABILITY__bindgen_ty_2__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PCIX_BRIDGE_CAPABILITY__bindgen_ty_2__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PCIX_BRIDGE_CAPABILITY__bindgen_ty_2__bindgen_ty_1 { # [ inline ] pub fn FunctionNumber ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_FunctionNumber ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn DeviceNumber ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_DeviceNumber ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 5u8 , val as u64 ) } } # [ inline ] pub fn BusNumber ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_BusNumber ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn Device64Bit ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Device64Bit ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Device133MHzCapable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 17usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Device133MHzCapable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 17usize , 1u8 , val as u64 ) } } # [ inline ] pub fn SplitCompletionDiscarded ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 18usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_SplitCompletionDiscarded ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 18usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UnexpectedSplitCompletion ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 19usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_UnexpectedSplitCompletion ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 19usize , 1u8 , val as u64 ) } } # [ inline ] pub fn SplitCompletionOverrun ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 20usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_SplitCompletionOverrun ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 20usize , 1u8 , val as u64 ) } } # [ inline ] pub fn SplitRequestDelayed ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 21usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_SplitRequestDelayed ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 21usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Rsvd ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 22usize , 7u8 ) as u32 ) } } # [ inline ] pub fn set_Rsvd ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 22usize , 7u8 , val as u64 ) } } # [ inline ] pub fn DIMCapable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 29usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_DIMCapable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 29usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Device266MHzCapable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 30usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Device266MHzCapable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 30usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Device533MHzCapable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 31usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Device533MHzCapable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 31usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( FunctionNumber : ULONG , DeviceNumber : ULONG , BusNumber : ULONG , Device64Bit : ULONG , Device133MHzCapable : ULONG , SplitCompletionDiscarded : ULONG , UnexpectedSplitCompletion : ULONG , SplitCompletionOverrun : ULONG , SplitRequestDelayed : ULONG , Rsvd : ULONG , DIMCapable : ULONG , Device266MHzCapable : ULONG , Device533MHzCapable : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let FunctionNumber : u32 = unsafe { :: std :: mem :: transmute ( FunctionNumber ) } ; FunctionNumber as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 5u8 , { let DeviceNumber : u32 = unsafe { :: std :: mem :: transmute ( DeviceNumber ) } ; DeviceNumber as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let BusNumber : u32 = unsafe { :: std :: mem :: transmute ( BusNumber ) } ; BusNumber as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 1u8 , { let Device64Bit : u32 = unsafe { :: std :: mem :: transmute ( Device64Bit ) } ; Device64Bit as u64 } ) ; __bindgen_bitfield_unit . set ( 17usize , 1u8 , { let Device133MHzCapable : u32 = unsafe { :: std :: mem :: transmute ( Device133MHzCapable ) } ; Device133MHzCapable as u64 } ) ; __bindgen_bitfield_unit . set ( 18usize , 1u8 , { let SplitCompletionDiscarded : u32 = unsafe { :: std :: mem :: transmute ( SplitCompletionDiscarded ) } ; SplitCompletionDiscarded as u64 } ) ; __bindgen_bitfield_unit . set ( 19usize , 1u8 , { let UnexpectedSplitCompletion : u32 = unsafe { :: std :: mem :: transmute ( UnexpectedSplitCompletion ) } ; UnexpectedSplitCompletion as u64 } ) ; __bindgen_bitfield_unit . set ( 20usize , 1u8 , { let SplitCompletionOverrun : u32 = unsafe { :: std :: mem :: transmute ( SplitCompletionOverrun ) } ; SplitCompletionOverrun as u64 } ) ; __bindgen_bitfield_unit . set ( 21usize , 1u8 , { let SplitRequestDelayed : u32 = unsafe { :: std :: mem :: transmute ( SplitRequestDelayed ) } ; SplitRequestDelayed as u64 } ) ; __bindgen_bitfield_unit . set ( 22usize , 7u8 , { let Rsvd : u32 = unsafe { :: std :: mem :: transmute ( Rsvd ) } ; Rsvd as u64 } ) ; __bindgen_bitfield_unit . set ( 29usize , 1u8 , { let DIMCapable : u32 = unsafe { :: std :: mem :: transmute ( DIMCapable ) } ; DIMCapable as u64 } ) ; __bindgen_bitfield_unit . set ( 30usize , 1u8 , { let Device266MHzCapable : u32 = unsafe { :: std :: mem :: transmute ( Device266MHzCapable ) } ; Device266MHzCapable as u64 } ) ; __bindgen_bitfield_unit . set ( 31usize , 1u8 , { let Device533MHzCapable : u32 = unsafe { :: std :: mem :: transmute ( Device533MHzCapable ) } ; Device533MHzCapable as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] pub struct _PCIX_BRIDGE_CAPABILITY__bindgen_ty_3 { pub __bindgen_anon_1 : __BindgenUnionField < _PCIX_BRIDGE_CAPABILITY__bindgen_ty_3__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PCIX_BRIDGE_CAPABILITY__bindgen_ty_3__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PCIX_BRIDGE_CAPABILITY__bindgen_ty_3__bindgen_ty_1 { # [ inline ] pub fn SelectSecondaryRegisters ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_SelectSecondaryRegisters ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ErrorPresentInOtherBank ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ErrorPresentInOtherBank ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AdditionalCorrectableError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AdditionalCorrectableError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AdditionalUncorrectableError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AdditionalUncorrectableError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ErrorPhase ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_ErrorPhase ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 3u8 , val as u64 ) } } # [ inline ] pub fn ErrorCorrected ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ErrorCorrected ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Syndrome ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_Syndrome ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn ErrorFirstCommand ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_ErrorFirstCommand ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 4u8 , val as u64 ) } } # [ inline ] pub fn ErrorSecondCommand ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 20usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_ErrorSecondCommand ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 20usize , 4u8 , val as u64 ) } } # [ inline ] pub fn ErrorUpperAttributes ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_ErrorUpperAttributes ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 4u8 , val as u64 ) } } # [ inline ] pub fn ControlUpdateEnable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 28usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ControlUpdateEnable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 28usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Rsvd ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 29usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Rsvd ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 29usize , 1u8 , val as u64 ) } } # [ inline ] pub fn DisableSingleBitCorrection ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 30usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_DisableSingleBitCorrection ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 30usize , 1u8 , val as u64 ) } } # [ inline ] pub fn EccMode ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 31usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_EccMode ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 31usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( SelectSecondaryRegisters : ULONG , ErrorPresentInOtherBank : ULONG , AdditionalCorrectableError : ULONG , AdditionalUncorrectableError : ULONG , ErrorPhase : ULONG , ErrorCorrected : ULONG , Syndrome : ULONG , ErrorFirstCommand : ULONG , ErrorSecondCommand : ULONG , ErrorUpperAttributes : ULONG , ControlUpdateEnable : ULONG , Rsvd : ULONG , DisableSingleBitCorrection : ULONG , EccMode : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let SelectSecondaryRegisters : u32 = unsafe { :: std :: mem :: transmute ( SelectSecondaryRegisters ) } ; SelectSecondaryRegisters as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let ErrorPresentInOtherBank : u32 = unsafe { :: std :: mem :: transmute ( ErrorPresentInOtherBank ) } ; ErrorPresentInOtherBank as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let AdditionalCorrectableError : u32 = unsafe { :: std :: mem :: transmute ( AdditionalCorrectableError ) } ; AdditionalCorrectableError as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let AdditionalUncorrectableError : u32 = unsafe { :: std :: mem :: transmute ( AdditionalUncorrectableError ) } ; AdditionalUncorrectableError as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 3u8 , { let ErrorPhase : u32 = unsafe { :: std :: mem :: transmute ( ErrorPhase ) } ; ErrorPhase as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let ErrorCorrected : u32 = unsafe { :: std :: mem :: transmute ( ErrorCorrected ) } ; ErrorCorrected as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let Syndrome : u32 = unsafe { :: std :: mem :: transmute ( Syndrome ) } ; Syndrome as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 4u8 , { let ErrorFirstCommand : u32 = unsafe { :: std :: mem :: transmute ( ErrorFirstCommand ) } ; ErrorFirstCommand as u64 } ) ; __bindgen_bitfield_unit . set ( 20usize , 4u8 , { let ErrorSecondCommand : u32 = unsafe { :: std :: mem :: transmute ( ErrorSecondCommand ) } ; ErrorSecondCommand as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 4u8 , { let ErrorUpperAttributes : u32 = unsafe { :: std :: mem :: transmute ( ErrorUpperAttributes ) } ; ErrorUpperAttributes as u64 } ) ; __bindgen_bitfield_unit . set ( 28usize , 1u8 , { let ControlUpdateEnable : u32 = unsafe { :: std :: mem :: transmute ( ControlUpdateEnable ) } ; ControlUpdateEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 29usize , 1u8 , { let Rsvd : u32 = unsafe { :: std :: mem :: transmute ( Rsvd ) } ; Rsvd as u64 } ) ; __bindgen_bitfield_unit . set ( 30usize , 1u8 , { let DisableSingleBitCorrection : u32 = unsafe { :: std :: mem :: transmute ( DisableSingleBitCorrection ) } ; DisableSingleBitCorrection as u64 } ) ; __bindgen_bitfield_unit . set ( 31usize , 1u8 , { let EccMode : u32 = unsafe { :: std :: mem :: transmute ( EccMode ) } ; EccMode as u64 } ) ; __bindgen_bitfield_unit } } pub type PCIX_BRIDGE_CAPABILITY = _PCIX_BRIDGE_CAPABILITY ; pub type PPCIX_BRIDGE_CAPABILITY = * mut _PCIX_BRIDGE_CAPABILITY ; # [ repr ( C ) ] pub struct _PCI_SUBSYSTEM_IDS_CAPABILITY { pub Header : PCI_CAPABILITIES_HEADER , pub Reserved : USHORT , pub SubVendorID : USHORT , pub SubSystemID : USHORT , } pub type PCI_SUBSYSTEM_IDS_CAPABILITY = _PCI_SUBSYSTEM_IDS_CAPABILITY ; pub type PPCI_SUBSYSTEM_IDS_CAPABILITY = * mut _PCI_SUBSYSTEM_IDS_CAPABILITY ; # [ repr ( C ) ] pub struct _PCI_ADVANCED_FEATURES_CAPABILITY { pub Header : PCI_CAPABILITIES_HEADER , pub Length : UCHAR , pub Capabilities : _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_1 , pub Control : _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_2 , pub Status : _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_3 , } # [ repr ( C ) ] pub struct _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_1 { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_1__bindgen_ty_1 > , pub AsUCHAR : __BindgenUnionField < UCHAR > , pub bindgen_union_field : u8 , } # [ repr ( C , packed ) ] pub struct _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn FunctionLevelResetSupported ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_FunctionLevelResetSupported ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn TransactionsPendingSupported ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_TransactionsPendingSupported ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Rsvd ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_Rsvd ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 6u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( FunctionLevelResetSupported : UCHAR , TransactionsPendingSupported : UCHAR , Rsvd : UCHAR ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let FunctionLevelResetSupported : u8 = unsafe { :: std :: mem :: transmute ( FunctionLevelResetSupported ) } ; FunctionLevelResetSupported as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let TransactionsPendingSupported : u8 = unsafe { :: std :: mem :: transmute ( TransactionsPendingSupported ) } ; TransactionsPendingSupported as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 6u8 , { let Rsvd : u8 = unsafe { :: std :: mem :: transmute ( Rsvd ) } ; Rsvd as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] pub struct _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_2 { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_2__bindgen_ty_1 > , pub AsUCHAR : __BindgenUnionField < UCHAR > , pub bindgen_union_field : u8 , } # [ repr ( C , packed ) ] pub struct _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_2__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_2__bindgen_ty_1 { # [ inline ] pub fn InitiateFunctionLevelReset ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_InitiateFunctionLevelReset ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Rsvd ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_Rsvd ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( InitiateFunctionLevelReset : UCHAR , Rsvd : UCHAR ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let InitiateFunctionLevelReset : u8 = unsafe { :: std :: mem :: transmute ( InitiateFunctionLevelReset ) } ; InitiateFunctionLevelReset as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 7u8 , { let Rsvd : u8 = unsafe { :: std :: mem :: transmute ( Rsvd ) } ; Rsvd as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] pub struct _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_3 { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_3__bindgen_ty_1 > , pub AsUCHAR : __BindgenUnionField < UCHAR > , pub bindgen_union_field : u8 , } # [ repr ( C , packed ) ] pub struct _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_3__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_3__bindgen_ty_1 { # [ inline ] pub fn TransactionsPending ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_TransactionsPending ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Rsvd ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_Rsvd ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( TransactionsPending : UCHAR , Rsvd : UCHAR ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let TransactionsPending : u8 = unsafe { :: std :: mem :: transmute ( TransactionsPending ) } ; TransactionsPending as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 7u8 , { let Rsvd : u8 = unsafe { :: std :: mem :: transmute ( Rsvd ) } ; Rsvd as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_ADVANCED_FEATURES_CAPABILITY = _PCI_ADVANCED_FEATURES_CAPABILITY ; pub type PPCI_ADVANCED_FEATURES_CAPABILITY = * mut _PCI_ADVANCED_FEATURES_CAPABILITY ; # [ repr ( C ) ] pub struct _PCI_ROOT_BUS_OSC_SUPPORT_FIELD { pub u : _PCI_ROOT_BUS_OSC_SUPPORT_FIELD__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _PCI_ROOT_BUS_OSC_SUPPORT_FIELD__bindgen_ty_1 { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_ROOT_BUS_OSC_SUPPORT_FIELD__bindgen_ty_1__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PCI_ROOT_BUS_OSC_SUPPORT_FIELD__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PCI_ROOT_BUS_OSC_SUPPORT_FIELD__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn ExtendedConfigOpRegions ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ExtendedConfigOpRegions ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ActiveStatePowerManagement ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ActiveStatePowerManagement ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ClockPowerManagement ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ClockPowerManagement ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn SegmentGroups ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_SegmentGroups ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MessageSignaledInterrupts ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_MessageSignaledInterrupts ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn OptimizedBufferFlushAndFill ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_OptimizedBufferFlushAndFill ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AspmOptionality ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AspmOptionality ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 25u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 25u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ExtendedConfigOpRegions : ULONG , ActiveStatePowerManagement : ULONG , ClockPowerManagement : ULONG , SegmentGroups : ULONG , MessageSignaledInterrupts : ULONG , OptimizedBufferFlushAndFill : ULONG , AspmOptionality : ULONG , Reserved : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let ExtendedConfigOpRegions : u32 = unsafe { :: std :: mem :: transmute ( ExtendedConfigOpRegions ) } ; ExtendedConfigOpRegions as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let ActiveStatePowerManagement : u32 = unsafe { :: std :: mem :: transmute ( ActiveStatePowerManagement ) } ; ActiveStatePowerManagement as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let ClockPowerManagement : u32 = unsafe { :: std :: mem :: transmute ( ClockPowerManagement ) } ; ClockPowerManagement as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let SegmentGroups : u32 = unsafe { :: std :: mem :: transmute ( SegmentGroups ) } ; SegmentGroups as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let MessageSignaledInterrupts : u32 = unsafe { :: std :: mem :: transmute ( MessageSignaledInterrupts ) } ; MessageSignaledInterrupts as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let OptimizedBufferFlushAndFill : u32 = unsafe { :: std :: mem :: transmute ( OptimizedBufferFlushAndFill ) } ; OptimizedBufferFlushAndFill as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let AspmOptionality : u32 = unsafe { :: std :: mem :: transmute ( AspmOptionality ) } ; AspmOptionality as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 25u8 , { let Reserved : u32 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_ROOT_BUS_OSC_SUPPORT_FIELD = _PCI_ROOT_BUS_OSC_SUPPORT_FIELD ; pub type PPCI_ROOT_BUS_OSC_SUPPORT_FIELD = * mut _PCI_ROOT_BUS_OSC_SUPPORT_FIELD ; # [ repr ( C ) ] pub struct _PCI_ROOT_BUS_OSC_CONTROL_FIELD { pub u : _PCI_ROOT_BUS_OSC_CONTROL_FIELD__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _PCI_ROOT_BUS_OSC_CONTROL_FIELD__bindgen_ty_1 { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_ROOT_BUS_OSC_CONTROL_FIELD__bindgen_ty_1__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PCI_ROOT_BUS_OSC_CONTROL_FIELD__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PCI_ROOT_BUS_OSC_CONTROL_FIELD__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn ExpressNativeHotPlug ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ExpressNativeHotPlug ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ShpcNativeHotPlug ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ShpcNativeHotPlug ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ExpressNativePME ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ExpressNativePME ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ExpressAdvancedErrorReporting ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ExpressAdvancedErrorReporting ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ExpressCapabilityStructure ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ExpressCapabilityStructure ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn LatencyToleranceReporting ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_LatencyToleranceReporting ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 26u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 26u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ExpressNativeHotPlug : ULONG , ShpcNativeHotPlug : ULONG , ExpressNativePME : ULONG , ExpressAdvancedErrorReporting : ULONG , ExpressCapabilityStructure : ULONG , LatencyToleranceReporting : ULONG , Reserved : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let ExpressNativeHotPlug : u32 = unsafe { :: std :: mem :: transmute ( ExpressNativeHotPlug ) } ; ExpressNativeHotPlug as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let ShpcNativeHotPlug : u32 = unsafe { :: std :: mem :: transmute ( ShpcNativeHotPlug ) } ; ShpcNativeHotPlug as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let ExpressNativePME : u32 = unsafe { :: std :: mem :: transmute ( ExpressNativePME ) } ; ExpressNativePME as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let ExpressAdvancedErrorReporting : u32 = unsafe { :: std :: mem :: transmute ( ExpressAdvancedErrorReporting ) } ; ExpressAdvancedErrorReporting as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let ExpressCapabilityStructure : u32 = unsafe { :: std :: mem :: transmute ( ExpressCapabilityStructure ) } ; ExpressCapabilityStructure as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let LatencyToleranceReporting : u32 = unsafe { :: std :: mem :: transmute ( LatencyToleranceReporting ) } ; LatencyToleranceReporting as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 26u8 , { let Reserved : u32 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_ROOT_BUS_OSC_CONTROL_FIELD = _PCI_ROOT_BUS_OSC_CONTROL_FIELD ; pub type PPCI_ROOT_BUS_OSC_CONTROL_FIELD = * mut _PCI_ROOT_BUS_OSC_CONTROL_FIELD ; # [ repr ( C ) ] pub struct _PCI_FIRMWARE_BUS_CAPS { pub Type : USHORT , pub Length : USHORT , pub __bindgen_anon_1 : _PCI_FIRMWARE_BUS_CAPS__bindgen_ty_1 , pub CurrentSpeedAndMode : UCHAR , pub SupportedSpeedsAndModesLowByte : UCHAR , pub SupportedSpeedsAndModesHighByte : UCHAR , pub Voltage : UCHAR , pub Reserved2 : [ UCHAR ; 7usize ] , } # [ repr ( C , packed ) ] pub struct _PCI_FIRMWARE_BUS_CAPS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl _PCI_FIRMWARE_BUS_CAPS__bindgen_ty_1 { # [ inline ] pub fn SixtyFourBitDevice ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_SixtyFourBitDevice ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PciXMode1EccCapable ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_PciXMode1EccCapable ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn DeviceIdMessagingCapable ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_DeviceIdMessagingCapable ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ObffWakeSignalCapable ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_ObffWakeSignalCapable ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved1 ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_Reserved1 ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( SixtyFourBitDevice : UCHAR , PciXMode1EccCapable : UCHAR , DeviceIdMessagingCapable : UCHAR , ObffWakeSignalCapable : UCHAR , Reserved1 : UCHAR ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let SixtyFourBitDevice : u8 = unsafe { :: std :: mem :: transmute ( SixtyFourBitDevice ) } ; SixtyFourBitDevice as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let PciXMode1EccCapable : u8 = unsafe { :: std :: mem :: transmute ( PciXMode1EccCapable ) } ; PciXMode1EccCapable as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let DeviceIdMessagingCapable : u8 = unsafe { :: std :: mem :: transmute ( DeviceIdMessagingCapable ) } ; DeviceIdMessagingCapable as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let ObffWakeSignalCapable : u8 = unsafe { :: std :: mem :: transmute ( ObffWakeSignalCapable ) } ; ObffWakeSignalCapable as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let Reserved1 : u8 = unsafe { :: std :: mem :: transmute ( Reserved1 ) } ; Reserved1 as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_FIRMWARE_BUS_CAPS = _PCI_FIRMWARE_BUS_CAPS ; pub type PPCI_FIRMWARE_BUS_CAPS = * mut _PCI_FIRMWARE_BUS_CAPS ; # [ repr ( C ) ] pub struct _PCI_FIRMWARE_BUS_CAPS_RETURN_BUFFER { pub Version : USHORT , pub Status : USHORT , pub Length : ULONG , pub Caps : PCI_FIRMWARE_BUS_CAPS , } pub type PCI_FIRMWARE_BUS_CAPS_RETURN_BUFFER = _PCI_FIRMWARE_BUS_CAPS_RETURN_BUFFER ; pub type PPCI_FIRMWARE_BUS_CAPS_RETURN_BUFFER = * mut _PCI_FIRMWARE_BUS_CAPS_RETURN_BUFFER ; pub const _PCI_HARDWARE_INTERFACE_PciConventional : _PCI_HARDWARE_INTERFACE = 0 ; pub const _PCI_HARDWARE_INTERFACE_PciXMode1 : _PCI_HARDWARE_INTERFACE = 1 ; pub const _PCI_HARDWARE_INTERFACE_PciXMode2 : _PCI_HARDWARE_INTERFACE = 2 ; pub const _PCI_HARDWARE_INTERFACE_PciExpress : _PCI_HARDWARE_INTERFACE = 3 ; pub type _PCI_HARDWARE_INTERFACE = i32 ; pub use self :: _PCI_HARDWARE_INTERFACE as PCI_HARDWARE_INTERFACE ; pub type PPCI_HARDWARE_INTERFACE = * mut _PCI_HARDWARE_INTERFACE ; pub const PCI_BUS_WIDTH_BusWidth32Bits : PCI_BUS_WIDTH = 0 ; pub const PCI_BUS_WIDTH_BusWidth64Bits : PCI_BUS_WIDTH = 1 ; pub type PCI_BUS_WIDTH = i32 ; # [ repr ( C ) ] pub struct _PCI_ROOT_BUS_HARDWARE_CAPABILITY { pub SecondaryInterface : PCI_HARDWARE_INTERFACE , pub __bindgen_anon_1 : _PCI_ROOT_BUS_HARDWARE_CAPABILITY__bindgen_ty_1 , pub OscFeatureSupport : PCI_ROOT_BUS_OSC_SUPPORT_FIELD , pub OscControlRequest : PCI_ROOT_BUS_OSC_CONTROL_FIELD , pub OscControlGranted : PCI_ROOT_BUS_OSC_CONTROL_FIELD , } # [ repr ( C ) ] pub struct _PCI_ROOT_BUS_HARDWARE_CAPABILITY__bindgen_ty_1 { pub BusCapabilitiesFound : BOOLEAN , pub CurrentSpeedAndMode : ULONG , pub SupportedSpeedsAndModes : ULONG , pub DeviceIDMessagingCapable : BOOLEAN , pub SecondaryBusWidth : PCI_BUS_WIDTH , } pub type PCI_ROOT_BUS_HARDWARE_CAPABILITY = _PCI_ROOT_BUS_HARDWARE_CAPABILITY ; pub type PPCI_ROOT_BUS_HARDWARE_CAPABILITY = * mut _PCI_ROOT_BUS_HARDWARE_CAPABILITY ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_CAPABILITIES_REGISTER { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_CAPABILITIES_REGISTER__bindgen_ty_1 > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : u16 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_CAPABILITIES_REGISTER__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl _PCI_EXPRESS_CAPABILITIES_REGISTER__bindgen_ty_1 { # [ inline ] pub fn CapabilityVersion ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u16 ) } } # [ inline ] pub fn set_CapabilityVersion ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn DeviceType ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u16 ) } } # [ inline ] pub fn set_DeviceType ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn SlotImplemented ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_SlotImplemented ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn InterruptMessageNumber ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 5u8 ) as u16 ) } } # [ inline ] pub fn set_InterruptMessageNumber ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 5u8 , val as u64 ) } } # [ inline ] pub fn Rsvd ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 2u8 ) as u16 ) } } # [ inline ] pub fn set_Rsvd ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 2u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( CapabilityVersion : USHORT , DeviceType : USHORT , SlotImplemented : USHORT , InterruptMessageNumber : USHORT , Rsvd : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let CapabilityVersion : u16 = unsafe { :: std :: mem :: transmute ( CapabilityVersion ) } ; CapabilityVersion as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let DeviceType : u16 = unsafe { :: std :: mem :: transmute ( DeviceType ) } ; DeviceType as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let SlotImplemented : u16 = unsafe { :: std :: mem :: transmute ( SlotImplemented ) } ; SlotImplemented as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 5u8 , { let InterruptMessageNumber : u16 = unsafe { :: std :: mem :: transmute ( InterruptMessageNumber ) } ; InterruptMessageNumber as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 2u8 , { let Rsvd : u16 = unsafe { :: std :: mem :: transmute ( Rsvd ) } ; Rsvd as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_CAPABILITIES_REGISTER = _PCI_EXPRESS_CAPABILITIES_REGISTER ; pub type PPCI_EXPRESS_CAPABILITIES_REGISTER = * mut _PCI_EXPRESS_CAPABILITIES_REGISTER ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER__bindgen_ty_1 { # [ inline ] pub fn MaxPayloadSizeSupported ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_MaxPayloadSizeSupported ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn PhantomFunctionsSupported ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_PhantomFunctionsSupported ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 2u8 , val as u64 ) } } # [ inline ] pub fn ExtendedTagSupported ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ExtendedTagSupported ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn L0sAcceptableLatency ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_L0sAcceptableLatency ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 3u8 , val as u64 ) } } # [ inline ] pub fn L1AcceptableLatency ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_L1AcceptableLatency ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 3u8 , val as u64 ) } } # [ inline ] pub fn Undefined ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_Undefined ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 3u8 , val as u64 ) } } # [ inline ] pub fn RoleBasedErrorReporting ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 15usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_RoleBasedErrorReporting ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 15usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Rsvd1 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_Rsvd1 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 2u8 , val as u64 ) } } # [ inline ] pub fn CapturedSlotPowerLimit ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 18usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_CapturedSlotPowerLimit ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 18usize , 8u8 , val as u64 ) } } # [ inline ] pub fn CapturedSlotPowerLimitScale ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 26usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_CapturedSlotPowerLimitScale ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 26usize , 2u8 , val as u64 ) } } # [ inline ] pub fn FunctionLevelResetCapability ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 28usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_FunctionLevelResetCapability ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 28usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Rsvd2 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 29usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_Rsvd2 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 29usize , 3u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( MaxPayloadSizeSupported : ULONG , PhantomFunctionsSupported : ULONG , ExtendedTagSupported : ULONG , L0sAcceptableLatency : ULONG , L1AcceptableLatency : ULONG , Undefined : ULONG , RoleBasedErrorReporting : ULONG , Rsvd1 : ULONG , CapturedSlotPowerLimit : ULONG , CapturedSlotPowerLimitScale : ULONG , FunctionLevelResetCapability : ULONG , Rsvd2 : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let MaxPayloadSizeSupported : u32 = unsafe { :: std :: mem :: transmute ( MaxPayloadSizeSupported ) } ; MaxPayloadSizeSupported as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 2u8 , { let PhantomFunctionsSupported : u32 = unsafe { :: std :: mem :: transmute ( PhantomFunctionsSupported ) } ; PhantomFunctionsSupported as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let ExtendedTagSupported : u32 = unsafe { :: std :: mem :: transmute ( ExtendedTagSupported ) } ; ExtendedTagSupported as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 3u8 , { let L0sAcceptableLatency : u32 = unsafe { :: std :: mem :: transmute ( L0sAcceptableLatency ) } ; L0sAcceptableLatency as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 3u8 , { let L1AcceptableLatency : u32 = unsafe { :: std :: mem :: transmute ( L1AcceptableLatency ) } ; L1AcceptableLatency as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 3u8 , { let Undefined : u32 = unsafe { :: std :: mem :: transmute ( Undefined ) } ; Undefined as u64 } ) ; __bindgen_bitfield_unit . set ( 15usize , 1u8 , { let RoleBasedErrorReporting : u32 = unsafe { :: std :: mem :: transmute ( RoleBasedErrorReporting ) } ; RoleBasedErrorReporting as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 2u8 , { let Rsvd1 : u32 = unsafe { :: std :: mem :: transmute ( Rsvd1 ) } ; Rsvd1 as u64 } ) ; __bindgen_bitfield_unit . set ( 18usize , 8u8 , { let CapturedSlotPowerLimit : u32 = unsafe { :: std :: mem :: transmute ( CapturedSlotPowerLimit ) } ; CapturedSlotPowerLimit as u64 } ) ; __bindgen_bitfield_unit . set ( 26usize , 2u8 , { let CapturedSlotPowerLimitScale : u32 = unsafe { :: std :: mem :: transmute ( CapturedSlotPowerLimitScale ) } ; CapturedSlotPowerLimitScale as u64 } ) ; __bindgen_bitfield_unit . set ( 28usize , 1u8 , { let FunctionLevelResetCapability : u32 = unsafe { :: std :: mem :: transmute ( FunctionLevelResetCapability ) } ; FunctionLevelResetCapability as u64 } ) ; __bindgen_bitfield_unit . set ( 29usize , 3u8 , { let Rsvd2 : u32 = unsafe { :: std :: mem :: transmute ( Rsvd2 ) } ; Rsvd2 as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER = _PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER ; pub type PPCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER = * mut _PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_DEVICE_CONTROL_REGISTER { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_DEVICE_CONTROL_REGISTER__bindgen_ty_1 > , pub __bindgen_anon_2 : __BindgenUnionField < _PCI_EXPRESS_DEVICE_CONTROL_REGISTER__bindgen_ty_2 > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : u16 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_DEVICE_CONTROL_REGISTER__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl _PCI_EXPRESS_DEVICE_CONTROL_REGISTER__bindgen_ty_1 { # [ inline ] pub fn CorrectableErrorEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_CorrectableErrorEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn NonFatalErrorEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_NonFatalErrorEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn FatalErrorEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_FatalErrorEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UnsupportedRequestErrorEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_UnsupportedRequestErrorEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn EnableRelaxedOrder ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_EnableRelaxedOrder ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MaxPayloadSize ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u16 ) } } # [ inline ] pub fn set_MaxPayloadSize ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn ExtendedTagEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_ExtendedTagEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PhantomFunctionsEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_PhantomFunctionsEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AuxPowerEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_AuxPowerEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 1u8 , val as u64 ) } } # [ inline ] pub fn NoSnoopEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_NoSnoopEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MaxReadRequestSize ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 3u8 ) as u16 ) } } # [ inline ] pub fn set_MaxReadRequestSize ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 3u8 , val as u64 ) } } # [ inline ] pub fn BridgeConfigRetryEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 15usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_BridgeConfigRetryEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 15usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( CorrectableErrorEnable : USHORT , NonFatalErrorEnable : USHORT , FatalErrorEnable : USHORT , UnsupportedRequestErrorEnable : USHORT , EnableRelaxedOrder : USHORT , MaxPayloadSize : USHORT , ExtendedTagEnable : USHORT , PhantomFunctionsEnable : USHORT , AuxPowerEnable : USHORT , NoSnoopEnable : USHORT , MaxReadRequestSize : USHORT , BridgeConfigRetryEnable : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let CorrectableErrorEnable : u16 = unsafe { :: std :: mem :: transmute ( CorrectableErrorEnable ) } ; CorrectableErrorEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let NonFatalErrorEnable : u16 = unsafe { :: std :: mem :: transmute ( NonFatalErrorEnable ) } ; NonFatalErrorEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let FatalErrorEnable : u16 = unsafe { :: std :: mem :: transmute ( FatalErrorEnable ) } ; FatalErrorEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let UnsupportedRequestErrorEnable : u16 = unsafe { :: std :: mem :: transmute ( UnsupportedRequestErrorEnable ) } ; UnsupportedRequestErrorEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let EnableRelaxedOrder : u16 = unsafe { :: std :: mem :: transmute ( EnableRelaxedOrder ) } ; EnableRelaxedOrder as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let MaxPayloadSize : u16 = unsafe { :: std :: mem :: transmute ( MaxPayloadSize ) } ; MaxPayloadSize as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let ExtendedTagEnable : u16 = unsafe { :: std :: mem :: transmute ( ExtendedTagEnable ) } ; ExtendedTagEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let PhantomFunctionsEnable : u16 = unsafe { :: std :: mem :: transmute ( PhantomFunctionsEnable ) } ; PhantomFunctionsEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 1u8 , { let AuxPowerEnable : u16 = unsafe { :: std :: mem :: transmute ( AuxPowerEnable ) } ; AuxPowerEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 1u8 , { let NoSnoopEnable : u16 = unsafe { :: std :: mem :: transmute ( NoSnoopEnable ) } ; NoSnoopEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 3u8 , { let MaxReadRequestSize : u16 = unsafe { :: std :: mem :: transmute ( MaxReadRequestSize ) } ; MaxReadRequestSize as u64 } ) ; __bindgen_bitfield_unit . set ( 15usize , 1u8 , { let BridgeConfigRetryEnable : u16 = unsafe { :: std :: mem :: transmute ( BridgeConfigRetryEnable ) } ; BridgeConfigRetryEnable as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] pub struct _PCI_EXPRESS_DEVICE_CONTROL_REGISTER__bindgen_ty_2 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl _PCI_EXPRESS_DEVICE_CONTROL_REGISTER__bindgen_ty_2 { # [ inline ] pub fn InitiateFunctionLevelReset ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 15usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_InitiateFunctionLevelReset ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 15usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( InitiateFunctionLevelReset : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 15usize , 1u8 , { let InitiateFunctionLevelReset : u16 = unsafe { :: std :: mem :: transmute ( InitiateFunctionLevelReset ) } ; InitiateFunctionLevelReset as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_DEVICE_CONTROL_REGISTER = _PCI_EXPRESS_DEVICE_CONTROL_REGISTER ; pub type PPCI_EXPRESS_DEVICE_CONTROL_REGISTER = * mut _PCI_EXPRESS_DEVICE_CONTROL_REGISTER ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_DEVICE_STATUS_REGISTER { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_DEVICE_STATUS_REGISTER__bindgen_ty_1 > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : u16 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_DEVICE_STATUS_REGISTER__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl _PCI_EXPRESS_DEVICE_STATUS_REGISTER__bindgen_ty_1 { # [ inline ] pub fn CorrectableErrorDetected ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_CorrectableErrorDetected ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn NonFatalErrorDetected ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_NonFatalErrorDetected ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn FatalErrorDetected ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_FatalErrorDetected ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UnsupportedRequestDetected ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_UnsupportedRequestDetected ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AuxPowerDetected ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_AuxPowerDetected ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn TransactionsPending ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_TransactionsPending ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Rsvd ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 10u8 ) as u16 ) } } # [ inline ] pub fn set_Rsvd ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 10u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( CorrectableErrorDetected : USHORT , NonFatalErrorDetected : USHORT , FatalErrorDetected : USHORT , UnsupportedRequestDetected : USHORT , AuxPowerDetected : USHORT , TransactionsPending : USHORT , Rsvd : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let CorrectableErrorDetected : u16 = unsafe { :: std :: mem :: transmute ( CorrectableErrorDetected ) } ; CorrectableErrorDetected as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let NonFatalErrorDetected : u16 = unsafe { :: std :: mem :: transmute ( NonFatalErrorDetected ) } ; NonFatalErrorDetected as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let FatalErrorDetected : u16 = unsafe { :: std :: mem :: transmute ( FatalErrorDetected ) } ; FatalErrorDetected as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let UnsupportedRequestDetected : u16 = unsafe { :: std :: mem :: transmute ( UnsupportedRequestDetected ) } ; UnsupportedRequestDetected as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let AuxPowerDetected : u16 = unsafe { :: std :: mem :: transmute ( AuxPowerDetected ) } ; AuxPowerDetected as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let TransactionsPending : u16 = unsafe { :: std :: mem :: transmute ( TransactionsPending ) } ; TransactionsPending as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 10u8 , { let Rsvd : u16 = unsafe { :: std :: mem :: transmute ( Rsvd ) } ; Rsvd as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_DEVICE_STATUS_REGISTER = _PCI_EXPRESS_DEVICE_STATUS_REGISTER ; pub type PPCI_EXPRESS_DEVICE_STATUS_REGISTER = * mut _PCI_EXPRESS_DEVICE_STATUS_REGISTER ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_LINK_CAPABILITIES_REGISTER { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_LINK_CAPABILITIES_REGISTER__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_LINK_CAPABILITIES_REGISTER__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PCI_EXPRESS_LINK_CAPABILITIES_REGISTER__bindgen_ty_1 { # [ inline ] pub fn MaximumLinkSpeed ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_MaximumLinkSpeed ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn MaximumLinkWidth ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 6u8 ) as u32 ) } } # [ inline ] pub fn set_MaximumLinkWidth ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 6u8 , val as u64 ) } } # [ inline ] pub fn ActiveStatePMSupport ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_ActiveStatePMSupport ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 2u8 , val as u64 ) } } # [ inline ] pub fn L0sExitLatency ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_L0sExitLatency ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 3u8 , val as u64 ) } } # [ inline ] pub fn L1ExitLatency ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 15usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_L1ExitLatency ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 15usize , 3u8 , val as u64 ) } } # [ inline ] pub fn ClockPowerManagement ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 18usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ClockPowerManagement ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 18usize , 1u8 , val as u64 ) } } # [ inline ] pub fn SurpriseDownErrorReportingCapable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 19usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_SurpriseDownErrorReportingCapable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 19usize , 1u8 , val as u64 ) } } # [ inline ] pub fn DataLinkLayerActiveReportingCapable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 20usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_DataLinkLayerActiveReportingCapable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 20usize , 1u8 , val as u64 ) } } # [ inline ] pub fn LinkBandwidthNotificationCapability ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 21usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_LinkBandwidthNotificationCapability ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 21usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AspmOptionalityCompliance ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 22usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AspmOptionalityCompliance ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 22usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Rsvd ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 23usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Rsvd ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 23usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PortNumber ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_PortNumber ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( MaximumLinkSpeed : ULONG , MaximumLinkWidth : ULONG , ActiveStatePMSupport : ULONG , L0sExitLatency : ULONG , L1ExitLatency : ULONG , ClockPowerManagement : ULONG , SurpriseDownErrorReportingCapable : ULONG , DataLinkLayerActiveReportingCapable : ULONG , LinkBandwidthNotificationCapability : ULONG , AspmOptionalityCompliance : ULONG , Rsvd : ULONG , PortNumber : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let MaximumLinkSpeed : u32 = unsafe { :: std :: mem :: transmute ( MaximumLinkSpeed ) } ; MaximumLinkSpeed as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 6u8 , { let MaximumLinkWidth : u32 = unsafe { :: std :: mem :: transmute ( MaximumLinkWidth ) } ; MaximumLinkWidth as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 2u8 , { let ActiveStatePMSupport : u32 = unsafe { :: std :: mem :: transmute ( ActiveStatePMSupport ) } ; ActiveStatePMSupport as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 3u8 , { let L0sExitLatency : u32 = unsafe { :: std :: mem :: transmute ( L0sExitLatency ) } ; L0sExitLatency as u64 } ) ; __bindgen_bitfield_unit . set ( 15usize , 3u8 , { let L1ExitLatency : u32 = unsafe { :: std :: mem :: transmute ( L1ExitLatency ) } ; L1ExitLatency as u64 } ) ; __bindgen_bitfield_unit . set ( 18usize , 1u8 , { let ClockPowerManagement : u32 = unsafe { :: std :: mem :: transmute ( ClockPowerManagement ) } ; ClockPowerManagement as u64 } ) ; __bindgen_bitfield_unit . set ( 19usize , 1u8 , { let SurpriseDownErrorReportingCapable : u32 = unsafe { :: std :: mem :: transmute ( SurpriseDownErrorReportingCapable ) } ; SurpriseDownErrorReportingCapable as u64 } ) ; __bindgen_bitfield_unit . set ( 20usize , 1u8 , { let DataLinkLayerActiveReportingCapable : u32 = unsafe { :: std :: mem :: transmute ( DataLinkLayerActiveReportingCapable ) } ; DataLinkLayerActiveReportingCapable as u64 } ) ; __bindgen_bitfield_unit . set ( 21usize , 1u8 , { let LinkBandwidthNotificationCapability : u32 = unsafe { :: std :: mem :: transmute ( LinkBandwidthNotificationCapability ) } ; LinkBandwidthNotificationCapability as u64 } ) ; __bindgen_bitfield_unit . set ( 22usize , 1u8 , { let AspmOptionalityCompliance : u32 = unsafe { :: std :: mem :: transmute ( AspmOptionalityCompliance ) } ; AspmOptionalityCompliance as u64 } ) ; __bindgen_bitfield_unit . set ( 23usize , 1u8 , { let Rsvd : u32 = unsafe { :: std :: mem :: transmute ( Rsvd ) } ; Rsvd as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let PortNumber : u32 = unsafe { :: std :: mem :: transmute ( PortNumber ) } ; PortNumber as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_LINK_CAPABILITIES_REGISTER = _PCI_EXPRESS_LINK_CAPABILITIES_REGISTER ; pub type PPCI_EXPRESS_LINK_CAPABILITIES_REGISTER = * mut _PCI_EXPRESS_LINK_CAPABILITIES_REGISTER ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_LINK_CONTROL_REGISTER { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_LINK_CONTROL_REGISTER__bindgen_ty_1 > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : u16 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_LINK_CONTROL_REGISTER__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl _PCI_EXPRESS_LINK_CONTROL_REGISTER__bindgen_ty_1 { # [ inline ] pub fn ActiveStatePMControl ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 2u8 ) as u16 ) } } # [ inline ] pub fn set_ActiveStatePMControl ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 2u8 , val as u64 ) } } # [ inline ] pub fn Rsvd1 ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_Rsvd1 ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ReadCompletionBoundary ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_ReadCompletionBoundary ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn LinkDisable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_LinkDisable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn RetrainLink ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_RetrainLink ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn CommonClockConfig ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_CommonClockConfig ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ExtendedSynch ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_ExtendedSynch ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn EnableClockPowerManagement ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_EnableClockPowerManagement ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Rsvd2 ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 7u8 ) as u16 ) } } # [ inline ] pub fn set_Rsvd2 ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ActiveStatePMControl : USHORT , Rsvd1 : USHORT , ReadCompletionBoundary : USHORT , LinkDisable : USHORT , RetrainLink : USHORT , CommonClockConfig : USHORT , ExtendedSynch : USHORT , EnableClockPowerManagement : USHORT , Rsvd2 : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 2u8 , { let ActiveStatePMControl : u16 = unsafe { :: std :: mem :: transmute ( ActiveStatePMControl ) } ; ActiveStatePMControl as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let Rsvd1 : u16 = unsafe { :: std :: mem :: transmute ( Rsvd1 ) } ; Rsvd1 as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let ReadCompletionBoundary : u16 = unsafe { :: std :: mem :: transmute ( ReadCompletionBoundary ) } ; ReadCompletionBoundary as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let LinkDisable : u16 = unsafe { :: std :: mem :: transmute ( LinkDisable ) } ; LinkDisable as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let RetrainLink : u16 = unsafe { :: std :: mem :: transmute ( RetrainLink ) } ; RetrainLink as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let CommonClockConfig : u16 = unsafe { :: std :: mem :: transmute ( CommonClockConfig ) } ; CommonClockConfig as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let ExtendedSynch : u16 = unsafe { :: std :: mem :: transmute ( ExtendedSynch ) } ; ExtendedSynch as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let EnableClockPowerManagement : u16 = unsafe { :: std :: mem :: transmute ( EnableClockPowerManagement ) } ; EnableClockPowerManagement as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 7u8 , { let Rsvd2 : u16 = unsafe { :: std :: mem :: transmute ( Rsvd2 ) } ; Rsvd2 as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_LINK_CONTROL_REGISTER = _PCI_EXPRESS_LINK_CONTROL_REGISTER ; pub type PPCI_EXPRESS_LINK_CONTROL_REGISTER = * mut _PCI_EXPRESS_LINK_CONTROL_REGISTER ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_LINK_STATUS_REGISTER { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_LINK_STATUS_REGISTER__bindgen_ty_1 > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : u16 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_LINK_STATUS_REGISTER__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl _PCI_EXPRESS_LINK_STATUS_REGISTER__bindgen_ty_1 { # [ inline ] pub fn LinkSpeed ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u16 ) } } # [ inline ] pub fn set_LinkSpeed ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn LinkWidth ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 6u8 ) as u16 ) } } # [ inline ] pub fn set_LinkWidth ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 6u8 , val as u64 ) } } # [ inline ] pub fn Undefined ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_Undefined ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 1u8 , val as u64 ) } } # [ inline ] pub fn LinkTraining ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_LinkTraining ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 1u8 , val as u64 ) } } # [ inline ] pub fn SlotClockConfig ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_SlotClockConfig ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 1u8 , val as u64 ) } } # [ inline ] pub fn DataLinkLayerActive ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 13usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_DataLinkLayerActive ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 13usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Rsvd ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 2u8 ) as u16 ) } } # [ inline ] pub fn set_Rsvd ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 2u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( LinkSpeed : USHORT , LinkWidth : USHORT , Undefined : USHORT , LinkTraining : USHORT , SlotClockConfig : USHORT , DataLinkLayerActive : USHORT , Rsvd : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let LinkSpeed : u16 = unsafe { :: std :: mem :: transmute ( LinkSpeed ) } ; LinkSpeed as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 6u8 , { let LinkWidth : u16 = unsafe { :: std :: mem :: transmute ( LinkWidth ) } ; LinkWidth as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 1u8 , { let Undefined : u16 = unsafe { :: std :: mem :: transmute ( Undefined ) } ; Undefined as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 1u8 , { let LinkTraining : u16 = unsafe { :: std :: mem :: transmute ( LinkTraining ) } ; LinkTraining as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 1u8 , { let SlotClockConfig : u16 = unsafe { :: std :: mem :: transmute ( SlotClockConfig ) } ; SlotClockConfig as u64 } ) ; __bindgen_bitfield_unit . set ( 13usize , 1u8 , { let DataLinkLayerActive : u16 = unsafe { :: std :: mem :: transmute ( DataLinkLayerActive ) } ; DataLinkLayerActive as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 2u8 , { let Rsvd : u16 = unsafe { :: std :: mem :: transmute ( Rsvd ) } ; Rsvd as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_LINK_STATUS_REGISTER = _PCI_EXPRESS_LINK_STATUS_REGISTER ; pub type PPCI_EXPRESS_LINK_STATUS_REGISTER = * mut _PCI_EXPRESS_LINK_STATUS_REGISTER ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER__bindgen_ty_1 { # [ inline ] pub fn AttentionButtonPresent ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AttentionButtonPresent ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PowerControllerPresent ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_PowerControllerPresent ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MRLSensorPresent ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_MRLSensorPresent ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AttentionIndicatorPresent ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AttentionIndicatorPresent ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PowerIndicatorPresent ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_PowerIndicatorPresent ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn HotPlugSurprise ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_HotPlugSurprise ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn HotPlugCapable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_HotPlugCapable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn SlotPowerLimit ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_SlotPowerLimit ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 8u8 , val as u64 ) } } # [ inline ] pub fn SlotPowerLimitScale ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 15usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_SlotPowerLimitScale ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 15usize , 2u8 , val as u64 ) } } # [ inline ] pub fn ElectromechanicalLockPresent ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 17usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ElectromechanicalLockPresent ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 17usize , 1u8 , val as u64 ) } } # [ inline ] pub fn NoCommandCompletedSupport ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 18usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_NoCommandCompletedSupport ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 18usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PhysicalSlotNumber ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 19usize , 13u8 ) as u32 ) } } # [ inline ] pub fn set_PhysicalSlotNumber ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 19usize , 13u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( AttentionButtonPresent : ULONG , PowerControllerPresent : ULONG , MRLSensorPresent : ULONG , AttentionIndicatorPresent : ULONG , PowerIndicatorPresent : ULONG , HotPlugSurprise : ULONG , HotPlugCapable : ULONG , SlotPowerLimit : ULONG , SlotPowerLimitScale : ULONG , ElectromechanicalLockPresent : ULONG , NoCommandCompletedSupport : ULONG , PhysicalSlotNumber : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let AttentionButtonPresent : u32 = unsafe { :: std :: mem :: transmute ( AttentionButtonPresent ) } ; AttentionButtonPresent as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let PowerControllerPresent : u32 = unsafe { :: std :: mem :: transmute ( PowerControllerPresent ) } ; PowerControllerPresent as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let MRLSensorPresent : u32 = unsafe { :: std :: mem :: transmute ( MRLSensorPresent ) } ; MRLSensorPresent as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let AttentionIndicatorPresent : u32 = unsafe { :: std :: mem :: transmute ( AttentionIndicatorPresent ) } ; AttentionIndicatorPresent as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let PowerIndicatorPresent : u32 = unsafe { :: std :: mem :: transmute ( PowerIndicatorPresent ) } ; PowerIndicatorPresent as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let HotPlugSurprise : u32 = unsafe { :: std :: mem :: transmute ( HotPlugSurprise ) } ; HotPlugSurprise as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let HotPlugCapable : u32 = unsafe { :: std :: mem :: transmute ( HotPlugCapable ) } ; HotPlugCapable as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 8u8 , { let SlotPowerLimit : u32 = unsafe { :: std :: mem :: transmute ( SlotPowerLimit ) } ; SlotPowerLimit as u64 } ) ; __bindgen_bitfield_unit . set ( 15usize , 2u8 , { let SlotPowerLimitScale : u32 = unsafe { :: std :: mem :: transmute ( SlotPowerLimitScale ) } ; SlotPowerLimitScale as u64 } ) ; __bindgen_bitfield_unit . set ( 17usize , 1u8 , { let ElectromechanicalLockPresent : u32 = unsafe { :: std :: mem :: transmute ( ElectromechanicalLockPresent ) } ; ElectromechanicalLockPresent as u64 } ) ; __bindgen_bitfield_unit . set ( 18usize , 1u8 , { let NoCommandCompletedSupport : u32 = unsafe { :: std :: mem :: transmute ( NoCommandCompletedSupport ) } ; NoCommandCompletedSupport as u64 } ) ; __bindgen_bitfield_unit . set ( 19usize , 13u8 , { let PhysicalSlotNumber : u32 = unsafe { :: std :: mem :: transmute ( PhysicalSlotNumber ) } ; PhysicalSlotNumber as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER = _PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER ; pub type PPCI_EXPRESS_SLOT_CAPABILITIES_REGISTER = * mut _PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_SLOT_CONTROL_REGISTER { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_SLOT_CONTROL_REGISTER__bindgen_ty_1 > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : u16 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_SLOT_CONTROL_REGISTER__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl _PCI_EXPRESS_SLOT_CONTROL_REGISTER__bindgen_ty_1 { # [ inline ] pub fn AttentionButtonEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_AttentionButtonEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PowerFaultDetectEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_PowerFaultDetectEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MRLSensorEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_MRLSensorEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PresenceDetectEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_PresenceDetectEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn CommandCompletedEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_CommandCompletedEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn HotPlugInterruptEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_HotPlugInterruptEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AttentionIndicatorControl ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 2u8 ) as u16 ) } } # [ inline ] pub fn set_AttentionIndicatorControl ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 2u8 , val as u64 ) } } # [ inline ] pub fn PowerIndicatorControl ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 2u8 ) as u16 ) } } # [ inline ] pub fn set_PowerIndicatorControl ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 2u8 , val as u64 ) } } # [ inline ] pub fn PowerControllerControl ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_PowerControllerControl ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ElectromechanicalLockControl ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_ElectromechanicalLockControl ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 1u8 , val as u64 ) } } # [ inline ] pub fn DataLinkStateChangeEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_DataLinkStateChangeEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Rsvd ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 13usize , 3u8 ) as u16 ) } } # [ inline ] pub fn set_Rsvd ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 13usize , 3u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( AttentionButtonEnable : USHORT , PowerFaultDetectEnable : USHORT , MRLSensorEnable : USHORT , PresenceDetectEnable : USHORT , CommandCompletedEnable : USHORT , HotPlugInterruptEnable : USHORT , AttentionIndicatorControl : USHORT , PowerIndicatorControl : USHORT , PowerControllerControl : USHORT , ElectromechanicalLockControl : USHORT , DataLinkStateChangeEnable : USHORT , Rsvd : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let AttentionButtonEnable : u16 = unsafe { :: std :: mem :: transmute ( AttentionButtonEnable ) } ; AttentionButtonEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let PowerFaultDetectEnable : u16 = unsafe { :: std :: mem :: transmute ( PowerFaultDetectEnable ) } ; PowerFaultDetectEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let MRLSensorEnable : u16 = unsafe { :: std :: mem :: transmute ( MRLSensorEnable ) } ; MRLSensorEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let PresenceDetectEnable : u16 = unsafe { :: std :: mem :: transmute ( PresenceDetectEnable ) } ; PresenceDetectEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let CommandCompletedEnable : u16 = unsafe { :: std :: mem :: transmute ( CommandCompletedEnable ) } ; CommandCompletedEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let HotPlugInterruptEnable : u16 = unsafe { :: std :: mem :: transmute ( HotPlugInterruptEnable ) } ; HotPlugInterruptEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 2u8 , { let AttentionIndicatorControl : u16 = unsafe { :: std :: mem :: transmute ( AttentionIndicatorControl ) } ; AttentionIndicatorControl as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 2u8 , { let PowerIndicatorControl : u16 = unsafe { :: std :: mem :: transmute ( PowerIndicatorControl ) } ; PowerIndicatorControl as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 1u8 , { let PowerControllerControl : u16 = unsafe { :: std :: mem :: transmute ( PowerControllerControl ) } ; PowerControllerControl as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 1u8 , { let ElectromechanicalLockControl : u16 = unsafe { :: std :: mem :: transmute ( ElectromechanicalLockControl ) } ; ElectromechanicalLockControl as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 1u8 , { let DataLinkStateChangeEnable : u16 = unsafe { :: std :: mem :: transmute ( DataLinkStateChangeEnable ) } ; DataLinkStateChangeEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 13usize , 3u8 , { let Rsvd : u16 = unsafe { :: std :: mem :: transmute ( Rsvd ) } ; Rsvd as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_SLOT_CONTROL_REGISTER = _PCI_EXPRESS_SLOT_CONTROL_REGISTER ; pub type PPCI_EXPRESS_SLOT_CONTROL_REGISTER = * mut _PCI_EXPRESS_SLOT_CONTROL_REGISTER ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_SLOT_STATUS_REGISTER { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_SLOT_STATUS_REGISTER__bindgen_ty_1 > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : u16 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_SLOT_STATUS_REGISTER__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl _PCI_EXPRESS_SLOT_STATUS_REGISTER__bindgen_ty_1 { # [ inline ] pub fn AttentionButtonPressed ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_AttentionButtonPressed ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PowerFaultDetected ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_PowerFaultDetected ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MRLSensorChanged ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_MRLSensorChanged ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PresenceDetectChanged ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_PresenceDetectChanged ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn CommandCompleted ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_CommandCompleted ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MRLSensorState ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_MRLSensorState ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PresenceDetectState ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_PresenceDetectState ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ElectromechanicalLockEngaged ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_ElectromechanicalLockEngaged ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn DataLinkStateChanged ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_DataLinkStateChanged ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Rsvd ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 7u8 ) as u16 ) } } # [ inline ] pub fn set_Rsvd ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( AttentionButtonPressed : USHORT , PowerFaultDetected : USHORT , MRLSensorChanged : USHORT , PresenceDetectChanged : USHORT , CommandCompleted : USHORT , MRLSensorState : USHORT , PresenceDetectState : USHORT , ElectromechanicalLockEngaged : USHORT , DataLinkStateChanged : USHORT , Rsvd : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let AttentionButtonPressed : u16 = unsafe { :: std :: mem :: transmute ( AttentionButtonPressed ) } ; AttentionButtonPressed as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let PowerFaultDetected : u16 = unsafe { :: std :: mem :: transmute ( PowerFaultDetected ) } ; PowerFaultDetected as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let MRLSensorChanged : u16 = unsafe { :: std :: mem :: transmute ( MRLSensorChanged ) } ; MRLSensorChanged as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let PresenceDetectChanged : u16 = unsafe { :: std :: mem :: transmute ( PresenceDetectChanged ) } ; PresenceDetectChanged as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let CommandCompleted : u16 = unsafe { :: std :: mem :: transmute ( CommandCompleted ) } ; CommandCompleted as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let MRLSensorState : u16 = unsafe { :: std :: mem :: transmute ( MRLSensorState ) } ; MRLSensorState as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let PresenceDetectState : u16 = unsafe { :: std :: mem :: transmute ( PresenceDetectState ) } ; PresenceDetectState as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let ElectromechanicalLockEngaged : u16 = unsafe { :: std :: mem :: transmute ( ElectromechanicalLockEngaged ) } ; ElectromechanicalLockEngaged as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let DataLinkStateChanged : u16 = unsafe { :: std :: mem :: transmute ( DataLinkStateChanged ) } ; DataLinkStateChanged as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 7u8 , { let Rsvd : u16 = unsafe { :: std :: mem :: transmute ( Rsvd ) } ; Rsvd as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_SLOT_STATUS_REGISTER = _PCI_EXPRESS_SLOT_STATUS_REGISTER ; pub type PPCI_EXPRESS_SLOT_STATUS_REGISTER = * mut _PCI_EXPRESS_SLOT_STATUS_REGISTER ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_ROOT_CONTROL_REGISTER { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_ROOT_CONTROL_REGISTER__bindgen_ty_1 > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : u16 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_ROOT_CONTROL_REGISTER__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl _PCI_EXPRESS_ROOT_CONTROL_REGISTER__bindgen_ty_1 { # [ inline ] pub fn CorrectableSerrEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_CorrectableSerrEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn NonFatalSerrEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_NonFatalSerrEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn FatalSerrEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_FatalSerrEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PMEInterruptEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_PMEInterruptEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn CRSSoftwareVisibilityEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_CRSSoftwareVisibilityEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Rsvd ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 11u8 ) as u16 ) } } # [ inline ] pub fn set_Rsvd ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 11u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( CorrectableSerrEnable : USHORT , NonFatalSerrEnable : USHORT , FatalSerrEnable : USHORT , PMEInterruptEnable : USHORT , CRSSoftwareVisibilityEnable : USHORT , Rsvd : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let CorrectableSerrEnable : u16 = unsafe { :: std :: mem :: transmute ( CorrectableSerrEnable ) } ; CorrectableSerrEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let NonFatalSerrEnable : u16 = unsafe { :: std :: mem :: transmute ( NonFatalSerrEnable ) } ; NonFatalSerrEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let FatalSerrEnable : u16 = unsafe { :: std :: mem :: transmute ( FatalSerrEnable ) } ; FatalSerrEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let PMEInterruptEnable : u16 = unsafe { :: std :: mem :: transmute ( PMEInterruptEnable ) } ; PMEInterruptEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let CRSSoftwareVisibilityEnable : u16 = unsafe { :: std :: mem :: transmute ( CRSSoftwareVisibilityEnable ) } ; CRSSoftwareVisibilityEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 11u8 , { let Rsvd : u16 = unsafe { :: std :: mem :: transmute ( Rsvd ) } ; Rsvd as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_ROOT_CONTROL_REGISTER = _PCI_EXPRESS_ROOT_CONTROL_REGISTER ; pub type PPCI_EXPRESS_ROOT_CONTROL_REGISTER = * mut _PCI_EXPRESS_ROOT_CONTROL_REGISTER ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER__bindgen_ty_1 > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : u16 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl _PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER__bindgen_ty_1 { # [ inline ] pub fn CRSSoftwareVisibility ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_CRSSoftwareVisibility ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Rsvd ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 15u8 ) as u16 ) } } # [ inline ] pub fn set_Rsvd ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 15u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( CRSSoftwareVisibility : USHORT , Rsvd : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let CRSSoftwareVisibility : u16 = unsafe { :: std :: mem :: transmute ( CRSSoftwareVisibility ) } ; CRSSoftwareVisibility as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 15u8 , { let Rsvd : u16 = unsafe { :: std :: mem :: transmute ( Rsvd ) } ; Rsvd as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER = _PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER ; pub type PPCI_EXPRESS_ROOT_CAPABILITIES_REGISTER = * mut _PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_ROOT_STATUS_REGISTER { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_ROOT_STATUS_REGISTER__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_ROOT_STATUS_REGISTER__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PCI_EXPRESS_ROOT_STATUS_REGISTER__bindgen_ty_1 { # [ inline ] pub fn PMERequestorId ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_PMERequestorId ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 16u8 , val as u64 ) } } # [ inline ] pub fn PMEStatus ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_PMEStatus ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PMEPending ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 17usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_PMEPending ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 17usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Rsvd ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 18usize , 14u8 ) as u32 ) } } # [ inline ] pub fn set_Rsvd ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 18usize , 14u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( PMERequestorId : ULONG , PMEStatus : ULONG , PMEPending : ULONG , Rsvd : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 16u8 , { let PMERequestorId : u32 = unsafe { :: std :: mem :: transmute ( PMERequestorId ) } ; PMERequestorId as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 1u8 , { let PMEStatus : u32 = unsafe { :: std :: mem :: transmute ( PMEStatus ) } ; PMEStatus as u64 } ) ; __bindgen_bitfield_unit . set ( 17usize , 1u8 , { let PMEPending : u32 = unsafe { :: std :: mem :: transmute ( PMEPending ) } ; PMEPending as u64 } ) ; __bindgen_bitfield_unit . set ( 18usize , 14u8 , { let Rsvd : u32 = unsafe { :: std :: mem :: transmute ( Rsvd ) } ; Rsvd as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_ROOT_STATUS_REGISTER = _PCI_EXPRESS_ROOT_STATUS_REGISTER ; pub type PPCI_EXPRESS_ROOT_STATUS_REGISTER = * mut _PCI_EXPRESS_ROOT_STATUS_REGISTER ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER__bindgen_ty_1 { # [ inline ] pub fn CompletionTimeoutRangesSupported ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_CompletionTimeoutRangesSupported ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn CompletionTimeoutDisableSupported ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_CompletionTimeoutDisableSupported ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AriForwardingSupported ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AriForwardingSupported ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AtomicOpRoutingSupported ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AtomicOpRoutingSupported ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AtomicOpCompleterSupported32Bit ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AtomicOpCompleterSupported32Bit ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AtomicOpCompleterSupported64Bit ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AtomicOpCompleterSupported64Bit ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn CASCompleterSupported128Bit ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_CASCompleterSupported128Bit ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn NoROEnabledPRPRPassing ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_NoROEnabledPRPRPassing ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 1u8 , val as u64 ) } } # [ inline ] pub fn LTRMechanismSupported ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_LTRMechanismSupported ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 1u8 , val as u64 ) } } # [ inline ] pub fn TPHCompleterSupported ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_TPHCompleterSupported ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 2u8 , val as u64 ) } } # [ inline ] pub fn Rsvd ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_Rsvd ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 4u8 , val as u64 ) } } # [ inline ] pub fn OBFFSupported ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 18usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_OBFFSupported ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 18usize , 2u8 , val as u64 ) } } # [ inline ] pub fn ExtendedFmtFieldSuported ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 20usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ExtendedFmtFieldSuported ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 20usize , 1u8 , val as u64 ) } } # [ inline ] pub fn EndEndTLPPrefixSupported ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 21usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_EndEndTLPPrefixSupported ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 21usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MaxEndEndTLPPrefixes ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 22usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_MaxEndEndTLPPrefixes ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 22usize , 2u8 , val as u64 ) } } # [ inline ] pub fn Rsvd2 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_Rsvd2 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( CompletionTimeoutRangesSupported : ULONG , CompletionTimeoutDisableSupported : ULONG , AriForwardingSupported : ULONG , AtomicOpRoutingSupported : ULONG , AtomicOpCompleterSupported32Bit : ULONG , AtomicOpCompleterSupported64Bit : ULONG , CASCompleterSupported128Bit : ULONG , NoROEnabledPRPRPassing : ULONG , LTRMechanismSupported : ULONG , TPHCompleterSupported : ULONG , Rsvd : ULONG , OBFFSupported : ULONG , ExtendedFmtFieldSuported : ULONG , EndEndTLPPrefixSupported : ULONG , MaxEndEndTLPPrefixes : ULONG , Rsvd2 : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let CompletionTimeoutRangesSupported : u32 = unsafe { :: std :: mem :: transmute ( CompletionTimeoutRangesSupported ) } ; CompletionTimeoutRangesSupported as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let CompletionTimeoutDisableSupported : u32 = unsafe { :: std :: mem :: transmute ( CompletionTimeoutDisableSupported ) } ; CompletionTimeoutDisableSupported as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let AriForwardingSupported : u32 = unsafe { :: std :: mem :: transmute ( AriForwardingSupported ) } ; AriForwardingSupported as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let AtomicOpRoutingSupported : u32 = unsafe { :: std :: mem :: transmute ( AtomicOpRoutingSupported ) } ; AtomicOpRoutingSupported as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let AtomicOpCompleterSupported32Bit : u32 = unsafe { :: std :: mem :: transmute ( AtomicOpCompleterSupported32Bit ) } ; AtomicOpCompleterSupported32Bit as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let AtomicOpCompleterSupported64Bit : u32 = unsafe { :: std :: mem :: transmute ( AtomicOpCompleterSupported64Bit ) } ; AtomicOpCompleterSupported64Bit as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let CASCompleterSupported128Bit : u32 = unsafe { :: std :: mem :: transmute ( CASCompleterSupported128Bit ) } ; CASCompleterSupported128Bit as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 1u8 , { let NoROEnabledPRPRPassing : u32 = unsafe { :: std :: mem :: transmute ( NoROEnabledPRPRPassing ) } ; NoROEnabledPRPRPassing as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 1u8 , { let LTRMechanismSupported : u32 = unsafe { :: std :: mem :: transmute ( LTRMechanismSupported ) } ; LTRMechanismSupported as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 2u8 , { let TPHCompleterSupported : u32 = unsafe { :: std :: mem :: transmute ( TPHCompleterSupported ) } ; TPHCompleterSupported as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 4u8 , { let Rsvd : u32 = unsafe { :: std :: mem :: transmute ( Rsvd ) } ; Rsvd as u64 } ) ; __bindgen_bitfield_unit . set ( 18usize , 2u8 , { let OBFFSupported : u32 = unsafe { :: std :: mem :: transmute ( OBFFSupported ) } ; OBFFSupported as u64 } ) ; __bindgen_bitfield_unit . set ( 20usize , 1u8 , { let ExtendedFmtFieldSuported : u32 = unsafe { :: std :: mem :: transmute ( ExtendedFmtFieldSuported ) } ; ExtendedFmtFieldSuported as u64 } ) ; __bindgen_bitfield_unit . set ( 21usize , 1u8 , { let EndEndTLPPrefixSupported : u32 = unsafe { :: std :: mem :: transmute ( EndEndTLPPrefixSupported ) } ; EndEndTLPPrefixSupported as u64 } ) ; __bindgen_bitfield_unit . set ( 22usize , 2u8 , { let MaxEndEndTLPPrefixes : u32 = unsafe { :: std :: mem :: transmute ( MaxEndEndTLPPrefixes ) } ; MaxEndEndTLPPrefixes as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let Rsvd2 : u32 = unsafe { :: std :: mem :: transmute ( Rsvd2 ) } ; Rsvd2 as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER = _PCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER ; pub type PPCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER = * mut _PCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_DEVICE_CONTROL_2_REGISTER { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_DEVICE_CONTROL_2_REGISTER__bindgen_ty_1 > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : u16 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_DEVICE_CONTROL_2_REGISTER__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl _PCI_EXPRESS_DEVICE_CONTROL_2_REGISTER__bindgen_ty_1 { # [ inline ] pub fn CompletionTimeoutValue ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u16 ) } } # [ inline ] pub fn set_CompletionTimeoutValue ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn CompletionTimeoutDisable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_CompletionTimeoutDisable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AriForwardingEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_AriForwardingEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AtomicOpRequesterEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_AtomicOpRequesterEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AtomicOpEgresBlocking ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_AtomicOpEgresBlocking ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn IDORequestEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_IDORequestEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn IDOCompletionEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_IDOCompletionEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn LTRMechanismEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_LTRMechanismEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Rsvd ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 2u8 ) as u16 ) } } # [ inline ] pub fn set_Rsvd ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 2u8 , val as u64 ) } } # [ inline ] pub fn OBFFEnable ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 13usize , 2u8 ) as u16 ) } } # [ inline ] pub fn set_OBFFEnable ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 13usize , 2u8 , val as u64 ) } } # [ inline ] pub fn EndEndTLPPrefixBlocking ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 15usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_EndEndTLPPrefixBlocking ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 15usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( CompletionTimeoutValue : USHORT , CompletionTimeoutDisable : USHORT , AriForwardingEnable : USHORT , AtomicOpRequesterEnable : USHORT , AtomicOpEgresBlocking : USHORT , IDORequestEnable : USHORT , IDOCompletionEnable : USHORT , LTRMechanismEnable : USHORT , Rsvd : USHORT , OBFFEnable : USHORT , EndEndTLPPrefixBlocking : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let CompletionTimeoutValue : u16 = unsafe { :: std :: mem :: transmute ( CompletionTimeoutValue ) } ; CompletionTimeoutValue as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let CompletionTimeoutDisable : u16 = unsafe { :: std :: mem :: transmute ( CompletionTimeoutDisable ) } ; CompletionTimeoutDisable as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let AriForwardingEnable : u16 = unsafe { :: std :: mem :: transmute ( AriForwardingEnable ) } ; AriForwardingEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let AtomicOpRequesterEnable : u16 = unsafe { :: std :: mem :: transmute ( AtomicOpRequesterEnable ) } ; AtomicOpRequesterEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let AtomicOpEgresBlocking : u16 = unsafe { :: std :: mem :: transmute ( AtomicOpEgresBlocking ) } ; AtomicOpEgresBlocking as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let IDORequestEnable : u16 = unsafe { :: std :: mem :: transmute ( IDORequestEnable ) } ; IDORequestEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let IDOCompletionEnable : u16 = unsafe { :: std :: mem :: transmute ( IDOCompletionEnable ) } ; IDOCompletionEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 1u8 , { let LTRMechanismEnable : u16 = unsafe { :: std :: mem :: transmute ( LTRMechanismEnable ) } ; LTRMechanismEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 2u8 , { let Rsvd : u16 = unsafe { :: std :: mem :: transmute ( Rsvd ) } ; Rsvd as u64 } ) ; __bindgen_bitfield_unit . set ( 13usize , 2u8 , { let OBFFEnable : u16 = unsafe { :: std :: mem :: transmute ( OBFFEnable ) } ; OBFFEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 15usize , 1u8 , { let EndEndTLPPrefixBlocking : u16 = unsafe { :: std :: mem :: transmute ( EndEndTLPPrefixBlocking ) } ; EndEndTLPPrefixBlocking as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_DEVICE_CONTROL_2_REGISTER = _PCI_EXPRESS_DEVICE_CONTROL_2_REGISTER ; pub type PPCI_EXPRESS_DEVICE_CONTROL_2_REGISTER = * mut _PCI_EXPRESS_DEVICE_CONTROL_2_REGISTER ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_DEVICE_STATUS_2_REGISTER { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_DEVICE_STATUS_2_REGISTER__bindgen_ty_1 > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : u16 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_DEVICE_STATUS_2_REGISTER__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl _PCI_EXPRESS_DEVICE_STATUS_2_REGISTER__bindgen_ty_1 { # [ inline ] pub fn Rsvd ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 16u8 ) as u16 ) } } # [ inline ] pub fn set_Rsvd ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 16u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Rsvd : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 16u8 , { let Rsvd : u16 = unsafe { :: std :: mem :: transmute ( Rsvd ) } ; Rsvd as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_DEVICE_STATUS_2_REGISTER = _PCI_EXPRESS_DEVICE_STATUS_2_REGISTER ; pub type PPCI_EXPRESS_DEVICE_STATUS_2_REGISTER = * mut _PCI_EXPRESS_DEVICE_STATUS_2_REGISTER ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_CAPABILITY { pub Header : PCI_CAPABILITIES_HEADER , pub ExpressCapabilities : PCI_EXPRESS_CAPABILITIES_REGISTER , pub DeviceCapabilities : PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER , pub DeviceControl : PCI_EXPRESS_DEVICE_CONTROL_REGISTER , pub DeviceStatus : PCI_EXPRESS_DEVICE_STATUS_REGISTER , pub LinkCapabilities : PCI_EXPRESS_LINK_CAPABILITIES_REGISTER , pub LinkControl : PCI_EXPRESS_LINK_CONTROL_REGISTER , pub LinkStatus : PCI_EXPRESS_LINK_STATUS_REGISTER , pub SlotCapabilities : PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER , pub SlotControl : PCI_EXPRESS_SLOT_CONTROL_REGISTER , pub SlotStatus : PCI_EXPRESS_SLOT_STATUS_REGISTER , pub RootControl : PCI_EXPRESS_ROOT_CONTROL_REGISTER , pub RootCapabilities : PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER , pub RootStatus : PCI_EXPRESS_ROOT_STATUS_REGISTER , pub DeviceCapabilities2 : PCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER , pub DeviceControl2 : PCI_EXPRESS_DEVICE_CONTROL_2_REGISTER , pub DeviceStatus2 : PCI_EXPRESS_DEVICE_STATUS_2_REGISTER , } pub type PCI_EXPRESS_CAPABILITY = _PCI_EXPRESS_CAPABILITY ; pub type PPCI_EXPRESS_CAPABILITY = * mut _PCI_EXPRESS_CAPABILITY ; pub const PCI_EXPRESS_MRL_STATE_MRLClosed : PCI_EXPRESS_MRL_STATE = 0 ; pub const PCI_EXPRESS_MRL_STATE_MRLOpen : PCI_EXPRESS_MRL_STATE = 1 ; pub type PCI_EXPRESS_MRL_STATE = i32 ; pub const PCI_EXPRESS_CARD_PRESENCE_SlotEmpty : PCI_EXPRESS_CARD_PRESENCE = 0 ; pub const PCI_EXPRESS_CARD_PRESENCE_CardPresent : PCI_EXPRESS_CARD_PRESENCE = 1 ; pub type PCI_EXPRESS_CARD_PRESENCE = i32 ; pub const PCI_EXPRESS_INDICATOR_STATE_IndicatorOn : PCI_EXPRESS_INDICATOR_STATE = 1 ; pub const PCI_EXPRESS_INDICATOR_STATE_IndicatorBlink : PCI_EXPRESS_INDICATOR_STATE = 2 ; pub const PCI_EXPRESS_INDICATOR_STATE_IndicatorOff : PCI_EXPRESS_INDICATOR_STATE = 3 ; pub type PCI_EXPRESS_INDICATOR_STATE = i32 ; pub const PCI_EXPRESS_POWER_STATE_PowerOn : PCI_EXPRESS_POWER_STATE = 0 ; pub const PCI_EXPRESS_POWER_STATE_PowerOff : PCI_EXPRESS_POWER_STATE = 1 ; pub type PCI_EXPRESS_POWER_STATE = i32 ; pub const PCI_EXPRESS_ASPM_SUPPORT_NoAspmSupport : PCI_EXPRESS_ASPM_SUPPORT = 0 ; pub const PCI_EXPRESS_ASPM_SUPPORT_L0sEntrySupport : PCI_EXPRESS_ASPM_SUPPORT = 1 ; pub const PCI_EXPRESS_ASPM_SUPPORT_L1EntrySupport : PCI_EXPRESS_ASPM_SUPPORT = 2 ; pub const PCI_EXPRESS_ASPM_SUPPORT_L0sAndL1EntrySupport : PCI_EXPRESS_ASPM_SUPPORT = 3 ; pub type PCI_EXPRESS_ASPM_SUPPORT = i32 ; pub const PCI_EXPRESS_ASPM_CONTROL_L0sAndL1EntryDisabled : PCI_EXPRESS_ASPM_CONTROL = 0 ; pub const PCI_EXPRESS_ASPM_CONTROL_L0sEntryEnabled : PCI_EXPRESS_ASPM_CONTROL = 1 ; pub const PCI_EXPRESS_ASPM_CONTROL_L1EntryEnabled : PCI_EXPRESS_ASPM_CONTROL = 2 ; pub const PCI_EXPRESS_ASPM_CONTROL_L0sAndL1EntryEnabled : PCI_EXPRESS_ASPM_CONTROL = 3 ; pub type PCI_EXPRESS_ASPM_CONTROL = i32 ; pub const PCI_EXPRESS_L0s_EXIT_LATENCY_L0s_Below64ns : PCI_EXPRESS_L0s_EXIT_LATENCY = 0 ; pub const PCI_EXPRESS_L0s_EXIT_LATENCY_L0s_64ns_128ns : PCI_EXPRESS_L0s_EXIT_LATENCY = 1 ; pub const PCI_EXPRESS_L0s_EXIT_LATENCY_L0s_128ns_256ns : PCI_EXPRESS_L0s_EXIT_LATENCY = 2 ; pub const PCI_EXPRESS_L0s_EXIT_LATENCY_L0s_256ns_512ns : PCI_EXPRESS_L0s_EXIT_LATENCY = 3 ; pub const PCI_EXPRESS_L0s_EXIT_LATENCY_L0s_512ns_1us : PCI_EXPRESS_L0s_EXIT_LATENCY = 4 ; pub const PCI_EXPRESS_L0s_EXIT_LATENCY_L0s_1us_2us : PCI_EXPRESS_L0s_EXIT_LATENCY = 5 ; pub const PCI_EXPRESS_L0s_EXIT_LATENCY_L0s_2us_4us : PCI_EXPRESS_L0s_EXIT_LATENCY = 6 ; pub const PCI_EXPRESS_L0s_EXIT_LATENCY_L0s_Above4us : PCI_EXPRESS_L0s_EXIT_LATENCY = 7 ; pub type PCI_EXPRESS_L0s_EXIT_LATENCY = i32 ; pub const PCI_EXPRESS_L1_EXIT_LATENCY_L1_Below1us : PCI_EXPRESS_L1_EXIT_LATENCY = 0 ; pub const PCI_EXPRESS_L1_EXIT_LATENCY_L1_1us_2us : PCI_EXPRESS_L1_EXIT_LATENCY = 1 ; pub const PCI_EXPRESS_L1_EXIT_LATENCY_L1_2us_4us : PCI_EXPRESS_L1_EXIT_LATENCY = 2 ; pub const PCI_EXPRESS_L1_EXIT_LATENCY_L1_4us_8us : PCI_EXPRESS_L1_EXIT_LATENCY = 3 ; pub const PCI_EXPRESS_L1_EXIT_LATENCY_L1_8us_16us : PCI_EXPRESS_L1_EXIT_LATENCY = 4 ; pub const PCI_EXPRESS_L1_EXIT_LATENCY_L1_16us_32us : PCI_EXPRESS_L1_EXIT_LATENCY = 5 ; pub const PCI_EXPRESS_L1_EXIT_LATENCY_L1_32us_64us : PCI_EXPRESS_L1_EXIT_LATENCY = 6 ; pub const PCI_EXPRESS_L1_EXIT_LATENCY_L1_Above64us : PCI_EXPRESS_L1_EXIT_LATENCY = 7 ; pub type PCI_EXPRESS_L1_EXIT_LATENCY = i32 ; pub const PCI_EXPRESS_DEVICE_TYPE_PciExpressEndpoint : PCI_EXPRESS_DEVICE_TYPE = 0 ; pub const PCI_EXPRESS_DEVICE_TYPE_PciExpressLegacyEndpoint : PCI_EXPRESS_DEVICE_TYPE = 1 ; pub const PCI_EXPRESS_DEVICE_TYPE_PciExpressRootPort : PCI_EXPRESS_DEVICE_TYPE = 4 ; pub const PCI_EXPRESS_DEVICE_TYPE_PciExpressUpstreamSwitchPort : PCI_EXPRESS_DEVICE_TYPE = 5 ; pub const PCI_EXPRESS_DEVICE_TYPE_PciExpressDownstreamSwitchPort : PCI_EXPRESS_DEVICE_TYPE = 6 ; pub const PCI_EXPRESS_DEVICE_TYPE_PciExpressToPciXBridge : PCI_EXPRESS_DEVICE_TYPE = 7 ; pub const PCI_EXPRESS_DEVICE_TYPE_PciXToExpressBridge : PCI_EXPRESS_DEVICE_TYPE = 8 ; pub const PCI_EXPRESS_DEVICE_TYPE_PciExpressRootComplexIntegratedEndpoint : PCI_EXPRESS_DEVICE_TYPE = 9 ; pub const PCI_EXPRESS_DEVICE_TYPE_PciExpressRootComplexEventCollector : PCI_EXPRESS_DEVICE_TYPE = 10 ; pub type PCI_EXPRESS_DEVICE_TYPE = i32 ; pub const PCI_EXPRESS_MAX_PAYLOAD_SIZE_MaxPayload128Bytes : PCI_EXPRESS_MAX_PAYLOAD_SIZE = 0 ; pub const PCI_EXPRESS_MAX_PAYLOAD_SIZE_MaxPayload256Bytes : PCI_EXPRESS_MAX_PAYLOAD_SIZE = 1 ; pub const PCI_EXPRESS_MAX_PAYLOAD_SIZE_MaxPayload512Bytes : PCI_EXPRESS_MAX_PAYLOAD_SIZE = 2 ; pub const PCI_EXPRESS_MAX_PAYLOAD_SIZE_MaxPayload1024Bytes : PCI_EXPRESS_MAX_PAYLOAD_SIZE = 3 ; pub const PCI_EXPRESS_MAX_PAYLOAD_SIZE_MaxPayload2048Bytes : PCI_EXPRESS_MAX_PAYLOAD_SIZE = 4 ; pub const PCI_EXPRESS_MAX_PAYLOAD_SIZE_MaxPayload4096Bytes : PCI_EXPRESS_MAX_PAYLOAD_SIZE = 5 ; pub type PCI_EXPRESS_MAX_PAYLOAD_SIZE = i32 ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_PME_REQUESTOR_ID { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_PME_REQUESTOR_ID__bindgen_ty_1 > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : u16 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_PME_REQUESTOR_ID__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl _PCI_EXPRESS_PME_REQUESTOR_ID__bindgen_ty_1 { # [ inline ] pub fn FunctionNumber ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u16 ) } } # [ inline ] pub fn set_FunctionNumber ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn DeviceNumber ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 5u8 ) as u16 ) } } # [ inline ] pub fn set_DeviceNumber ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 5u8 , val as u64 ) } } # [ inline ] pub fn BusNumber ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u16 ) } } # [ inline ] pub fn set_BusNumber ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( FunctionNumber : USHORT , DeviceNumber : USHORT , BusNumber : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let FunctionNumber : u16 = unsafe { :: std :: mem :: transmute ( FunctionNumber ) } ; FunctionNumber as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 5u8 , { let DeviceNumber : u16 = unsafe { :: std :: mem :: transmute ( DeviceNumber ) } ; DeviceNumber as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let BusNumber : u16 = unsafe { :: std :: mem :: transmute ( BusNumber ) } ; BusNumber as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_PME_REQUESTOR_ID = _PCI_EXPRESS_PME_REQUESTOR_ID ; pub type PPCI_EXPRESS_PME_REQUESTOR_ID = * mut _PCI_EXPRESS_PME_REQUESTOR_ID ; pub type PciPin2Line = :: std :: option :: Option < unsafe extern "C" fn ( BusHandler : * mut _BUS_HANDLER , RootHandler : * mut _BUS_HANDLER , SlotNumber : PCI_SLOT_NUMBER , PciData : PPCI_COMMON_CONFIG ) > ; pub type PciLine2Pin = :: std :: option :: Option < unsafe extern "C" fn ( BusHandler : * mut _BUS_HANDLER , RootHandler : * mut _BUS_HANDLER , SlotNumber : PCI_SLOT_NUMBER , PciNewData : PPCI_COMMON_CONFIG , PciOldData : PPCI_COMMON_CONFIG ) > ; pub type PciReadWriteConfig = :: std :: option :: Option < unsafe extern "C" fn ( BusHandler : * mut _BUS_HANDLER , Slot : PCI_SLOT_NUMBER , Buffer : PVOID , Offset : ULONG , Length : ULONG ) > ; # [ repr ( C ) ] pub struct _PCIBUSDATA { pub Tag : ULONG , pub Version : ULONG , pub ReadConfig : PciReadWriteConfig , pub WriteConfig : PciReadWriteConfig , pub Pin2Line : PciPin2Line , pub Line2Pin : PciLine2Pin , pub ParentSlot : PCI_SLOT_NUMBER , pub Reserved : [ PVOID ; 4usize ] , } pub type PCIBUSDATA = _PCIBUSDATA ; pub type PPCIBUSDATA = * mut _PCIBUSDATA ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_LTR_MAX_LATENCY_REGISTER { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_LTR_MAX_LATENCY_REGISTER__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_LTR_MAX_LATENCY_REGISTER__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PCI_EXPRESS_LTR_MAX_LATENCY_REGISTER__bindgen_ty_1 { # [ inline ] pub fn MaxSnoopLatencyValue ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 10u8 ) as u32 ) } } # [ inline ] pub fn set_MaxSnoopLatencyValue ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 10u8 , val as u64 ) } } # [ inline ] pub fn MaxSnoopLatencyScale ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_MaxSnoopLatencyScale ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 3u8 , val as u64 ) } } # [ inline ] pub fn Rsvd ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 13usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_Rsvd ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 13usize , 2u8 , val as u64 ) } } # [ inline ] pub fn MaxSnoopRequirement ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 15usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_MaxSnoopRequirement ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 15usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MaxNoSnoopLatencyValue ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 10u8 ) as u32 ) } } # [ inline ] pub fn set_MaxNoSnoopLatencyValue ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 10u8 , val as u64 ) } } # [ inline ] pub fn MaxNoSnoopLatencyScale ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 26usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_MaxNoSnoopLatencyScale ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 26usize , 3u8 , val as u64 ) } } # [ inline ] pub fn Rsvd2 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 29usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_Rsvd2 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 29usize , 2u8 , val as u64 ) } } # [ inline ] pub fn MaxNoSnoopRequirement ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 31usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_MaxNoSnoopRequirement ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 31usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( MaxSnoopLatencyValue : ULONG , MaxSnoopLatencyScale : ULONG , Rsvd : ULONG , MaxSnoopRequirement : ULONG , MaxNoSnoopLatencyValue : ULONG , MaxNoSnoopLatencyScale : ULONG , Rsvd2 : ULONG , MaxNoSnoopRequirement : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 10u8 , { let MaxSnoopLatencyValue : u32 = unsafe { :: std :: mem :: transmute ( MaxSnoopLatencyValue ) } ; MaxSnoopLatencyValue as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 3u8 , { let MaxSnoopLatencyScale : u32 = unsafe { :: std :: mem :: transmute ( MaxSnoopLatencyScale ) } ; MaxSnoopLatencyScale as u64 } ) ; __bindgen_bitfield_unit . set ( 13usize , 2u8 , { let Rsvd : u32 = unsafe { :: std :: mem :: transmute ( Rsvd ) } ; Rsvd as u64 } ) ; __bindgen_bitfield_unit . set ( 15usize , 1u8 , { let MaxSnoopRequirement : u32 = unsafe { :: std :: mem :: transmute ( MaxSnoopRequirement ) } ; MaxSnoopRequirement as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 10u8 , { let MaxNoSnoopLatencyValue : u32 = unsafe { :: std :: mem :: transmute ( MaxNoSnoopLatencyValue ) } ; MaxNoSnoopLatencyValue as u64 } ) ; __bindgen_bitfield_unit . set ( 26usize , 3u8 , { let MaxNoSnoopLatencyScale : u32 = unsafe { :: std :: mem :: transmute ( MaxNoSnoopLatencyScale ) } ; MaxNoSnoopLatencyScale as u64 } ) ; __bindgen_bitfield_unit . set ( 29usize , 2u8 , { let Rsvd2 : u32 = unsafe { :: std :: mem :: transmute ( Rsvd2 ) } ; Rsvd2 as u64 } ) ; __bindgen_bitfield_unit . set ( 31usize , 1u8 , { let MaxNoSnoopRequirement : u32 = unsafe { :: std :: mem :: transmute ( MaxNoSnoopRequirement ) } ; MaxNoSnoopRequirement as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_LTR_MAX_LATENCY_REGISTER = _PCI_EXPRESS_LTR_MAX_LATENCY_REGISTER ; pub type PPCI_EXPRESS_LTR_MAX_LATENCY_REGISTER = * mut _PCI_EXPRESS_LTR_MAX_LATENCY_REGISTER ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_LTR_CAPABILITY { pub Header : PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER , pub Latency : PCI_EXPRESS_LTR_MAX_LATENCY_REGISTER , } pub type PCI_EXPRESS_LTR_CAPABILITY = _PCI_EXPRESS_LTR_CAPABILITY ; pub type PPCI_EXPRESS_LTR_CAPABILITY = * mut _PCI_EXPRESS_LTR_CAPABILITY ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER__bindgen_ty_1 { # [ inline ] pub fn NoStModeSupported ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_NoStModeSupported ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn InteruptVectorModeSupported ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_InteruptVectorModeSupported ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn DeviceSpecificModeSupported ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_DeviceSpecificModeSupported ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Rsvd ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_Rsvd ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 5u8 , val as u64 ) } } # [ inline ] pub fn ExtendedTPHRequesterSupported ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ExtendedTPHRequesterSupported ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn StTableLocation ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_StTableLocation ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 2u8 , val as u64 ) } } # [ inline ] pub fn Rsvd2 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_Rsvd2 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 5u8 , val as u64 ) } } # [ inline ] pub fn StTableSize ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 11u8 ) as u32 ) } } # [ inline ] pub fn set_StTableSize ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 11u8 , val as u64 ) } } # [ inline ] pub fn Rsvd3 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 27usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_Rsvd3 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 27usize , 5u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( NoStModeSupported : ULONG , InteruptVectorModeSupported : ULONG , DeviceSpecificModeSupported : ULONG , Rsvd : ULONG , ExtendedTPHRequesterSupported : ULONG , StTableLocation : ULONG , Rsvd2 : ULONG , StTableSize : ULONG , Rsvd3 : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let NoStModeSupported : u32 = unsafe { :: std :: mem :: transmute ( NoStModeSupported ) } ; NoStModeSupported as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let InteruptVectorModeSupported : u32 = unsafe { :: std :: mem :: transmute ( InteruptVectorModeSupported ) } ; InteruptVectorModeSupported as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let DeviceSpecificModeSupported : u32 = unsafe { :: std :: mem :: transmute ( DeviceSpecificModeSupported ) } ; DeviceSpecificModeSupported as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 5u8 , { let Rsvd : u32 = unsafe { :: std :: mem :: transmute ( Rsvd ) } ; Rsvd as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let ExtendedTPHRequesterSupported : u32 = unsafe { :: std :: mem :: transmute ( ExtendedTPHRequesterSupported ) } ; ExtendedTPHRequesterSupported as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 2u8 , { let StTableLocation : u32 = unsafe { :: std :: mem :: transmute ( StTableLocation ) } ; StTableLocation as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 5u8 , { let Rsvd2 : u32 = unsafe { :: std :: mem :: transmute ( Rsvd2 ) } ; Rsvd2 as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 11u8 , { let StTableSize : u32 = unsafe { :: std :: mem :: transmute ( StTableSize ) } ; StTableSize as u64 } ) ; __bindgen_bitfield_unit . set ( 27usize , 5u8 , { let Rsvd3 : u32 = unsafe { :: std :: mem :: transmute ( Rsvd3 ) } ; Rsvd3 as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER = _PCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER ; pub type PPCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER = * mut _PCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER__bindgen_ty_1 { # [ inline ] pub fn StModeSelect ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_StModeSelect ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn Rsvd ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_Rsvd ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 5u8 , val as u64 ) } } # [ inline ] pub fn TphRequesterEnable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_TphRequesterEnable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 2u8 , val as u64 ) } } # [ inline ] pub fn Rsvd2 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 22u8 ) as u32 ) } } # [ inline ] pub fn set_Rsvd2 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 22u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( StModeSelect : ULONG , Rsvd : ULONG , TphRequesterEnable : ULONG , Rsvd2 : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let StModeSelect : u32 = unsafe { :: std :: mem :: transmute ( StModeSelect ) } ; StModeSelect as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 5u8 , { let Rsvd : u32 = unsafe { :: std :: mem :: transmute ( Rsvd ) } ; Rsvd as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 2u8 , { let TphRequesterEnable : u32 = unsafe { :: std :: mem :: transmute ( TphRequesterEnable ) } ; TphRequesterEnable as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 22u8 , { let Rsvd2 : u32 = unsafe { :: std :: mem :: transmute ( Rsvd2 ) } ; Rsvd2 as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER = _PCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER ; pub type PPCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER = * mut _PCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_TPH_ST_TABLE_ENTRY { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_TPH_ST_TABLE_ENTRY__bindgen_ty_1 > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : u16 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_TPH_ST_TABLE_ENTRY__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl _PCI_EXPRESS_TPH_ST_TABLE_ENTRY__bindgen_ty_1 { # [ inline ] pub fn LowerEntry ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u16 ) } } # [ inline ] pub fn set_LowerEntry ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn UpperEntry ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u16 ) } } # [ inline ] pub fn set_UpperEntry ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( LowerEntry : USHORT , UpperEntry : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let LowerEntry : u16 = unsafe { :: std :: mem :: transmute ( LowerEntry ) } ; LowerEntry as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let UpperEntry : u16 = unsafe { :: std :: mem :: transmute ( UpperEntry ) } ; UpperEntry as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_TPH_ST_TABLE_ENTRY = _PCI_EXPRESS_TPH_ST_TABLE_ENTRY ; pub type PPCI_EXPRESS_TPH_ST_TABLE_ENTRY = * mut _PCI_EXPRESS_TPH_ST_TABLE_ENTRY ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_TPH_REQUESTER_CAPABILITY { pub Header : PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER , pub RequesterCapability : PCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER , pub RequesterControl : PCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER , } pub type PCI_EXPRESS_TPH_REQUESTER_CAPABILITY = _PCI_EXPRESS_TPH_REQUESTER_CAPABILITY ; pub type PPCI_EXPRESS_TPH_REQUESTER_CAPABILITY = * mut _PCI_EXPRESS_TPH_REQUESTER_CAPABILITY ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER__bindgen_ty_1 { # [ inline ] pub fn PciPmL12Supported ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_PciPmL12Supported ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PciPmL11Supported ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_PciPmL11Supported ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AspmL12Supported ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AspmL12Supported ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AspmL11Supported ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AspmL11Supported ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn L1PmSsSupported ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_L1PmSsSupported ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Rsvd ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_Rsvd ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn PortCommonModeRestoreTime ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_PortCommonModeRestoreTime ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn PortTPowerOnScale ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_PortTPowerOnScale ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 2u8 , val as u64 ) } } # [ inline ] pub fn Rsvd2 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 18usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Rsvd2 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 18usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PortTPowerOnValue ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 19usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_PortTPowerOnValue ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 19usize , 5u8 , val as u64 ) } } # [ inline ] pub fn Rsvd3 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_Rsvd3 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( PciPmL12Supported : ULONG , PciPmL11Supported : ULONG , AspmL12Supported : ULONG , AspmL11Supported : ULONG , L1PmSsSupported : ULONG , Rsvd : ULONG , PortCommonModeRestoreTime : ULONG , PortTPowerOnScale : ULONG , Rsvd2 : ULONG , PortTPowerOnValue : ULONG , Rsvd3 : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let PciPmL12Supported : u32 = unsafe { :: std :: mem :: transmute ( PciPmL12Supported ) } ; PciPmL12Supported as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let PciPmL11Supported : u32 = unsafe { :: std :: mem :: transmute ( PciPmL11Supported ) } ; PciPmL11Supported as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let AspmL12Supported : u32 = unsafe { :: std :: mem :: transmute ( AspmL12Supported ) } ; AspmL12Supported as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let AspmL11Supported : u32 = unsafe { :: std :: mem :: transmute ( AspmL11Supported ) } ; AspmL11Supported as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let L1PmSsSupported : u32 = unsafe { :: std :: mem :: transmute ( L1PmSsSupported ) } ; L1PmSsSupported as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let Rsvd : u32 = unsafe { :: std :: mem :: transmute ( Rsvd ) } ; Rsvd as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let PortCommonModeRestoreTime : u32 = unsafe { :: std :: mem :: transmute ( PortCommonModeRestoreTime ) } ; PortCommonModeRestoreTime as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 2u8 , { let PortTPowerOnScale : u32 = unsafe { :: std :: mem :: transmute ( PortTPowerOnScale ) } ; PortTPowerOnScale as u64 } ) ; __bindgen_bitfield_unit . set ( 18usize , 1u8 , { let Rsvd2 : u32 = unsafe { :: std :: mem :: transmute ( Rsvd2 ) } ; Rsvd2 as u64 } ) ; __bindgen_bitfield_unit . set ( 19usize , 5u8 , { let PortTPowerOnValue : u32 = unsafe { :: std :: mem :: transmute ( PortTPowerOnValue ) } ; PortTPowerOnValue as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let Rsvd3 : u32 = unsafe { :: std :: mem :: transmute ( Rsvd3 ) } ; Rsvd3 as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER = _PCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER ; pub type PPCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER = * mut _PCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER__bindgen_ty_1 { # [ inline ] pub fn PciPmL12Enabled ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_PciPmL12Enabled ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PciPmL11Enabled ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_PciPmL11Enabled ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AspmL12Enabled ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AspmL12Enabled ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AspmL11Enabled ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AspmL11Enabled ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Rsvd ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_Rsvd ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn CommonModeRestoreTime ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_CommonModeRestoreTime ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn LtrL12ThresholdValue ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 10u8 ) as u32 ) } } # [ inline ] pub fn set_LtrL12ThresholdValue ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 10u8 , val as u64 ) } } # [ inline ] pub fn Rsvd2 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 26usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_Rsvd2 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 26usize , 3u8 , val as u64 ) } } # [ inline ] pub fn LtrL12ThresholdScale ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 29usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_LtrL12ThresholdScale ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 29usize , 3u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( PciPmL12Enabled : ULONG , PciPmL11Enabled : ULONG , AspmL12Enabled : ULONG , AspmL11Enabled : ULONG , Rsvd : ULONG , CommonModeRestoreTime : ULONG , LtrL12ThresholdValue : ULONG , Rsvd2 : ULONG , LtrL12ThresholdScale : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let PciPmL12Enabled : u32 = unsafe { :: std :: mem :: transmute ( PciPmL12Enabled ) } ; PciPmL12Enabled as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let PciPmL11Enabled : u32 = unsafe { :: std :: mem :: transmute ( PciPmL11Enabled ) } ; PciPmL11Enabled as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let AspmL12Enabled : u32 = unsafe { :: std :: mem :: transmute ( AspmL12Enabled ) } ; AspmL12Enabled as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let AspmL11Enabled : u32 = unsafe { :: std :: mem :: transmute ( AspmL11Enabled ) } ; AspmL11Enabled as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let Rsvd : u32 = unsafe { :: std :: mem :: transmute ( Rsvd ) } ; Rsvd as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let CommonModeRestoreTime : u32 = unsafe { :: std :: mem :: transmute ( CommonModeRestoreTime ) } ; CommonModeRestoreTime as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 10u8 , { let LtrL12ThresholdValue : u32 = unsafe { :: std :: mem :: transmute ( LtrL12ThresholdValue ) } ; LtrL12ThresholdValue as u64 } ) ; __bindgen_bitfield_unit . set ( 26usize , 3u8 , { let Rsvd2 : u32 = unsafe { :: std :: mem :: transmute ( Rsvd2 ) } ; Rsvd2 as u64 } ) ; __bindgen_bitfield_unit . set ( 29usize , 3u8 , { let LtrL12ThresholdScale : u32 = unsafe { :: std :: mem :: transmute ( LtrL12ThresholdScale ) } ; LtrL12ThresholdScale as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER = _PCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER ; pub type PPCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER = * mut _PCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER__bindgen_ty_1 { # [ inline ] pub fn TPowerOnScale ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_TPowerOnScale ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 2u8 , val as u64 ) } } # [ inline ] pub fn Rsvd ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Rsvd ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn TPowerOnValue ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_TPowerOnValue ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 5u8 , val as u64 ) } } # [ inline ] pub fn Rsvd2 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 24u8 ) as u32 ) } } # [ inline ] pub fn set_Rsvd2 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 24u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( TPowerOnScale : ULONG , Rsvd : ULONG , TPowerOnValue : ULONG , Rsvd2 : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 2u8 , { let TPowerOnScale : u32 = unsafe { :: std :: mem :: transmute ( TPowerOnScale ) } ; TPowerOnScale as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let Rsvd : u32 = unsafe { :: std :: mem :: transmute ( Rsvd ) } ; Rsvd as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 5u8 , { let TPowerOnValue : u32 = unsafe { :: std :: mem :: transmute ( TPowerOnValue ) } ; TPowerOnValue as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 24u8 , { let Rsvd2 : u32 = unsafe { :: std :: mem :: transmute ( Rsvd2 ) } ; Rsvd2 as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER = _PCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER ; pub type PPCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER = * mut _PCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_L1_PM_SS_CAPABILITY { pub Header : PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER , pub L1PmSsCapabilities : PCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER , pub L1PmSsControl1 : PCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER , pub L1PmSsControl2 : PCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER , } pub type PCI_EXPRESS_L1_PM_SS_CAPABILITY = _PCI_EXPRESS_L1_PM_SS_CAPABILITY ; pub type PPCI_EXPRESS_L1_PM_SS_CAPABILITY = * mut _PCI_EXPRESS_L1_PM_SS_CAPABILITY ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER__bindgen_ty_1 { # [ inline ] pub fn Rsvd ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_Rsvd ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn SizesSupported ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 20u8 ) as u32 ) } } # [ inline ] pub fn set_SizesSupported ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 20u8 , val as u64 ) } } # [ inline ] pub fn Rsvd2 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_Rsvd2 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Rsvd : ULONG , SizesSupported : ULONG , Rsvd2 : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let Rsvd : u32 = unsafe { :: std :: mem :: transmute ( Rsvd ) } ; Rsvd as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 20u8 , { let SizesSupported : u32 = unsafe { :: std :: mem :: transmute ( SizesSupported ) } ; SizesSupported as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let Rsvd2 : u32 = unsafe { :: std :: mem :: transmute ( Rsvd2 ) } ; Rsvd2 as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER = _PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER ; pub type PPCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER = * mut _PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER { pub __bindgen_anon_1 : __BindgenUnionField < _PCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _PCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _PCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER__bindgen_ty_1 { # [ inline ] pub fn BarIndex ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_BarIndex ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn Rsvd ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_Rsvd ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 2u8 , val as u64 ) } } # [ inline ] pub fn NumberOfResizableBars ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_NumberOfResizableBars ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn BarSize ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_BarSize ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 5u8 , val as u64 ) } } # [ inline ] pub fn Rsvd2 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 13usize , 19u8 ) as u32 ) } } # [ inline ] pub fn set_Rsvd2 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 13usize , 19u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( BarIndex : ULONG , Rsvd : ULONG , NumberOfResizableBars : ULONG , BarSize : ULONG , Rsvd2 : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let BarIndex : u32 = unsafe { :: std :: mem :: transmute ( BarIndex ) } ; BarIndex as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 2u8 , { let Rsvd : u32 = unsafe { :: std :: mem :: transmute ( Rsvd ) } ; Rsvd as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let NumberOfResizableBars : u32 = unsafe { :: std :: mem :: transmute ( NumberOfResizableBars ) } ; NumberOfResizableBars as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 5u8 , { let BarSize : u32 = unsafe { :: std :: mem :: transmute ( BarSize ) } ; BarSize as u64 } ) ; __bindgen_bitfield_unit . set ( 13usize , 19u8 , { let Rsvd2 : u32 = unsafe { :: std :: mem :: transmute ( Rsvd2 ) } ; Rsvd2 as u64 } ) ; __bindgen_bitfield_unit } } pub type PCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER = _PCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER ; pub type PPCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER = * mut _PCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_RESIZABLE_BAR_ENTRY { pub Capability : PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER , pub Control : PCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER , } pub type PCI_EXPRESS_RESIZABLE_BAR_ENTRY = _PCI_EXPRESS_RESIZABLE_BAR_ENTRY ; pub type PPCI_EXPRESS_RESIZABLE_BAR_ENTRY = * mut _PCI_EXPRESS_RESIZABLE_BAR_ENTRY ; # [ repr ( C ) ] pub struct _PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY { pub Header : PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER , pub Entry : [ PCI_EXPRESS_RESIZABLE_BAR_ENTRY ; 6usize ] , } pub type PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY = _PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY ; pub type PPCI_EXPRESS_RESIZABLE_BAR_CAPABILITY = * mut _PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY ; pub type PCI_READ_WRITE_CONFIG = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , BusOffset : ULONG , Slot : ULONG , Buffer : PVOID , Offset : ULONG , Length : ULONG ) -> ULONG > ; pub type PPCI_READ_WRITE_CONFIG = PCI_READ_WRITE_CONFIG ; pub type PCI_PIN_TO_LINE = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , PciData : PPCI_COMMON_CONFIG ) > ; pub type PPCI_PIN_TO_LINE = PCI_PIN_TO_LINE ; pub type PCI_LINE_TO_PIN = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , PciNewData : PPCI_COMMON_CONFIG , PciOldData : PPCI_COMMON_CONFIG ) > ; pub type PPCI_LINE_TO_PIN = PCI_LINE_TO_PIN ; pub type PCI_ROOT_BUS_CAPABILITY = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , HardwareCapability : PPCI_ROOT_BUS_HARDWARE_CAPABILITY ) > ; pub type PPCI_ROOT_BUS_CAPABILITY = PCI_ROOT_BUS_CAPABILITY ; pub type PCI_EXPRESS_WAKE_CONTROL = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID , EnableWake : BOOLEAN ) > ; pub type PPCI_EXPRESS_WAKE_CONTROL = PCI_EXPRESS_WAKE_CONTROL ; pub type PCI_PREPARE_MULTISTAGE_RESUME = :: std :: option :: Option < unsafe extern "C" fn ( Context : PVOID ) > ; pub type PPCI_PREPARE_MULTISTAGE_RESUME = PCI_PREPARE_MULTISTAGE_RESUME ; # [ repr ( C ) ] pub struct _PCI_BUS_INTERFACE_STANDARD { pub Size : USHORT , pub Version : USHORT , pub Context : PVOID , pub InterfaceReference : PINTERFACE_REFERENCE , pub InterfaceDereference : PINTERFACE_DEREFERENCE , pub ReadConfig : PPCI_READ_WRITE_CONFIG , pub WriteConfig : PPCI_READ_WRITE_CONFIG , pub PinToLine : PPCI_PIN_TO_LINE , pub LineToPin : PPCI_LINE_TO_PIN , pub RootBusCapability : PPCI_ROOT_BUS_CAPABILITY , pub ExpressWakeControl : PPCI_EXPRESS_WAKE_CONTROL , pub PrepareMultistageResume : PPCI_PREPARE_MULTISTAGE_RESUME , } pub type PCI_BUS_INTERFACE_STANDARD = _PCI_BUS_INTERFACE_STANDARD ; pub type PPCI_BUS_INTERFACE_STANDARD = * mut _PCI_BUS_INTERFACE_STANDARD ; extern "C" { pub fn ZwSetInformationThread ( ThreadHandle : HANDLE , ThreadInformationClass : THREADINFOCLASS , ThreadInformation : PVOID , ThreadInformationLength : ULONG ) -> NTSTATUS ; } extern "C" { pub fn ZwCreateTimer ( TimerHandle : PHANDLE , DesiredAccess : ACCESS_MASK , ObjectAttributes : POBJECT_ATTRIBUTES , TimerType : TIMER_TYPE ) -> NTSTATUS ; } extern "C" { pub fn ZwOpenTimer ( TimerHandle : PHANDLE , DesiredAccess : ACCESS_MASK , ObjectAttributes : POBJECT_ATTRIBUTES ) -> NTSTATUS ; } extern "C" { pub fn ZwCancelTimer ( TimerHandle : HANDLE , CurrentState : PBOOLEAN ) -> NTSTATUS ; } extern "C" { pub fn ZwSetTimer ( TimerHandle : HANDLE , DueTime : PLARGE_INTEGER , TimerApcRoutine : PTIMER_APC_ROUTINE , TimerContext : PVOID , ResumeTimer : BOOLEAN , Period : LONG , PreviousState : PBOOLEAN ) -> NTSTATUS ; } extern "C" { pub fn ZwSetTimerEx ( TimerHandle : HANDLE , TimerSetInformationClass : TIMER_SET_INFORMATION_CLASS , TimerSetInformation : PVOID , TimerSetInformationLength : ULONG ) -> NTSTATUS ; } extern "C" { pub fn ZwQueryVolumeInformationFile ( FileHandle : HANDLE , IoStatusBlock : PIO_STATUS_BLOCK , FsInformation : PVOID , Length : ULONG , FsInformationClass : FS_INFORMATION_CLASS ) -> NTSTATUS ; } extern "C" { pub fn ZwDeviceIoControlFile ( FileHandle : HANDLE , Event : HANDLE , ApcRoutine : PIO_APC_ROUTINE , ApcContext : PVOID , IoStatusBlock : PIO_STATUS_BLOCK , IoControlCode : ULONG , InputBuffer : PVOID , InputBufferLength : ULONG , OutputBuffer : PVOID , OutputBufferLength : ULONG ) -> NTSTATUS ; } extern "C" { pub fn ZwDisplayString ( String : PUNICODE_STRING ) -> NTSTATUS ; } extern "C" { pub fn ZwPowerInformation ( InformationLevel : POWER_INFORMATION_LEVEL , InputBuffer : PVOID , InputBufferLength : ULONG , OutputBuffer : PVOID , OutputBufferLength : ULONG ) -> NTSTATUS ; } extern "C" { pub fn ZwAllocateLocallyUniqueId ( Luid : PLUID ) -> NTSTATUS ; } extern "C" { pub fn ZwTerminateProcess ( ProcessHandle : HANDLE , ExitStatus : NTSTATUS ) -> NTSTATUS ; } extern "C" { pub fn ZwOpenProcess ( ProcessHandle : PHANDLE , DesiredAccess : ACCESS_MASK , ObjectAttributes : POBJECT_ATTRIBUTES , ClientId : PCLIENT_ID ) -> NTSTATUS ; } pub const _WHEA_ERROR_SOURCE_TYPE_WheaErrSrcTypeMCE : _WHEA_ERROR_SOURCE_TYPE = 0 ; pub const _WHEA_ERROR_SOURCE_TYPE_WheaErrSrcTypeCMC : _WHEA_ERROR_SOURCE_TYPE = 1 ; pub const _WHEA_ERROR_SOURCE_TYPE_WheaErrSrcTypeCPE : _WHEA_ERROR_SOURCE_TYPE = 2 ; pub const _WHEA_ERROR_SOURCE_TYPE_WheaErrSrcTypeNMI : _WHEA_ERROR_SOURCE_TYPE = 3 ; pub const _WHEA_ERROR_SOURCE_TYPE_WheaErrSrcTypePCIe : _WHEA_ERROR_SOURCE_TYPE = 4 ; pub const _WHEA_ERROR_SOURCE_TYPE_WheaErrSrcTypeGeneric : _WHEA_ERROR_SOURCE_TYPE = 5 ; pub const _WHEA_ERROR_SOURCE_TYPE_WheaErrSrcTypeINIT : _WHEA_ERROR_SOURCE_TYPE = 6 ; pub const _WHEA_ERROR_SOURCE_TYPE_WheaErrSrcTypeBOOT : _WHEA_ERROR_SOURCE_TYPE = 7 ; pub const _WHEA_ERROR_SOURCE_TYPE_WheaErrSrcTypeSCIGeneric : _WHEA_ERROR_SOURCE_TYPE = 8 ; pub const _WHEA_ERROR_SOURCE_TYPE_WheaErrSrcTypeIPFMCA : _WHEA_ERROR_SOURCE_TYPE = 9 ; pub const _WHEA_ERROR_SOURCE_TYPE_WheaErrSrcTypeIPFCMC : _WHEA_ERROR_SOURCE_TYPE = 10 ; pub const _WHEA_ERROR_SOURCE_TYPE_WheaErrSrcTypeIPFCPE : _WHEA_ERROR_SOURCE_TYPE = 11 ; pub const _WHEA_ERROR_SOURCE_TYPE_WheaErrSrcTypeGenericV2 : _WHEA_ERROR_SOURCE_TYPE = 12 ; pub const _WHEA_ERROR_SOURCE_TYPE_WheaErrSrcTypeSCIGenericV2 : _WHEA_ERROR_SOURCE_TYPE = 13 ; pub const _WHEA_ERROR_SOURCE_TYPE_WheaErrSrcTypeMax : _WHEA_ERROR_SOURCE_TYPE = 14 ; pub type _WHEA_ERROR_SOURCE_TYPE = i32 ; pub use self :: _WHEA_ERROR_SOURCE_TYPE as WHEA_ERROR_SOURCE_TYPE ; pub type PWHEA_ERROR_SOURCE_TYPE = * mut _WHEA_ERROR_SOURCE_TYPE ; pub const _WHEA_ERROR_SOURCE_STATE_WheaErrSrcStateStopped : _WHEA_ERROR_SOURCE_STATE = 1 ; pub const _WHEA_ERROR_SOURCE_STATE_WheaErrSrcStateStarted : _WHEA_ERROR_SOURCE_STATE = 2 ; pub type _WHEA_ERROR_SOURCE_STATE = i32 ; pub use self :: _WHEA_ERROR_SOURCE_STATE as WHEA_ERROR_SOURCE_STATE ; pub type PWHEA_ERROR_SOURCE_STATE = * mut _WHEA_ERROR_SOURCE_STATE ; # [ repr ( C , packed ) ] pub struct _WHEA_NOTIFICATION_FLAGS { pub __bindgen_anon_1 : __BindgenUnionField < _WHEA_NOTIFICATION_FLAGS__bindgen_ty_1 > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : [ u8 ; 2usize ] , } # [ repr ( C , packed ) ] pub struct _WHEA_NOTIFICATION_FLAGS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > , } impl _WHEA_NOTIFICATION_FLAGS__bindgen_ty_1 { # [ inline ] pub fn PollIntervalRW ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_PollIntervalRW ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn SwitchToPollingThresholdRW ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_SwitchToPollingThresholdRW ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn SwitchToPollingWindowRW ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_SwitchToPollingWindowRW ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ErrorThresholdRW ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_ErrorThresholdRW ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ErrorThresholdWindowRW ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_ErrorThresholdWindowRW ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 11u8 ) as u16 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 11u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( PollIntervalRW : USHORT , SwitchToPollingThresholdRW : USHORT , SwitchToPollingWindowRW : USHORT , ErrorThresholdRW : USHORT , ErrorThresholdWindowRW : USHORT , Reserved : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let PollIntervalRW : u16 = unsafe { :: std :: mem :: transmute ( PollIntervalRW ) } ; PollIntervalRW as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let SwitchToPollingThresholdRW : u16 = unsafe { :: std :: mem :: transmute ( SwitchToPollingThresholdRW ) } ; SwitchToPollingThresholdRW as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let SwitchToPollingWindowRW : u16 = unsafe { :: std :: mem :: transmute ( SwitchToPollingWindowRW ) } ; SwitchToPollingWindowRW as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let ErrorThresholdRW : u16 = unsafe { :: std :: mem :: transmute ( ErrorThresholdRW ) } ; ErrorThresholdRW as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let ErrorThresholdWindowRW : u16 = unsafe { :: std :: mem :: transmute ( ErrorThresholdWindowRW ) } ; ErrorThresholdWindowRW as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 11u8 , { let Reserved : u16 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_NOTIFICATION_FLAGS = _WHEA_NOTIFICATION_FLAGS ; pub type PWHEA_NOTIFICATION_FLAGS = * mut _WHEA_NOTIFICATION_FLAGS ; # [ repr ( C ) ] pub struct _XPF_MC_BANK_FLAGS { pub __bindgen_anon_1 : __BindgenUnionField < _XPF_MC_BANK_FLAGS__bindgen_ty_1 > , pub AsUCHAR : __BindgenUnionField < UCHAR > , pub bindgen_union_field : u8 , } # [ repr ( C , packed ) ] pub struct _XPF_MC_BANK_FLAGS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl _XPF_MC_BANK_FLAGS__bindgen_ty_1 { # [ inline ] pub fn ClearOnInitializationRW ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_ClearOnInitializationRW ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ControlDataRW ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_ControlDataRW ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 6u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ClearOnInitializationRW : UCHAR , ControlDataRW : UCHAR , Reserved : UCHAR ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let ClearOnInitializationRW : u8 = unsafe { :: std :: mem :: transmute ( ClearOnInitializationRW ) } ; ClearOnInitializationRW as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let ControlDataRW : u8 = unsafe { :: std :: mem :: transmute ( ControlDataRW ) } ; ControlDataRW as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 6u8 , { let Reserved : u8 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type XPF_MC_BANK_FLAGS = _XPF_MC_BANK_FLAGS ; pub type PXPF_MC_BANK_FLAGS = * mut _XPF_MC_BANK_FLAGS ; # [ repr ( C , packed ) ] pub struct _XPF_MCE_FLAGS { pub __bindgen_anon_1 : __BindgenUnionField < _XPF_MCE_FLAGS__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : [ u8 ; 4usize ] , } # [ repr ( C , packed ) ] pub struct _XPF_MCE_FLAGS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , } impl _XPF_MCE_FLAGS__bindgen_ty_1 { # [ inline ] pub fn MCG_CapabilityRW ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_MCG_CapabilityRW ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MCG_GlobalControlRW ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_MCG_GlobalControlRW ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 30u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 30u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( MCG_CapabilityRW : ULONG , MCG_GlobalControlRW : ULONG , Reserved : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let MCG_CapabilityRW : u32 = unsafe { :: std :: mem :: transmute ( MCG_CapabilityRW ) } ; MCG_CapabilityRW as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let MCG_GlobalControlRW : u32 = unsafe { :: std :: mem :: transmute ( MCG_GlobalControlRW ) } ; MCG_GlobalControlRW as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 30u8 , { let Reserved : u32 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type XPF_MCE_FLAGS = _XPF_MCE_FLAGS ; pub type PXPF_MCE_FLAGS = * mut _XPF_MCE_FLAGS ; # [ repr ( C , packed ) ] pub struct _AER_ROOTPORT_DESCRIPTOR_FLAGS { pub __bindgen_anon_1 : __BindgenUnionField < _AER_ROOTPORT_DESCRIPTOR_FLAGS__bindgen_ty_1 > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : [ u8 ; 2usize ] , } # [ repr ( C , packed ) ] pub struct _AER_ROOTPORT_DESCRIPTOR_FLAGS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > , } impl _AER_ROOTPORT_DESCRIPTOR_FLAGS__bindgen_ty_1 { # [ inline ] pub fn UncorrectableErrorMaskRW ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_UncorrectableErrorMaskRW ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UncorrectableErrorSeverityRW ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_UncorrectableErrorSeverityRW ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn CorrectableErrorMaskRW ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_CorrectableErrorMaskRW ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AdvancedCapsAndControlRW ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_AdvancedCapsAndControlRW ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn RootErrorCommandRW ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_RootErrorCommandRW ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 11u8 ) as u16 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 11u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( UncorrectableErrorMaskRW : USHORT , UncorrectableErrorSeverityRW : USHORT , CorrectableErrorMaskRW : USHORT , AdvancedCapsAndControlRW : USHORT , RootErrorCommandRW : USHORT , Reserved : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let UncorrectableErrorMaskRW : u16 = unsafe { :: std :: mem :: transmute ( UncorrectableErrorMaskRW ) } ; UncorrectableErrorMaskRW as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let UncorrectableErrorSeverityRW : u16 = unsafe { :: std :: mem :: transmute ( UncorrectableErrorSeverityRW ) } ; UncorrectableErrorSeverityRW as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let CorrectableErrorMaskRW : u16 = unsafe { :: std :: mem :: transmute ( CorrectableErrorMaskRW ) } ; CorrectableErrorMaskRW as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let AdvancedCapsAndControlRW : u16 = unsafe { :: std :: mem :: transmute ( AdvancedCapsAndControlRW ) } ; AdvancedCapsAndControlRW as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let RootErrorCommandRW : u16 = unsafe { :: std :: mem :: transmute ( RootErrorCommandRW ) } ; RootErrorCommandRW as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 11u8 , { let Reserved : u16 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type AER_ROOTPORT_DESCRIPTOR_FLAGS = _AER_ROOTPORT_DESCRIPTOR_FLAGS ; pub type PAER_ROOTPORT_DESCRIPTOR_FLAGS = * mut _AER_ROOTPORT_DESCRIPTOR_FLAGS ; # [ repr ( C , packed ) ] pub struct _AER_ENDPOINT_DESCRIPTOR_FLAGS { pub __bindgen_anon_1 : __BindgenUnionField < _AER_ENDPOINT_DESCRIPTOR_FLAGS__bindgen_ty_1 > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : [ u8 ; 2usize ] , } # [ repr ( C , packed ) ] pub struct _AER_ENDPOINT_DESCRIPTOR_FLAGS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > , } impl _AER_ENDPOINT_DESCRIPTOR_FLAGS__bindgen_ty_1 { # [ inline ] pub fn UncorrectableErrorMaskRW ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_UncorrectableErrorMaskRW ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UncorrectableErrorSeverityRW ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_UncorrectableErrorSeverityRW ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn CorrectableErrorMaskRW ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_CorrectableErrorMaskRW ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AdvancedCapsAndControlRW ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_AdvancedCapsAndControlRW ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 12u8 ) as u16 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 12u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( UncorrectableErrorMaskRW : USHORT , UncorrectableErrorSeverityRW : USHORT , CorrectableErrorMaskRW : USHORT , AdvancedCapsAndControlRW : USHORT , Reserved : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let UncorrectableErrorMaskRW : u16 = unsafe { :: std :: mem :: transmute ( UncorrectableErrorMaskRW ) } ; UncorrectableErrorMaskRW as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let UncorrectableErrorSeverityRW : u16 = unsafe { :: std :: mem :: transmute ( UncorrectableErrorSeverityRW ) } ; UncorrectableErrorSeverityRW as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let CorrectableErrorMaskRW : u16 = unsafe { :: std :: mem :: transmute ( CorrectableErrorMaskRW ) } ; CorrectableErrorMaskRW as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let AdvancedCapsAndControlRW : u16 = unsafe { :: std :: mem :: transmute ( AdvancedCapsAndControlRW ) } ; AdvancedCapsAndControlRW as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 12u8 , { let Reserved : u16 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type AER_ENDPOINT_DESCRIPTOR_FLAGS = _AER_ENDPOINT_DESCRIPTOR_FLAGS ; pub type PAER_ENDPOINT_DESCRIPTOR_FLAGS = * mut _AER_ENDPOINT_DESCRIPTOR_FLAGS ; # [ repr ( C , packed ) ] pub struct _AER_BRIDGE_DESCRIPTOR_FLAGS { pub __bindgen_anon_1 : __BindgenUnionField < _AER_BRIDGE_DESCRIPTOR_FLAGS__bindgen_ty_1 > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : [ u8 ; 2usize ] , } # [ repr ( C , packed ) ] pub struct _AER_BRIDGE_DESCRIPTOR_FLAGS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > , } impl _AER_BRIDGE_DESCRIPTOR_FLAGS__bindgen_ty_1 { # [ inline ] pub fn UncorrectableErrorMaskRW ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_UncorrectableErrorMaskRW ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UncorrectableErrorSeverityRW ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_UncorrectableErrorSeverityRW ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn CorrectableErrorMaskRW ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_CorrectableErrorMaskRW ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AdvancedCapsAndControlRW ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_AdvancedCapsAndControlRW ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn SecondaryUncorrectableErrorMaskRW ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_SecondaryUncorrectableErrorMaskRW ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn SecondaryUncorrectableErrorSevRW ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_SecondaryUncorrectableErrorSevRW ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn SecondaryCapsAndControlRW ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_SecondaryCapsAndControlRW ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 9u8 ) as u16 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 9u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( UncorrectableErrorMaskRW : USHORT , UncorrectableErrorSeverityRW : USHORT , CorrectableErrorMaskRW : USHORT , AdvancedCapsAndControlRW : USHORT , SecondaryUncorrectableErrorMaskRW : USHORT , SecondaryUncorrectableErrorSevRW : USHORT , SecondaryCapsAndControlRW : USHORT , Reserved : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let UncorrectableErrorMaskRW : u16 = unsafe { :: std :: mem :: transmute ( UncorrectableErrorMaskRW ) } ; UncorrectableErrorMaskRW as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let UncorrectableErrorSeverityRW : u16 = unsafe { :: std :: mem :: transmute ( UncorrectableErrorSeverityRW ) } ; UncorrectableErrorSeverityRW as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let CorrectableErrorMaskRW : u16 = unsafe { :: std :: mem :: transmute ( CorrectableErrorMaskRW ) } ; CorrectableErrorMaskRW as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let AdvancedCapsAndControlRW : u16 = unsafe { :: std :: mem :: transmute ( AdvancedCapsAndControlRW ) } ; AdvancedCapsAndControlRW as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let SecondaryUncorrectableErrorMaskRW : u16 = unsafe { :: std :: mem :: transmute ( SecondaryUncorrectableErrorMaskRW ) } ; SecondaryUncorrectableErrorMaskRW as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let SecondaryUncorrectableErrorSevRW : u16 = unsafe { :: std :: mem :: transmute ( SecondaryUncorrectableErrorSevRW ) } ; SecondaryUncorrectableErrorSevRW as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let SecondaryCapsAndControlRW : u16 = unsafe { :: std :: mem :: transmute ( SecondaryCapsAndControlRW ) } ; SecondaryCapsAndControlRW as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 9u8 , { let Reserved : u16 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type AER_BRIDGE_DESCRIPTOR_FLAGS = _AER_BRIDGE_DESCRIPTOR_FLAGS ; pub type PAER_BRIDGE_DESCRIPTOR_FLAGS = * mut _AER_BRIDGE_DESCRIPTOR_FLAGS ; # [ repr ( C ) ] pub struct _WHEA_NOTIFICATION_DESCRIPTOR { pub Type : UCHAR , pub Length : UCHAR , pub Flags : WHEA_NOTIFICATION_FLAGS , pub u : _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1 { pub Polled : __BindgenUnionField < _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 > , pub Interrupt : __BindgenUnionField < _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 > , pub LocalInterrupt : __BindgenUnionField < _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3 > , pub Sci : __BindgenUnionField < _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4 > , pub Nmi : __BindgenUnionField < _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5 > , pub Sea : __BindgenUnionField < _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6 > , pub Sei : __BindgenUnionField < _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7 > , pub Gsiv : __BindgenUnionField < _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8 > , pub bindgen_union_field : [ u8 ; 24usize ] , } # [ repr ( C , packed ) ] pub struct _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 { pub PollInterval : ULONG , } # [ repr ( C , packed ) ] pub struct _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 { pub PollInterval : ULONG , pub Vector : ULONG , pub SwitchToPollingThreshold : ULONG , pub SwitchToPollingWindow : ULONG , pub ErrorThreshold : ULONG , pub ErrorThresholdWindow : ULONG , } # [ repr ( C , packed ) ] pub struct _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3 { pub PollInterval : ULONG , pub Vector : ULONG , pub SwitchToPollingThreshold : ULONG , pub SwitchToPollingWindow : ULONG , pub ErrorThreshold : ULONG , pub ErrorThresholdWindow : ULONG , } # [ repr ( C , packed ) ] pub struct _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4 { pub PollInterval : ULONG , pub Vector : ULONG , pub SwitchToPollingThreshold : ULONG , pub SwitchToPollingWindow : ULONG , pub ErrorThreshold : ULONG , pub ErrorThresholdWindow : ULONG , } # [ repr ( C , packed ) ] pub struct _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5 { pub PollInterval : ULONG , pub Vector : ULONG , pub SwitchToPollingThreshold : ULONG , pub SwitchToPollingWindow : ULONG , pub ErrorThreshold : ULONG , pub ErrorThresholdWindow : ULONG , } # [ repr ( C , packed ) ] pub struct _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6 { pub PollInterval : ULONG , pub Vector : ULONG , pub SwitchToPollingThreshold : ULONG , pub SwitchToPollingWindow : ULONG , pub ErrorThreshold : ULONG , pub ErrorThresholdWindow : ULONG , } # [ repr ( C , packed ) ] pub struct _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7 { pub PollInterval : ULONG , pub Vector : ULONG , pub SwitchToPollingThreshold : ULONG , pub SwitchToPollingWindow : ULONG , pub ErrorThreshold : ULONG , pub ErrorThresholdWindow : ULONG , } # [ repr ( C , packed ) ] pub struct _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8 { pub PollInterval : ULONG , pub Vector : ULONG , pub SwitchToPollingThreshold : ULONG , pub SwitchToPollingWindow : ULONG , pub ErrorThreshold : ULONG , pub ErrorThresholdWindow : ULONG , } pub type WHEA_NOTIFICATION_DESCRIPTOR = _WHEA_NOTIFICATION_DESCRIPTOR ; pub type PWHEA_NOTIFICATION_DESCRIPTOR = * mut _WHEA_NOTIFICATION_DESCRIPTOR ; # [ repr ( C , packed ) ] pub struct _WHEA_XPF_MC_BANK_DESCRIPTOR { pub BankNumber : UCHAR , pub ClearOnInitialization : BOOLEAN , pub StatusDataFormat : UCHAR , pub Flags : XPF_MC_BANK_FLAGS , pub ControlMsr : ULONG , pub StatusMsr : ULONG , pub AddressMsr : ULONG , pub MiscMsr : ULONG , pub ControlData : ULONGLONG , } pub type WHEA_XPF_MC_BANK_DESCRIPTOR = _WHEA_XPF_MC_BANK_DESCRIPTOR ; pub type PWHEA_XPF_MC_BANK_DESCRIPTOR = * mut _WHEA_XPF_MC_BANK_DESCRIPTOR ; # [ repr ( C , packed ) ] pub struct _WHEA_XPF_MCE_DESCRIPTOR { pub Type : USHORT , pub Enabled : UCHAR , pub NumberOfBanks : UCHAR , pub Flags : XPF_MCE_FLAGS , pub MCG_Capability : ULONGLONG , pub MCG_GlobalControl : ULONGLONG , pub Banks : [ WHEA_XPF_MC_BANK_DESCRIPTOR ; 32usize ] , } pub type WHEA_XPF_MCE_DESCRIPTOR = _WHEA_XPF_MCE_DESCRIPTOR ; pub type PWHEA_XPF_MCE_DESCRIPTOR = * mut _WHEA_XPF_MCE_DESCRIPTOR ; # [ repr ( C , packed ) ] pub struct _WHEA_XPF_CMC_DESCRIPTOR { pub Type : USHORT , pub Enabled : BOOLEAN , pub NumberOfBanks : UCHAR , pub Reserved : ULONG , pub Notify : WHEA_NOTIFICATION_DESCRIPTOR , pub Banks : [ WHEA_XPF_MC_BANK_DESCRIPTOR ; 32usize ] , } pub type WHEA_XPF_CMC_DESCRIPTOR = _WHEA_XPF_CMC_DESCRIPTOR ; pub type PWHEA_XPF_CMC_DESCRIPTOR = * mut _WHEA_XPF_CMC_DESCRIPTOR ; # [ repr ( C ) ] pub struct _WHEA_PCI_SLOT_NUMBER { pub u : _WHEA_PCI_SLOT_NUMBER__bindgen_ty_1 , } # [ repr ( C , packed ) ] pub struct _WHEA_PCI_SLOT_NUMBER__bindgen_ty_1 { pub bits : __BindgenUnionField < _WHEA_PCI_SLOT_NUMBER__bindgen_ty_1__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : [ u8 ; 4usize ] , } # [ repr ( C , packed ) ] pub struct _WHEA_PCI_SLOT_NUMBER__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , } impl _WHEA_PCI_SLOT_NUMBER__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn DeviceNumber ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_DeviceNumber ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 5u8 , val as u64 ) } } # [ inline ] pub fn FunctionNumber ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_FunctionNumber ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 24u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 24u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( DeviceNumber : ULONG , FunctionNumber : ULONG , Reserved : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 5u8 , { let DeviceNumber : u32 = unsafe { :: std :: mem :: transmute ( DeviceNumber ) } ; DeviceNumber as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let FunctionNumber : u32 = unsafe { :: std :: mem :: transmute ( FunctionNumber ) } ; FunctionNumber as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 24u8 , { let Reserved : u32 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_PCI_SLOT_NUMBER = _WHEA_PCI_SLOT_NUMBER ; pub type PWHEA_PCI_SLOT_NUMBER = * mut _WHEA_PCI_SLOT_NUMBER ; # [ repr ( C , packed ) ] pub struct _WHEA_XPF_NMI_DESCRIPTOR { pub Type : USHORT , pub Enabled : BOOLEAN , } pub type WHEA_XPF_NMI_DESCRIPTOR = _WHEA_XPF_NMI_DESCRIPTOR ; pub type PWHEA_XPF_NMI_DESCRIPTOR = * mut _WHEA_XPF_NMI_DESCRIPTOR ; # [ repr ( C , packed ) ] pub struct _WHEA_AER_ROOTPORT_DESCRIPTOR { pub Type : USHORT , pub Enabled : BOOLEAN , pub Reserved : UCHAR , pub BusNumber : ULONG , pub Slot : WHEA_PCI_SLOT_NUMBER , pub DeviceControl : USHORT , pub Flags : AER_ROOTPORT_DESCRIPTOR_FLAGS , pub UncorrectableErrorMask : ULONG , pub UncorrectableErrorSeverity : ULONG , pub CorrectableErrorMask : ULONG , pub AdvancedCapsAndControl : ULONG , pub RootErrorCommand : ULONG , } pub type WHEA_AER_ROOTPORT_DESCRIPTOR = _WHEA_AER_ROOTPORT_DESCRIPTOR ; pub type PWHEA_AER_ROOTPORT_DESCRIPTOR = * mut _WHEA_AER_ROOTPORT_DESCRIPTOR ; # [ repr ( C , packed ) ] pub struct _WHEA_AER_ENDPOINT_DESCRIPTOR { pub Type : USHORT , pub Enabled : BOOLEAN , pub Reserved : UCHAR , pub BusNumber : ULONG , pub Slot : WHEA_PCI_SLOT_NUMBER , pub DeviceControl : USHORT , pub Flags : AER_ENDPOINT_DESCRIPTOR_FLAGS , pub UncorrectableErrorMask : ULONG , pub UncorrectableErrorSeverity : ULONG , pub CorrectableErrorMask : ULONG , pub AdvancedCapsAndControl : ULONG , } pub type WHEA_AER_ENDPOINT_DESCRIPTOR = _WHEA_AER_ENDPOINT_DESCRIPTOR ; pub type PWHEA_AER_ENDPOINT_DESCRIPTOR = * mut _WHEA_AER_ENDPOINT_DESCRIPTOR ; # [ repr ( C , packed ) ] pub struct _WHEA_AER_BRIDGE_DESCRIPTOR { pub Type : USHORT , pub Enabled : BOOLEAN , pub Reserved : UCHAR , pub BusNumber : ULONG , pub Slot : WHEA_PCI_SLOT_NUMBER , pub DeviceControl : USHORT , pub Flags : AER_BRIDGE_DESCRIPTOR_FLAGS , pub UncorrectableErrorMask : ULONG , pub UncorrectableErrorSeverity : ULONG , pub CorrectableErrorMask : ULONG , pub AdvancedCapsAndControl : ULONG , pub SecondaryUncorrectableErrorMask : ULONG , pub SecondaryUncorrectableErrorSev : ULONG , pub SecondaryCapsAndControl : ULONG , } pub type WHEA_AER_BRIDGE_DESCRIPTOR = _WHEA_AER_BRIDGE_DESCRIPTOR ; pub type PWHEA_AER_BRIDGE_DESCRIPTOR = * mut _WHEA_AER_BRIDGE_DESCRIPTOR ; # [ repr ( C , packed ) ] pub struct _WHEA_GENERIC_ERROR_DESCRIPTOR { pub Type : USHORT , pub Reserved : UCHAR , pub Enabled : UCHAR , pub ErrStatusBlockLength : ULONG , pub RelatedErrorSourceId : ULONG , pub ErrStatusAddressSpaceID : UCHAR , pub ErrStatusAddressBitWidth : UCHAR , pub ErrStatusAddressBitOffset : UCHAR , pub ErrStatusAddressAccessSize : UCHAR , pub ErrStatusAddress : LARGE_INTEGER , pub Notify : WHEA_NOTIFICATION_DESCRIPTOR , } pub type WHEA_GENERIC_ERROR_DESCRIPTOR = _WHEA_GENERIC_ERROR_DESCRIPTOR ; pub type PWHEA_GENERIC_ERROR_DESCRIPTOR = * mut _WHEA_GENERIC_ERROR_DESCRIPTOR ; # [ repr ( C , packed ) ] pub struct _WHEA_GENERIC_ERROR_DESCRIPTOR_V2 { pub Type : USHORT , pub Reserved : UCHAR , pub Enabled : UCHAR , pub ErrStatusBlockLength : ULONG , pub RelatedErrorSourceId : ULONG , pub ErrStatusAddressSpaceID : UCHAR , pub ErrStatusAddressBitWidth : UCHAR , pub ErrStatusAddressBitOffset : UCHAR , pub ErrStatusAddressAccessSize : UCHAR , pub ErrStatusAddress : LARGE_INTEGER , pub Notify : WHEA_NOTIFICATION_DESCRIPTOR , pub ReadAckAddressSpaceID : UCHAR , pub ReadAckAddressBitWidth : UCHAR , pub ReadAckAddressBitOffset : UCHAR , pub ReadAckAddressAccessSize : UCHAR , pub ReadAckAddress : LARGE_INTEGER , pub ReadAckPreserveMask : ULONGLONG , pub ReadAckWriteMask : ULONGLONG , } pub type WHEA_GENERIC_ERROR_DESCRIPTOR_V2 = _WHEA_GENERIC_ERROR_DESCRIPTOR_V2 ; pub type PWHEA_GENERIC_ERROR_DESCRIPTOR_V2 = * mut _WHEA_GENERIC_ERROR_DESCRIPTOR_V2 ; # [ repr ( C , packed ) ] pub struct _WHEA_IPF_MCA_DESCRIPTOR { pub Type : USHORT , pub Enabled : UCHAR , pub Reserved : UCHAR , } pub type WHEA_IPF_MCA_DESCRIPTOR = _WHEA_IPF_MCA_DESCRIPTOR ; pub type PWHEA_IPF_MCA_DESCRIPTOR = * mut _WHEA_IPF_MCA_DESCRIPTOR ; # [ repr ( C , packed ) ] pub struct _WHEA_IPF_CMC_DESCRIPTOR { pub Type : USHORT , pub Enabled : UCHAR , pub Reserved : UCHAR , } pub type WHEA_IPF_CMC_DESCRIPTOR = _WHEA_IPF_CMC_DESCRIPTOR ; pub type PWHEA_IPF_CMC_DESCRIPTOR = * mut _WHEA_IPF_CMC_DESCRIPTOR ; # [ repr ( C , packed ) ] pub struct _WHEA_IPF_CPE_DESCRIPTOR { pub Type : USHORT , pub Enabled : UCHAR , pub Reserved : UCHAR , } pub type WHEA_IPF_CPE_DESCRIPTOR = _WHEA_IPF_CPE_DESCRIPTOR ; pub type PWHEA_IPF_CPE_DESCRIPTOR = * mut _WHEA_IPF_CPE_DESCRIPTOR ; # [ repr ( C , packed ) ] pub struct _WHEA_ERROR_SOURCE_DESCRIPTOR { pub Length : ULONG , pub Version : ULONG , pub Type : WHEA_ERROR_SOURCE_TYPE , pub State : WHEA_ERROR_SOURCE_STATE , pub MaxRawDataLength : ULONG , pub NumRecordsToPreallocate : ULONG , pub MaxSectionsPerRecord : ULONG , pub ErrorSourceId : ULONG , pub PlatformErrorSourceId : ULONG , pub Flags : ULONG , pub Info : _WHEA_ERROR_SOURCE_DESCRIPTOR__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _WHEA_ERROR_SOURCE_DESCRIPTOR__bindgen_ty_1 { pub XpfMceDescriptor : __BindgenUnionField < WHEA_XPF_MCE_DESCRIPTOR > , pub XpfCmcDescriptor : __BindgenUnionField < WHEA_XPF_CMC_DESCRIPTOR > , pub XpfNmiDescriptor : __BindgenUnionField < WHEA_XPF_NMI_DESCRIPTOR > , pub IpfMcaDescriptor : __BindgenUnionField < WHEA_IPF_MCA_DESCRIPTOR > , pub IpfCmcDescriptor : __BindgenUnionField < WHEA_IPF_CMC_DESCRIPTOR > , pub IpfCpeDescriptor : __BindgenUnionField < WHEA_IPF_CPE_DESCRIPTOR > , pub AerRootportDescriptor : __BindgenUnionField < WHEA_AER_ROOTPORT_DESCRIPTOR > , pub AerEndpointDescriptor : __BindgenUnionField < WHEA_AER_ENDPOINT_DESCRIPTOR > , pub AerBridgeDescriptor : __BindgenUnionField < WHEA_AER_BRIDGE_DESCRIPTOR > , pub GenErrDescriptor : __BindgenUnionField < WHEA_GENERIC_ERROR_DESCRIPTOR > , pub GenErrDescriptorV2 : __BindgenUnionField < WHEA_GENERIC_ERROR_DESCRIPTOR_V2 > , pub bindgen_union_field : [ u8 ; 932usize ] , } pub type WHEA_ERROR_SOURCE_DESCRIPTOR = _WHEA_ERROR_SOURCE_DESCRIPTOR ; # [ repr ( C , packed ) ] pub struct _WHEA_REVISION { pub __bindgen_anon_1 : __BindgenUnionField < _WHEA_REVISION__bindgen_ty_1 > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : [ u8 ; 2usize ] , } # [ repr ( C ) ] pub struct _WHEA_REVISION__bindgen_ty_1 { pub MinorRevision : UCHAR , pub MajorRevision : UCHAR , } pub type WHEA_REVISION = _WHEA_REVISION ; pub type PWHEA_REVISION = * mut _WHEA_REVISION ; pub const _WHEA_ERROR_SEVERITY_WheaErrSevRecoverable : _WHEA_ERROR_SEVERITY = 0 ; pub const _WHEA_ERROR_SEVERITY_WheaErrSevFatal : _WHEA_ERROR_SEVERITY = 1 ; pub const _WHEA_ERROR_SEVERITY_WheaErrSevCorrected : _WHEA_ERROR_SEVERITY = 2 ; pub const _WHEA_ERROR_SEVERITY_WheaErrSevInformational : _WHEA_ERROR_SEVERITY = 3 ; pub type _WHEA_ERROR_SEVERITY = i32 ; pub use self :: _WHEA_ERROR_SEVERITY as WHEA_ERROR_SEVERITY ; pub type PWHEA_ERROR_SEVERITY = * mut _WHEA_ERROR_SEVERITY ; # [ repr ( C , packed ) ] pub struct _WHEA_TIMESTAMP { pub __bindgen_anon_1 : __BindgenUnionField < _WHEA_TIMESTAMP__bindgen_ty_1 > , pub AsLARGE_INTEGER : __BindgenUnionField < LARGE_INTEGER > , pub bindgen_union_field : [ u8 ; 8usize ] , } # [ repr ( C , packed ) ] pub struct _WHEA_TIMESTAMP__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u8 > , } impl _WHEA_TIMESTAMP__bindgen_ty_1 { # [ inline ] pub fn Seconds ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u64 ) } } # [ inline ] pub fn set_Seconds ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn Minutes ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u64 ) } } # [ inline ] pub fn set_Minutes ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn Hours ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 8u8 ) as u64 ) } } # [ inline ] pub fn set_Hours ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 8u8 , val as u64 ) } } # [ inline ] pub fn Precise ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_Precise ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 25usize , 7u8 ) as u64 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 25usize , 7u8 , val as u64 ) } } # [ inline ] pub fn Day ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 32usize , 8u8 ) as u64 ) } } # [ inline ] pub fn set_Day ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 32usize , 8u8 , val as u64 ) } } # [ inline ] pub fn Month ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 40usize , 8u8 ) as u64 ) } } # [ inline ] pub fn set_Month ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 40usize , 8u8 , val as u64 ) } } # [ inline ] pub fn Year ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 48usize , 8u8 ) as u64 ) } } # [ inline ] pub fn set_Year ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 48usize , 8u8 , val as u64 ) } } # [ inline ] pub fn Century ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 56usize , 8u8 ) as u64 ) } } # [ inline ] pub fn set_Century ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 56usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Seconds : ULONGLONG , Minutes : ULONGLONG , Hours : ULONGLONG , Precise : ULONGLONG , Reserved : ULONGLONG , Day : ULONGLONG , Month : ULONGLONG , Year : ULONGLONG , Century : ULONGLONG ) -> __BindgenBitfieldUnit < [ u8 ; 8usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let Seconds : u64 = unsafe { :: std :: mem :: transmute ( Seconds ) } ; Seconds as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let Minutes : u64 = unsafe { :: std :: mem :: transmute ( Minutes ) } ; Minutes as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 8u8 , { let Hours : u64 = unsafe { :: std :: mem :: transmute ( Hours ) } ; Hours as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 1u8 , { let Precise : u64 = unsafe { :: std :: mem :: transmute ( Precise ) } ; Precise as u64 } ) ; __bindgen_bitfield_unit . set ( 25usize , 7u8 , { let Reserved : u64 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit . set ( 32usize , 8u8 , { let Day : u64 = unsafe { :: std :: mem :: transmute ( Day ) } ; Day as u64 } ) ; __bindgen_bitfield_unit . set ( 40usize , 8u8 , { let Month : u64 = unsafe { :: std :: mem :: transmute ( Month ) } ; Month as u64 } ) ; __bindgen_bitfield_unit . set ( 48usize , 8u8 , { let Year : u64 = unsafe { :: std :: mem :: transmute ( Year ) } ; Year as u64 } ) ; __bindgen_bitfield_unit . set ( 56usize , 8u8 , { let Century : u64 = unsafe { :: std :: mem :: transmute ( Century ) } ; Century as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_TIMESTAMP = _WHEA_TIMESTAMP ; pub type PWHEA_TIMESTAMP = * mut _WHEA_TIMESTAMP ; # [ repr ( C , packed ) ] pub struct _WHEA_PERSISTENCE_INFO { pub __bindgen_anon_1 : __BindgenUnionField < _WHEA_PERSISTENCE_INFO__bindgen_ty_1 > , pub AsULONGLONG : __BindgenUnionField < ULONGLONG > , pub bindgen_union_field : [ u8 ; 8usize ] , } # [ repr ( C , packed ) ] pub struct _WHEA_PERSISTENCE_INFO__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u32 > , } impl _WHEA_PERSISTENCE_INFO__bindgen_ty_1 { # [ inline ] pub fn Signature ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 16u8 ) as u64 ) } } # [ inline ] pub fn set_Signature ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 16u8 , val as u64 ) } } # [ inline ] pub fn Length ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 24u8 ) as u64 ) } } # [ inline ] pub fn set_Length ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 24u8 , val as u64 ) } } # [ inline ] pub fn Identifier ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 40usize , 16u8 ) as u64 ) } } # [ inline ] pub fn set_Identifier ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 40usize , 16u8 , val as u64 ) } } # [ inline ] pub fn Attributes ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 56usize , 2u8 ) as u64 ) } } # [ inline ] pub fn set_Attributes ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 56usize , 2u8 , val as u64 ) } } # [ inline ] pub fn DoNotLog ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 58usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_DoNotLog ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 58usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 59usize , 5u8 ) as u64 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 59usize , 5u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Signature : ULONGLONG , Length : ULONGLONG , Identifier : ULONGLONG , Attributes : ULONGLONG , DoNotLog : ULONGLONG , Reserved : ULONGLONG ) -> __BindgenBitfieldUnit < [ u8 ; 8usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 16u8 , { let Signature : u64 = unsafe { :: std :: mem :: transmute ( Signature ) } ; Signature as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 24u8 , { let Length : u64 = unsafe { :: std :: mem :: transmute ( Length ) } ; Length as u64 } ) ; __bindgen_bitfield_unit . set ( 40usize , 16u8 , { let Identifier : u64 = unsafe { :: std :: mem :: transmute ( Identifier ) } ; Identifier as u64 } ) ; __bindgen_bitfield_unit . set ( 56usize , 2u8 , { let Attributes : u64 = unsafe { :: std :: mem :: transmute ( Attributes ) } ; Attributes as u64 } ) ; __bindgen_bitfield_unit . set ( 58usize , 1u8 , { let DoNotLog : u64 = unsafe { :: std :: mem :: transmute ( DoNotLog ) } ; DoNotLog as u64 } ) ; __bindgen_bitfield_unit . set ( 59usize , 5u8 , { let Reserved : u64 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_PERSISTENCE_INFO = _WHEA_PERSISTENCE_INFO ; pub type PWHEA_PERSISTENCE_INFO = * mut _WHEA_PERSISTENCE_INFO ; # [ repr ( C , packed ) ] pub struct _WHEA_ERROR_STATUS { pub ErrorStatus : __BindgenUnionField < ULONGLONG > , pub __bindgen_anon_1 : __BindgenUnionField < _WHEA_ERROR_STATUS__bindgen_ty_1 > , pub bindgen_union_field : [ u8 ; 8usize ] , } # [ repr ( C , packed ) ] pub struct _WHEA_ERROR_STATUS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > , } impl _WHEA_ERROR_STATUS__bindgen_ty_1 { # [ inline ] pub fn Reserved1 ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u64 ) } } # [ inline ] pub fn set_Reserved1 ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn ErrorType ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u64 ) } } # [ inline ] pub fn set_ErrorType ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn Address ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_Address ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Control ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 17usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_Control ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 17usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Data ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 18usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_Data ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 18usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Responder ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 19usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_Responder ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 19usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Requester ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 20usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_Requester ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 20usize , 1u8 , val as u64 ) } } # [ inline ] pub fn FirstError ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 21usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_FirstError ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 21usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Overflow ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 22usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_Overflow ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 22usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved2 ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 23usize , 41u8 ) as u64 ) } } # [ inline ] pub fn set_Reserved2 ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 23usize , 41u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Reserved1 : ULONGLONG , ErrorType : ULONGLONG , Address : ULONGLONG , Control : ULONGLONG , Data : ULONGLONG , Responder : ULONGLONG , Requester : ULONGLONG , FirstError : ULONGLONG , Overflow : ULONGLONG , Reserved2 : ULONGLONG ) -> __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let Reserved1 : u64 = unsafe { :: std :: mem :: transmute ( Reserved1 ) } ; Reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let ErrorType : u64 = unsafe { :: std :: mem :: transmute ( ErrorType ) } ; ErrorType as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 1u8 , { let Address : u64 = unsafe { :: std :: mem :: transmute ( Address ) } ; Address as u64 } ) ; __bindgen_bitfield_unit . set ( 17usize , 1u8 , { let Control : u64 = unsafe { :: std :: mem :: transmute ( Control ) } ; Control as u64 } ) ; __bindgen_bitfield_unit . set ( 18usize , 1u8 , { let Data : u64 = unsafe { :: std :: mem :: transmute ( Data ) } ; Data as u64 } ) ; __bindgen_bitfield_unit . set ( 19usize , 1u8 , { let Responder : u64 = unsafe { :: std :: mem :: transmute ( Responder ) } ; Responder as u64 } ) ; __bindgen_bitfield_unit . set ( 20usize , 1u8 , { let Requester : u64 = unsafe { :: std :: mem :: transmute ( Requester ) } ; Requester as u64 } ) ; __bindgen_bitfield_unit . set ( 21usize , 1u8 , { let FirstError : u64 = unsafe { :: std :: mem :: transmute ( FirstError ) } ; FirstError as u64 } ) ; __bindgen_bitfield_unit . set ( 22usize , 1u8 , { let Overflow : u64 = unsafe { :: std :: mem :: transmute ( Overflow ) } ; Overflow as u64 } ) ; __bindgen_bitfield_unit . set ( 23usize , 41u8 , { let Reserved2 : u64 = unsafe { :: std :: mem :: transmute ( Reserved2 ) } ; Reserved2 as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_ERROR_STATUS = _WHEA_ERROR_STATUS ; pub type PWHEA_ERROR_STATUS = * mut _WHEA_ERROR_STATUS ; # [ repr ( C , packed ) ] pub struct _WHEA_ERROR_RECORD_HEADER_VALIDBITS { pub __bindgen_anon_1 : __BindgenUnionField < _WHEA_ERROR_RECORD_HEADER_VALIDBITS__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : [ u8 ; 4usize ] , } # [ repr ( C , packed ) ] pub struct _WHEA_ERROR_RECORD_HEADER_VALIDBITS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , } impl _WHEA_ERROR_RECORD_HEADER_VALIDBITS__bindgen_ty_1 { # [ inline ] pub fn PlatformId ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_PlatformId ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Timestamp ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Timestamp ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PartitionId ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_PartitionId ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 29u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 29u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( PlatformId : ULONG , Timestamp : ULONG , PartitionId : ULONG , Reserved : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let PlatformId : u32 = unsafe { :: std :: mem :: transmute ( PlatformId ) } ; PlatformId as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let Timestamp : u32 = unsafe { :: std :: mem :: transmute ( Timestamp ) } ; Timestamp as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let PartitionId : u32 = unsafe { :: std :: mem :: transmute ( PartitionId ) } ; PartitionId as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 29u8 , { let Reserved : u32 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_ERROR_RECORD_HEADER_VALIDBITS = _WHEA_ERROR_RECORD_HEADER_VALIDBITS ; pub type PWHEA_ERROR_RECORD_HEADER_VALIDBITS = * mut _WHEA_ERROR_RECORD_HEADER_VALIDBITS ; # [ repr ( C , packed ) ] pub struct _WHEA_ERROR_RECORD_HEADER_FLAGS { pub __bindgen_anon_1 : __BindgenUnionField < _WHEA_ERROR_RECORD_HEADER_FLAGS__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : [ u8 ; 4usize ] , } # [ repr ( C , packed ) ] pub struct _WHEA_ERROR_RECORD_HEADER_FLAGS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , } impl _WHEA_ERROR_RECORD_HEADER_FLAGS__bindgen_ty_1 { # [ inline ] pub fn Recovered ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Recovered ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PreviousError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_PreviousError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Simulated ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Simulated ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 29u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 29u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Recovered : ULONG , PreviousError : ULONG , Simulated : ULONG , Reserved : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let Recovered : u32 = unsafe { :: std :: mem :: transmute ( Recovered ) } ; Recovered as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let PreviousError : u32 = unsafe { :: std :: mem :: transmute ( PreviousError ) } ; PreviousError as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let Simulated : u32 = unsafe { :: std :: mem :: transmute ( Simulated ) } ; Simulated as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 29u8 , { let Reserved : u32 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_ERROR_RECORD_HEADER_FLAGS = _WHEA_ERROR_RECORD_HEADER_FLAGS ; pub type PWHEA_ERROR_RECORD_HEADER_FLAGS = * mut _WHEA_ERROR_RECORD_HEADER_FLAGS ; # [ repr ( C , packed ) ] pub struct _WHEA_ERROR_RECORD_HEADER { pub Signature : ULONG , pub Revision : WHEA_REVISION , pub SignatureEnd : ULONG , pub SectionCount : USHORT , pub Severity : WHEA_ERROR_SEVERITY , pub ValidBits : WHEA_ERROR_RECORD_HEADER_VALIDBITS , pub Length : ULONG , pub Timestamp : WHEA_TIMESTAMP , pub PlatformId : GUID , pub PartitionId : GUID , pub CreatorId : GUID , pub NotifyType : GUID , pub RecordId : ULONGLONG , pub Flags : WHEA_ERROR_RECORD_HEADER_FLAGS , pub PersistenceInfo : WHEA_PERSISTENCE_INFO , pub Reserved : [ UCHAR ; 12usize ] , } pub type WHEA_ERROR_RECORD_HEADER = _WHEA_ERROR_RECORD_HEADER ; pub type PWHEA_ERROR_RECORD_HEADER = * mut _WHEA_ERROR_RECORD_HEADER ; # [ repr ( C , packed ) ] pub struct _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS { pub __bindgen_anon_1 : __BindgenUnionField < _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : [ u8 ; 4usize ] , } # [ repr ( C , packed ) ] pub struct _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , } impl _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS__bindgen_ty_1 { # [ inline ] pub fn Primary ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Primary ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ContainmentWarning ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ContainmentWarning ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reset ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Reset ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ThresholdExceeded ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ThresholdExceeded ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ResourceNotAvailable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ResourceNotAvailable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn LatentError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_LatentError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Propagated ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Propagated ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 25u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 25u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Primary : ULONG , ContainmentWarning : ULONG , Reset : ULONG , ThresholdExceeded : ULONG , ResourceNotAvailable : ULONG , LatentError : ULONG , Propagated : ULONG , Reserved : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let Primary : u32 = unsafe { :: std :: mem :: transmute ( Primary ) } ; Primary as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let ContainmentWarning : u32 = unsafe { :: std :: mem :: transmute ( ContainmentWarning ) } ; ContainmentWarning as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let Reset : u32 = unsafe { :: std :: mem :: transmute ( Reset ) } ; Reset as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let ThresholdExceeded : u32 = unsafe { :: std :: mem :: transmute ( ThresholdExceeded ) } ; ThresholdExceeded as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let ResourceNotAvailable : u32 = unsafe { :: std :: mem :: transmute ( ResourceNotAvailable ) } ; ResourceNotAvailable as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let LatentError : u32 = unsafe { :: std :: mem :: transmute ( LatentError ) } ; LatentError as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let Propagated : u32 = unsafe { :: std :: mem :: transmute ( Propagated ) } ; Propagated as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 25u8 , { let Reserved : u32 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS = _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS ; pub type PWHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS = * mut _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS ; # [ repr ( C ) ] pub struct _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS { pub __bindgen_anon_1 : __BindgenUnionField < _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS__bindgen_ty_1 > , pub AsUCHAR : __BindgenUnionField < UCHAR > , pub bindgen_union_field : u8 , } # [ repr ( C , packed ) ] pub struct _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS__bindgen_ty_1 { # [ inline ] pub fn FRUId ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_FRUId ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn FRUText ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_FRUText ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 6u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( FRUId : UCHAR , FRUText : UCHAR , Reserved : UCHAR ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let FRUId : u8 = unsafe { :: std :: mem :: transmute ( FRUId ) } ; FRUId as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let FRUText : u8 = unsafe { :: std :: mem :: transmute ( FRUText ) } ; FRUText as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 6u8 , { let Reserved : u8 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS = _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS ; pub type PWHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS = * mut _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS ; # [ repr ( C , packed ) ] pub struct _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR { pub SectionOffset : ULONG , pub SectionLength : ULONG , pub Revision : WHEA_REVISION , pub ValidBits : WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS , pub Reserved : UCHAR , pub Flags : WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS , pub SectionType : GUID , pub FRUId : GUID , pub SectionSeverity : WHEA_ERROR_SEVERITY , pub FRUText : [ CCHAR ; 20usize ] , } pub type WHEA_ERROR_RECORD_SECTION_DESCRIPTOR = _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR ; pub type PWHEA_ERROR_RECORD_SECTION_DESCRIPTOR = * mut _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR ; # [ repr ( C ) ] pub struct _WHEA_ERROR_RECORD { pub Header : WHEA_ERROR_RECORD_HEADER , pub SectionDescriptor : [ WHEA_ERROR_RECORD_SECTION_DESCRIPTOR ; 1usize ] , } pub type WHEA_ERROR_RECORD = _WHEA_ERROR_RECORD ; # [ repr ( C , packed ) ] pub struct _WHEA_PROCESSOR_FAMILY_INFO { pub __bindgen_anon_1 : __BindgenUnionField < _WHEA_PROCESSOR_FAMILY_INFO__bindgen_ty_1 > , pub AsULONGLONG : __BindgenUnionField < ULONGLONG > , pub bindgen_union_field : [ u8 ; 8usize ] , } # [ repr ( C , packed ) ] pub struct _WHEA_PROCESSOR_FAMILY_INFO__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub Reserved3 : ULONG , } impl _WHEA_PROCESSOR_FAMILY_INFO__bindgen_ty_1 { # [ inline ] pub fn Stepping ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_Stepping ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn Model ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_Model ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn Family ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_Family ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 4u8 , val as u64 ) } } # [ inline ] pub fn ProcessorType ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_ProcessorType ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 2u8 , val as u64 ) } } # [ inline ] pub fn Reserved1 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved1 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 2u8 , val as u64 ) } } # [ inline ] pub fn ExtendedModel ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_ExtendedModel ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 4u8 , val as u64 ) } } # [ inline ] pub fn ExtendedFamily ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 20usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_ExtendedFamily ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 20usize , 8u8 , val as u64 ) } } # [ inline ] pub fn Reserved2 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 28usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved2 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 28usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Stepping : ULONG , Model : ULONG , Family : ULONG , ProcessorType : ULONG , Reserved1 : ULONG , ExtendedModel : ULONG , ExtendedFamily : ULONG , Reserved2 : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let Stepping : u32 = unsafe { :: std :: mem :: transmute ( Stepping ) } ; Stepping as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let Model : u32 = unsafe { :: std :: mem :: transmute ( Model ) } ; Model as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 4u8 , { let Family : u32 = unsafe { :: std :: mem :: transmute ( Family ) } ; Family as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 2u8 , { let ProcessorType : u32 = unsafe { :: std :: mem :: transmute ( ProcessorType ) } ; ProcessorType as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 2u8 , { let Reserved1 : u32 = unsafe { :: std :: mem :: transmute ( Reserved1 ) } ; Reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 4u8 , { let ExtendedModel : u32 = unsafe { :: std :: mem :: transmute ( ExtendedModel ) } ; ExtendedModel as u64 } ) ; __bindgen_bitfield_unit . set ( 20usize , 8u8 , { let ExtendedFamily : u32 = unsafe { :: std :: mem :: transmute ( ExtendedFamily ) } ; ExtendedFamily as u64 } ) ; __bindgen_bitfield_unit . set ( 28usize , 4u8 , { let Reserved2 : u32 = unsafe { :: std :: mem :: transmute ( Reserved2 ) } ; Reserved2 as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_PROCESSOR_FAMILY_INFO = _WHEA_PROCESSOR_FAMILY_INFO ; pub type PWHEA_PROCESSOR_FAMILY_INFO = * mut _WHEA_PROCESSOR_FAMILY_INFO ; # [ repr ( C , packed ) ] pub struct _WHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS { pub __bindgen_anon_1 : __BindgenUnionField < _WHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS__bindgen_ty_1 > , pub ValidBits : __BindgenUnionField < ULONGLONG > , pub bindgen_union_field : [ u8 ; 8usize ] , } # [ repr ( C , packed ) ] pub struct _WHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > , } impl _WHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS__bindgen_ty_1 { # [ inline ] pub fn ProcessorType ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_ProcessorType ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn InstructionSet ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_InstructionSet ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ErrorType ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_ErrorType ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Operation ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_Operation ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Flags ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_Flags ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Level ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_Level ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn CPUVersion ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_CPUVersion ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn CPUBrandString ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_CPUBrandString ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ProcessorId ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_ProcessorId ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn TargetAddress ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_TargetAddress ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn RequesterId ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_RequesterId ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ResponderId ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_ResponderId ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 1u8 , val as u64 ) } } # [ inline ] pub fn InstructionPointer ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_InstructionPointer ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 13usize , 51u8 ) as u64 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 13usize , 51u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ProcessorType : ULONGLONG , InstructionSet : ULONGLONG , ErrorType : ULONGLONG , Operation : ULONGLONG , Flags : ULONGLONG , Level : ULONGLONG , CPUVersion : ULONGLONG , CPUBrandString : ULONGLONG , ProcessorId : ULONGLONG , TargetAddress : ULONGLONG , RequesterId : ULONGLONG , ResponderId : ULONGLONG , InstructionPointer : ULONGLONG , Reserved : ULONGLONG ) -> __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let ProcessorType : u64 = unsafe { :: std :: mem :: transmute ( ProcessorType ) } ; ProcessorType as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let InstructionSet : u64 = unsafe { :: std :: mem :: transmute ( InstructionSet ) } ; InstructionSet as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let ErrorType : u64 = unsafe { :: std :: mem :: transmute ( ErrorType ) } ; ErrorType as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let Operation : u64 = unsafe { :: std :: mem :: transmute ( Operation ) } ; Operation as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let Flags : u64 = unsafe { :: std :: mem :: transmute ( Flags ) } ; Flags as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let Level : u64 = unsafe { :: std :: mem :: transmute ( Level ) } ; Level as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let CPUVersion : u64 = unsafe { :: std :: mem :: transmute ( CPUVersion ) } ; CPUVersion as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let CPUBrandString : u64 = unsafe { :: std :: mem :: transmute ( CPUBrandString ) } ; CPUBrandString as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let ProcessorId : u64 = unsafe { :: std :: mem :: transmute ( ProcessorId ) } ; ProcessorId as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let TargetAddress : u64 = unsafe { :: std :: mem :: transmute ( TargetAddress ) } ; TargetAddress as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 1u8 , { let RequesterId : u64 = unsafe { :: std :: mem :: transmute ( RequesterId ) } ; RequesterId as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 1u8 , { let ResponderId : u64 = unsafe { :: std :: mem :: transmute ( ResponderId ) } ; ResponderId as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 1u8 , { let InstructionPointer : u64 = unsafe { :: std :: mem :: transmute ( InstructionPointer ) } ; InstructionPointer as u64 } ) ; __bindgen_bitfield_unit . set ( 13usize , 51u8 , { let Reserved : u64 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS = _WHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS ; pub type PWHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS = * mut _WHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS ; # [ repr ( C , packed ) ] pub struct _WHEA_PROCESSOR_GENERIC_ERROR_SECTION { pub ValidBits : WHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS , pub ProcessorType : UCHAR , pub InstructionSet : UCHAR , pub ErrorType : UCHAR , pub Operation : UCHAR , pub Flags : UCHAR , pub Level : UCHAR , pub Reserved : USHORT , pub CPUVersion : ULONGLONG , pub CPUBrandString : [ UCHAR ; 128usize ] , pub ProcessorId : ULONGLONG , pub TargetAddress : ULONGLONG , pub RequesterId : ULONGLONG , pub ResponderId : ULONGLONG , pub InstructionPointer : ULONGLONG , } pub type WHEA_PROCESSOR_GENERIC_ERROR_SECTION = _WHEA_PROCESSOR_GENERIC_ERROR_SECTION ; pub type PWHEA_PROCESSOR_GENERIC_ERROR_SECTION = * mut _WHEA_PROCESSOR_GENERIC_ERROR_SECTION ; # [ repr ( C , packed ) ] pub struct _WHEA_XPF_CACHE_CHECK { pub __bindgen_anon_1 : __BindgenUnionField < _WHEA_XPF_CACHE_CHECK__bindgen_ty_1 > , pub XpfCacheCheck : __BindgenUnionField < ULONGLONG > , pub bindgen_union_field : [ u8 ; 8usize ] , } # [ repr ( C , packed ) ] pub struct _WHEA_XPF_CACHE_CHECK__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > , } impl _WHEA_XPF_CACHE_CHECK__bindgen_ty_1 { # [ inline ] pub fn TransactionTypeValid ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_TransactionTypeValid ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn OperationValid ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_OperationValid ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn LevelValid ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_LevelValid ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ProcessorContextCorruptValid ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_ProcessorContextCorruptValid ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UncorrectedValid ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_UncorrectedValid ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PreciseIPValid ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_PreciseIPValid ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn RestartableIPValid ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_RestartableIPValid ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn OverflowValid ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_OverflowValid ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ReservedValid ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u64 ) } } # [ inline ] pub fn set_ReservedValid ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn TransactionType ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 2u8 ) as u64 ) } } # [ inline ] pub fn set_TransactionType ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 2u8 , val as u64 ) } } # [ inline ] pub fn Operation ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 18usize , 4u8 ) as u64 ) } } # [ inline ] pub fn set_Operation ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 18usize , 4u8 , val as u64 ) } } # [ inline ] pub fn Level ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 22usize , 3u8 ) as u64 ) } } # [ inline ] pub fn set_Level ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 22usize , 3u8 , val as u64 ) } } # [ inline ] pub fn ProcessorContextCorrupt ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 25usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_ProcessorContextCorrupt ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 25usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Uncorrected ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 26usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_Uncorrected ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 26usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PreciseIP ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 27usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_PreciseIP ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 27usize , 1u8 , val as u64 ) } } # [ inline ] pub fn RestartableIP ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 28usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_RestartableIP ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 28usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Overflow ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 29usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_Overflow ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 29usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 30usize , 34u8 ) as u64 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 30usize , 34u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( TransactionTypeValid : ULONGLONG , OperationValid : ULONGLONG , LevelValid : ULONGLONG , ProcessorContextCorruptValid : ULONGLONG , UncorrectedValid : ULONGLONG , PreciseIPValid : ULONGLONG , RestartableIPValid : ULONGLONG , OverflowValid : ULONGLONG , ReservedValid : ULONGLONG , TransactionType : ULONGLONG , Operation : ULONGLONG , Level : ULONGLONG , ProcessorContextCorrupt : ULONGLONG , Uncorrected : ULONGLONG , PreciseIP : ULONGLONG , RestartableIP : ULONGLONG , Overflow : ULONGLONG , Reserved : ULONGLONG ) -> __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let TransactionTypeValid : u64 = unsafe { :: std :: mem :: transmute ( TransactionTypeValid ) } ; TransactionTypeValid as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let OperationValid : u64 = unsafe { :: std :: mem :: transmute ( OperationValid ) } ; OperationValid as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let LevelValid : u64 = unsafe { :: std :: mem :: transmute ( LevelValid ) } ; LevelValid as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let ProcessorContextCorruptValid : u64 = unsafe { :: std :: mem :: transmute ( ProcessorContextCorruptValid ) } ; ProcessorContextCorruptValid as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let UncorrectedValid : u64 = unsafe { :: std :: mem :: transmute ( UncorrectedValid ) } ; UncorrectedValid as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let PreciseIPValid : u64 = unsafe { :: std :: mem :: transmute ( PreciseIPValid ) } ; PreciseIPValid as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let RestartableIPValid : u64 = unsafe { :: std :: mem :: transmute ( RestartableIPValid ) } ; RestartableIPValid as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let OverflowValid : u64 = unsafe { :: std :: mem :: transmute ( OverflowValid ) } ; OverflowValid as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let ReservedValid : u64 = unsafe { :: std :: mem :: transmute ( ReservedValid ) } ; ReservedValid as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 2u8 , { let TransactionType : u64 = unsafe { :: std :: mem :: transmute ( TransactionType ) } ; TransactionType as u64 } ) ; __bindgen_bitfield_unit . set ( 18usize , 4u8 , { let Operation : u64 = unsafe { :: std :: mem :: transmute ( Operation ) } ; Operation as u64 } ) ; __bindgen_bitfield_unit . set ( 22usize , 3u8 , { let Level : u64 = unsafe { :: std :: mem :: transmute ( Level ) } ; Level as u64 } ) ; __bindgen_bitfield_unit . set ( 25usize , 1u8 , { let ProcessorContextCorrupt : u64 = unsafe { :: std :: mem :: transmute ( ProcessorContextCorrupt ) } ; ProcessorContextCorrupt as u64 } ) ; __bindgen_bitfield_unit . set ( 26usize , 1u8 , { let Uncorrected : u64 = unsafe { :: std :: mem :: transmute ( Uncorrected ) } ; Uncorrected as u64 } ) ; __bindgen_bitfield_unit . set ( 27usize , 1u8 , { let PreciseIP : u64 = unsafe { :: std :: mem :: transmute ( PreciseIP ) } ; PreciseIP as u64 } ) ; __bindgen_bitfield_unit . set ( 28usize , 1u8 , { let RestartableIP : u64 = unsafe { :: std :: mem :: transmute ( RestartableIP ) } ; RestartableIP as u64 } ) ; __bindgen_bitfield_unit . set ( 29usize , 1u8 , { let Overflow : u64 = unsafe { :: std :: mem :: transmute ( Overflow ) } ; Overflow as u64 } ) ; __bindgen_bitfield_unit . set ( 30usize , 34u8 , { let Reserved : u64 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_XPF_CACHE_CHECK = _WHEA_XPF_CACHE_CHECK ; pub type PWHEA_XPF_CACHE_CHECK = * mut _WHEA_XPF_CACHE_CHECK ; # [ repr ( C , packed ) ] pub struct _WHEA_XPF_TLB_CHECK { pub __bindgen_anon_1 : __BindgenUnionField < _WHEA_XPF_TLB_CHECK__bindgen_ty_1 > , pub XpfTLBCheck : __BindgenUnionField < ULONGLONG > , pub bindgen_union_field : [ u8 ; 8usize ] , } # [ repr ( C , packed ) ] pub struct _WHEA_XPF_TLB_CHECK__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > , } impl _WHEA_XPF_TLB_CHECK__bindgen_ty_1 { # [ inline ] pub fn TransactionTypeValid ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_TransactionTypeValid ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn OperationValid ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_OperationValid ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn LevelValid ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_LevelValid ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ProcessorContextCorruptValid ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_ProcessorContextCorruptValid ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UncorrectedValid ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_UncorrectedValid ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PreciseIPValid ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_PreciseIPValid ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn RestartableIPValid ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_RestartableIPValid ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn OverflowValid ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_OverflowValid ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ReservedValid ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u64 ) } } # [ inline ] pub fn set_ReservedValid ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn TransactionType ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 2u8 ) as u64 ) } } # [ inline ] pub fn set_TransactionType ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 2u8 , val as u64 ) } } # [ inline ] pub fn Operation ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 18usize , 4u8 ) as u64 ) } } # [ inline ] pub fn set_Operation ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 18usize , 4u8 , val as u64 ) } } # [ inline ] pub fn Level ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 22usize , 3u8 ) as u64 ) } } # [ inline ] pub fn set_Level ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 22usize , 3u8 , val as u64 ) } } # [ inline ] pub fn ProcessorContextCorrupt ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 25usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_ProcessorContextCorrupt ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 25usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Uncorrected ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 26usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_Uncorrected ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 26usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PreciseIP ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 27usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_PreciseIP ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 27usize , 1u8 , val as u64 ) } } # [ inline ] pub fn RestartableIP ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 28usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_RestartableIP ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 28usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Overflow ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 29usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_Overflow ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 29usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 30usize , 34u8 ) as u64 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 30usize , 34u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( TransactionTypeValid : ULONGLONG , OperationValid : ULONGLONG , LevelValid : ULONGLONG , ProcessorContextCorruptValid : ULONGLONG , UncorrectedValid : ULONGLONG , PreciseIPValid : ULONGLONG , RestartableIPValid : ULONGLONG , OverflowValid : ULONGLONG , ReservedValid : ULONGLONG , TransactionType : ULONGLONG , Operation : ULONGLONG , Level : ULONGLONG , ProcessorContextCorrupt : ULONGLONG , Uncorrected : ULONGLONG , PreciseIP : ULONGLONG , RestartableIP : ULONGLONG , Overflow : ULONGLONG , Reserved : ULONGLONG ) -> __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let TransactionTypeValid : u64 = unsafe { :: std :: mem :: transmute ( TransactionTypeValid ) } ; TransactionTypeValid as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let OperationValid : u64 = unsafe { :: std :: mem :: transmute ( OperationValid ) } ; OperationValid as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let LevelValid : u64 = unsafe { :: std :: mem :: transmute ( LevelValid ) } ; LevelValid as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let ProcessorContextCorruptValid : u64 = unsafe { :: std :: mem :: transmute ( ProcessorContextCorruptValid ) } ; ProcessorContextCorruptValid as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let UncorrectedValid : u64 = unsafe { :: std :: mem :: transmute ( UncorrectedValid ) } ; UncorrectedValid as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let PreciseIPValid : u64 = unsafe { :: std :: mem :: transmute ( PreciseIPValid ) } ; PreciseIPValid as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let RestartableIPValid : u64 = unsafe { :: std :: mem :: transmute ( RestartableIPValid ) } ; RestartableIPValid as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let OverflowValid : u64 = unsafe { :: std :: mem :: transmute ( OverflowValid ) } ; OverflowValid as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let ReservedValid : u64 = unsafe { :: std :: mem :: transmute ( ReservedValid ) } ; ReservedValid as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 2u8 , { let TransactionType : u64 = unsafe { :: std :: mem :: transmute ( TransactionType ) } ; TransactionType as u64 } ) ; __bindgen_bitfield_unit . set ( 18usize , 4u8 , { let Operation : u64 = unsafe { :: std :: mem :: transmute ( Operation ) } ; Operation as u64 } ) ; __bindgen_bitfield_unit . set ( 22usize , 3u8 , { let Level : u64 = unsafe { :: std :: mem :: transmute ( Level ) } ; Level as u64 } ) ; __bindgen_bitfield_unit . set ( 25usize , 1u8 , { let ProcessorContextCorrupt : u64 = unsafe { :: std :: mem :: transmute ( ProcessorContextCorrupt ) } ; ProcessorContextCorrupt as u64 } ) ; __bindgen_bitfield_unit . set ( 26usize , 1u8 , { let Uncorrected : u64 = unsafe { :: std :: mem :: transmute ( Uncorrected ) } ; Uncorrected as u64 } ) ; __bindgen_bitfield_unit . set ( 27usize , 1u8 , { let PreciseIP : u64 = unsafe { :: std :: mem :: transmute ( PreciseIP ) } ; PreciseIP as u64 } ) ; __bindgen_bitfield_unit . set ( 28usize , 1u8 , { let RestartableIP : u64 = unsafe { :: std :: mem :: transmute ( RestartableIP ) } ; RestartableIP as u64 } ) ; __bindgen_bitfield_unit . set ( 29usize , 1u8 , { let Overflow : u64 = unsafe { :: std :: mem :: transmute ( Overflow ) } ; Overflow as u64 } ) ; __bindgen_bitfield_unit . set ( 30usize , 34u8 , { let Reserved : u64 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_XPF_TLB_CHECK = _WHEA_XPF_TLB_CHECK ; pub type PWHEA_XPF_TLB_CHECK = * mut _WHEA_XPF_TLB_CHECK ; # [ repr ( C , packed ) ] pub struct _WHEA_XPF_BUS_CHECK { pub __bindgen_anon_1 : __BindgenUnionField < _WHEA_XPF_BUS_CHECK__bindgen_ty_1 > , pub XpfBusCheck : __BindgenUnionField < ULONGLONG > , pub bindgen_union_field : [ u8 ; 8usize ] , } # [ repr ( C , packed ) ] pub struct _WHEA_XPF_BUS_CHECK__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u32 > , } impl _WHEA_XPF_BUS_CHECK__bindgen_ty_1 { # [ inline ] pub fn TransactionTypeValid ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_TransactionTypeValid ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn OperationValid ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_OperationValid ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn LevelValid ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_LevelValid ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ProcessorContextCorruptValid ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_ProcessorContextCorruptValid ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UncorrectedValid ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_UncorrectedValid ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PreciseIPValid ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_PreciseIPValid ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn RestartableIPValid ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_RestartableIPValid ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn OverflowValid ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_OverflowValid ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ParticipationValid ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_ParticipationValid ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn TimeoutValid ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_TimeoutValid ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AddressSpaceValid ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_AddressSpaceValid ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ReservedValid ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 5u8 ) as u64 ) } } # [ inline ] pub fn set_ReservedValid ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 5u8 , val as u64 ) } } # [ inline ] pub fn TransactionType ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 2u8 ) as u64 ) } } # [ inline ] pub fn set_TransactionType ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 2u8 , val as u64 ) } } # [ inline ] pub fn Operation ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 18usize , 4u8 ) as u64 ) } } # [ inline ] pub fn set_Operation ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 18usize , 4u8 , val as u64 ) } } # [ inline ] pub fn Level ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 22usize , 3u8 ) as u64 ) } } # [ inline ] pub fn set_Level ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 22usize , 3u8 , val as u64 ) } } # [ inline ] pub fn ProcessorContextCorrupt ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 25usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_ProcessorContextCorrupt ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 25usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Uncorrected ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 26usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_Uncorrected ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 26usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PreciseIP ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 27usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_PreciseIP ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 27usize , 1u8 , val as u64 ) } } # [ inline ] pub fn RestartableIP ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 28usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_RestartableIP ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 28usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Overflow ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 29usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_Overflow ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 29usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Participation ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 30usize , 2u8 ) as u64 ) } } # [ inline ] pub fn set_Participation ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 30usize , 2u8 , val as u64 ) } } # [ inline ] pub fn Timeout ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 32usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_Timeout ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 32usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AddressSpace ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 33usize , 2u8 ) as u64 ) } } # [ inline ] pub fn set_AddressSpace ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 33usize , 2u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 35usize , 29u8 ) as u64 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 35usize , 29u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( TransactionTypeValid : ULONGLONG , OperationValid : ULONGLONG , LevelValid : ULONGLONG , ProcessorContextCorruptValid : ULONGLONG , UncorrectedValid : ULONGLONG , PreciseIPValid : ULONGLONG , RestartableIPValid : ULONGLONG , OverflowValid : ULONGLONG , ParticipationValid : ULONGLONG , TimeoutValid : ULONGLONG , AddressSpaceValid : ULONGLONG , ReservedValid : ULONGLONG , TransactionType : ULONGLONG , Operation : ULONGLONG , Level : ULONGLONG , ProcessorContextCorrupt : ULONGLONG , Uncorrected : ULONGLONG , PreciseIP : ULONGLONG , RestartableIP : ULONGLONG , Overflow : ULONGLONG , Participation : ULONGLONG , Timeout : ULONGLONG , AddressSpace : ULONGLONG , Reserved : ULONGLONG ) -> __BindgenBitfieldUnit < [ u8 ; 8usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let TransactionTypeValid : u64 = unsafe { :: std :: mem :: transmute ( TransactionTypeValid ) } ; TransactionTypeValid as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let OperationValid : u64 = unsafe { :: std :: mem :: transmute ( OperationValid ) } ; OperationValid as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let LevelValid : u64 = unsafe { :: std :: mem :: transmute ( LevelValid ) } ; LevelValid as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let ProcessorContextCorruptValid : u64 = unsafe { :: std :: mem :: transmute ( ProcessorContextCorruptValid ) } ; ProcessorContextCorruptValid as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let UncorrectedValid : u64 = unsafe { :: std :: mem :: transmute ( UncorrectedValid ) } ; UncorrectedValid as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let PreciseIPValid : u64 = unsafe { :: std :: mem :: transmute ( PreciseIPValid ) } ; PreciseIPValid as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let RestartableIPValid : u64 = unsafe { :: std :: mem :: transmute ( RestartableIPValid ) } ; RestartableIPValid as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let OverflowValid : u64 = unsafe { :: std :: mem :: transmute ( OverflowValid ) } ; OverflowValid as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let ParticipationValid : u64 = unsafe { :: std :: mem :: transmute ( ParticipationValid ) } ; ParticipationValid as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let TimeoutValid : u64 = unsafe { :: std :: mem :: transmute ( TimeoutValid ) } ; TimeoutValid as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 1u8 , { let AddressSpaceValid : u64 = unsafe { :: std :: mem :: transmute ( AddressSpaceValid ) } ; AddressSpaceValid as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 5u8 , { let ReservedValid : u64 = unsafe { :: std :: mem :: transmute ( ReservedValid ) } ; ReservedValid as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 2u8 , { let TransactionType : u64 = unsafe { :: std :: mem :: transmute ( TransactionType ) } ; TransactionType as u64 } ) ; __bindgen_bitfield_unit . set ( 18usize , 4u8 , { let Operation : u64 = unsafe { :: std :: mem :: transmute ( Operation ) } ; Operation as u64 } ) ; __bindgen_bitfield_unit . set ( 22usize , 3u8 , { let Level : u64 = unsafe { :: std :: mem :: transmute ( Level ) } ; Level as u64 } ) ; __bindgen_bitfield_unit . set ( 25usize , 1u8 , { let ProcessorContextCorrupt : u64 = unsafe { :: std :: mem :: transmute ( ProcessorContextCorrupt ) } ; ProcessorContextCorrupt as u64 } ) ; __bindgen_bitfield_unit . set ( 26usize , 1u8 , { let Uncorrected : u64 = unsafe { :: std :: mem :: transmute ( Uncorrected ) } ; Uncorrected as u64 } ) ; __bindgen_bitfield_unit . set ( 27usize , 1u8 , { let PreciseIP : u64 = unsafe { :: std :: mem :: transmute ( PreciseIP ) } ; PreciseIP as u64 } ) ; __bindgen_bitfield_unit . set ( 28usize , 1u8 , { let RestartableIP : u64 = unsafe { :: std :: mem :: transmute ( RestartableIP ) } ; RestartableIP as u64 } ) ; __bindgen_bitfield_unit . set ( 29usize , 1u8 , { let Overflow : u64 = unsafe { :: std :: mem :: transmute ( Overflow ) } ; Overflow as u64 } ) ; __bindgen_bitfield_unit . set ( 30usize , 2u8 , { let Participation : u64 = unsafe { :: std :: mem :: transmute ( Participation ) } ; Participation as u64 } ) ; __bindgen_bitfield_unit . set ( 32usize , 1u8 , { let Timeout : u64 = unsafe { :: std :: mem :: transmute ( Timeout ) } ; Timeout as u64 } ) ; __bindgen_bitfield_unit . set ( 33usize , 2u8 , { let AddressSpace : u64 = unsafe { :: std :: mem :: transmute ( AddressSpace ) } ; AddressSpace as u64 } ) ; __bindgen_bitfield_unit . set ( 35usize , 29u8 , { let Reserved : u64 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_XPF_BUS_CHECK = _WHEA_XPF_BUS_CHECK ; pub type PWHEA_XPF_BUS_CHECK = * mut _WHEA_XPF_BUS_CHECK ; # [ repr ( C , packed ) ] pub struct _WHEA_XPF_MS_CHECK { pub __bindgen_anon_1 : __BindgenUnionField < _WHEA_XPF_MS_CHECK__bindgen_ty_1 > , pub XpfMsCheck : __BindgenUnionField < ULONGLONG > , pub bindgen_union_field : [ u8 ; 8usize ] , } # [ repr ( C , packed ) ] pub struct _WHEA_XPF_MS_CHECK__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > , } impl _WHEA_XPF_MS_CHECK__bindgen_ty_1 { # [ inline ] pub fn ErrorTypeValid ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_ErrorTypeValid ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ProcessorContextCorruptValid ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_ProcessorContextCorruptValid ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UncorrectedValid ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_UncorrectedValid ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PreciseIPValid ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_PreciseIPValid ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn RestartableIPValid ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_RestartableIPValid ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn OverflowValid ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_OverflowValid ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ReservedValue ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 10u8 ) as u64 ) } } # [ inline ] pub fn set_ReservedValue ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 10u8 , val as u64 ) } } # [ inline ] pub fn ErrorType ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 3u8 ) as u64 ) } } # [ inline ] pub fn set_ErrorType ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 3u8 , val as u64 ) } } # [ inline ] pub fn ProcessorContextCorrupt ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 19usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_ProcessorContextCorrupt ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 19usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Uncorrected ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 20usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_Uncorrected ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 20usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PreciseIP ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 21usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_PreciseIP ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 21usize , 1u8 , val as u64 ) } } # [ inline ] pub fn RestartableIP ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 22usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_RestartableIP ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 22usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Overflow ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 23usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_Overflow ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 23usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 40u8 ) as u64 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 40u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ErrorTypeValid : ULONGLONG , ProcessorContextCorruptValid : ULONGLONG , UncorrectedValid : ULONGLONG , PreciseIPValid : ULONGLONG , RestartableIPValid : ULONGLONG , OverflowValid : ULONGLONG , ReservedValue : ULONGLONG , ErrorType : ULONGLONG , ProcessorContextCorrupt : ULONGLONG , Uncorrected : ULONGLONG , PreciseIP : ULONGLONG , RestartableIP : ULONGLONG , Overflow : ULONGLONG , Reserved : ULONGLONG ) -> __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let ErrorTypeValid : u64 = unsafe { :: std :: mem :: transmute ( ErrorTypeValid ) } ; ErrorTypeValid as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let ProcessorContextCorruptValid : u64 = unsafe { :: std :: mem :: transmute ( ProcessorContextCorruptValid ) } ; ProcessorContextCorruptValid as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let UncorrectedValid : u64 = unsafe { :: std :: mem :: transmute ( UncorrectedValid ) } ; UncorrectedValid as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let PreciseIPValid : u64 = unsafe { :: std :: mem :: transmute ( PreciseIPValid ) } ; PreciseIPValid as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let RestartableIPValid : u64 = unsafe { :: std :: mem :: transmute ( RestartableIPValid ) } ; RestartableIPValid as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let OverflowValid : u64 = unsafe { :: std :: mem :: transmute ( OverflowValid ) } ; OverflowValid as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 10u8 , { let ReservedValue : u64 = unsafe { :: std :: mem :: transmute ( ReservedValue ) } ; ReservedValue as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 3u8 , { let ErrorType : u64 = unsafe { :: std :: mem :: transmute ( ErrorType ) } ; ErrorType as u64 } ) ; __bindgen_bitfield_unit . set ( 19usize , 1u8 , { let ProcessorContextCorrupt : u64 = unsafe { :: std :: mem :: transmute ( ProcessorContextCorrupt ) } ; ProcessorContextCorrupt as u64 } ) ; __bindgen_bitfield_unit . set ( 20usize , 1u8 , { let Uncorrected : u64 = unsafe { :: std :: mem :: transmute ( Uncorrected ) } ; Uncorrected as u64 } ) ; __bindgen_bitfield_unit . set ( 21usize , 1u8 , { let PreciseIP : u64 = unsafe { :: std :: mem :: transmute ( PreciseIP ) } ; PreciseIP as u64 } ) ; __bindgen_bitfield_unit . set ( 22usize , 1u8 , { let RestartableIP : u64 = unsafe { :: std :: mem :: transmute ( RestartableIP ) } ; RestartableIP as u64 } ) ; __bindgen_bitfield_unit . set ( 23usize , 1u8 , { let Overflow : u64 = unsafe { :: std :: mem :: transmute ( Overflow ) } ; Overflow as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 40u8 , { let Reserved : u64 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_XPF_MS_CHECK = _WHEA_XPF_MS_CHECK ; pub type PWHEA_XPF_MS_CHECK = * mut _WHEA_XPF_MS_CHECK ; # [ repr ( C , packed ) ] pub struct _WHEA_XPF_PROCINFO_VALIDBITS { pub __bindgen_anon_1 : __BindgenUnionField < _WHEA_XPF_PROCINFO_VALIDBITS__bindgen_ty_1 > , pub ValidBits : __BindgenUnionField < ULONGLONG > , pub bindgen_union_field : [ u8 ; 8usize ] , } # [ repr ( C , packed ) ] pub struct _WHEA_XPF_PROCINFO_VALIDBITS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > , } impl _WHEA_XPF_PROCINFO_VALIDBITS__bindgen_ty_1 { # [ inline ] pub fn CheckInfo ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_CheckInfo ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn TargetId ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_TargetId ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn RequesterId ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_RequesterId ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ResponderId ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_ResponderId ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn InstructionPointer ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_InstructionPointer ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 59u8 ) as u64 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 59u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( CheckInfo : ULONGLONG , TargetId : ULONGLONG , RequesterId : ULONGLONG , ResponderId : ULONGLONG , InstructionPointer : ULONGLONG , Reserved : ULONGLONG ) -> __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let CheckInfo : u64 = unsafe { :: std :: mem :: transmute ( CheckInfo ) } ; CheckInfo as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let TargetId : u64 = unsafe { :: std :: mem :: transmute ( TargetId ) } ; TargetId as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let RequesterId : u64 = unsafe { :: std :: mem :: transmute ( RequesterId ) } ; RequesterId as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let ResponderId : u64 = unsafe { :: std :: mem :: transmute ( ResponderId ) } ; ResponderId as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let InstructionPointer : u64 = unsafe { :: std :: mem :: transmute ( InstructionPointer ) } ; InstructionPointer as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 59u8 , { let Reserved : u64 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_XPF_PROCINFO_VALIDBITS = _WHEA_XPF_PROCINFO_VALIDBITS ; pub type PWHEA_XPF_PROCINFO_VALIDBITS = * mut _WHEA_XPF_PROCINFO_VALIDBITS ; # [ repr ( C , packed ) ] pub struct _WHEA_XPF_PROCINFO { pub CheckInfoId : GUID , pub ValidBits : WHEA_XPF_PROCINFO_VALIDBITS , pub CheckInfo : _WHEA_XPF_PROCINFO__bindgen_ty_1 , pub TargetId : ULONGLONG , pub RequesterId : ULONGLONG , pub ResponderId : ULONGLONG , pub InstructionPointer : ULONGLONG , } # [ repr ( C , packed ) ] pub struct _WHEA_XPF_PROCINFO__bindgen_ty_1 { pub CacheCheck : __BindgenUnionField < WHEA_XPF_CACHE_CHECK > , pub TlbCheck : __BindgenUnionField < WHEA_XPF_TLB_CHECK > , pub BusCheck : __BindgenUnionField < WHEA_XPF_BUS_CHECK > , pub MsCheck : __BindgenUnionField < WHEA_XPF_MS_CHECK > , pub AsULONGLONG : __BindgenUnionField < ULONGLONG > , pub bindgen_union_field : [ u8 ; 8usize ] , } pub type WHEA_XPF_PROCINFO = _WHEA_XPF_PROCINFO ; pub type PWHEA_XPF_PROCINFO = * mut _WHEA_XPF_PROCINFO ; # [ repr ( C , packed ) ] pub struct _WHEA_X86_REGISTER_STATE { pub Eax : ULONG , pub Ebx : ULONG , pub Ecx : ULONG , pub Edx : ULONG , pub Esi : ULONG , pub Edi : ULONG , pub Ebp : ULONG , pub Esp : ULONG , pub Cs : USHORT , pub Ds : USHORT , pub Ss : USHORT , pub Es : USHORT , pub Fs : USHORT , pub Gs : USHORT , pub Eflags : ULONG , pub Eip : ULONG , pub Cr0 : ULONG , pub Cr1 : ULONG , pub Cr2 : ULONG , pub Cr3 : ULONG , pub Cr4 : ULONG , pub Gdtr : ULONGLONG , pub Idtr : ULONGLONG , pub Ldtr : USHORT , pub Tr : USHORT , } pub type WHEA_X86_REGISTER_STATE = _WHEA_X86_REGISTER_STATE ; pub type PWHEA_X86_REGISTER_STATE = * mut _WHEA_X86_REGISTER_STATE ; # [ repr ( C ) ] pub struct _WHEA128A { pub Low : ULONGLONG , pub High : LONGLONG , } pub type WHEA128A = _WHEA128A ; pub type PWHEA128A = * mut _WHEA128A ; # [ repr ( C ) ] pub struct _WHEA_X64_REGISTER_STATE { pub Rax : ULONGLONG , pub Rbx : ULONGLONG , pub Rcx : ULONGLONG , pub Rdx : ULONGLONG , pub Rsi : ULONGLONG , pub Rdi : ULONGLONG , pub Rbp : ULONGLONG , pub Rsp : ULONGLONG , pub R8 : ULONGLONG , pub R9 : ULONGLONG , pub R10 : ULONGLONG , pub R11 : ULONGLONG , pub R12 : ULONGLONG , pub R13 : ULONGLONG , pub R14 : ULONGLONG , pub R15 : ULONGLONG , pub Cs : USHORT , pub Ds : USHORT , pub Ss : USHORT , pub Es : USHORT , pub Fs : USHORT , pub Gs : USHORT , pub Reserved : ULONG , pub Rflags : ULONGLONG , pub Eip : ULONGLONG , pub Cr0 : ULONGLONG , pub Cr1 : ULONGLONG , pub Cr2 : ULONGLONG , pub Cr3 : ULONGLONG , pub Cr4 : ULONGLONG , pub Cr8 : ULONGLONG , pub Gdtr : WHEA128A , pub Idtr : WHEA128A , pub Ldtr : USHORT , pub Tr : USHORT , pub __bindgen_padding_0 : [ u32 ; 3usize ] , } pub type WHEA_X64_REGISTER_STATE = _WHEA_X64_REGISTER_STATE ; pub type PWHEA_X64_REGISTER_STATE = * mut _WHEA_X64_REGISTER_STATE ; # [ repr ( C , packed ) ] pub struct _WHEA_XPF_CONTEXT_INFO { pub RegisterContextType : USHORT , pub RegisterDataSize : USHORT , pub MSRAddress : ULONG , pub MmRegisterAddress : ULONGLONG , } pub type WHEA_XPF_CONTEXT_INFO = _WHEA_XPF_CONTEXT_INFO ; pub type PWHEA_XPF_CONTEXT_INFO = * mut _WHEA_XPF_CONTEXT_INFO ; # [ repr ( C , packed ) ] pub struct _WHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS { pub __bindgen_anon_1 : __BindgenUnionField < _WHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS__bindgen_ty_1 > , pub ValidBits : __BindgenUnionField < ULONGLONG > , pub bindgen_union_field : [ u8 ; 8usize ] , } # [ repr ( C , packed ) ] pub struct _WHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > , } impl _WHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS__bindgen_ty_1 { # [ inline ] pub fn LocalAPICId ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_LocalAPICId ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn CpuId ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_CpuId ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ProcInfoCount ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 6u8 ) as u64 ) } } # [ inline ] pub fn set_ProcInfoCount ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 6u8 , val as u64 ) } } # [ inline ] pub fn ContextInfoCount ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 6u8 ) as u64 ) } } # [ inline ] pub fn set_ContextInfoCount ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 6u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 50u8 ) as u64 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 50u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( LocalAPICId : ULONGLONG , CpuId : ULONGLONG , ProcInfoCount : ULONGLONG , ContextInfoCount : ULONGLONG , Reserved : ULONGLONG ) -> __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let LocalAPICId : u64 = unsafe { :: std :: mem :: transmute ( LocalAPICId ) } ; LocalAPICId as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let CpuId : u64 = unsafe { :: std :: mem :: transmute ( CpuId ) } ; CpuId as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 6u8 , { let ProcInfoCount : u64 = unsafe { :: std :: mem :: transmute ( ProcInfoCount ) } ; ProcInfoCount as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 6u8 , { let ContextInfoCount : u64 = unsafe { :: std :: mem :: transmute ( ContextInfoCount ) } ; ContextInfoCount as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 50u8 , { let Reserved : u64 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS = _WHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS ; pub type PWHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS = * mut _WHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS ; # [ repr ( C , packed ) ] pub struct _WHEA_XPF_PROCESSOR_ERROR_SECTION { pub ValidBits : WHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS , pub LocalAPICId : ULONGLONG , pub CpuId : [ UCHAR ; 48usize ] , pub VariableInfo : [ UCHAR ; 1usize ] , } pub type WHEA_XPF_PROCESSOR_ERROR_SECTION = _WHEA_XPF_PROCESSOR_ERROR_SECTION ; pub type PWHEA_XPF_PROCESSOR_ERROR_SECTION = * mut _WHEA_XPF_PROCESSOR_ERROR_SECTION ; # [ repr ( C , packed ) ] pub struct _WHEA_MEMORY_ERROR_SECTION_VALIDBITS { pub __bindgen_anon_1 : __BindgenUnionField < _WHEA_MEMORY_ERROR_SECTION_VALIDBITS__bindgen_ty_1 > , pub ValidBits : __BindgenUnionField < ULONGLONG > , pub bindgen_union_field : [ u8 ; 8usize ] , } # [ repr ( C , packed ) ] pub struct _WHEA_MEMORY_ERROR_SECTION_VALIDBITS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > , } impl _WHEA_MEMORY_ERROR_SECTION_VALIDBITS__bindgen_ty_1 { # [ inline ] pub fn ErrorStatus ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_ErrorStatus ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PhysicalAddress ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_PhysicalAddress ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PhysicalAddressMask ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_PhysicalAddressMask ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Node ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_Node ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Card ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_Card ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Module ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_Module ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Bank ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_Bank ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Device ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_Device ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Row ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_Row ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Column ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_Column ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn BitPosition ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_BitPosition ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 1u8 , val as u64 ) } } # [ inline ] pub fn RequesterId ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_RequesterId ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ResponderId ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_ResponderId ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 1u8 , val as u64 ) } } # [ inline ] pub fn TargetId ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 13usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_TargetId ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 13usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ErrorType ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_ErrorType ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 15usize , 49u8 ) as u64 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 15usize , 49u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ErrorStatus : ULONGLONG , PhysicalAddress : ULONGLONG , PhysicalAddressMask : ULONGLONG , Node : ULONGLONG , Card : ULONGLONG , Module : ULONGLONG , Bank : ULONGLONG , Device : ULONGLONG , Row : ULONGLONG , Column : ULONGLONG , BitPosition : ULONGLONG , RequesterId : ULONGLONG , ResponderId : ULONGLONG , TargetId : ULONGLONG , ErrorType : ULONGLONG , Reserved : ULONGLONG ) -> __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let ErrorStatus : u64 = unsafe { :: std :: mem :: transmute ( ErrorStatus ) } ; ErrorStatus as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let PhysicalAddress : u64 = unsafe { :: std :: mem :: transmute ( PhysicalAddress ) } ; PhysicalAddress as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let PhysicalAddressMask : u64 = unsafe { :: std :: mem :: transmute ( PhysicalAddressMask ) } ; PhysicalAddressMask as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let Node : u64 = unsafe { :: std :: mem :: transmute ( Node ) } ; Node as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let Card : u64 = unsafe { :: std :: mem :: transmute ( Card ) } ; Card as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let Module : u64 = unsafe { :: std :: mem :: transmute ( Module ) } ; Module as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let Bank : u64 = unsafe { :: std :: mem :: transmute ( Bank ) } ; Bank as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let Device : u64 = unsafe { :: std :: mem :: transmute ( Device ) } ; Device as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let Row : u64 = unsafe { :: std :: mem :: transmute ( Row ) } ; Row as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let Column : u64 = unsafe { :: std :: mem :: transmute ( Column ) } ; Column as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 1u8 , { let BitPosition : u64 = unsafe { :: std :: mem :: transmute ( BitPosition ) } ; BitPosition as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 1u8 , { let RequesterId : u64 = unsafe { :: std :: mem :: transmute ( RequesterId ) } ; RequesterId as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 1u8 , { let ResponderId : u64 = unsafe { :: std :: mem :: transmute ( ResponderId ) } ; ResponderId as u64 } ) ; __bindgen_bitfield_unit . set ( 13usize , 1u8 , { let TargetId : u64 = unsafe { :: std :: mem :: transmute ( TargetId ) } ; TargetId as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 1u8 , { let ErrorType : u64 = unsafe { :: std :: mem :: transmute ( ErrorType ) } ; ErrorType as u64 } ) ; __bindgen_bitfield_unit . set ( 15usize , 49u8 , { let Reserved : u64 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_MEMORY_ERROR_SECTION_VALIDBITS = _WHEA_MEMORY_ERROR_SECTION_VALIDBITS ; pub type PWHEA_MEMORY_ERROR_SECTION_VALIDBITS = * mut _WHEA_MEMORY_ERROR_SECTION_VALIDBITS ; # [ repr ( C , packed ) ] pub struct _WHEA_MEMORY_ERROR_SECTION { pub ValidBits : WHEA_MEMORY_ERROR_SECTION_VALIDBITS , pub ErrorStatus : WHEA_ERROR_STATUS , pub PhysicalAddress : ULONGLONG , pub PhysicalAddressMask : ULONGLONG , pub Node : USHORT , pub Card : USHORT , pub Module : USHORT , pub Bank : USHORT , pub Device : USHORT , pub Row : USHORT , pub Column : USHORT , pub BitPosition : USHORT , pub RequesterId : ULONGLONG , pub ResponderId : ULONGLONG , pub TargetId : ULONGLONG , pub ErrorType : UCHAR , } pub type WHEA_MEMORY_ERROR_SECTION = _WHEA_MEMORY_ERROR_SECTION ; pub type PWHEA_MEMORY_ERROR_SECTION = * mut _WHEA_MEMORY_ERROR_SECTION ; # [ repr ( C , packed ) ] pub struct _WHEA_PCIEXPRESS_ERROR_SECTION_VALIDBITS { pub __bindgen_anon_1 : __BindgenUnionField < _WHEA_PCIEXPRESS_ERROR_SECTION_VALIDBITS__bindgen_ty_1 > , pub ValidBits : __BindgenUnionField < ULONGLONG > , pub bindgen_union_field : [ u8 ; 8usize ] , } # [ repr ( C , packed ) ] pub struct _WHEA_PCIEXPRESS_ERROR_SECTION_VALIDBITS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > , } impl _WHEA_PCIEXPRESS_ERROR_SECTION_VALIDBITS__bindgen_ty_1 { # [ inline ] pub fn PortType ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_PortType ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Version ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_Version ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn CommandStatus ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_CommandStatus ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn DeviceId ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_DeviceId ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn DeviceSerialNumber ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_DeviceSerialNumber ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn BridgeControlStatus ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_BridgeControlStatus ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ExpressCapability ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_ExpressCapability ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AerInfo ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_AerInfo ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 56u8 ) as u64 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 56u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( PortType : ULONGLONG , Version : ULONGLONG , CommandStatus : ULONGLONG , DeviceId : ULONGLONG , DeviceSerialNumber : ULONGLONG , BridgeControlStatus : ULONGLONG , ExpressCapability : ULONGLONG , AerInfo : ULONGLONG , Reserved : ULONGLONG ) -> __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let PortType : u64 = unsafe { :: std :: mem :: transmute ( PortType ) } ; PortType as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let Version : u64 = unsafe { :: std :: mem :: transmute ( Version ) } ; Version as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let CommandStatus : u64 = unsafe { :: std :: mem :: transmute ( CommandStatus ) } ; CommandStatus as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let DeviceId : u64 = unsafe { :: std :: mem :: transmute ( DeviceId ) } ; DeviceId as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let DeviceSerialNumber : u64 = unsafe { :: std :: mem :: transmute ( DeviceSerialNumber ) } ; DeviceSerialNumber as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let BridgeControlStatus : u64 = unsafe { :: std :: mem :: transmute ( BridgeControlStatus ) } ; BridgeControlStatus as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let ExpressCapability : u64 = unsafe { :: std :: mem :: transmute ( ExpressCapability ) } ; ExpressCapability as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let AerInfo : u64 = unsafe { :: std :: mem :: transmute ( AerInfo ) } ; AerInfo as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 56u8 , { let Reserved : u64 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_PCIEXPRESS_ERROR_SECTION_VALIDBITS = _WHEA_PCIEXPRESS_ERROR_SECTION_VALIDBITS ; pub type PWHEA_PCIEXPRESS_ERROR_SECTION_VALIDBITS = * mut _WHEA_PCIEXPRESS_ERROR_SECTION_VALIDBITS ; # [ repr ( C , packed ) ] pub struct _WHEA_PCIEXPRESS_DEVICE_ID { pub VendorID : USHORT , pub DeviceID : USHORT , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 12usize ] , u32 > , } impl _WHEA_PCIEXPRESS_DEVICE_ID { # [ inline ] pub fn ClassCode ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 24u8 ) as u32 ) } } # [ inline ] pub fn set_ClassCode ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 24u8 , val as u64 ) } } # [ inline ] pub fn FunctionNumber ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_FunctionNumber ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn DeviceNumber ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 32usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_DeviceNumber ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 32usize , 8u8 , val as u64 ) } } # [ inline ] pub fn Segment ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 40usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_Segment ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 40usize , 16u8 , val as u64 ) } } # [ inline ] pub fn PrimaryBusNumber ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 56usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_PrimaryBusNumber ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 56usize , 8u8 , val as u64 ) } } # [ inline ] pub fn SecondaryBusNumber ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 64usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_SecondaryBusNumber ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 64usize , 8u8 , val as u64 ) } } # [ inline ] pub fn Reserved1 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 72usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved1 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 72usize , 3u8 , val as u64 ) } } # [ inline ] pub fn SlotNumber ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 75usize , 13u8 ) as u32 ) } } # [ inline ] pub fn set_SlotNumber ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 75usize , 13u8 , val as u64 ) } } # [ inline ] pub fn Reserved2 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 88usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved2 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 88usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ClassCode : ULONG , FunctionNumber : ULONG , DeviceNumber : ULONG , Segment : ULONG , PrimaryBusNumber : ULONG , SecondaryBusNumber : ULONG , Reserved1 : ULONG , SlotNumber : ULONG , Reserved2 : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 12usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 12usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 24u8 , { let ClassCode : u32 = unsafe { :: std :: mem :: transmute ( ClassCode ) } ; ClassCode as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let FunctionNumber : u32 = unsafe { :: std :: mem :: transmute ( FunctionNumber ) } ; FunctionNumber as u64 } ) ; __bindgen_bitfield_unit . set ( 32usize , 8u8 , { let DeviceNumber : u32 = unsafe { :: std :: mem :: transmute ( DeviceNumber ) } ; DeviceNumber as u64 } ) ; __bindgen_bitfield_unit . set ( 40usize , 16u8 , { let Segment : u32 = unsafe { :: std :: mem :: transmute ( Segment ) } ; Segment as u64 } ) ; __bindgen_bitfield_unit . set ( 56usize , 8u8 , { let PrimaryBusNumber : u32 = unsafe { :: std :: mem :: transmute ( PrimaryBusNumber ) } ; PrimaryBusNumber as u64 } ) ; __bindgen_bitfield_unit . set ( 64usize , 8u8 , { let SecondaryBusNumber : u32 = unsafe { :: std :: mem :: transmute ( SecondaryBusNumber ) } ; SecondaryBusNumber as u64 } ) ; __bindgen_bitfield_unit . set ( 72usize , 3u8 , { let Reserved1 : u32 = unsafe { :: std :: mem :: transmute ( Reserved1 ) } ; Reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 75usize , 13u8 , { let SlotNumber : u32 = unsafe { :: std :: mem :: transmute ( SlotNumber ) } ; SlotNumber as u64 } ) ; __bindgen_bitfield_unit . set ( 88usize , 8u8 , { let Reserved2 : u32 = unsafe { :: std :: mem :: transmute ( Reserved2 ) } ; Reserved2 as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_PCIEXPRESS_DEVICE_ID = _WHEA_PCIEXPRESS_DEVICE_ID ; pub type PWHEA_PCIEXPRESS_DEVICE_ID = * mut _WHEA_PCIEXPRESS_DEVICE_ID ; # [ repr ( C , packed ) ] pub struct _WHEA_PCIEXPRESS_VERSION { pub __bindgen_anon_1 : __BindgenUnionField < _WHEA_PCIEXPRESS_VERSION__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : [ u8 ; 4usize ] , } # [ repr ( C , packed ) ] pub struct _WHEA_PCIEXPRESS_VERSION__bindgen_ty_1 { pub MinorVersion : UCHAR , pub MajorVersion : UCHAR , pub Reserved : USHORT , } pub type WHEA_PCIEXPRESS_VERSION = _WHEA_PCIEXPRESS_VERSION ; pub type PWHEA_PCIEXPRESS_VERSION = * mut _WHEA_PCIEXPRESS_VERSION ; # [ repr ( C , packed ) ] pub struct _WHEA_PCIEXPRESS_COMMAND_STATUS { pub __bindgen_anon_1 : __BindgenUnionField < _WHEA_PCIEXPRESS_COMMAND_STATUS__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : [ u8 ; 4usize ] , } # [ repr ( C , packed ) ] pub struct _WHEA_PCIEXPRESS_COMMAND_STATUS__bindgen_ty_1 { pub Command : USHORT , pub Status : USHORT , } pub type WHEA_PCIEXPRESS_COMMAND_STATUS = _WHEA_PCIEXPRESS_COMMAND_STATUS ; pub type PWHEA_PCIEXPRESS_COMMAND_STATUS = * mut _WHEA_PCIEXPRESS_COMMAND_STATUS ; # [ repr ( C , packed ) ] pub struct _WHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS { pub __bindgen_anon_1 : __BindgenUnionField < _WHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : [ u8 ; 4usize ] , } # [ repr ( C , packed ) ] pub struct _WHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS__bindgen_ty_1 { pub BridgeSecondaryStatus : USHORT , pub BridgeControl : USHORT , } pub type WHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS = _WHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS ; pub type PWHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS = * mut _WHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS ; pub const _WHEA_PCIEXPRESS_DEVICE_TYPE_WheaPciExpressEndpoint : _WHEA_PCIEXPRESS_DEVICE_TYPE = 0 ; pub const _WHEA_PCIEXPRESS_DEVICE_TYPE_WheaPciExpressLegacyEndpoint : _WHEA_PCIEXPRESS_DEVICE_TYPE = 1 ; pub const _WHEA_PCIEXPRESS_DEVICE_TYPE_WheaPciExpressRootPort : _WHEA_PCIEXPRESS_DEVICE_TYPE = 4 ; pub const _WHEA_PCIEXPRESS_DEVICE_TYPE_WheaPciExpressUpstreamSwitchPort : _WHEA_PCIEXPRESS_DEVICE_TYPE = 5 ; pub const _WHEA_PCIEXPRESS_DEVICE_TYPE_WheaPciExpressDownstreamSwitchPort : _WHEA_PCIEXPRESS_DEVICE_TYPE = 6 ; pub const _WHEA_PCIEXPRESS_DEVICE_TYPE_WheaPciExpressToPciXBridge : _WHEA_PCIEXPRESS_DEVICE_TYPE = 7 ; pub const _WHEA_PCIEXPRESS_DEVICE_TYPE_WheaPciXToExpressBridge : _WHEA_PCIEXPRESS_DEVICE_TYPE = 8 ; pub const _WHEA_PCIEXPRESS_DEVICE_TYPE_WheaPciExpressRootComplexIntegratedEndpoint : _WHEA_PCIEXPRESS_DEVICE_TYPE = 9 ; pub const _WHEA_PCIEXPRESS_DEVICE_TYPE_WheaPciExpressRootComplexEventCollector : _WHEA_PCIEXPRESS_DEVICE_TYPE = 10 ; pub type _WHEA_PCIEXPRESS_DEVICE_TYPE = i32 ; pub use self :: _WHEA_PCIEXPRESS_DEVICE_TYPE as WHEA_PCIEXPRESS_DEVICE_TYPE ; # [ repr ( C , packed ) ] pub struct _WHEA_PCIEXPRESS_ERROR_SECTION { pub ValidBits : WHEA_PCIEXPRESS_ERROR_SECTION_VALIDBITS , pub PortType : WHEA_PCIEXPRESS_DEVICE_TYPE , pub Version : WHEA_PCIEXPRESS_VERSION , pub CommandStatus : WHEA_PCIEXPRESS_COMMAND_STATUS , pub Reserved : ULONG , pub DeviceId : WHEA_PCIEXPRESS_DEVICE_ID , pub DeviceSerialNumber : ULONGLONG , pub BridgeControlStatus : WHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS , pub ExpressCapability : [ UCHAR ; 60usize ] , pub AerInfo : [ UCHAR ; 96usize ] , } pub type WHEA_PCIEXPRESS_ERROR_SECTION = _WHEA_PCIEXPRESS_ERROR_SECTION ; pub type PWHEA_PCIEXPRESS_ERROR_SECTION = * mut _WHEA_PCIEXPRESS_ERROR_SECTION ; # [ repr ( C , packed ) ] pub struct _WHEA_PCIXBUS_ERROR_SECTION_VALIDBITS { pub __bindgen_anon_1 : __BindgenUnionField < _WHEA_PCIXBUS_ERROR_SECTION_VALIDBITS__bindgen_ty_1 > , pub ValidBits : __BindgenUnionField < ULONGLONG > , pub bindgen_union_field : [ u8 ; 8usize ] , } # [ repr ( C , packed ) ] pub struct _WHEA_PCIXBUS_ERROR_SECTION_VALIDBITS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > , } impl _WHEA_PCIXBUS_ERROR_SECTION_VALIDBITS__bindgen_ty_1 { # [ inline ] pub fn ErrorStatus ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_ErrorStatus ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ErrorType ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_ErrorType ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn BusId ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_BusId ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn BusAddress ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_BusAddress ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn BusData ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_BusData ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn BusCommand ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_BusCommand ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn RequesterId ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_RequesterId ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn CompleterId ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_CompleterId ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn TargetId ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_TargetId ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 55u8 ) as u64 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 55u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ErrorStatus : ULONGLONG , ErrorType : ULONGLONG , BusId : ULONGLONG , BusAddress : ULONGLONG , BusData : ULONGLONG , BusCommand : ULONGLONG , RequesterId : ULONGLONG , CompleterId : ULONGLONG , TargetId : ULONGLONG , Reserved : ULONGLONG ) -> __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let ErrorStatus : u64 = unsafe { :: std :: mem :: transmute ( ErrorStatus ) } ; ErrorStatus as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let ErrorType : u64 = unsafe { :: std :: mem :: transmute ( ErrorType ) } ; ErrorType as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let BusId : u64 = unsafe { :: std :: mem :: transmute ( BusId ) } ; BusId as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let BusAddress : u64 = unsafe { :: std :: mem :: transmute ( BusAddress ) } ; BusAddress as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let BusData : u64 = unsafe { :: std :: mem :: transmute ( BusData ) } ; BusData as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let BusCommand : u64 = unsafe { :: std :: mem :: transmute ( BusCommand ) } ; BusCommand as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let RequesterId : u64 = unsafe { :: std :: mem :: transmute ( RequesterId ) } ; RequesterId as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let CompleterId : u64 = unsafe { :: std :: mem :: transmute ( CompleterId ) } ; CompleterId as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let TargetId : u64 = unsafe { :: std :: mem :: transmute ( TargetId ) } ; TargetId as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 55u8 , { let Reserved : u64 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_PCIXBUS_ERROR_SECTION_VALIDBITS = _WHEA_PCIXBUS_ERROR_SECTION_VALIDBITS ; pub type PWHEA_PCIXBUS_ERROR_SECTION_VALIDBITS = * mut _WHEA_PCIXBUS_ERROR_SECTION_VALIDBITS ; # [ repr ( C , packed ) ] pub struct _WHEA_PCIXBUS_ID { pub __bindgen_anon_1 : __BindgenUnionField < _WHEA_PCIXBUS_ID__bindgen_ty_1 > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : [ u8 ; 2usize ] , } # [ repr ( C ) ] pub struct _WHEA_PCIXBUS_ID__bindgen_ty_1 { pub BusNumber : UCHAR , pub BusSegment : UCHAR , } pub type WHEA_PCIXBUS_ID = _WHEA_PCIXBUS_ID ; pub type PWHEA_PCIXBUS_ID = * mut _WHEA_PCIXBUS_ID ; # [ repr ( C , packed ) ] pub struct _WHEA_PCIXBUS_COMMAND { pub __bindgen_anon_1 : __BindgenUnionField < _WHEA_PCIXBUS_COMMAND__bindgen_ty_1 > , pub AsULONGLONG : __BindgenUnionField < ULONGLONG > , pub bindgen_union_field : [ u8 ; 8usize ] , } # [ repr ( C , packed ) ] pub struct _WHEA_PCIXBUS_COMMAND__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > , } impl _WHEA_PCIXBUS_COMMAND__bindgen_ty_1 { # [ inline ] pub fn Command ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 56u8 ) as u64 ) } } # [ inline ] pub fn set_Command ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 56u8 , val as u64 ) } } # [ inline ] pub fn PCIXCommand ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 56usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_PCIXCommand ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 56usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 57usize , 7u8 ) as u64 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 57usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( Command : ULONGLONG , PCIXCommand : ULONGLONG , Reserved : ULONGLONG ) -> __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 56u8 , { let Command : u64 = unsafe { :: std :: mem :: transmute ( Command ) } ; Command as u64 } ) ; __bindgen_bitfield_unit . set ( 56usize , 1u8 , { let PCIXCommand : u64 = unsafe { :: std :: mem :: transmute ( PCIXCommand ) } ; PCIXCommand as u64 } ) ; __bindgen_bitfield_unit . set ( 57usize , 7u8 , { let Reserved : u64 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_PCIXBUS_COMMAND = _WHEA_PCIXBUS_COMMAND ; pub type PWHEA_PCIXBUS_COMMAND = * mut _WHEA_PCIXBUS_COMMAND ; # [ repr ( C , packed ) ] pub struct _WHEA_PCIXBUS_ERROR_SECTION { pub ValidBits : WHEA_PCIXBUS_ERROR_SECTION_VALIDBITS , pub ErrorStatus : WHEA_ERROR_STATUS , pub ErrorType : USHORT , pub BusId : WHEA_PCIXBUS_ID , pub Reserved : ULONG , pub BusAddress : ULONGLONG , pub BusData : ULONGLONG , pub BusCommand : WHEA_PCIXBUS_COMMAND , pub RequesterId : ULONGLONG , pub CompleterId : ULONGLONG , pub TargetId : ULONGLONG , } pub type WHEA_PCIXBUS_ERROR_SECTION = _WHEA_PCIXBUS_ERROR_SECTION ; pub type PWHEA_PCIXBUS_ERROR_SECTION = * mut _WHEA_PCIXBUS_ERROR_SECTION ; # [ repr ( C , packed ) ] pub struct _WHEA_PCIXDEVICE_ERROR_SECTION_VALIDBITS { pub __bindgen_anon_1 : __BindgenUnionField < _WHEA_PCIXDEVICE_ERROR_SECTION_VALIDBITS__bindgen_ty_1 > , pub ValidBits : __BindgenUnionField < ULONGLONG > , pub bindgen_union_field : [ u8 ; 8usize ] , } # [ repr ( C , packed ) ] pub struct _WHEA_PCIXDEVICE_ERROR_SECTION_VALIDBITS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > , } impl _WHEA_PCIXDEVICE_ERROR_SECTION_VALIDBITS__bindgen_ty_1 { # [ inline ] pub fn ErrorStatus ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_ErrorStatus ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn IdInfo ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_IdInfo ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MemoryNumber ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_MemoryNumber ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn IoNumber ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_IoNumber ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn RegisterDataPairs ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_RegisterDataPairs ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 59u8 ) as u64 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 59u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ErrorStatus : ULONGLONG , IdInfo : ULONGLONG , MemoryNumber : ULONGLONG , IoNumber : ULONGLONG , RegisterDataPairs : ULONGLONG , Reserved : ULONGLONG ) -> __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let ErrorStatus : u64 = unsafe { :: std :: mem :: transmute ( ErrorStatus ) } ; ErrorStatus as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let IdInfo : u64 = unsafe { :: std :: mem :: transmute ( IdInfo ) } ; IdInfo as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let MemoryNumber : u64 = unsafe { :: std :: mem :: transmute ( MemoryNumber ) } ; MemoryNumber as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let IoNumber : u64 = unsafe { :: std :: mem :: transmute ( IoNumber ) } ; IoNumber as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let RegisterDataPairs : u64 = unsafe { :: std :: mem :: transmute ( RegisterDataPairs ) } ; RegisterDataPairs as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 59u8 , { let Reserved : u64 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_PCIXDEVICE_ERROR_SECTION_VALIDBITS = _WHEA_PCIXDEVICE_ERROR_SECTION_VALIDBITS ; pub type PWHEA_PCIXDEVICE_ERROR_SECTION_VALIDBITS = * mut _WHEA_PCIXDEVICE_ERROR_SECTION_VALIDBITS ; # [ repr ( C , packed ) ] pub struct _WHEA_PCIXDEVICE_ID { pub VendorId : USHORT , pub DeviceId : USHORT , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u32 > , pub Reserved2 : ULONG , } impl _WHEA_PCIXDEVICE_ID { # [ inline ] pub fn ClassCode ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 24u8 ) as u32 ) } } # [ inline ] pub fn set_ClassCode ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 24u8 , val as u64 ) } } # [ inline ] pub fn FunctionNumber ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_FunctionNumber ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn DeviceNumber ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 32usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_DeviceNumber ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 32usize , 8u8 , val as u64 ) } } # [ inline ] pub fn BusNumber ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 40usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_BusNumber ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 40usize , 8u8 , val as u64 ) } } # [ inline ] pub fn SegmentNumber ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 48usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_SegmentNumber ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 48usize , 8u8 , val as u64 ) } } # [ inline ] pub fn Reserved1 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 56usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved1 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 56usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ClassCode : ULONG , FunctionNumber : ULONG , DeviceNumber : ULONG , BusNumber : ULONG , SegmentNumber : ULONG , Reserved1 : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 8usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 24u8 , { let ClassCode : u32 = unsafe { :: std :: mem :: transmute ( ClassCode ) } ; ClassCode as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let FunctionNumber : u32 = unsafe { :: std :: mem :: transmute ( FunctionNumber ) } ; FunctionNumber as u64 } ) ; __bindgen_bitfield_unit . set ( 32usize , 8u8 , { let DeviceNumber : u32 = unsafe { :: std :: mem :: transmute ( DeviceNumber ) } ; DeviceNumber as u64 } ) ; __bindgen_bitfield_unit . set ( 40usize , 8u8 , { let BusNumber : u32 = unsafe { :: std :: mem :: transmute ( BusNumber ) } ; BusNumber as u64 } ) ; __bindgen_bitfield_unit . set ( 48usize , 8u8 , { let SegmentNumber : u32 = unsafe { :: std :: mem :: transmute ( SegmentNumber ) } ; SegmentNumber as u64 } ) ; __bindgen_bitfield_unit . set ( 56usize , 8u8 , { let Reserved1 : u32 = unsafe { :: std :: mem :: transmute ( Reserved1 ) } ; Reserved1 as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_PCIXDEVICE_ID = _WHEA_PCIXDEVICE_ID ; pub type PWHEA_PCIXDEVICE_ID = * mut _WHEA_PCIXDEVICE_ID ; # [ repr ( C , packed ) ] pub struct WHEA_PCIXDEVICE_REGISTER_PAIR { pub Register : ULONGLONG , pub Data : ULONGLONG , } pub type PWHEA_PCIXDEVICE_REGISTER_PAIR = * mut WHEA_PCIXDEVICE_REGISTER_PAIR ; # [ repr ( C , packed ) ] pub struct _WHEA_PCIXDEVICE_ERROR_SECTION { pub ValidBits : WHEA_PCIXDEVICE_ERROR_SECTION_VALIDBITS , pub ErrorStatus : WHEA_ERROR_STATUS , pub IdInfo : WHEA_PCIXDEVICE_ID , pub MemoryNumber : ULONG , pub IoNumber : ULONG , pub RegisterDataPairs : [ WHEA_PCIXDEVICE_REGISTER_PAIR ; 1usize ] , } pub type WHEA_PCIXDEVICE_ERROR_SECTION = _WHEA_PCIXDEVICE_ERROR_SECTION ; pub type PWHEA_PCIXDEVICE_ERROR_SECTION = * mut _WHEA_PCIXDEVICE_ERROR_SECTION ; # [ repr ( C , packed ) ] pub struct _WHEA_FIRMWARE_ERROR_RECORD_REFERENCE { pub Type : UCHAR , pub Reserved : [ UCHAR ; 7usize ] , pub FirmwareRecordId : ULONGLONG , } pub type WHEA_FIRMWARE_ERROR_RECORD_REFERENCE = _WHEA_FIRMWARE_ERROR_RECORD_REFERENCE ; pub type PWHEA_FIRMWARE_ERROR_RECORD_REFERENCE = * mut _WHEA_FIRMWARE_ERROR_RECORD_REFERENCE ; # [ repr ( C , packed ) ] pub struct _MCG_STATUS { pub __bindgen_anon_1 : __BindgenUnionField < _MCG_STATUS__bindgen_ty_1 > , pub QuadPart : __BindgenUnionField < ULONGLONG > , pub bindgen_union_field : [ u8 ; 8usize ] , } # [ repr ( C , packed ) ] pub struct _MCG_STATUS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub Reserved2 : ULONG , } impl _MCG_STATUS__bindgen_ty_1 { # [ inline ] pub fn RestartIpValid ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_RestartIpValid ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ErrorIpValid ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ErrorIpValid ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MachineCheckInProgress ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_MachineCheckInProgress ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved1 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 29u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved1 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 29u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( RestartIpValid : ULONG , ErrorIpValid : ULONG , MachineCheckInProgress : ULONG , Reserved1 : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let RestartIpValid : u32 = unsafe { :: std :: mem :: transmute ( RestartIpValid ) } ; RestartIpValid as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let ErrorIpValid : u32 = unsafe { :: std :: mem :: transmute ( ErrorIpValid ) } ; ErrorIpValid as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let MachineCheckInProgress : u32 = unsafe { :: std :: mem :: transmute ( MachineCheckInProgress ) } ; MachineCheckInProgress as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 29u8 , { let Reserved1 : u32 = unsafe { :: std :: mem :: transmute ( Reserved1 ) } ; Reserved1 as u64 } ) ; __bindgen_bitfield_unit } } pub type MCG_STATUS = _MCG_STATUS ; pub type PMCG_STATUS = * mut _MCG_STATUS ; # [ repr ( C , packed ) ] pub struct _MCI_STATUS { pub __bindgen_anon_1 : __BindgenUnionField < _MCI_STATUS__bindgen_ty_1 > , pub QuadPart : __BindgenUnionField < ULONG64 > , pub bindgen_union_field : [ u8 ; 8usize ] , } # [ repr ( C , packed ) ] pub struct _MCI_STATUS__bindgen_ty_1 { pub McaErrorCode : USHORT , pub ModelErrorCode : USHORT , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , } impl _MCI_STATUS__bindgen_ty_1 { # [ inline ] pub fn OtherInformation ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 23u8 ) as u32 ) } } # [ inline ] pub fn set_OtherInformation ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 23u8 , val as u64 ) } } # [ inline ] pub fn ActionRequired ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 23usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ActionRequired ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 23usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Signalling ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Signalling ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ContextCorrupt ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 25usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ContextCorrupt ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 25usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AddressValid ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 26usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AddressValid ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 26usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MiscValid ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 27usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_MiscValid ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 27usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ErrorEnabled ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 28usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ErrorEnabled ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 28usize , 1u8 , val as u64 ) } } # [ inline ] pub fn UncorrectedError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 29usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_UncorrectedError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 29usize , 1u8 , val as u64 ) } } # [ inline ] pub fn StatusOverFlow ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 30usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_StatusOverFlow ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 30usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Valid ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 31usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Valid ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 31usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( OtherInformation : ULONG , ActionRequired : ULONG , Signalling : ULONG , ContextCorrupt : ULONG , AddressValid : ULONG , MiscValid : ULONG , ErrorEnabled : ULONG , UncorrectedError : ULONG , StatusOverFlow : ULONG , Valid : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 23u8 , { let OtherInformation : u32 = unsafe { :: std :: mem :: transmute ( OtherInformation ) } ; OtherInformation as u64 } ) ; __bindgen_bitfield_unit . set ( 23usize , 1u8 , { let ActionRequired : u32 = unsafe { :: std :: mem :: transmute ( ActionRequired ) } ; ActionRequired as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 1u8 , { let Signalling : u32 = unsafe { :: std :: mem :: transmute ( Signalling ) } ; Signalling as u64 } ) ; __bindgen_bitfield_unit . set ( 25usize , 1u8 , { let ContextCorrupt : u32 = unsafe { :: std :: mem :: transmute ( ContextCorrupt ) } ; ContextCorrupt as u64 } ) ; __bindgen_bitfield_unit . set ( 26usize , 1u8 , { let AddressValid : u32 = unsafe { :: std :: mem :: transmute ( AddressValid ) } ; AddressValid as u64 } ) ; __bindgen_bitfield_unit . set ( 27usize , 1u8 , { let MiscValid : u32 = unsafe { :: std :: mem :: transmute ( MiscValid ) } ; MiscValid as u64 } ) ; __bindgen_bitfield_unit . set ( 28usize , 1u8 , { let ErrorEnabled : u32 = unsafe { :: std :: mem :: transmute ( ErrorEnabled ) } ; ErrorEnabled as u64 } ) ; __bindgen_bitfield_unit . set ( 29usize , 1u8 , { let UncorrectedError : u32 = unsafe { :: std :: mem :: transmute ( UncorrectedError ) } ; UncorrectedError as u64 } ) ; __bindgen_bitfield_unit . set ( 30usize , 1u8 , { let StatusOverFlow : u32 = unsafe { :: std :: mem :: transmute ( StatusOverFlow ) } ; StatusOverFlow as u64 } ) ; __bindgen_bitfield_unit . set ( 31usize , 1u8 , { let Valid : u32 = unsafe { :: std :: mem :: transmute ( Valid ) } ; Valid as u64 } ) ; __bindgen_bitfield_unit } } pub type MCI_STATUS = _MCI_STATUS ; pub type PMCI_STATUS = * mut _MCI_STATUS ; pub const _WHEA_CPU_VENDOR_WheaCpuVendorOther : _WHEA_CPU_VENDOR = 0 ; pub const _WHEA_CPU_VENDOR_WheaCpuVendorIntel : _WHEA_CPU_VENDOR = 1 ; pub const _WHEA_CPU_VENDOR_WheaCpuVendorAmd : _WHEA_CPU_VENDOR = 2 ; pub type _WHEA_CPU_VENDOR = i32 ; pub use self :: _WHEA_CPU_VENDOR as WHEA_CPU_VENDOR ; pub type PWHEA_CPU_VENDOR = * mut _WHEA_CPU_VENDOR ; # [ repr ( C , packed ) ] pub struct _WHEA_XPF_MCA_SECTION { pub VersionNumber : ULONG , pub CpuVendor : WHEA_CPU_VENDOR , pub Timestamp : LARGE_INTEGER , pub ProcessorNumber : ULONG , pub GlobalStatus : MCG_STATUS , pub InstructionPointer : ULONGLONG , pub BankNumber : ULONG , pub Status : MCI_STATUS , pub Address : ULONGLONG , pub Misc : ULONGLONG , pub ExtendedRegisterCount : ULONG , pub Reserved2 : ULONG , pub ExtendedRegisters : [ ULONGLONG ; 24usize ] , } pub type WHEA_XPF_MCA_SECTION = _WHEA_XPF_MCA_SECTION ; pub type PWHEA_XPF_MCA_SECTION = * mut _WHEA_XPF_MCA_SECTION ; # [ repr ( C , packed ) ] pub struct _WHEA_NMI_ERROR_SECTION_FLAGS { pub __bindgen_anon_1 : __BindgenUnionField < _WHEA_NMI_ERROR_SECTION_FLAGS__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : [ u8 ; 4usize ] , } # [ repr ( C , packed ) ] pub struct _WHEA_NMI_ERROR_SECTION_FLAGS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , } impl _WHEA_NMI_ERROR_SECTION_FLAGS__bindgen_ty_1 { # [ inline ] pub fn HypervisorError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_HypervisorError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 31u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 31u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( HypervisorError : ULONG , Reserved : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let HypervisorError : u32 = unsafe { :: std :: mem :: transmute ( HypervisorError ) } ; HypervisorError as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 31u8 , { let Reserved : u32 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_NMI_ERROR_SECTION_FLAGS = _WHEA_NMI_ERROR_SECTION_FLAGS ; pub type PWHEA_NMI_ERROR_SECTION_FLAGS = * mut _WHEA_NMI_ERROR_SECTION_FLAGS ; # [ repr ( C ) ] pub struct _WHEA_NMI_ERROR_SECTION { pub Data : [ UCHAR ; 8usize ] , pub Flags : WHEA_NMI_ERROR_SECTION_FLAGS , } pub type WHEA_NMI_ERROR_SECTION = _WHEA_NMI_ERROR_SECTION ; pub type PWHEA_NMI_ERROR_SECTION = * mut _WHEA_NMI_ERROR_SECTION ; # [ repr ( C , packed ) ] pub struct _WHEA_ARM_PROCESSOR_ERROR_SECTION_VALID_BITS { pub __bindgen_anon_1 : __BindgenUnionField < _WHEA_ARM_PROCESSOR_ERROR_SECTION_VALID_BITS__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : [ u8 ; 4usize ] , } # [ repr ( C , packed ) ] pub struct _WHEA_ARM_PROCESSOR_ERROR_SECTION_VALID_BITS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , } impl _WHEA_ARM_PROCESSOR_ERROR_SECTION_VALID_BITS__bindgen_ty_1 { # [ inline ] pub fn MPIDR ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_MPIDR ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AffinityLevel ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AffinityLevel ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn RunningState ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_RunningState ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn VendorSpecificInfo ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_VendorSpecificInfo ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 28u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 28u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( MPIDR : ULONG , AffinityLevel : ULONG , RunningState : ULONG , VendorSpecificInfo : ULONG , Reserved : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let MPIDR : u32 = unsafe { :: std :: mem :: transmute ( MPIDR ) } ; MPIDR as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let AffinityLevel : u32 = unsafe { :: std :: mem :: transmute ( AffinityLevel ) } ; AffinityLevel as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let RunningState : u32 = unsafe { :: std :: mem :: transmute ( RunningState ) } ; RunningState as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let VendorSpecificInfo : u32 = unsafe { :: std :: mem :: transmute ( VendorSpecificInfo ) } ; VendorSpecificInfo as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 28u8 , { let Reserved : u32 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_ARM_PROCESSOR_ERROR_SECTION_VALID_BITS = _WHEA_ARM_PROCESSOR_ERROR_SECTION_VALID_BITS ; pub type PWHEA_ARM_PROCESSOR_ERROR_SECTION_VALID_BITS = * mut _WHEA_ARM_PROCESSOR_ERROR_SECTION_VALID_BITS ; # [ repr ( C , packed ) ] pub struct _WHEA_ARM_PROCESSOR_ERROR_SECTION { pub ValidBits : WHEA_ARM_PROCESSOR_ERROR_SECTION_VALID_BITS , pub ErrorInformationStructures : USHORT , pub ContextInformationStructures : USHORT , pub SectionLength : ULONG , pub ErrorAffinityLevel : UCHAR , pub Reserved : [ UCHAR ; 3usize ] , pub MPIDR_EL1 : ULONGLONG , pub MIDR_EL1 : ULONGLONG , pub RunningState : ULONG , pub PSCIState : ULONG , pub Data : [ UCHAR ; 1usize ] , } pub type WHEA_ARM_PROCESSOR_ERROR_SECTION = _WHEA_ARM_PROCESSOR_ERROR_SECTION ; pub type PWHEA_ARM_PROCESSOR_ERROR_SECTION = * mut _WHEA_ARM_PROCESSOR_ERROR_SECTION ; # [ repr ( C , packed ) ] pub struct _WHEA_ARM_PROCESSOR_ERROR_INFORMATION_VALID_BITS { pub __bindgen_anon_1 : __BindgenUnionField < _WHEA_ARM_PROCESSOR_ERROR_INFORMATION_VALID_BITS__bindgen_ty_1 > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : [ u8 ; 2usize ] , } # [ repr ( C , packed ) ] pub struct _WHEA_ARM_PROCESSOR_ERROR_INFORMATION_VALID_BITS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > , } impl _WHEA_ARM_PROCESSOR_ERROR_INFORMATION_VALID_BITS__bindgen_ty_1 { # [ inline ] pub fn MultipleError ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_MultipleError ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Flags ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_Flags ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ErrorInformation ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_ErrorInformation ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn VirtualFaultAddress ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_VirtualFaultAddress ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PhysicalFaultAddress ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_PhysicalFaultAddress ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 11u8 ) as u16 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 11u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( MultipleError : USHORT , Flags : USHORT , ErrorInformation : USHORT , VirtualFaultAddress : USHORT , PhysicalFaultAddress : USHORT , Reserved : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let MultipleError : u16 = unsafe { :: std :: mem :: transmute ( MultipleError ) } ; MultipleError as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let Flags : u16 = unsafe { :: std :: mem :: transmute ( Flags ) } ; Flags as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let ErrorInformation : u16 = unsafe { :: std :: mem :: transmute ( ErrorInformation ) } ; ErrorInformation as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let VirtualFaultAddress : u16 = unsafe { :: std :: mem :: transmute ( VirtualFaultAddress ) } ; VirtualFaultAddress as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let PhysicalFaultAddress : u16 = unsafe { :: std :: mem :: transmute ( PhysicalFaultAddress ) } ; PhysicalFaultAddress as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 11u8 , { let Reserved : u16 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_ARM_PROCESSOR_ERROR_INFORMATION_VALID_BITS = _WHEA_ARM_PROCESSOR_ERROR_INFORMATION_VALID_BITS ; pub type PWHEA_ARM_PROCESSOR_ERROR_INFORMATION_VALID_BITS = * mut _WHEA_ARM_PROCESSOR_ERROR_INFORMATION_VALID_BITS ; # [ repr ( C , packed ) ] pub struct _WHEA_ARM_CACHE_ERROR_VALID_BITS { pub __bindgen_anon_1 : __BindgenUnionField < _WHEA_ARM_CACHE_ERROR_VALID_BITS__bindgen_ty_1 > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : [ u8 ; 2usize ] , } # [ repr ( C , packed ) ] pub struct _WHEA_ARM_CACHE_ERROR_VALID_BITS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > , } impl _WHEA_ARM_CACHE_ERROR_VALID_BITS__bindgen_ty_1 { # [ inline ] pub fn TransactionType ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_TransactionType ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Operation ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_Operation ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Level ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_Level ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ProcessorContextCorrupt ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_ProcessorContextCorrupt ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Corrected ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_Corrected ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PrecisePC ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_PrecisePC ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn RestartablePC ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_RestartablePC ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 9u8 ) as u16 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 9u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( TransactionType : USHORT , Operation : USHORT , Level : USHORT , ProcessorContextCorrupt : USHORT , Corrected : USHORT , PrecisePC : USHORT , RestartablePC : USHORT , Reserved : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let TransactionType : u16 = unsafe { :: std :: mem :: transmute ( TransactionType ) } ; TransactionType as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let Operation : u16 = unsafe { :: std :: mem :: transmute ( Operation ) } ; Operation as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let Level : u16 = unsafe { :: std :: mem :: transmute ( Level ) } ; Level as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let ProcessorContextCorrupt : u16 = unsafe { :: std :: mem :: transmute ( ProcessorContextCorrupt ) } ; ProcessorContextCorrupt as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let Corrected : u16 = unsafe { :: std :: mem :: transmute ( Corrected ) } ; Corrected as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let PrecisePC : u16 = unsafe { :: std :: mem :: transmute ( PrecisePC ) } ; PrecisePC as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let RestartablePC : u16 = unsafe { :: std :: mem :: transmute ( RestartablePC ) } ; RestartablePC as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 9u8 , { let Reserved : u16 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_ARM_CACHE_ERROR_VALID_BITS = _WHEA_ARM_CACHE_ERROR_VALID_BITS ; pub type PWHEA_ARM_CACHE_ERROR_VALID_BITS = * mut _WHEA_ARM_CACHE_ERROR_VALID_BITS ; # [ repr ( C , packed ) ] pub struct _WHEA_ARM_CACHE_ERROR { pub ValidationBit : WHEA_ARM_CACHE_ERROR_VALID_BITS , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > , pub __bindgen_padding_0 : [ u8 ; 2usize ] , } impl _WHEA_ARM_CACHE_ERROR { # [ inline ] pub fn TransactionType ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_TransactionType ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 2u8 , val as u64 ) } } # [ inline ] pub fn Operation ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_Operation ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 4u8 , val as u64 ) } } # [ inline ] pub fn Level ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_Level ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 3u8 , val as u64 ) } } # [ inline ] pub fn ProcessorContextCorrupt ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_ProcessorContextCorrupt ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Corrected ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_Corrected ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PrecisePC ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 13usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_PrecisePC ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 13usize , 1u8 , val as u64 ) } } # [ inline ] pub fn RestartablePC ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_RestartablePC ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 15usize , 35u8 ) as u64 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 15usize , 35u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( TransactionType : UCHAR , Operation : UCHAR , Level : UCHAR , ProcessorContextCorrupt : UCHAR , Corrected : UCHAR , PrecisePC : UCHAR , RestartablePC : UCHAR , Reserved : ULONGLONG ) -> __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 2u8 , { let TransactionType : u8 = unsafe { :: std :: mem :: transmute ( TransactionType ) } ; TransactionType as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 4u8 , { let Operation : u8 = unsafe { :: std :: mem :: transmute ( Operation ) } ; Operation as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 3u8 , { let Level : u8 = unsafe { :: std :: mem :: transmute ( Level ) } ; Level as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 1u8 , { let ProcessorContextCorrupt : u8 = unsafe { :: std :: mem :: transmute ( ProcessorContextCorrupt ) } ; ProcessorContextCorrupt as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 1u8 , { let Corrected : u8 = unsafe { :: std :: mem :: transmute ( Corrected ) } ; Corrected as u64 } ) ; __bindgen_bitfield_unit . set ( 13usize , 1u8 , { let PrecisePC : u8 = unsafe { :: std :: mem :: transmute ( PrecisePC ) } ; PrecisePC as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 1u8 , { let RestartablePC : u8 = unsafe { :: std :: mem :: transmute ( RestartablePC ) } ; RestartablePC as u64 } ) ; __bindgen_bitfield_unit . set ( 15usize , 35u8 , { let Reserved : u64 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_ARM_CACHE_ERROR = _WHEA_ARM_CACHE_ERROR ; pub type PWHEA_ARM_CACHE_ERROR = * mut _WHEA_ARM_CACHE_ERROR ; # [ repr ( C , packed ) ] pub struct _WHEA_ARM_TLB_ERROR_VALID_BITS { pub __bindgen_anon_1 : __BindgenUnionField < _WHEA_ARM_TLB_ERROR_VALID_BITS__bindgen_ty_1 > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : [ u8 ; 2usize ] , } # [ repr ( C , packed ) ] pub struct _WHEA_ARM_TLB_ERROR_VALID_BITS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > , } impl _WHEA_ARM_TLB_ERROR_VALID_BITS__bindgen_ty_1 { # [ inline ] pub fn TransactionType ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_TransactionType ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Operation ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_Operation ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Level ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_Level ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ProcessorContextCorrupt ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_ProcessorContextCorrupt ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Corrected ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_Corrected ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PrecisePC ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_PrecisePC ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn RestartablePC ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_RestartablePC ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 9u8 ) as u16 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 9u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( TransactionType : USHORT , Operation : USHORT , Level : USHORT , ProcessorContextCorrupt : USHORT , Corrected : USHORT , PrecisePC : USHORT , RestartablePC : USHORT , Reserved : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let TransactionType : u16 = unsafe { :: std :: mem :: transmute ( TransactionType ) } ; TransactionType as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let Operation : u16 = unsafe { :: std :: mem :: transmute ( Operation ) } ; Operation as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let Level : u16 = unsafe { :: std :: mem :: transmute ( Level ) } ; Level as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let ProcessorContextCorrupt : u16 = unsafe { :: std :: mem :: transmute ( ProcessorContextCorrupt ) } ; ProcessorContextCorrupt as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let Corrected : u16 = unsafe { :: std :: mem :: transmute ( Corrected ) } ; Corrected as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let PrecisePC : u16 = unsafe { :: std :: mem :: transmute ( PrecisePC ) } ; PrecisePC as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let RestartablePC : u16 = unsafe { :: std :: mem :: transmute ( RestartablePC ) } ; RestartablePC as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 9u8 , { let Reserved : u16 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_ARM_TLB_ERROR_VALID_BITS = _WHEA_ARM_TLB_ERROR_VALID_BITS ; pub type PWHEA_ARM_TLB_ERROR_VALID_BITS = * mut _WHEA_ARM_TLB_ERROR_VALID_BITS ; # [ repr ( C , packed ) ] pub struct _WHEA_ARM_TLB_ERROR { pub ValidationBit : WHEA_ARM_TLB_ERROR_VALID_BITS , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > , pub __bindgen_padding_0 : [ u8 ; 2usize ] , } impl _WHEA_ARM_TLB_ERROR { # [ inline ] pub fn TransactionType ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_TransactionType ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 2u8 , val as u64 ) } } # [ inline ] pub fn Operation ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_Operation ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 4u8 , val as u64 ) } } # [ inline ] pub fn Level ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_Level ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 3u8 , val as u64 ) } } # [ inline ] pub fn ProcessorContextCorrupt ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_ProcessorContextCorrupt ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Corrected ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_Corrected ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PrecisePC ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 13usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_PrecisePC ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 13usize , 1u8 , val as u64 ) } } # [ inline ] pub fn RestartablePC ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_RestartablePC ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONGLONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 15usize , 36u8 ) as u64 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONGLONG ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 15usize , 36u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( TransactionType : UCHAR , Operation : UCHAR , Level : UCHAR , ProcessorContextCorrupt : UCHAR , Corrected : UCHAR , PrecisePC : UCHAR , RestartablePC : UCHAR , Reserved : ULONGLONG ) -> __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 2u8 , { let TransactionType : u8 = unsafe { :: std :: mem :: transmute ( TransactionType ) } ; TransactionType as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 4u8 , { let Operation : u8 = unsafe { :: std :: mem :: transmute ( Operation ) } ; Operation as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 3u8 , { let Level : u8 = unsafe { :: std :: mem :: transmute ( Level ) } ; Level as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 1u8 , { let ProcessorContextCorrupt : u8 = unsafe { :: std :: mem :: transmute ( ProcessorContextCorrupt ) } ; ProcessorContextCorrupt as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 1u8 , { let Corrected : u8 = unsafe { :: std :: mem :: transmute ( Corrected ) } ; Corrected as u64 } ) ; __bindgen_bitfield_unit . set ( 13usize , 1u8 , { let PrecisePC : u8 = unsafe { :: std :: mem :: transmute ( PrecisePC ) } ; PrecisePC as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 1u8 , { let RestartablePC : u8 = unsafe { :: std :: mem :: transmute ( RestartablePC ) } ; RestartablePC as u64 } ) ; __bindgen_bitfield_unit . set ( 15usize , 36u8 , { let Reserved : u64 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_ARM_TLB_ERROR = _WHEA_ARM_TLB_ERROR ; pub type PWHEA_ARM_TLB_ERROR = * mut _WHEA_ARM_TLB_ERROR ; # [ repr ( C , packed ) ] pub struct _WHEA_ARM_BUS_ERROR_VALID_BITS { pub __bindgen_anon_1 : __BindgenUnionField < _WHEA_ARM_BUS_ERROR_VALID_BITS__bindgen_ty_1 > , pub AsUSHORT : __BindgenUnionField < USHORT > , pub bindgen_union_field : [ u8 ; 2usize ] , } # [ repr ( C , packed ) ] pub struct _WHEA_ARM_BUS_ERROR_VALID_BITS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , } impl _WHEA_ARM_BUS_ERROR_VALID_BITS__bindgen_ty_1 { # [ inline ] pub fn TransactionType ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_TransactionType ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Operation ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_Operation ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Level ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_Level ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ProcessorContextCorrupt ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_ProcessorContextCorrupt ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Corrected ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_Corrected ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PrecisePC ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_PrecisePC ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn RestartablePC ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_RestartablePC ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ParticipationType ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_ParticipationType ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Timeout ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_Timeout ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AddressSpace ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_AddressSpace ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MemoryAttributes ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_MemoryAttributes ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AccessMode ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_AccessMode ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 4u8 ) as u16 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( TransactionType : USHORT , Operation : USHORT , Level : USHORT , ProcessorContextCorrupt : USHORT , Corrected : USHORT , PrecisePC : USHORT , RestartablePC : USHORT , ParticipationType : USHORT , Timeout : USHORT , AddressSpace : USHORT , MemoryAttributes : USHORT , AccessMode : USHORT , Reserved : USHORT ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let TransactionType : u16 = unsafe { :: std :: mem :: transmute ( TransactionType ) } ; TransactionType as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let Operation : u16 = unsafe { :: std :: mem :: transmute ( Operation ) } ; Operation as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let Level : u16 = unsafe { :: std :: mem :: transmute ( Level ) } ; Level as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let ProcessorContextCorrupt : u16 = unsafe { :: std :: mem :: transmute ( ProcessorContextCorrupt ) } ; ProcessorContextCorrupt as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let Corrected : u16 = unsafe { :: std :: mem :: transmute ( Corrected ) } ; Corrected as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let PrecisePC : u16 = unsafe { :: std :: mem :: transmute ( PrecisePC ) } ; PrecisePC as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let RestartablePC : u16 = unsafe { :: std :: mem :: transmute ( RestartablePC ) } ; RestartablePC as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let ParticipationType : u16 = unsafe { :: std :: mem :: transmute ( ParticipationType ) } ; ParticipationType as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let Timeout : u16 = unsafe { :: std :: mem :: transmute ( Timeout ) } ; Timeout as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let AddressSpace : u16 = unsafe { :: std :: mem :: transmute ( AddressSpace ) } ; AddressSpace as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 1u8 , { let MemoryAttributes : u16 = unsafe { :: std :: mem :: transmute ( MemoryAttributes ) } ; MemoryAttributes as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 1u8 , { let AccessMode : u16 = unsafe { :: std :: mem :: transmute ( AccessMode ) } ; AccessMode as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 4u8 , { let Reserved : u16 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_ARM_BUS_ERROR_VALID_BITS = _WHEA_ARM_BUS_ERROR_VALID_BITS ; pub type PWHEA_ARM_BUS_ERROR_VALID_BITS = * mut _WHEA_ARM_BUS_ERROR_VALID_BITS ; # [ repr ( C , packed ) ] pub struct _WHEA_ARM_BUS_ERROR { pub ValidationBit : WHEA_ARM_BUS_ERROR_VALID_BITS , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u32 > , pub __bindgen_padding_0 : [ u8 ; 2usize ] , } impl _WHEA_ARM_BUS_ERROR { # [ inline ] pub fn TransactionType ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_TransactionType ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 2u8 , val as u64 ) } } # [ inline ] pub fn Operation ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_Operation ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 4u8 , val as u64 ) } } # [ inline ] pub fn Level ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_Level ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 3u8 , val as u64 ) } } # [ inline ] pub fn ProcessorContextCorrupt ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_ProcessorContextCorrupt ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Corrected ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_Corrected ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PrecisePC ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 13usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_PrecisePC ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 13usize , 1u8 , val as u64 ) } } # [ inline ] pub fn RestartablePC ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_RestartablePC ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ParticipationType ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_ParticipationType ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 2u8 , val as u64 ) } } # [ inline ] pub fn TimeOut ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 18usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_TimeOut ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 18usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AddressSpace ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 19usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_AddressSpace ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 19usize , 2u8 , val as u64 ) } } # [ inline ] pub fn MemoryAccessAttributes ( & self ) -> USHORT { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 21usize , 9u8 ) as u16 ) } } # [ inline ] pub fn set_MemoryAccessAttributes ( & mut self , val : USHORT ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 21usize , 9u8 , val as u64 ) } } # [ inline ] pub fn AccessMode ( & self ) -> UCHAR { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 30usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_AccessMode ( & mut self , val : UCHAR ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 30usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 32usize , 20u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 32usize , 20u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( TransactionType : UCHAR , Operation : UCHAR , Level : UCHAR , ProcessorContextCorrupt : UCHAR , Corrected : UCHAR , PrecisePC : UCHAR , RestartablePC : UCHAR , ParticipationType : UCHAR , TimeOut : UCHAR , AddressSpace : UCHAR , MemoryAccessAttributes : USHORT , AccessMode : UCHAR , Reserved : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 8usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 2u8 , { let TransactionType : u8 = unsafe { :: std :: mem :: transmute ( TransactionType ) } ; TransactionType as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 4u8 , { let Operation : u8 = unsafe { :: std :: mem :: transmute ( Operation ) } ; Operation as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 3u8 , { let Level : u8 = unsafe { :: std :: mem :: transmute ( Level ) } ; Level as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 1u8 , { let ProcessorContextCorrupt : u8 = unsafe { :: std :: mem :: transmute ( ProcessorContextCorrupt ) } ; ProcessorContextCorrupt as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 1u8 , { let Corrected : u8 = unsafe { :: std :: mem :: transmute ( Corrected ) } ; Corrected as u64 } ) ; __bindgen_bitfield_unit . set ( 13usize , 1u8 , { let PrecisePC : u8 = unsafe { :: std :: mem :: transmute ( PrecisePC ) } ; PrecisePC as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 1u8 , { let RestartablePC : u8 = unsafe { :: std :: mem :: transmute ( RestartablePC ) } ; RestartablePC as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 2u8 , { let ParticipationType : u8 = unsafe { :: std :: mem :: transmute ( ParticipationType ) } ; ParticipationType as u64 } ) ; __bindgen_bitfield_unit . set ( 18usize , 1u8 , { let TimeOut : u8 = unsafe { :: std :: mem :: transmute ( TimeOut ) } ; TimeOut as u64 } ) ; __bindgen_bitfield_unit . set ( 19usize , 2u8 , { let AddressSpace : u8 = unsafe { :: std :: mem :: transmute ( AddressSpace ) } ; AddressSpace as u64 } ) ; __bindgen_bitfield_unit . set ( 21usize , 9u8 , { let MemoryAccessAttributes : u16 = unsafe { :: std :: mem :: transmute ( MemoryAccessAttributes ) } ; MemoryAccessAttributes as u64 } ) ; __bindgen_bitfield_unit . set ( 30usize , 1u8 , { let AccessMode : u8 = unsafe { :: std :: mem :: transmute ( AccessMode ) } ; AccessMode as u64 } ) ; __bindgen_bitfield_unit . set ( 32usize , 20u8 , { let Reserved : u32 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_ARM_BUS_ERROR = _WHEA_ARM_BUS_ERROR ; pub type PWHEA_ARM_BUS_ERROR = * mut _WHEA_ARM_BUS_ERROR ; # [ repr ( C , packed ) ] pub struct _WHEA_ARM_PROCESSOR_ERROR { pub CacheError : __BindgenUnionField < WHEA_ARM_CACHE_ERROR > , pub TlbError : __BindgenUnionField < WHEA_ARM_TLB_ERROR > , pub BusError : __BindgenUnionField < WHEA_ARM_BUS_ERROR > , pub AsULONGLONG : __BindgenUnionField < ULONGLONG > , pub bindgen_union_field : [ u8 ; 12usize ] , } pub type WHEA_ARM_PROCESSOR_ERROR = _WHEA_ARM_PROCESSOR_ERROR ; pub type PWHEA_ARM_PROCESSOR_ERROR = * mut _WHEA_ARM_PROCESSOR_ERROR ; # [ repr ( C , packed ) ] pub struct _WHEA_ARM_PROCESSOR_ERROR_INFORMATION { pub Version : UCHAR , pub Length : UCHAR , pub ValidationBit : WHEA_ARM_PROCESSOR_ERROR_INFORMATION_VALID_BITS , pub Type : UCHAR , pub MultipleError : USHORT , pub Flags : UCHAR , pub ErrorInformation : ULONGLONG , pub VirtualFaultAddress : ULONGLONG , pub PhysicalFaultAddress : ULONGLONG , } pub type WHEA_ARM_PROCESSOR_ERROR_INFORMATION = _WHEA_ARM_PROCESSOR_ERROR_INFORMATION ; pub type PWHEA_ARM_PROCESSOR_ERROR_INFORMATION = * mut _WHEA_ARM_PROCESSOR_ERROR_INFORMATION ; # [ repr ( C , packed ) ] pub struct _WHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER_FLAGS { pub __bindgen_anon_1 : __BindgenUnionField < _WHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER_FLAGS__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : [ u8 ; 4usize ] , } # [ repr ( C , packed ) ] pub struct _WHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER_FLAGS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , } impl _WHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER_FLAGS__bindgen_ty_1 { # [ inline ] pub fn ExceptionLevel ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ExceptionLevel ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn NonSecure ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_NonSecure ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn AArch64 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_AArch64 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 29u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 29u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ExceptionLevel : ULONG , NonSecure : ULONG , AArch64 : ULONG , Reserved : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let ExceptionLevel : u32 = unsafe { :: std :: mem :: transmute ( ExceptionLevel ) } ; ExceptionLevel as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let NonSecure : u32 = unsafe { :: std :: mem :: transmute ( NonSecure ) } ; NonSecure as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let AArch64 : u32 = unsafe { :: std :: mem :: transmute ( AArch64 ) } ; AArch64 as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 29u8 , { let Reserved : u32 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER_FLAGS = _WHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER_FLAGS ; pub type PWHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER_FLAGS = * mut _WHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER_FLAGS ; # [ repr ( C , packed ) ] pub struct _WHEA_ARMV8_AARCH32_GPRS { pub R0 : ULONG , pub R1 : ULONG , pub R2 : ULONG , pub R3 : ULONG , pub R4 : ULONG , pub R5 : ULONG , pub R6 : ULONG , pub R7 : ULONG , pub R8 : ULONG , pub R9 : ULONG , pub R10 : ULONG , pub R11 : ULONG , pub R12 : ULONG , pub R13 : ULONG , pub R14 : ULONG , pub R15 : ULONG , } pub type WHEA_ARMV8_AARCH32_GPRS = _WHEA_ARMV8_AARCH32_GPRS ; pub type PWHEA_ARMV8_AARCH32_GPRS = * mut _WHEA_ARMV8_AARCH32_GPRS ; # [ repr ( C , packed ) ] pub struct _WHEA_ARM_AARCH32_EL1_CSR { pub DFAR : ULONG , pub DFSR : ULONG , pub IFAR : ULONG , pub ISR : ULONG , pub MAIR0 : ULONG , pub MAIR1 : ULONG , pub MIDR : ULONG , pub MPIDR : ULONG , pub NMRR : ULONG , pub PRRR : ULONG , pub SCTLR : ULONG , pub SPSR : ULONG , pub SPSR_abt : ULONG , pub SPSR_fiq : ULONG , pub SPSR_irq : ULONG , pub SPSR_svc : ULONG , pub SPSR_und : ULONG , pub TPIDRPRW : ULONG , pub TPIDRURO : ULONG , pub TPIDRURW : ULONG , pub TTBCR : ULONG , pub TTBR0 : ULONG , pub TTBR1 : ULONG , pub DACR : ULONG , } pub type WHEA_ARM_AARCH32_EL1_CSR = _WHEA_ARM_AARCH32_EL1_CSR ; pub type PWHEA_ARM_AARCH32_EL1 = * mut _WHEA_ARM_AARCH32_EL1_CSR ; # [ repr ( C , packed ) ] pub struct _WHEA_ARM_AARCH32_EL2_CSR { pub ELR_hyp : ULONG , pub HAMAIR0 : ULONG , pub HAMAIR1 : ULONG , pub HCR : ULONG , pub HCR2 : ULONG , pub HDFAR : ULONG , pub HIFAR : ULONG , pub HPFAR : ULONG , pub HSR : ULONG , pub HTCR : ULONG , pub HTPIDR : ULONG , pub HTTBR : ULONG , pub SPSR_hyp : ULONG , pub VTCR : ULONG , pub VTTBR : ULONG , pub DACR32_EL2 : ULONG , } pub type WHEA_ARM_AARCH32_EL2_CSR = _WHEA_ARM_AARCH32_EL2_CSR ; pub type PWHEA_ARM_AARCH32_EL2_CSR = * mut _WHEA_ARM_AARCH32_EL2_CSR ; # [ repr ( C , packed ) ] pub struct _WHEA_ARM_AARCH32_SECURE_CSR { pub SCTLR : ULONG , pub SPSR_mon : ULONG , } pub type WHEA_ARM_AARCH32_SECURE_CSR = _WHEA_ARM_AARCH32_SECURE_CSR ; pub type PWHEA_ARM_AARCH32_SECURE_CSR = * mut _WHEA_ARM_AARCH32_SECURE_CSR ; # [ repr ( C , packed ) ] pub struct _WHEA_ARMV8_AARCH64_GPRS { pub X0 : ULONGLONG , pub X1 : ULONGLONG , pub X2 : ULONGLONG , pub X3 : ULONGLONG , pub X4 : ULONGLONG , pub X5 : ULONGLONG , pub X6 : ULONGLONG , pub X7 : ULONGLONG , pub X8 : ULONGLONG , pub X9 : ULONGLONG , pub X10 : ULONGLONG , pub X11 : ULONGLONG , pub X12 : ULONGLONG , pub X13 : ULONGLONG , pub X14 : ULONGLONG , pub X15 : ULONGLONG , pub X16 : ULONGLONG , pub X17 : ULONGLONG , pub X18 : ULONGLONG , pub X19 : ULONGLONG , pub X20 : ULONGLONG , pub X21 : ULONGLONG , pub X22 : ULONGLONG , pub X23 : ULONGLONG , pub X24 : ULONGLONG , pub X25 : ULONGLONG , pub X26 : ULONGLONG , pub X27 : ULONGLONG , pub X28 : ULONGLONG , pub X29 : ULONGLONG , pub X30 : ULONGLONG , pub SP : ULONGLONG , } pub type WHEA_ARMV8_AARCH64_GPRS = _WHEA_ARMV8_AARCH64_GPRS ; pub type PWHEA_ARMV8_AARCH64_GPRS = * mut _WHEA_ARMV8_AARCH64_GPRS ; # [ repr ( C , packed ) ] pub struct _WHEA_ARM_AARCH64_EL1_CSR { pub ELR_EL1 : ULONGLONG , pub ESR_EL2 : ULONGLONG , pub FAR_EL1 : ULONGLONG , pub ISR_EL1 : ULONGLONG , pub MAIR_EL1 : ULONGLONG , pub MIDR_EL1 : ULONGLONG , pub MPIDR_EL1 : ULONGLONG , pub SCTLR_EL1 : ULONGLONG , pub SP_EL0 : ULONGLONG , pub SP_EL1 : ULONGLONG , pub SPSR_EL1 : ULONGLONG , pub TCR_EL1 : ULONGLONG , pub TPIDR_EL0 : ULONGLONG , pub TPIDR_EL1 : ULONGLONG , pub TPIDRRO_EL0 : ULONGLONG , pub TTBR0_EL1 : ULONGLONG , pub TTBR1_EL1 : ULONGLONG , } pub type WHEA_ARM_AARCH64_EL1_CSR = _WHEA_ARM_AARCH64_EL1_CSR ; pub type PWHEA_ARM_AARCH64_EL1_CSR = * mut _WHEA_ARM_AARCH64_EL1_CSR ; # [ repr ( C , packed ) ] pub struct _WHEA_ARM_AARCH64_EL2_CSR { pub ELR_EL2 : ULONGLONG , pub ESR_EL2 : ULONGLONG , pub FAR_EL2 : ULONGLONG , pub HACR_EL2 : ULONGLONG , pub HCR_EL2 : ULONGLONG , pub HPFAR_EL2 : ULONGLONG , pub MAIR_EL2 : ULONGLONG , pub SCTLR_EL2 : ULONGLONG , pub SP_EL2 : ULONGLONG , pub SPSR_EL2 : ULONGLONG , pub TCR_EL2 : ULONGLONG , pub TPIDR_EL2 : ULONGLONG , pub TTBR0_EL2 : ULONGLONG , pub VTCR_EL2 : ULONGLONG , pub VTTBR_EL2 : ULONGLONG , } pub type WHEA_ARM_AARCH64_EL2_CSR = _WHEA_ARM_AARCH64_EL2_CSR ; pub type PWHEA_ARM_AARCH64_EL2_CSR = * mut _WHEA_ARM_AARCH64_EL2_CSR ; # [ repr ( C , packed ) ] pub struct _WHEA_ARMV8_AARCH64_EL3_CSR { pub ELR_EL3 : ULONGLONG , pub ESR_EL3 : ULONGLONG , pub FAR_EL3 : ULONGLONG , pub MAIR_EL3 : ULONGLONG , pub SCTLR_EL3 : ULONGLONG , pub SP_EL3 : ULONGLONG , pub SPSR_EL3 : ULONGLONG , pub TCR_EL3 : ULONGLONG , pub TPIDR_EL3 : ULONGLONG , pub TTBR0_EL3 : ULONGLONG , } pub type WHEA_ARMV8_AARCH64_EL3_CSR = _WHEA_ARMV8_AARCH64_EL3_CSR ; pub type PWHEA_ARMV8_AARCH64_EL3_CSR = * mut _WHEA_ARMV8_AARCH64_EL3_CSR ; # [ repr ( C , packed ) ] pub struct _WHEA_ARM_MISC_CSR { pub MRSEncoding : USHORT , pub Value : ULONGLONG , } pub type WHEA_ARM_MISC_CSR = _WHEA_ARM_MISC_CSR ; pub type PWHEA_ARM_MISC_CSR = * mut _WHEA_ARM_MISC_CSR ; # [ repr ( C , packed ) ] pub struct _WHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER { pub Version : USHORT , pub RegisterContextType : USHORT , pub RegisterArraySize : ULONG , pub RegisterArray : [ UCHAR ; 1usize ] , } pub type WHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER = _WHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER ; pub type PWHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER = * mut _WHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER ; extern "C" { # [ link_name = "\u{1}CMC_NOTIFY_TYPE_GUID" ] pub static mut CMC_NOTIFY_TYPE_GUID : GUID ; } extern "C" { # [ link_name = "\u{1}CPE_NOTIFY_TYPE_GUID" ] pub static mut CPE_NOTIFY_TYPE_GUID : GUID ; } extern "C" { # [ link_name = "\u{1}MCE_NOTIFY_TYPE_GUID" ] pub static mut MCE_NOTIFY_TYPE_GUID : GUID ; } extern "C" { # [ link_name = "\u{1}PCIe_NOTIFY_TYPE_GUID" ] pub static mut PCIe_NOTIFY_TYPE_GUID : GUID ; } extern "C" { # [ link_name = "\u{1}INIT_NOTIFY_TYPE_GUID" ] pub static mut INIT_NOTIFY_TYPE_GUID : GUID ; } extern "C" { # [ link_name = "\u{1}NMI_NOTIFY_TYPE_GUID" ] pub static mut NMI_NOTIFY_TYPE_GUID : GUID ; } extern "C" { # [ link_name = "\u{1}BOOT_NOTIFY_TYPE_GUID" ] pub static mut BOOT_NOTIFY_TYPE_GUID : GUID ; } extern "C" { # [ link_name = "\u{1}SEA_NOTIFY_TYPE_GUID" ] pub static mut SEA_NOTIFY_TYPE_GUID : GUID ; } extern "C" { # [ link_name = "\u{1}SEI_NOTIFY_TYPE_GUID" ] pub static mut SEI_NOTIFY_TYPE_GUID : GUID ; } extern "C" { # [ link_name = "\u{1}PEI_NOTIFY_TYPE_GUID" ] pub static mut PEI_NOTIFY_TYPE_GUID : GUID ; } extern "C" { # [ link_name = "\u{1}PROCESSOR_GENERIC_ERROR_SECTION_GUID" ] pub static mut PROCESSOR_GENERIC_ERROR_SECTION_GUID : GUID ; } extern "C" { # [ link_name = "\u{1}XPF_PROCESSOR_ERROR_SECTION_GUID" ] pub static mut XPF_PROCESSOR_ERROR_SECTION_GUID : GUID ; } extern "C" { # [ link_name = "\u{1}IPF_PROCESSOR_ERROR_SECTION_GUID" ] pub static mut IPF_PROCESSOR_ERROR_SECTION_GUID : GUID ; } extern "C" { # [ link_name = "\u{1}ARM_PROCESSOR_ERROR_SECTION_GUID" ] pub static mut ARM_PROCESSOR_ERROR_SECTION_GUID : GUID ; } extern "C" { # [ link_name = "\u{1}MEMORY_ERROR_SECTION_GUID" ] pub static mut MEMORY_ERROR_SECTION_GUID : GUID ; } extern "C" { # [ link_name = "\u{1}PCIEXPRESS_ERROR_SECTION_GUID" ] pub static mut PCIEXPRESS_ERROR_SECTION_GUID : GUID ; } extern "C" { # [ link_name = "\u{1}PCIXBUS_ERROR_SECTION_GUID" ] pub static mut PCIXBUS_ERROR_SECTION_GUID : GUID ; } extern "C" { # [ link_name = "\u{1}PCIXDEVICE_ERROR_SECTION_GUID" ] pub static mut PCIXDEVICE_ERROR_SECTION_GUID : GUID ; } extern "C" { # [ link_name = "\u{1}FIRMWARE_ERROR_RECORD_REFERENCE_GUID" ] pub static mut FIRMWARE_ERROR_RECORD_REFERENCE_GUID : GUID ; } extern "C" { # [ link_name = "\u{1}WHEA_CACHECHECK_GUID" ] pub static mut WHEA_CACHECHECK_GUID : GUID ; } extern "C" { # [ link_name = "\u{1}WHEA_TLBCHECK_GUID" ] pub static mut WHEA_TLBCHECK_GUID : GUID ; } extern "C" { # [ link_name = "\u{1}WHEA_BUSCHECK_GUID" ] pub static mut WHEA_BUSCHECK_GUID : GUID ; } extern "C" { # [ link_name = "\u{1}WHEA_MSCHECK_GUID" ] pub static mut WHEA_MSCHECK_GUID : GUID ; } extern "C" { # [ link_name = "\u{1}WHEA_RECORD_CREATOR_GUID" ] pub static mut WHEA_RECORD_CREATOR_GUID : GUID ; } extern "C" { # [ link_name = "\u{1}GENERIC_NOTIFY_TYPE_GUID" ] pub static mut GENERIC_NOTIFY_TYPE_GUID : GUID ; } extern "C" { # [ link_name = "\u{1}IPF_SAL_RECORD_SECTION_GUID" ] pub static mut IPF_SAL_RECORD_SECTION_GUID : GUID ; } extern "C" { # [ link_name = "\u{1}XPF_MCA_SECTION_GUID" ] pub static mut XPF_MCA_SECTION_GUID : GUID ; } extern "C" { # [ link_name = "\u{1}NMI_SECTION_GUID" ] pub static mut NMI_SECTION_GUID : GUID ; } extern "C" { # [ link_name = "\u{1}GENERIC_SECTION_GUID" ] pub static mut GENERIC_SECTION_GUID : GUID ; } extern "C" { # [ link_name = "\u{1}WHEA_ERROR_PACKET_SECTION_GUID" ] pub static mut WHEA_ERROR_PACKET_SECTION_GUID : GUID ; } pub const _WHEA_ERROR_TYPE_WheaErrTypeProcessor : _WHEA_ERROR_TYPE = 0 ; pub const _WHEA_ERROR_TYPE_WheaErrTypeMemory : _WHEA_ERROR_TYPE = 1 ; pub const _WHEA_ERROR_TYPE_WheaErrTypePCIExpress : _WHEA_ERROR_TYPE = 2 ; pub const _WHEA_ERROR_TYPE_WheaErrTypeNMI : _WHEA_ERROR_TYPE = 3 ; pub const _WHEA_ERROR_TYPE_WheaErrTypePCIXBus : _WHEA_ERROR_TYPE = 4 ; pub const _WHEA_ERROR_TYPE_WheaErrTypePCIXDevice : _WHEA_ERROR_TYPE = 5 ; pub const _WHEA_ERROR_TYPE_WheaErrTypeGeneric : _WHEA_ERROR_TYPE = 6 ; pub type _WHEA_ERROR_TYPE = i32 ; pub use self :: _WHEA_ERROR_TYPE as WHEA_ERROR_TYPE ; pub type PWHEA_ERROR_TYPE = * mut _WHEA_ERROR_TYPE ; # [ repr ( C , packed ) ] pub struct _WHEA_ERROR_PACKET_FLAGS { pub __bindgen_anon_1 : __BindgenUnionField < _WHEA_ERROR_PACKET_FLAGS__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : [ u8 ; 4usize ] , } # [ repr ( C , packed ) ] pub struct _WHEA_ERROR_PACKET_FLAGS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , } impl _WHEA_ERROR_PACKET_FLAGS__bindgen_ty_1 { # [ inline ] pub fn PreviousError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_PreviousError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved1 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved1 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn HypervisorError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_HypervisorError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Simulated ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_Simulated ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PlatformPfaControl ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_PlatformPfaControl ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PlatformDirectedOffline ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_PlatformDirectedOffline ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved2 ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 26u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved2 ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 26u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( PreviousError : ULONG , Reserved1 : ULONG , HypervisorError : ULONG , Simulated : ULONG , PlatformPfaControl : ULONG , PlatformDirectedOffline : ULONG , Reserved2 : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let PreviousError : u32 = unsafe { :: std :: mem :: transmute ( PreviousError ) } ; PreviousError as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let Reserved1 : u32 = unsafe { :: std :: mem :: transmute ( Reserved1 ) } ; Reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let HypervisorError : u32 = unsafe { :: std :: mem :: transmute ( HypervisorError ) } ; HypervisorError as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let Simulated : u32 = unsafe { :: std :: mem :: transmute ( Simulated ) } ; Simulated as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let PlatformPfaControl : u32 = unsafe { :: std :: mem :: transmute ( PlatformPfaControl ) } ; PlatformPfaControl as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let PlatformDirectedOffline : u32 = unsafe { :: std :: mem :: transmute ( PlatformDirectedOffline ) } ; PlatformDirectedOffline as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 26u8 , { let Reserved2 : u32 = unsafe { :: std :: mem :: transmute ( Reserved2 ) } ; Reserved2 as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_ERROR_PACKET_FLAGS = _WHEA_ERROR_PACKET_FLAGS ; pub type PWHEA_ERROR_PACKET_FLAGS = * mut _WHEA_ERROR_PACKET_FLAGS ; pub const _WHEA_ERROR_PACKET_DATA_FORMAT_WheaDataFormatIPFSalRecord : _WHEA_ERROR_PACKET_DATA_FORMAT = 0 ; pub const _WHEA_ERROR_PACKET_DATA_FORMAT_WheaDataFormatXPFMCA : _WHEA_ERROR_PACKET_DATA_FORMAT = 1 ; pub const _WHEA_ERROR_PACKET_DATA_FORMAT_WheaDataFormatMemory : _WHEA_ERROR_PACKET_DATA_FORMAT = 2 ; pub const _WHEA_ERROR_PACKET_DATA_FORMAT_WheaDataFormatPCIExpress : _WHEA_ERROR_PACKET_DATA_FORMAT = 3 ; pub const _WHEA_ERROR_PACKET_DATA_FORMAT_WheaDataFormatNMIPort : _WHEA_ERROR_PACKET_DATA_FORMAT = 4 ; pub const _WHEA_ERROR_PACKET_DATA_FORMAT_WheaDataFormatPCIXBus : _WHEA_ERROR_PACKET_DATA_FORMAT = 5 ; pub const _WHEA_ERROR_PACKET_DATA_FORMAT_WheaDataFormatPCIXDevice : _WHEA_ERROR_PACKET_DATA_FORMAT = 6 ; pub const _WHEA_ERROR_PACKET_DATA_FORMAT_WheaDataFormatGeneric : _WHEA_ERROR_PACKET_DATA_FORMAT = 7 ; pub const _WHEA_ERROR_PACKET_DATA_FORMAT_WheaDataFormatMax : _WHEA_ERROR_PACKET_DATA_FORMAT = 8 ; pub type _WHEA_ERROR_PACKET_DATA_FORMAT = i32 ; pub use self :: _WHEA_ERROR_PACKET_DATA_FORMAT as WHEA_ERROR_PACKET_DATA_FORMAT ; pub type PWHEA_ERROR_PACKET_DATA_FORMAT = * mut _WHEA_ERROR_PACKET_DATA_FORMAT ; pub const _WHEA_RAW_DATA_FORMAT_WheaRawDataFormatIPFSalRecord : _WHEA_RAW_DATA_FORMAT = 0 ; pub const _WHEA_RAW_DATA_FORMAT_WheaRawDataFormatIA32MCA : _WHEA_RAW_DATA_FORMAT = 1 ; pub const _WHEA_RAW_DATA_FORMAT_WheaRawDataFormatIntel64MCA : _WHEA_RAW_DATA_FORMAT = 2 ; pub const _WHEA_RAW_DATA_FORMAT_WheaRawDataFormatAMD64MCA : _WHEA_RAW_DATA_FORMAT = 3 ; pub const _WHEA_RAW_DATA_FORMAT_WheaRawDataFormatMemory : _WHEA_RAW_DATA_FORMAT = 4 ; pub const _WHEA_RAW_DATA_FORMAT_WheaRawDataFormatPCIExpress : _WHEA_RAW_DATA_FORMAT = 5 ; pub const _WHEA_RAW_DATA_FORMAT_WheaRawDataFormatNMIPort : _WHEA_RAW_DATA_FORMAT = 6 ; pub const _WHEA_RAW_DATA_FORMAT_WheaRawDataFormatPCIXBus : _WHEA_RAW_DATA_FORMAT = 7 ; pub const _WHEA_RAW_DATA_FORMAT_WheaRawDataFormatPCIXDevice : _WHEA_RAW_DATA_FORMAT = 8 ; pub const _WHEA_RAW_DATA_FORMAT_WheaRawDataFormatGeneric : _WHEA_RAW_DATA_FORMAT = 9 ; pub const _WHEA_RAW_DATA_FORMAT_WheaRawDataFormatMax : _WHEA_RAW_DATA_FORMAT = 10 ; pub type _WHEA_RAW_DATA_FORMAT = i32 ; pub use self :: _WHEA_RAW_DATA_FORMAT as WHEA_RAW_DATA_FORMAT ; pub type PWHEA_RAW_DATA_FORMAT = * mut _WHEA_RAW_DATA_FORMAT ; # [ repr ( C , packed ) ] pub struct _WHEA_ERROR_PACKET_V1 { pub Signature : ULONG , pub Flags : WHEA_ERROR_PACKET_FLAGS , pub Size : ULONG , pub RawDataLength : ULONG , pub Reserved1 : ULONGLONG , pub Context : ULONGLONG , pub ErrorType : WHEA_ERROR_TYPE , pub ErrorSeverity : WHEA_ERROR_SEVERITY , pub ErrorSourceId : ULONG , pub ErrorSourceType : WHEA_ERROR_SOURCE_TYPE , pub Reserved2 : ULONG , pub Version : ULONG , pub Cpu : ULONGLONG , pub u : _WHEA_ERROR_PACKET_V1__bindgen_ty_1 , pub RawDataFormat : WHEA_RAW_DATA_FORMAT , pub RawDataOffset : ULONG , pub RawData : [ UCHAR ; 1usize ] , } # [ repr ( C ) ] pub struct _WHEA_ERROR_PACKET_V1__bindgen_ty_1 { pub ProcessorError : __BindgenUnionField < WHEA_PROCESSOR_GENERIC_ERROR_SECTION > , pub MemoryError : __BindgenUnionField < WHEA_MEMORY_ERROR_SECTION > , pub NmiError : __BindgenUnionField < WHEA_NMI_ERROR_SECTION > , pub PciExpressError : __BindgenUnionField < WHEA_PCIEXPRESS_ERROR_SECTION > , pub PciXBusError : __BindgenUnionField < WHEA_PCIXBUS_ERROR_SECTION > , pub PciXDeviceError : __BindgenUnionField < WHEA_PCIXDEVICE_ERROR_SECTION > , pub bindgen_union_field : [ u8 ; 208usize ] , } pub type WHEA_ERROR_PACKET_V1 = _WHEA_ERROR_PACKET_V1 ; pub type PWHEA_ERROR_PACKET_V1 = * mut _WHEA_ERROR_PACKET_V1 ; # [ repr ( C , packed ) ] pub struct _WHEA_ERROR_PACKET_V2 { pub Signature : ULONG , pub Version : ULONG , pub Length : ULONG , pub Flags : WHEA_ERROR_PACKET_FLAGS , pub ErrorType : WHEA_ERROR_TYPE , pub ErrorSeverity : WHEA_ERROR_SEVERITY , pub ErrorSourceId : ULONG , pub ErrorSourceType : WHEA_ERROR_SOURCE_TYPE , pub NotifyType : GUID , pub Context : ULONGLONG , pub DataFormat : WHEA_ERROR_PACKET_DATA_FORMAT , pub Reserved1 : ULONG , pub DataOffset : ULONG , pub DataLength : ULONG , pub PshedDataOffset : ULONG , pub PshedDataLength : ULONG , } pub type WHEA_ERROR_PACKET_V2 = _WHEA_ERROR_PACKET_V2 ; pub type PWHEA_ERROR_PACKET_V2 = * mut _WHEA_ERROR_PACKET_V2 ; pub type WHEA_ERROR_PACKET = _WHEA_ERROR_PACKET_V2 ; pub type PWHEA_ERROR_PACKET = * mut _WHEA_ERROR_PACKET_V2 ; # [ repr ( C , packed ) ] pub struct _WHEA_GENERIC_ERROR_BLOCKSTATUS { pub __bindgen_anon_1 : __BindgenUnionField < _WHEA_GENERIC_ERROR_BLOCKSTATUS__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : [ u8 ; 4usize ] , } # [ repr ( C , packed ) ] pub struct _WHEA_GENERIC_ERROR_BLOCKSTATUS__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , } impl _WHEA_GENERIC_ERROR_BLOCKSTATUS__bindgen_ty_1 { # [ inline ] pub fn UncorrectableError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_UncorrectableError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn CorrectableError ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_CorrectableError ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MultipleUncorrectableErrors ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_MultipleUncorrectableErrors ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MultipleCorrectableErrors ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_MultipleCorrectableErrors ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ErrorDataEntryCount ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 10u8 ) as u32 ) } } # [ inline ] pub fn set_ErrorDataEntryCount ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 10u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 18u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 18u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( UncorrectableError : ULONG , CorrectableError : ULONG , MultipleUncorrectableErrors : ULONG , MultipleCorrectableErrors : ULONG , ErrorDataEntryCount : ULONG , Reserved : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let UncorrectableError : u32 = unsafe { :: std :: mem :: transmute ( UncorrectableError ) } ; UncorrectableError as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let CorrectableError : u32 = unsafe { :: std :: mem :: transmute ( CorrectableError ) } ; CorrectableError as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let MultipleUncorrectableErrors : u32 = unsafe { :: std :: mem :: transmute ( MultipleUncorrectableErrors ) } ; MultipleUncorrectableErrors as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let MultipleCorrectableErrors : u32 = unsafe { :: std :: mem :: transmute ( MultipleCorrectableErrors ) } ; MultipleCorrectableErrors as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 10u8 , { let ErrorDataEntryCount : u32 = unsafe { :: std :: mem :: transmute ( ErrorDataEntryCount ) } ; ErrorDataEntryCount as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 18u8 , { let Reserved : u32 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_GENERIC_ERROR_BLOCKSTATUS = _WHEA_GENERIC_ERROR_BLOCKSTATUS ; pub type PWHEA_GENERIC_ERROR_BLOCKSTATUS = * mut _WHEA_GENERIC_ERROR_BLOCKSTATUS ; # [ repr ( C , packed ) ] pub struct _WHEA_GENERIC_ERROR { pub BlockStatus : WHEA_GENERIC_ERROR_BLOCKSTATUS , pub RawDataOffset : ULONG , pub RawDataLength : ULONG , pub DataLength : ULONG , pub ErrorSeverity : WHEA_ERROR_SEVERITY , pub Data : [ UCHAR ; 1usize ] , } pub type WHEA_GENERIC_ERROR = _WHEA_GENERIC_ERROR ; pub type PWHEA_GENERIC_ERROR = * mut _WHEA_GENERIC_ERROR ; # [ repr ( C , packed ) ] pub struct _WHEA_GENERIC_ERROR_DATA_ENTRY_V1 { pub SectionType : GUID , pub ErrorSeverity : WHEA_ERROR_SEVERITY , pub Revision : WHEA_REVISION , pub ValidBits : UCHAR , pub Flags : UCHAR , pub ErrorDataLength : ULONG , pub FRUId : GUID , pub FRUText : [ UCHAR ; 20usize ] , pub Data : [ UCHAR ; 1usize ] , } pub type WHEA_GENERIC_ERROR_DATA_ENTRY_V1 = _WHEA_GENERIC_ERROR_DATA_ENTRY_V1 ; pub type PWHEA_GENERIC_ERROR_DATA_ENTRY_V1 = * mut _WHEA_GENERIC_ERROR_DATA_ENTRY_V1 ; # [ repr ( C , packed ) ] pub struct _WHEA_GENERIC_ERROR_DATA_ENTRY_V2 { pub SectionType : GUID , pub ErrorSeverity : WHEA_ERROR_SEVERITY , pub Revision : WHEA_REVISION , pub ValidBits : UCHAR , pub Flags : UCHAR , pub ErrorDataLength : ULONG , pub FRUId : GUID , pub FRUText : [ UCHAR ; 20usize ] , pub Timestamp : WHEA_TIMESTAMP , pub Data : [ UCHAR ; 1usize ] , } pub type WHEA_GENERIC_ERROR_DATA_ENTRY_V2 = _WHEA_GENERIC_ERROR_DATA_ENTRY_V2 ; pub type PWHEA_GENERIC_ERROR_DATA_ENTRY_V2 = * mut _WHEA_GENERIC_ERROR_DATA_ENTRY_V2 ; pub type WHEA_GENERIC_ERROR_DATA_ENTRY = _WHEA_GENERIC_ERROR_DATA_ENTRY_V2 ; pub type PWHEA_GENERIC_ERROR_DATA_ENTRY = * mut _WHEA_GENERIC_ERROR_DATA_ENTRY_V2 ; # [ repr ( C ) ] pub struct _WHEA_ERROR_INJECTION_CAPABILITIES { pub __bindgen_anon_1 : __BindgenUnionField < _WHEA_ERROR_INJECTION_CAPABILITIES__bindgen_ty_1 > , pub AsULONG : __BindgenUnionField < ULONG > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _WHEA_ERROR_INJECTION_CAPABILITIES__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl _WHEA_ERROR_INJECTION_CAPABILITIES__bindgen_ty_1 { # [ inline ] pub fn ProcessorCorrectable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ProcessorCorrectable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ProcessorUncorrectableNonFatal ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ProcessorUncorrectableNonFatal ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ProcessorUncorrectableFatal ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ProcessorUncorrectableFatal ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MemoryCorrectable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_MemoryCorrectable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MemoryUncorrectableNonFatal ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_MemoryUncorrectableNonFatal ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn MemoryUncorrectableFatal ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_MemoryUncorrectableFatal ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PCIExpressCorrectable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_PCIExpressCorrectable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PCIExpressUncorrectableNonFatal ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_PCIExpressUncorrectableNonFatal ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PCIExpressUncorrectableFatal ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_PCIExpressUncorrectableFatal ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PlatformCorrectable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_PlatformCorrectable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PlatformUncorrectableNonFatal ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_PlatformUncorrectableNonFatal ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 1u8 , val as u64 ) } } # [ inline ] pub fn PlatformUncorrectableFatal ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_PlatformUncorrectableFatal ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 1u8 , val as u64 ) } } # [ inline ] pub fn IA64Corrected ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_IA64Corrected ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 1u8 , val as u64 ) } } # [ inline ] pub fn IA64Recoverable ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 13usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_IA64Recoverable ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 13usize , 1u8 , val as u64 ) } } # [ inline ] pub fn IA64Fatal ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_IA64Fatal ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 1u8 , val as u64 ) } } # [ inline ] pub fn IA64RecoverableCache ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 15usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_IA64RecoverableCache ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 15usize , 1u8 , val as u64 ) } } # [ inline ] pub fn IA64RecoverableRegFile ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_IA64RecoverableRegFile ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 1u8 , val as u64 ) } } # [ inline ] pub fn Reserved ( & self ) -> ULONG { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 17usize , 15u8 ) as u32 ) } } # [ inline ] pub fn set_Reserved ( & mut self , val : ULONG ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 17usize , 15u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ProcessorCorrectable : ULONG , ProcessorUncorrectableNonFatal : ULONG , ProcessorUncorrectableFatal : ULONG , MemoryCorrectable : ULONG , MemoryUncorrectableNonFatal : ULONG , MemoryUncorrectableFatal : ULONG , PCIExpressCorrectable : ULONG , PCIExpressUncorrectableNonFatal : ULONG , PCIExpressUncorrectableFatal : ULONG , PlatformCorrectable : ULONG , PlatformUncorrectableNonFatal : ULONG , PlatformUncorrectableFatal : ULONG , IA64Corrected : ULONG , IA64Recoverable : ULONG , IA64Fatal : ULONG , IA64RecoverableCache : ULONG , IA64RecoverableRegFile : ULONG , Reserved : ULONG ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let ProcessorCorrectable : u32 = unsafe { :: std :: mem :: transmute ( ProcessorCorrectable ) } ; ProcessorCorrectable as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let ProcessorUncorrectableNonFatal : u32 = unsafe { :: std :: mem :: transmute ( ProcessorUncorrectableNonFatal ) } ; ProcessorUncorrectableNonFatal as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let ProcessorUncorrectableFatal : u32 = unsafe { :: std :: mem :: transmute ( ProcessorUncorrectableFatal ) } ; ProcessorUncorrectableFatal as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let MemoryCorrectable : u32 = unsafe { :: std :: mem :: transmute ( MemoryCorrectable ) } ; MemoryCorrectable as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let MemoryUncorrectableNonFatal : u32 = unsafe { :: std :: mem :: transmute ( MemoryUncorrectableNonFatal ) } ; MemoryUncorrectableNonFatal as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let MemoryUncorrectableFatal : u32 = unsafe { :: std :: mem :: transmute ( MemoryUncorrectableFatal ) } ; MemoryUncorrectableFatal as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let PCIExpressCorrectable : u32 = unsafe { :: std :: mem :: transmute ( PCIExpressCorrectable ) } ; PCIExpressCorrectable as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let PCIExpressUncorrectableNonFatal : u32 = unsafe { :: std :: mem :: transmute ( PCIExpressUncorrectableNonFatal ) } ; PCIExpressUncorrectableNonFatal as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let PCIExpressUncorrectableFatal : u32 = unsafe { :: std :: mem :: transmute ( PCIExpressUncorrectableFatal ) } ; PCIExpressUncorrectableFatal as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let PlatformCorrectable : u32 = unsafe { :: std :: mem :: transmute ( PlatformCorrectable ) } ; PlatformCorrectable as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 1u8 , { let PlatformUncorrectableNonFatal : u32 = unsafe { :: std :: mem :: transmute ( PlatformUncorrectableNonFatal ) } ; PlatformUncorrectableNonFatal as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 1u8 , { let PlatformUncorrectableFatal : u32 = unsafe { :: std :: mem :: transmute ( PlatformUncorrectableFatal ) } ; PlatformUncorrectableFatal as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 1u8 , { let IA64Corrected : u32 = unsafe { :: std :: mem :: transmute ( IA64Corrected ) } ; IA64Corrected as u64 } ) ; __bindgen_bitfield_unit . set ( 13usize , 1u8 , { let IA64Recoverable : u32 = unsafe { :: std :: mem :: transmute ( IA64Recoverable ) } ; IA64Recoverable as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 1u8 , { let IA64Fatal : u32 = unsafe { :: std :: mem :: transmute ( IA64Fatal ) } ; IA64Fatal as u64 } ) ; __bindgen_bitfield_unit . set ( 15usize , 1u8 , { let IA64RecoverableCache : u32 = unsafe { :: std :: mem :: transmute ( IA64RecoverableCache ) } ; IA64RecoverableCache as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 1u8 , { let IA64RecoverableRegFile : u32 = unsafe { :: std :: mem :: transmute ( IA64RecoverableRegFile ) } ; IA64RecoverableRegFile as u64 } ) ; __bindgen_bitfield_unit . set ( 17usize , 15u8 , { let Reserved : u32 = unsafe { :: std :: mem :: transmute ( Reserved ) } ; Reserved as u64 } ) ; __bindgen_bitfield_unit } } pub type WHEA_ERROR_INJECTION_CAPABILITIES = _WHEA_ERROR_INJECTION_CAPABILITIES ; pub type PWHEA_ERROR_INJECTION_CAPABILITIES = * mut _WHEA_ERROR_INJECTION_CAPABILITIES ; # [ repr ( C ) ] pub struct _WHEA_RECOVERY_CONTEXT { pub __bindgen_anon_1 : _WHEA_RECOVERY_CONTEXT__bindgen_ty_1 , pub PartitionId : UINT64 , pub VpIndex : UINT32 , } # [ repr ( C ) ] pub struct _WHEA_RECOVERY_CONTEXT__bindgen_ty_1 { pub MemoryError : __BindgenUnionField < _WHEA_RECOVERY_CONTEXT__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : [ u64 ; 2usize ] , } # [ repr ( C ) ] pub struct _WHEA_RECOVERY_CONTEXT__bindgen_ty_1__bindgen_ty_1 { pub Address : ULONG_PTR , pub Consumed : BOOLEAN , pub ErrorCode : UINT16 , pub ErrorIpValid : BOOLEAN , pub RestartIpValid : BOOLEAN , } pub type WHEA_RECOVERY_CONTEXT = _WHEA_RECOVERY_CONTEXT ; pub type PWHEA_RECOVERY_CONTEXT = * mut _WHEA_RECOVERY_CONTEXT ; pub type HVL_WHEA_ERROR_NOTIFICATION = :: std :: option :: Option < unsafe extern "C" fn ( RecoveryContext : PWHEA_RECOVERY_CONTEXT , PlatformDirected : BOOLEAN , Poisoned : BOOLEAN ) -> NTSTATUS > ; pub type PHVL_WHEA_ERROR_NOTIFICATION = HVL_WHEA_ERROR_NOTIFICATION ; extern "C" { # [ link_name = "\u{1}HvlpWheaErrorNotificationCallback" ] pub static mut HvlpWheaErrorNotificationCallback : PHVL_WHEA_ERROR_NOTIFICATION ; } extern "C" { pub fn HvlRegisterWheaErrorNotification ( Callback : PHVL_WHEA_ERROR_NOTIFICATION ) -> NTSTATUS ; } extern "C" { pub fn HvlUnregisterWheaErrorNotification ( Callback : PHVL_WHEA_ERROR_NOTIFICATION ) -> NTSTATUS ; } pub type PSHED_PI_GET_ALL_ERROR_SOURCES = :: std :: option :: Option < unsafe extern "C" fn ( PluginContext : PVOID , Count : PULONG , ErrorSrcs : * mut PWHEA_ERROR_SOURCE_DESCRIPTOR , Length : PULONG ) -> NTSTATUS > ; pub type PSHED_PI_GET_ERROR_SOURCE_INFO = :: std :: option :: Option < unsafe extern "C" fn ( PluginContext : PVOID , ErrorSource : PWHEA_ERROR_SOURCE_DESCRIPTOR ) -> NTSTATUS > ; pub type PSHED_PI_SET_ERROR_SOURCE_INFO = :: std :: option :: Option < unsafe extern "C" fn ( PluginContext : PVOID , ErrorSource : PWHEA_ERROR_SOURCE_DESCRIPTOR ) -> NTSTATUS > ; pub type PSHED_PI_ENABLE_ERROR_SOURCE = :: std :: option :: Option < unsafe extern "C" fn ( PluginContext : PVOID , ErrorSource : PWHEA_ERROR_SOURCE_DESCRIPTOR ) -> NTSTATUS > ; pub type PSHED_PI_DISABLE_ERROR_SOURCE = :: std :: option :: Option < unsafe extern "C" fn ( PluginContext : PVOID , ErrorSource : PWHEA_ERROR_SOURCE_DESCRIPTOR ) -> NTSTATUS > ; pub type PSHED_PI_WRITE_ERROR_RECORD = :: std :: option :: Option < unsafe extern "C" fn ( PluginContext : PVOID , Flags : ULONG , RecordLength : ULONG , ErrorRecord : PWHEA_ERROR_RECORD ) -> NTSTATUS > ; pub type PSHED_PI_READ_ERROR_RECORD = :: std :: option :: Option < unsafe extern "C" fn ( PluginContext : PVOID , Flags : ULONG , ErrorRecordId : ULONGLONG , NextErrorRecordId : PULONGLONG , RecordLength : PULONG , ErrorRecord : PWHEA_ERROR_RECORD ) -> NTSTATUS > ; pub type PSHED_PI_CLEAR_ERROR_RECORD = :: std :: option :: Option < unsafe extern "C" fn ( PluginContext : PVOID , Flags : ULONG , ErrorRecordId : ULONGLONG ) -> NTSTATUS > ; pub type PSHED_PI_RETRIEVE_ERROR_INFO = :: std :: option :: Option < unsafe extern "C" fn ( PluginContext : PVOID , ErrorSource : PWHEA_ERROR_SOURCE_DESCRIPTOR , BufferLength : ULONGLONG , Packet : PWHEA_ERROR_PACKET ) -> NTSTATUS > ; pub type PSHED_PI_FINALIZE_ERROR_RECORD = :: std :: option :: Option < unsafe extern "C" fn ( PluginContext : PVOID , ErrorSource : PWHEA_ERROR_SOURCE_DESCRIPTOR , BufferLength : ULONG , ErrorRecord : PWHEA_ERROR_RECORD ) -> NTSTATUS > ; pub type PSHED_PI_CLEAR_ERROR_STATUS = :: std :: option :: Option < unsafe extern "C" fn ( PluginContext : PVOID , ErrorSource : PWHEA_ERROR_SOURCE_DESCRIPTOR , BufferLength : ULONG , ErrorRecord : PWHEA_ERROR_RECORD ) -> NTSTATUS > ; pub type PSHED_PI_ATTEMPT_ERROR_RECOVERY = :: std :: option :: Option < unsafe extern "C" fn ( PluginContext : PVOID , BufferLength : ULONG , ErrorRecord : PWHEA_ERROR_RECORD ) -> NTSTATUS > ; pub type PSHED_PI_GET_INJECTION_CAPABILITIES = :: std :: option :: Option < unsafe extern "C" fn ( PluginContext : PVOID , Capabilities : PWHEA_ERROR_INJECTION_CAPABILITIES ) -> NTSTATUS > ; pub type PSHED_PI_INJECT_ERROR = :: std :: option :: Option < unsafe extern "C" fn ( PluginContext : PVOID , ErrorType : ULONGLONG , Parameter1 : ULONGLONG , Parameter2 : ULONGLONG , Parameter3 : ULONGLONG , Parameter4 : ULONGLONG ) -> NTSTATUS > ; # [ repr ( C ) ] pub struct _WHEA_PSHED_PLUGIN_CALLBACKS { pub GetAllErrorSources : PSHED_PI_GET_ALL_ERROR_SOURCES , pub Reserved : PVOID , pub GetErrorSourceInfo : PSHED_PI_GET_ERROR_SOURCE_INFO , pub SetErrorSourceInfo : PSHED_PI_SET_ERROR_SOURCE_INFO , pub EnableErrorSource : PSHED_PI_ENABLE_ERROR_SOURCE , pub DisableErrorSource : PSHED_PI_DISABLE_ERROR_SOURCE , pub WriteErrorRecord : PSHED_PI_WRITE_ERROR_RECORD , pub ReadErrorRecord : PSHED_PI_READ_ERROR_RECORD , pub ClearErrorRecord : PSHED_PI_CLEAR_ERROR_RECORD , pub RetrieveErrorInfo : PSHED_PI_RETRIEVE_ERROR_INFO , pub FinalizeErrorRecord : PSHED_PI_FINALIZE_ERROR_RECORD , pub ClearErrorStatus : PSHED_PI_CLEAR_ERROR_STATUS , pub AttemptRecovery : PSHED_PI_ATTEMPT_ERROR_RECOVERY , pub GetInjectionCapabilities : PSHED_PI_GET_INJECTION_CAPABILITIES , pub InjectError : PSHED_PI_INJECT_ERROR , } pub type WHEA_PSHED_PLUGIN_CALLBACKS = _WHEA_PSHED_PLUGIN_CALLBACKS ; pub type PWHEA_PSHED_PLUGIN_CALLBACKS = * mut _WHEA_PSHED_PLUGIN_CALLBACKS ; # [ repr ( C ) ] pub struct _WHEA_PSHED_PLUGIN_REGISTRATION_PACKET { pub Length : ULONG , pub Version : ULONG , pub Context : PVOID , pub FunctionalAreaMask : ULONG , pub Reserved : ULONG , pub Callbacks : WHEA_PSHED_PLUGIN_CALLBACKS , } pub type WHEA_PSHED_PLUGIN_REGISTRATION_PACKET = _WHEA_PSHED_PLUGIN_REGISTRATION_PACKET ; pub type PWHEA_PSHED_PLUGIN_REGISTRATION_PACKET = * mut _WHEA_PSHED_PLUGIN_REGISTRATION_PACKET ; extern "C" { pub fn PshedAllocateMemory ( Size : ULONG ) -> PVOID ; } extern "C" { pub fn PshedFreeMemory ( Address : PVOID ) ; } extern "C" { pub fn PshedIsSystemWheaEnabled ( ) -> BOOLEAN ; } extern "C" { pub fn PshedRegisterPlugin ( Packet : PWHEA_PSHED_PLUGIN_REGISTRATION_PACKET ) -> NTSTATUS ; } extern "C" { pub fn PshedSynchronizeExecution ( ErrorSource : PWHEA_ERROR_SOURCE_DESCRIPTOR , SynchronizeRoutine : PKSYNCHRONIZE_ROUTINE , SynchronizeContext : PVOID ) -> BOOLEAN ; } pub const _SOC_SUBSYSTEM_TYPE_SOC_SUBSYS_WIRELESS_MODEM : _SOC_SUBSYSTEM_TYPE = 0 ; pub const _SOC_SUBSYSTEM_TYPE_SOC_SUBSYS_AUDIO_DSP : _SOC_SUBSYSTEM_TYPE = 1 ; pub const _SOC_SUBSYSTEM_TYPE_SOC_SUBSYS_WIRELSS_CONNECTIVITY : _SOC_SUBSYSTEM_TYPE = 2 ; pub const _SOC_SUBSYSTEM_TYPE_SOC_SUBSYS_SENSORS : _SOC_SUBSYSTEM_TYPE = 3 ; pub const _SOC_SUBSYSTEM_TYPE_SOC_SUBSYS_VENDOR_DEFINED : _SOC_SUBSYSTEM_TYPE = 65536 ; pub type _SOC_SUBSYSTEM_TYPE = i32 ; pub use self :: _SOC_SUBSYSTEM_TYPE as SOC_SUBSYSTEM_TYPE ; pub type PSOC_SUBSYSTEM_TYPE = * mut _SOC_SUBSYSTEM_TYPE ; # [ repr ( C ) ] pub struct _SOC_SUBSYSTEM_FAILURE_DETAILS { pub SubsysType : SOC_SUBSYSTEM_TYPE , pub FirmwareVersion : ULONG64 , pub HardwareVersion : ULONG64 , pub UnifiedFailureRegionSize : ULONG , pub UnifiedFailureRegion : [ CHAR ; 1usize ] , } pub type SOC_SUBSYSTEM_FAILURE_DETAILS = _SOC_SUBSYSTEM_FAILURE_DETAILS ; pub type PSOC_SUBSYSTEM_FAILURE_DETAILS = * mut _SOC_SUBSYSTEM_FAILURE_DETAILS ; pub type WDFFUNC = :: std :: option :: Option < unsafe extern "C" fn ( ) > ; extern "C" { # [ link_name = "\u{1}WdfFunctions_01023" ] pub static mut WdfFunctions_01023 : * const WDFFUNC ; } extern "C" { # [ link_name = "\u{1}WdfDriverMiniportUnloadOverride" ] pub static mut WdfDriverMiniportUnloadOverride : WDFFUNC ; } pub type __prefast_analysis_mode_flag2 = :: std :: os :: raw :: c_int ; pub type BYTE = UCHAR ; pub const _WDF_TRI_STATE_WdfFalse : _WDF_TRI_STATE = 0 ; pub const _WDF_TRI_STATE_WdfTrue : _WDF_TRI_STATE = 1 ; pub const _WDF_TRI_STATE_WdfUseDefault : _WDF_TRI_STATE = 2 ; pub type _WDF_TRI_STATE = i32 ; pub use self :: _WDF_TRI_STATE as WDF_TRI_STATE ; pub type PWDF_TRI_STATE = * mut _WDF_TRI_STATE ; pub type WDFCONTEXT = PVOID ; # [ repr ( C ) ] pub struct WDFDEVICE_INIT { _unused : [ u8 ; 0 ] , } pub type PWDFDEVICE_INIT = * mut WDFDEVICE_INIT ; # [ repr ( C ) ] pub struct WDFCXDEVICE_INIT { _unused : [ u8 ; 0 ] , } pub type PWDFCXDEVICE_INIT = * mut WDFCXDEVICE_INIT ; pub type PWDF_OBJECT_ATTRIBUTES = * mut _WDF_OBJECT_ATTRIBUTES ; pub type WDFOBJECT = HANDLE ; pub type PWDFOBJECT = * mut HANDLE ; # [ repr ( C ) ] pub struct WDFDRIVER__ { pub unused : :: std :: os :: raw :: c_int , } pub type WDFDRIVER = * mut WDFDRIVER__ ; # [ repr ( C ) ] pub struct WDFDEVICE__ { pub unused : :: std :: os :: raw :: c_int , } pub type WDFDEVICE = * mut WDFDEVICE__ ; # [ repr ( C ) ] pub struct WDFWMIPROVIDER__ { pub unused : :: std :: os :: raw :: c_int , } pub type WDFWMIPROVIDER = * mut WDFWMIPROVIDER__ ; # [ repr ( C ) ] pub struct WDFWMIINSTANCE__ { pub unused : :: std :: os :: raw :: c_int , } pub type WDFWMIINSTANCE = * mut WDFWMIINSTANCE__ ; # [ repr ( C ) ] pub struct WDFQUEUE__ { pub unused : :: std :: os :: raw :: c_int , } pub type WDFQUEUE = * mut WDFQUEUE__ ; # [ repr ( C ) ] pub struct WDFREQUEST__ { pub unused : :: std :: os :: raw :: c_int , } pub type WDFREQUEST = * mut WDFREQUEST__ ; # [ repr ( C ) ] pub struct WDFFILEOBJECT__ { pub unused : :: std :: os :: raw :: c_int , } pub type WDFFILEOBJECT = * mut WDFFILEOBJECT__ ; # [ repr ( C ) ] pub struct WDFDPC__ { pub unused : :: std :: os :: raw :: c_int , } pub type WDFDPC = * mut WDFDPC__ ; # [ repr ( C ) ] pub struct WDFTIMER__ { pub unused : :: std :: os :: raw :: c_int , } pub type WDFTIMER = * mut WDFTIMER__ ; # [ repr ( C ) ] pub struct WDFWORKITEM__ { pub unused : :: std :: os :: raw :: c_int , } pub type WDFWORKITEM = * mut WDFWORKITEM__ ; # [ repr ( C ) ] pub struct WDFINTERRUPT__ { pub unused : :: std :: os :: raw :: c_int , } pub type WDFINTERRUPT = * mut WDFINTERRUPT__ ; # [ repr ( C ) ] pub struct WDFWAITLOCK__ { pub unused : :: std :: os :: raw :: c_int , } pub type WDFWAITLOCK = * mut WDFWAITLOCK__ ; # [ repr ( C ) ] pub struct WDFSPINLOCK__ { pub unused : :: std :: os :: raw :: c_int , } pub type WDFSPINLOCK = * mut WDFSPINLOCK__ ; # [ repr ( C ) ] pub struct WDFMEMORY__ { pub unused : :: std :: os :: raw :: c_int , } pub type WDFMEMORY = * mut WDFMEMORY__ ; # [ repr ( C ) ] pub struct WDFLOOKASIDE__ { pub unused : :: std :: os :: raw :: c_int , } pub type WDFLOOKASIDE = * mut WDFLOOKASIDE__ ; # [ repr ( C ) ] pub struct WDFIOTARGET__ { pub unused : :: std :: os :: raw :: c_int , } pub type WDFIOTARGET = * mut WDFIOTARGET__ ; # [ repr ( C ) ] pub struct WDFUSBDEVICE__ { pub unused : :: std :: os :: raw :: c_int , } pub type WDFUSBDEVICE = * mut WDFUSBDEVICE__ ; # [ repr ( C ) ] pub struct WDFUSBINTERFACE__ { pub unused : :: std :: os :: raw :: c_int , } pub type WDFUSBINTERFACE = * mut WDFUSBINTERFACE__ ; # [ repr ( C ) ] pub struct WDFUSBPIPE__ { pub unused : :: std :: os :: raw :: c_int , } pub type WDFUSBPIPE = * mut WDFUSBPIPE__ ; # [ repr ( C ) ] pub struct WDFDMAENABLER__ { pub unused : :: std :: os :: raw :: c_int , } pub type WDFDMAENABLER = * mut WDFDMAENABLER__ ; # [ repr ( C ) ] pub struct WDFDMATRANSACTION__ { pub unused : :: std :: os :: raw :: c_int , } pub type WDFDMATRANSACTION = * mut WDFDMATRANSACTION__ ; # [ repr ( C ) ] pub struct WDFCOMMONBUFFER__ { pub unused : :: std :: os :: raw :: c_int , } pub type WDFCOMMONBUFFER = * mut WDFCOMMONBUFFER__ ; # [ repr ( C ) ] pub struct WDFKEY__ { pub unused : :: std :: os :: raw :: c_int , } pub type WDFKEY = * mut WDFKEY__ ; # [ repr ( C ) ] pub struct WDFSTRING__ { pub unused : :: std :: os :: raw :: c_int , } pub type WDFSTRING = * mut WDFSTRING__ ; # [ repr ( C ) ] pub struct WDFCOLLECTION__ { pub unused : :: std :: os :: raw :: c_int , } pub type WDFCOLLECTION = * mut WDFCOLLECTION__ ; # [ repr ( C ) ] pub struct WDFCHILDLIST__ { pub unused : :: std :: os :: raw :: c_int , } pub type WDFCHILDLIST = * mut WDFCHILDLIST__ ; # [ repr ( C ) ] pub struct WDFIORESREQLIST__ { pub unused : :: std :: os :: raw :: c_int , } pub type WDFIORESREQLIST = * mut WDFIORESREQLIST__ ; # [ repr ( C ) ] pub struct WDFIORESLIST__ { pub unused : :: std :: os :: raw :: c_int , } pub type WDFIORESLIST = * mut WDFIORESLIST__ ; # [ repr ( C ) ] pub struct WDFCMRESLIST__ { pub unused : :: std :: os :: raw :: c_int , } pub type WDFCMRESLIST = * mut WDFCMRESLIST__ ; # [ repr ( C ) ] pub struct WDFCOMPANIONTARGET__ { pub unused : :: std :: os :: raw :: c_int , } pub type WDFCOMPANIONTARGET = * mut WDFCOMPANIONTARGET__ ; # [ repr ( C ) ] pub struct _WDF_DRIVER_GLOBALS { pub Driver : WDFDRIVER , pub DriverFlags : ULONG , pub DriverTag : ULONG , pub DriverName : [ CHAR ; 32usize ] , pub DisplaceDriverUnload : BOOLEAN , } pub type WDF_DRIVER_GLOBALS = _WDF_DRIVER_GLOBALS ; pub type PWDF_DRIVER_GLOBALS = * mut _WDF_DRIVER_GLOBALS ; extern "C" { # [ link_name = "\u{1}WdfDriverGlobals" ] pub static mut WdfDriverGlobals : PWDF_DRIVER_GLOBALS ; } pub const _WDFFUNCENUM_WdfChildListCreateTableIndex : _WDFFUNCENUM = 0 ; pub const _WDFFUNCENUM_WdfChildListGetDeviceTableIndex : _WDFFUNCENUM = 1 ; pub const _WDFFUNCENUM_WdfChildListRetrievePdoTableIndex : _WDFFUNCENUM = 2 ; pub const _WDFFUNCENUM_WdfChildListRetrieveAddressDescriptionTableIndex : _WDFFUNCENUM = 3 ; pub const _WDFFUNCENUM_WdfChildListBeginScanTableIndex : _WDFFUNCENUM = 4 ; pub const _WDFFUNCENUM_WdfChildListEndScanTableIndex : _WDFFUNCENUM = 5 ; pub const _WDFFUNCENUM_WdfChildListBeginIterationTableIndex : _WDFFUNCENUM = 6 ; pub const _WDFFUNCENUM_WdfChildListRetrieveNextDeviceTableIndex : _WDFFUNCENUM = 7 ; pub const _WDFFUNCENUM_WdfChildListEndIterationTableIndex : _WDFFUNCENUM = 8 ; pub const _WDFFUNCENUM_WdfChildListAddOrUpdateChildDescriptionAsPresentTableIndex : _WDFFUNCENUM = 9 ; pub const _WDFFUNCENUM_WdfChildListUpdateChildDescriptionAsMissingTableIndex : _WDFFUNCENUM = 10 ; pub const _WDFFUNCENUM_WdfChildListUpdateAllChildDescriptionsAsPresentTableIndex : _WDFFUNCENUM = 11 ; pub const _WDFFUNCENUM_WdfChildListRequestChildEjectTableIndex : _WDFFUNCENUM = 12 ; pub const _WDFFUNCENUM_WdfCollectionCreateTableIndex : _WDFFUNCENUM = 13 ; pub const _WDFFUNCENUM_WdfCollectionGetCountTableIndex : _WDFFUNCENUM = 14 ; pub const _WDFFUNCENUM_WdfCollectionAddTableIndex : _WDFFUNCENUM = 15 ; pub const _WDFFUNCENUM_WdfCollectionRemoveTableIndex : _WDFFUNCENUM = 16 ; pub const _WDFFUNCENUM_WdfCollectionRemoveItemTableIndex : _WDFFUNCENUM = 17 ; pub const _WDFFUNCENUM_WdfCollectionGetItemTableIndex : _WDFFUNCENUM = 18 ; pub const _WDFFUNCENUM_WdfCollectionGetFirstItemTableIndex : _WDFFUNCENUM = 19 ; pub const _WDFFUNCENUM_WdfCollectionGetLastItemTableIndex : _WDFFUNCENUM = 20 ; pub const _WDFFUNCENUM_WdfCommonBufferCreateTableIndex : _WDFFUNCENUM = 21 ; pub const _WDFFUNCENUM_WdfCommonBufferGetAlignedVirtualAddressTableIndex : _WDFFUNCENUM = 22 ; pub const _WDFFUNCENUM_WdfCommonBufferGetAlignedLogicalAddressTableIndex : _WDFFUNCENUM = 23 ; pub const _WDFFUNCENUM_WdfCommonBufferGetLengthTableIndex : _WDFFUNCENUM = 24 ; pub const _WDFFUNCENUM_WdfControlDeviceInitAllocateTableIndex : _WDFFUNCENUM = 25 ; pub const _WDFFUNCENUM_WdfControlDeviceInitSetShutdownNotificationTableIndex : _WDFFUNCENUM = 26 ; pub const _WDFFUNCENUM_WdfControlFinishInitializingTableIndex : _WDFFUNCENUM = 27 ; pub const _WDFFUNCENUM_WdfDeviceGetDeviceStateTableIndex : _WDFFUNCENUM = 28 ; pub const _WDFFUNCENUM_WdfDeviceSetDeviceStateTableIndex : _WDFFUNCENUM = 29 ; pub const _WDFFUNCENUM_WdfWdmDeviceGetWdfDeviceHandleTableIndex : _WDFFUNCENUM = 30 ; pub const _WDFFUNCENUM_WdfDeviceWdmGetDeviceObjectTableIndex : _WDFFUNCENUM = 31 ; pub const _WDFFUNCENUM_WdfDeviceWdmGetAttachedDeviceTableIndex : _WDFFUNCENUM = 32 ; pub const _WDFFUNCENUM_WdfDeviceWdmGetPhysicalDeviceTableIndex : _WDFFUNCENUM = 33 ; pub const _WDFFUNCENUM_WdfDeviceWdmDispatchPreprocessedIrpTableIndex : _WDFFUNCENUM = 34 ; pub const _WDFFUNCENUM_WdfDeviceAddDependentUsageDeviceObjectTableIndex : _WDFFUNCENUM = 35 ; pub const _WDFFUNCENUM_WdfDeviceAddRemovalRelationsPhysicalDeviceTableIndex : _WDFFUNCENUM = 36 ; pub const _WDFFUNCENUM_WdfDeviceRemoveRemovalRelationsPhysicalDeviceTableIndex : _WDFFUNCENUM = 37 ; pub const _WDFFUNCENUM_WdfDeviceClearRemovalRelationsDevicesTableIndex : _WDFFUNCENUM = 38 ; pub const _WDFFUNCENUM_WdfDeviceGetDriverTableIndex : _WDFFUNCENUM = 39 ; pub const _WDFFUNCENUM_WdfDeviceRetrieveDeviceNameTableIndex : _WDFFUNCENUM = 40 ; pub const _WDFFUNCENUM_WdfDeviceAssignMofResourceNameTableIndex : _WDFFUNCENUM = 41 ; pub const _WDFFUNCENUM_WdfDeviceGetIoTargetTableIndex : _WDFFUNCENUM = 42 ; pub const _WDFFUNCENUM_WdfDeviceGetDevicePnpStateTableIndex : _WDFFUNCENUM = 43 ; pub const _WDFFUNCENUM_WdfDeviceGetDevicePowerStateTableIndex : _WDFFUNCENUM = 44 ; pub const _WDFFUNCENUM_WdfDeviceGetDevicePowerPolicyStateTableIndex : _WDFFUNCENUM = 45 ; pub const _WDFFUNCENUM_WdfDeviceAssignS0IdleSettingsTableIndex : _WDFFUNCENUM = 46 ; pub const _WDFFUNCENUM_WdfDeviceAssignSxWakeSettingsTableIndex : _WDFFUNCENUM = 47 ; pub const _WDFFUNCENUM_WdfDeviceOpenRegistryKeyTableIndex : _WDFFUNCENUM = 48 ; pub const _WDFFUNCENUM_WdfDeviceSetSpecialFileSupportTableIndex : _WDFFUNCENUM = 49 ; pub const _WDFFUNCENUM_WdfDeviceSetCharacteristicsTableIndex : _WDFFUNCENUM = 50 ; pub const _WDFFUNCENUM_WdfDeviceGetCharacteristicsTableIndex : _WDFFUNCENUM = 51 ; pub const _WDFFUNCENUM_WdfDeviceGetAlignmentRequirementTableIndex : _WDFFUNCENUM = 52 ; pub const _WDFFUNCENUM_WdfDeviceSetAlignmentRequirementTableIndex : _WDFFUNCENUM = 53 ; pub const _WDFFUNCENUM_WdfDeviceInitFreeTableIndex : _WDFFUNCENUM = 54 ; pub const _WDFFUNCENUM_WdfDeviceInitSetPnpPowerEventCallbacksTableIndex : _WDFFUNCENUM = 55 ; pub const _WDFFUNCENUM_WdfDeviceInitSetPowerPolicyEventCallbacksTableIndex : _WDFFUNCENUM = 56 ; pub const _WDFFUNCENUM_WdfDeviceInitSetPowerPolicyOwnershipTableIndex : _WDFFUNCENUM = 57 ; pub const _WDFFUNCENUM_WdfDeviceInitRegisterPnpStateChangeCallbackTableIndex : _WDFFUNCENUM = 58 ; pub const _WDFFUNCENUM_WdfDeviceInitRegisterPowerStateChangeCallbackTableIndex : _WDFFUNCENUM = 59 ; pub const _WDFFUNCENUM_WdfDeviceInitRegisterPowerPolicyStateChangeCallbackTableIndex : _WDFFUNCENUM = 60 ; pub const _WDFFUNCENUM_WdfDeviceInitSetIoTypeTableIndex : _WDFFUNCENUM = 61 ; pub const _WDFFUNCENUM_WdfDeviceInitSetExclusiveTableIndex : _WDFFUNCENUM = 62 ; pub const _WDFFUNCENUM_WdfDeviceInitSetPowerNotPageableTableIndex : _WDFFUNCENUM = 63 ; pub const _WDFFUNCENUM_WdfDeviceInitSetPowerPageableTableIndex : _WDFFUNCENUM = 64 ; pub const _WDFFUNCENUM_WdfDeviceInitSetPowerInrushTableIndex : _WDFFUNCENUM = 65 ; pub const _WDFFUNCENUM_WdfDeviceInitSetDeviceTypeTableIndex : _WDFFUNCENUM = 66 ; pub const _WDFFUNCENUM_WdfDeviceInitAssignNameTableIndex : _WDFFUNCENUM = 67 ; pub const _WDFFUNCENUM_WdfDeviceInitAssignSDDLStringTableIndex : _WDFFUNCENUM = 68 ; pub const _WDFFUNCENUM_WdfDeviceInitSetDeviceClassTableIndex : _WDFFUNCENUM = 69 ; pub const _WDFFUNCENUM_WdfDeviceInitSetCharacteristicsTableIndex : _WDFFUNCENUM = 70 ; pub const _WDFFUNCENUM_WdfDeviceInitSetFileObjectConfigTableIndex : _WDFFUNCENUM = 71 ; pub const _WDFFUNCENUM_WdfDeviceInitSetRequestAttributesTableIndex : _WDFFUNCENUM = 72 ; pub const _WDFFUNCENUM_WdfDeviceInitAssignWdmIrpPreprocessCallbackTableIndex : _WDFFUNCENUM = 73 ; pub const _WDFFUNCENUM_WdfDeviceInitSetIoInCallerContextCallbackTableIndex : _WDFFUNCENUM = 74 ; pub const _WDFFUNCENUM_WdfDeviceCreateTableIndex : _WDFFUNCENUM = 75 ; pub const _WDFFUNCENUM_WdfDeviceSetStaticStopRemoveTableIndex : _WDFFUNCENUM = 76 ; pub const _WDFFUNCENUM_WdfDeviceCreateDeviceInterfaceTableIndex : _WDFFUNCENUM = 77 ; pub const _WDFFUNCENUM_WdfDeviceSetDeviceInterfaceStateTableIndex : _WDFFUNCENUM = 78 ; pub const _WDFFUNCENUM_WdfDeviceRetrieveDeviceInterfaceStringTableIndex : _WDFFUNCENUM = 79 ; pub const _WDFFUNCENUM_WdfDeviceCreateSymbolicLinkTableIndex : _WDFFUNCENUM = 80 ; pub const _WDFFUNCENUM_WdfDeviceQueryPropertyTableIndex : _WDFFUNCENUM = 81 ; pub const _WDFFUNCENUM_WdfDeviceAllocAndQueryPropertyTableIndex : _WDFFUNCENUM = 82 ; pub const _WDFFUNCENUM_WdfDeviceSetPnpCapabilitiesTableIndex : _WDFFUNCENUM = 83 ; pub const _WDFFUNCENUM_WdfDeviceSetPowerCapabilitiesTableIndex : _WDFFUNCENUM = 84 ; pub const _WDFFUNCENUM_WdfDeviceSetBusInformationForChildrenTableIndex : _WDFFUNCENUM = 85 ; pub const _WDFFUNCENUM_WdfDeviceIndicateWakeStatusTableIndex : _WDFFUNCENUM = 86 ; pub const _WDFFUNCENUM_WdfDeviceSetFailedTableIndex : _WDFFUNCENUM = 87 ; pub const _WDFFUNCENUM_WdfDeviceStopIdleNoTrackTableIndex : _WDFFUNCENUM = 88 ; pub const _WDFFUNCENUM_WdfDeviceResumeIdleNoTrackTableIndex : _WDFFUNCENUM = 89 ; pub const _WDFFUNCENUM_WdfDeviceGetFileObjectTableIndex : _WDFFUNCENUM = 90 ; pub const _WDFFUNCENUM_WdfDeviceEnqueueRequestTableIndex : _WDFFUNCENUM = 91 ; pub const _WDFFUNCENUM_WdfDeviceGetDefaultQueueTableIndex : _WDFFUNCENUM = 92 ; pub const _WDFFUNCENUM_WdfDeviceConfigureRequestDispatchingTableIndex : _WDFFUNCENUM = 93 ; pub const _WDFFUNCENUM_WdfDmaEnablerCreateTableIndex : _WDFFUNCENUM = 94 ; pub const _WDFFUNCENUM_WdfDmaEnablerGetMaximumLengthTableIndex : _WDFFUNCENUM = 95 ; pub const _WDFFUNCENUM_WdfDmaEnablerGetMaximumScatterGatherElementsTableIndex : _WDFFUNCENUM = 96 ; pub const _WDFFUNCENUM_WdfDmaEnablerSetMaximumScatterGatherElementsTableIndex : _WDFFUNCENUM = 97 ; pub const _WDFFUNCENUM_WdfDmaTransactionCreateTableIndex : _WDFFUNCENUM = 98 ; pub const _WDFFUNCENUM_WdfDmaTransactionInitializeTableIndex : _WDFFUNCENUM = 99 ; pub const _WDFFUNCENUM_WdfDmaTransactionInitializeUsingRequestTableIndex : _WDFFUNCENUM = 100 ; pub const _WDFFUNCENUM_WdfDmaTransactionExecuteTableIndex : _WDFFUNCENUM = 101 ; pub const _WDFFUNCENUM_WdfDmaTransactionReleaseTableIndex : _WDFFUNCENUM = 102 ; pub const _WDFFUNCENUM_WdfDmaTransactionDmaCompletedTableIndex : _WDFFUNCENUM = 103 ; pub const _WDFFUNCENUM_WdfDmaTransactionDmaCompletedWithLengthTableIndex : _WDFFUNCENUM = 104 ; pub const _WDFFUNCENUM_WdfDmaTransactionDmaCompletedFinalTableIndex : _WDFFUNCENUM = 105 ; pub const _WDFFUNCENUM_WdfDmaTransactionGetBytesTransferredTableIndex : _WDFFUNCENUM = 106 ; pub const _WDFFUNCENUM_WdfDmaTransactionSetMaximumLengthTableIndex : _WDFFUNCENUM = 107 ; pub const _WDFFUNCENUM_WdfDmaTransactionGetRequestTableIndex : _WDFFUNCENUM = 108 ; pub const _WDFFUNCENUM_WdfDmaTransactionGetCurrentDmaTransferLengthTableIndex : _WDFFUNCENUM = 109 ; pub const _WDFFUNCENUM_WdfDmaTransactionGetDeviceTableIndex : _WDFFUNCENUM = 110 ; pub const _WDFFUNCENUM_WdfDpcCreateTableIndex : _WDFFUNCENUM = 111 ; pub const _WDFFUNCENUM_WdfDpcEnqueueTableIndex : _WDFFUNCENUM = 112 ; pub const _WDFFUNCENUM_WdfDpcCancelTableIndex : _WDFFUNCENUM = 113 ; pub const _WDFFUNCENUM_WdfDpcGetParentObjectTableIndex : _WDFFUNCENUM = 114 ; pub const _WDFFUNCENUM_WdfDpcWdmGetDpcTableIndex : _WDFFUNCENUM = 115 ; pub const _WDFFUNCENUM_WdfDriverCreateTableIndex : _WDFFUNCENUM = 116 ; pub const _WDFFUNCENUM_WdfDriverGetRegistryPathTableIndex : _WDFFUNCENUM = 117 ; pub const _WDFFUNCENUM_WdfDriverWdmGetDriverObjectTableIndex : _WDFFUNCENUM = 118 ; pub const _WDFFUNCENUM_WdfDriverOpenParametersRegistryKeyTableIndex : _WDFFUNCENUM = 119 ; pub const _WDFFUNCENUM_WdfWdmDriverGetWdfDriverHandleTableIndex : _WDFFUNCENUM = 120 ; pub const _WDFFUNCENUM_WdfDriverRegisterTraceInfoTableIndex : _WDFFUNCENUM = 121 ; pub const _WDFFUNCENUM_WdfDriverRetrieveVersionStringTableIndex : _WDFFUNCENUM = 122 ; pub const _WDFFUNCENUM_WdfDriverIsVersionAvailableTableIndex : _WDFFUNCENUM = 123 ; pub const _WDFFUNCENUM_WdfFdoInitWdmGetPhysicalDeviceTableIndex : _WDFFUNCENUM = 124 ; pub const _WDFFUNCENUM_WdfFdoInitOpenRegistryKeyTableIndex : _WDFFUNCENUM = 125 ; pub const _WDFFUNCENUM_WdfFdoInitQueryPropertyTableIndex : _WDFFUNCENUM = 126 ; pub const _WDFFUNCENUM_WdfFdoInitAllocAndQueryPropertyTableIndex : _WDFFUNCENUM = 127 ; pub const _WDFFUNCENUM_WdfFdoInitSetEventCallbacksTableIndex : _WDFFUNCENUM = 128 ; pub const _WDFFUNCENUM_WdfFdoInitSetFilterTableIndex : _WDFFUNCENUM = 129 ; pub const _WDFFUNCENUM_WdfFdoInitSetDefaultChildListConfigTableIndex : _WDFFUNCENUM = 130 ; pub const _WDFFUNCENUM_WdfFdoQueryForInterfaceTableIndex : _WDFFUNCENUM = 131 ; pub const _WDFFUNCENUM_WdfFdoGetDefaultChildListTableIndex : _WDFFUNCENUM = 132 ; pub const _WDFFUNCENUM_WdfFdoAddStaticChildTableIndex : _WDFFUNCENUM = 133 ; pub const _WDFFUNCENUM_WdfFdoLockStaticChildListForIterationTableIndex : _WDFFUNCENUM = 134 ; pub const _WDFFUNCENUM_WdfFdoRetrieveNextStaticChildTableIndex : _WDFFUNCENUM = 135 ; pub const _WDFFUNCENUM_WdfFdoUnlockStaticChildListFromIterationTableIndex : _WDFFUNCENUM = 136 ; pub const _WDFFUNCENUM_WdfFileObjectGetFileNameTableIndex : _WDFFUNCENUM = 137 ; pub const _WDFFUNCENUM_WdfFileObjectGetFlagsTableIndex : _WDFFUNCENUM = 138 ; pub const _WDFFUNCENUM_WdfFileObjectGetDeviceTableIndex : _WDFFUNCENUM = 139 ; pub const _WDFFUNCENUM_WdfFileObjectWdmGetFileObjectTableIndex : _WDFFUNCENUM = 140 ; pub const _WDFFUNCENUM_WdfInterruptCreateTableIndex : _WDFFUNCENUM = 141 ; pub const _WDFFUNCENUM_WdfInterruptQueueDpcForIsrTableIndex : _WDFFUNCENUM = 142 ; pub const _WDFFUNCENUM_WdfInterruptSynchronizeTableIndex : _WDFFUNCENUM = 143 ; pub const _WDFFUNCENUM_WdfInterruptAcquireLockTableIndex : _WDFFUNCENUM = 144 ; pub const _WDFFUNCENUM_WdfInterruptReleaseLockTableIndex : _WDFFUNCENUM = 145 ; pub const _WDFFUNCENUM_WdfInterruptEnableTableIndex : _WDFFUNCENUM = 146 ; pub const _WDFFUNCENUM_WdfInterruptDisableTableIndex : _WDFFUNCENUM = 147 ; pub const _WDFFUNCENUM_WdfInterruptWdmGetInterruptTableIndex : _WDFFUNCENUM = 148 ; pub const _WDFFUNCENUM_WdfInterruptGetInfoTableIndex : _WDFFUNCENUM = 149 ; pub const _WDFFUNCENUM_WdfInterruptSetPolicyTableIndex : _WDFFUNCENUM = 150 ; pub const _WDFFUNCENUM_WdfInterruptGetDeviceTableIndex : _WDFFUNCENUM = 151 ; pub const _WDFFUNCENUM_WdfIoQueueCreateTableIndex : _WDFFUNCENUM = 152 ; pub const _WDFFUNCENUM_WdfIoQueueGetStateTableIndex : _WDFFUNCENUM = 153 ; pub const _WDFFUNCENUM_WdfIoQueueStartTableIndex : _WDFFUNCENUM = 154 ; pub const _WDFFUNCENUM_WdfIoQueueStopTableIndex : _WDFFUNCENUM = 155 ; pub const _WDFFUNCENUM_WdfIoQueueStopSynchronouslyTableIndex : _WDFFUNCENUM = 156 ; pub const _WDFFUNCENUM_WdfIoQueueGetDeviceTableIndex : _WDFFUNCENUM = 157 ; pub const _WDFFUNCENUM_WdfIoQueueRetrieveNextRequestTableIndex : _WDFFUNCENUM = 158 ; pub const _WDFFUNCENUM_WdfIoQueueRetrieveRequestByFileObjectTableIndex : _WDFFUNCENUM = 159 ; pub const _WDFFUNCENUM_WdfIoQueueFindRequestTableIndex : _WDFFUNCENUM = 160 ; pub const _WDFFUNCENUM_WdfIoQueueRetrieveFoundRequestTableIndex : _WDFFUNCENUM = 161 ; pub const _WDFFUNCENUM_WdfIoQueueDrainSynchronouslyTableIndex : _WDFFUNCENUM = 162 ; pub const _WDFFUNCENUM_WdfIoQueueDrainTableIndex : _WDFFUNCENUM = 163 ; pub const _WDFFUNCENUM_WdfIoQueuePurgeSynchronouslyTableIndex : _WDFFUNCENUM = 164 ; pub const _WDFFUNCENUM_WdfIoQueuePurgeTableIndex : _WDFFUNCENUM = 165 ; pub const _WDFFUNCENUM_WdfIoQueueReadyNotifyTableIndex : _WDFFUNCENUM = 166 ; pub const _WDFFUNCENUM_WdfIoTargetCreateTableIndex : _WDFFUNCENUM = 167 ; pub const _WDFFUNCENUM_WdfIoTargetOpenTableIndex : _WDFFUNCENUM = 168 ; pub const _WDFFUNCENUM_WdfIoTargetCloseForQueryRemoveTableIndex : _WDFFUNCENUM = 169 ; pub const _WDFFUNCENUM_WdfIoTargetCloseTableIndex : _WDFFUNCENUM = 170 ; pub const _WDFFUNCENUM_WdfIoTargetStartTableIndex : _WDFFUNCENUM = 171 ; pub const _WDFFUNCENUM_WdfIoTargetStopTableIndex : _WDFFUNCENUM = 172 ; pub const _WDFFUNCENUM_WdfIoTargetGetStateTableIndex : _WDFFUNCENUM = 173 ; pub const _WDFFUNCENUM_WdfIoTargetGetDeviceTableIndex : _WDFFUNCENUM = 174 ; pub const _WDFFUNCENUM_WdfIoTargetQueryTargetPropertyTableIndex : _WDFFUNCENUM = 175 ; pub const _WDFFUNCENUM_WdfIoTargetAllocAndQueryTargetPropertyTableIndex : _WDFFUNCENUM = 176 ; pub const _WDFFUNCENUM_WdfIoTargetQueryForInterfaceTableIndex : _WDFFUNCENUM = 177 ; pub const _WDFFUNCENUM_WdfIoTargetWdmGetTargetDeviceObjectTableIndex : _WDFFUNCENUM = 178 ; pub const _WDFFUNCENUM_WdfIoTargetWdmGetTargetPhysicalDeviceTableIndex : _WDFFUNCENUM = 179 ; pub const _WDFFUNCENUM_WdfIoTargetWdmGetTargetFileObjectTableIndex : _WDFFUNCENUM = 180 ; pub const _WDFFUNCENUM_WdfIoTargetWdmGetTargetFileHandleTableIndex : _WDFFUNCENUM = 181 ; pub const _WDFFUNCENUM_WdfIoTargetSendReadSynchronouslyTableIndex : _WDFFUNCENUM = 182 ; pub const _WDFFUNCENUM_WdfIoTargetFormatRequestForReadTableIndex : _WDFFUNCENUM = 183 ; pub const _WDFFUNCENUM_WdfIoTargetSendWriteSynchronouslyTableIndex : _WDFFUNCENUM = 184 ; pub const _WDFFUNCENUM_WdfIoTargetFormatRequestForWriteTableIndex : _WDFFUNCENUM = 185 ; pub const _WDFFUNCENUM_WdfIoTargetSendIoctlSynchronouslyTableIndex : _WDFFUNCENUM = 186 ; pub const _WDFFUNCENUM_WdfIoTargetFormatRequestForIoctlTableIndex : _WDFFUNCENUM = 187 ; pub const _WDFFUNCENUM_WdfIoTargetSendInternalIoctlSynchronouslyTableIndex : _WDFFUNCENUM = 188 ; pub const _WDFFUNCENUM_WdfIoTargetFormatRequestForInternalIoctlTableIndex : _WDFFUNCENUM = 189 ; pub const _WDFFUNCENUM_WdfIoTargetSendInternalIoctlOthersSynchronouslyTableIndex : _WDFFUNCENUM = 190 ; pub const _WDFFUNCENUM_WdfIoTargetFormatRequestForInternalIoctlOthersTableIndex : _WDFFUNCENUM = 191 ; pub const _WDFFUNCENUM_WdfMemoryCreateTableIndex : _WDFFUNCENUM = 192 ; pub const _WDFFUNCENUM_WdfMemoryCreatePreallocatedTableIndex : _WDFFUNCENUM = 193 ; pub const _WDFFUNCENUM_WdfMemoryGetBufferTableIndex : _WDFFUNCENUM = 194 ; pub const _WDFFUNCENUM_WdfMemoryAssignBufferTableIndex : _WDFFUNCENUM = 195 ; pub const _WDFFUNCENUM_WdfMemoryCopyToBufferTableIndex : _WDFFUNCENUM = 196 ; pub const _WDFFUNCENUM_WdfMemoryCopyFromBufferTableIndex : _WDFFUNCENUM = 197 ; pub const _WDFFUNCENUM_WdfLookasideListCreateTableIndex : _WDFFUNCENUM = 198 ; pub const _WDFFUNCENUM_WdfMemoryCreateFromLookasideTableIndex : _WDFFUNCENUM = 199 ; pub const _WDFFUNCENUM_WdfDeviceMiniportCreateTableIndex : _WDFFUNCENUM = 200 ; pub const _WDFFUNCENUM_WdfDriverMiniportUnloadTableIndex : _WDFFUNCENUM = 201 ; pub const _WDFFUNCENUM_WdfObjectGetTypedContextWorkerTableIndex : _WDFFUNCENUM = 202 ; pub const _WDFFUNCENUM_WdfObjectAllocateContextTableIndex : _WDFFUNCENUM = 203 ; pub const _WDFFUNCENUM_WdfObjectContextGetObjectTableIndex : _WDFFUNCENUM = 204 ; pub const _WDFFUNCENUM_WdfObjectReferenceActualTableIndex : _WDFFUNCENUM = 205 ; pub const _WDFFUNCENUM_WdfObjectDereferenceActualTableIndex : _WDFFUNCENUM = 206 ; pub const _WDFFUNCENUM_WdfObjectCreateTableIndex : _WDFFUNCENUM = 207 ; pub const _WDFFUNCENUM_WdfObjectDeleteTableIndex : _WDFFUNCENUM = 208 ; pub const _WDFFUNCENUM_WdfObjectQueryTableIndex : _WDFFUNCENUM = 209 ; pub const _WDFFUNCENUM_WdfPdoInitAllocateTableIndex : _WDFFUNCENUM = 210 ; pub const _WDFFUNCENUM_WdfPdoInitSetEventCallbacksTableIndex : _WDFFUNCENUM = 211 ; pub const _WDFFUNCENUM_WdfPdoInitAssignDeviceIDTableIndex : _WDFFUNCENUM = 212 ; pub const _WDFFUNCENUM_WdfPdoInitAssignInstanceIDTableIndex : _WDFFUNCENUM = 213 ; pub const _WDFFUNCENUM_WdfPdoInitAddHardwareIDTableIndex : _WDFFUNCENUM = 214 ; pub const _WDFFUNCENUM_WdfPdoInitAddCompatibleIDTableIndex : _WDFFUNCENUM = 215 ; pub const _WDFFUNCENUM_WdfPdoInitAddDeviceTextTableIndex : _WDFFUNCENUM = 216 ; pub const _WDFFUNCENUM_WdfPdoInitSetDefaultLocaleTableIndex : _WDFFUNCENUM = 217 ; pub const _WDFFUNCENUM_WdfPdoInitAssignRawDeviceTableIndex : _WDFFUNCENUM = 218 ; pub const _WDFFUNCENUM_WdfPdoMarkMissingTableIndex : _WDFFUNCENUM = 219 ; pub const _WDFFUNCENUM_WdfPdoRequestEjectTableIndex : _WDFFUNCENUM = 220 ; pub const _WDFFUNCENUM_WdfPdoGetParentTableIndex : _WDFFUNCENUM = 221 ; pub const _WDFFUNCENUM_WdfPdoRetrieveIdentificationDescriptionTableIndex : _WDFFUNCENUM = 222 ; pub const _WDFFUNCENUM_WdfPdoRetrieveAddressDescriptionTableIndex : _WDFFUNCENUM = 223 ; pub const _WDFFUNCENUM_WdfPdoUpdateAddressDescriptionTableIndex : _WDFFUNCENUM = 224 ; pub const _WDFFUNCENUM_WdfPdoAddEjectionRelationsPhysicalDeviceTableIndex : _WDFFUNCENUM = 225 ; pub const _WDFFUNCENUM_WdfPdoRemoveEjectionRelationsPhysicalDeviceTableIndex : _WDFFUNCENUM = 226 ; pub const _WDFFUNCENUM_WdfPdoClearEjectionRelationsDevicesTableIndex : _WDFFUNCENUM = 227 ; pub const _WDFFUNCENUM_WdfDeviceAddQueryInterfaceTableIndex : _WDFFUNCENUM = 228 ; pub const _WDFFUNCENUM_WdfRegistryOpenKeyTableIndex : _WDFFUNCENUM = 229 ; pub const _WDFFUNCENUM_WdfRegistryCreateKeyTableIndex : _WDFFUNCENUM = 230 ; pub const _WDFFUNCENUM_WdfRegistryCloseTableIndex : _WDFFUNCENUM = 231 ; pub const _WDFFUNCENUM_WdfRegistryWdmGetHandleTableIndex : _WDFFUNCENUM = 232 ; pub const _WDFFUNCENUM_WdfRegistryRemoveKeyTableIndex : _WDFFUNCENUM = 233 ; pub const _WDFFUNCENUM_WdfRegistryRemoveValueTableIndex : _WDFFUNCENUM = 234 ; pub const _WDFFUNCENUM_WdfRegistryQueryValueTableIndex : _WDFFUNCENUM = 235 ; pub const _WDFFUNCENUM_WdfRegistryQueryMemoryTableIndex : _WDFFUNCENUM = 236 ; pub const _WDFFUNCENUM_WdfRegistryQueryMultiStringTableIndex : _WDFFUNCENUM = 237 ; pub const _WDFFUNCENUM_WdfRegistryQueryUnicodeStringTableIndex : _WDFFUNCENUM = 238 ; pub const _WDFFUNCENUM_WdfRegistryQueryStringTableIndex : _WDFFUNCENUM = 239 ; pub const _WDFFUNCENUM_WdfRegistryQueryULongTableIndex : _WDFFUNCENUM = 240 ; pub const _WDFFUNCENUM_WdfRegistryAssignValueTableIndex : _WDFFUNCENUM = 241 ; pub const _WDFFUNCENUM_WdfRegistryAssignMemoryTableIndex : _WDFFUNCENUM = 242 ; pub const _WDFFUNCENUM_WdfRegistryAssignMultiStringTableIndex : _WDFFUNCENUM = 243 ; pub const _WDFFUNCENUM_WdfRegistryAssignUnicodeStringTableIndex : _WDFFUNCENUM = 244 ; pub const _WDFFUNCENUM_WdfRegistryAssignStringTableIndex : _WDFFUNCENUM = 245 ; pub const _WDFFUNCENUM_WdfRegistryAssignULongTableIndex : _WDFFUNCENUM = 246 ; pub const _WDFFUNCENUM_WdfRequestCreateTableIndex : _WDFFUNCENUM = 247 ; pub const _WDFFUNCENUM_WdfRequestCreateFromIrpTableIndex : _WDFFUNCENUM = 248 ; pub const _WDFFUNCENUM_WdfRequestReuseTableIndex : _WDFFUNCENUM = 249 ; pub const _WDFFUNCENUM_WdfRequestChangeTargetTableIndex : _WDFFUNCENUM = 250 ; pub const _WDFFUNCENUM_WdfRequestFormatRequestUsingCurrentTypeTableIndex : _WDFFUNCENUM = 251 ; pub const _WDFFUNCENUM_WdfRequestWdmFormatUsingStackLocationTableIndex : _WDFFUNCENUM = 252 ; pub const _WDFFUNCENUM_WdfRequestSendTableIndex : _WDFFUNCENUM = 253 ; pub const _WDFFUNCENUM_WdfRequestGetStatusTableIndex : _WDFFUNCENUM = 254 ; pub const _WDFFUNCENUM_WdfRequestMarkCancelableTableIndex : _WDFFUNCENUM = 255 ; pub const _WDFFUNCENUM_WdfRequestUnmarkCancelableTableIndex : _WDFFUNCENUM = 256 ; pub const _WDFFUNCENUM_WdfRequestIsCanceledTableIndex : _WDFFUNCENUM = 257 ; pub const _WDFFUNCENUM_WdfRequestCancelSentRequestTableIndex : _WDFFUNCENUM = 258 ; pub const _WDFFUNCENUM_WdfRequestIsFrom32BitProcessTableIndex : _WDFFUNCENUM = 259 ; pub const _WDFFUNCENUM_WdfRequestSetCompletionRoutineTableIndex : _WDFFUNCENUM = 260 ; pub const _WDFFUNCENUM_WdfRequestGetCompletionParamsTableIndex : _WDFFUNCENUM = 261 ; pub const _WDFFUNCENUM_WdfRequestAllocateTimerTableIndex : _WDFFUNCENUM = 262 ; pub const _WDFFUNCENUM_WdfRequestCompleteTableIndex : _WDFFUNCENUM = 263 ; pub const _WDFFUNCENUM_WdfRequestCompleteWithPriorityBoostTableIndex : _WDFFUNCENUM = 264 ; pub const _WDFFUNCENUM_WdfRequestCompleteWithInformationTableIndex : _WDFFUNCENUM = 265 ; pub const _WDFFUNCENUM_WdfRequestGetParametersTableIndex : _WDFFUNCENUM = 266 ; pub const _WDFFUNCENUM_WdfRequestRetrieveInputMemoryTableIndex : _WDFFUNCENUM = 267 ; pub const _WDFFUNCENUM_WdfRequestRetrieveOutputMemoryTableIndex : _WDFFUNCENUM = 268 ; pub const _WDFFUNCENUM_WdfRequestRetrieveInputBufferTableIndex : _WDFFUNCENUM = 269 ; pub const _WDFFUNCENUM_WdfRequestRetrieveOutputBufferTableIndex : _WDFFUNCENUM = 270 ; pub const _WDFFUNCENUM_WdfRequestRetrieveInputWdmMdlTableIndex : _WDFFUNCENUM = 271 ; pub const _WDFFUNCENUM_WdfRequestRetrieveOutputWdmMdlTableIndex : _WDFFUNCENUM = 272 ; pub const _WDFFUNCENUM_WdfRequestRetrieveUnsafeUserInputBufferTableIndex : _WDFFUNCENUM = 273 ; pub const _WDFFUNCENUM_WdfRequestRetrieveUnsafeUserOutputBufferTableIndex : _WDFFUNCENUM = 274 ; pub const _WDFFUNCENUM_WdfRequestSetInformationTableIndex : _WDFFUNCENUM = 275 ; pub const _WDFFUNCENUM_WdfRequestGetInformationTableIndex : _WDFFUNCENUM = 276 ; pub const _WDFFUNCENUM_WdfRequestGetFileObjectTableIndex : _WDFFUNCENUM = 277 ; pub const _WDFFUNCENUM_WdfRequestProbeAndLockUserBufferForReadTableIndex : _WDFFUNCENUM = 278 ; pub const _WDFFUNCENUM_WdfRequestProbeAndLockUserBufferForWriteTableIndex : _WDFFUNCENUM = 279 ; pub const _WDFFUNCENUM_WdfRequestGetRequestorModeTableIndex : _WDFFUNCENUM = 280 ; pub const _WDFFUNCENUM_WdfRequestForwardToIoQueueTableIndex : _WDFFUNCENUM = 281 ; pub const _WDFFUNCENUM_WdfRequestGetIoQueueTableIndex : _WDFFUNCENUM = 282 ; pub const _WDFFUNCENUM_WdfRequestRequeueTableIndex : _WDFFUNCENUM = 283 ; pub const _WDFFUNCENUM_WdfRequestStopAcknowledgeTableIndex : _WDFFUNCENUM = 284 ; pub const _WDFFUNCENUM_WdfRequestWdmGetIrpTableIndex : _WDFFUNCENUM = 285 ; pub const _WDFFUNCENUM_WdfIoResourceRequirementsListSetSlotNumberTableIndex : _WDFFUNCENUM = 286 ; pub const _WDFFUNCENUM_WdfIoResourceRequirementsListSetInterfaceTypeTableIndex : _WDFFUNCENUM = 287 ; pub const _WDFFUNCENUM_WdfIoResourceRequirementsListAppendIoResListTableIndex : _WDFFUNCENUM = 288 ; pub const _WDFFUNCENUM_WdfIoResourceRequirementsListInsertIoResListTableIndex : _WDFFUNCENUM = 289 ; pub const _WDFFUNCENUM_WdfIoResourceRequirementsListGetCountTableIndex : _WDFFUNCENUM = 290 ; pub const _WDFFUNCENUM_WdfIoResourceRequirementsListGetIoResListTableIndex : _WDFFUNCENUM = 291 ; pub const _WDFFUNCENUM_WdfIoResourceRequirementsListRemoveTableIndex : _WDFFUNCENUM = 292 ; pub const _WDFFUNCENUM_WdfIoResourceRequirementsListRemoveByIoResListTableIndex : _WDFFUNCENUM = 293 ; pub const _WDFFUNCENUM_WdfIoResourceListCreateTableIndex : _WDFFUNCENUM = 294 ; pub const _WDFFUNCENUM_WdfIoResourceListAppendDescriptorTableIndex : _WDFFUNCENUM = 295 ; pub const _WDFFUNCENUM_WdfIoResourceListInsertDescriptorTableIndex : _WDFFUNCENUM = 296 ; pub const _WDFFUNCENUM_WdfIoResourceListUpdateDescriptorTableIndex : _WDFFUNCENUM = 297 ; pub const _WDFFUNCENUM_WdfIoResourceListGetCountTableIndex : _WDFFUNCENUM = 298 ; pub const _WDFFUNCENUM_WdfIoResourceListGetDescriptorTableIndex : _WDFFUNCENUM = 299 ; pub const _WDFFUNCENUM_WdfIoResourceListRemoveTableIndex : _WDFFUNCENUM = 300 ; pub const _WDFFUNCENUM_WdfIoResourceListRemoveByDescriptorTableIndex : _WDFFUNCENUM = 301 ; pub const _WDFFUNCENUM_WdfCmResourceListAppendDescriptorTableIndex : _WDFFUNCENUM = 302 ; pub const _WDFFUNCENUM_WdfCmResourceListInsertDescriptorTableIndex : _WDFFUNCENUM = 303 ; pub const _WDFFUNCENUM_WdfCmResourceListGetCountTableIndex : _WDFFUNCENUM = 304 ; pub const _WDFFUNCENUM_WdfCmResourceListGetDescriptorTableIndex : _WDFFUNCENUM = 305 ; pub const _WDFFUNCENUM_WdfCmResourceListRemoveTableIndex : _WDFFUNCENUM = 306 ; pub const _WDFFUNCENUM_WdfCmResourceListRemoveByDescriptorTableIndex : _WDFFUNCENUM = 307 ; pub const _WDFFUNCENUM_WdfStringCreateTableIndex : _WDFFUNCENUM = 308 ; pub const _WDFFUNCENUM_WdfStringGetUnicodeStringTableIndex : _WDFFUNCENUM = 309 ; pub const _WDFFUNCENUM_WdfObjectAcquireLockTableIndex : _WDFFUNCENUM = 310 ; pub const _WDFFUNCENUM_WdfObjectReleaseLockTableIndex : _WDFFUNCENUM = 311 ; pub const _WDFFUNCENUM_WdfWaitLockCreateTableIndex : _WDFFUNCENUM = 312 ; pub const _WDFFUNCENUM_WdfWaitLockAcquireTableIndex : _WDFFUNCENUM = 313 ; pub const _WDFFUNCENUM_WdfWaitLockReleaseTableIndex : _WDFFUNCENUM = 314 ; pub const _WDFFUNCENUM_WdfSpinLockCreateTableIndex : _WDFFUNCENUM = 315 ; pub const _WDFFUNCENUM_WdfSpinLockAcquireTableIndex : _WDFFUNCENUM = 316 ; pub const _WDFFUNCENUM_WdfSpinLockReleaseTableIndex : _WDFFUNCENUM = 317 ; pub const _WDFFUNCENUM_WdfTimerCreateTableIndex : _WDFFUNCENUM = 318 ; pub const _WDFFUNCENUM_WdfTimerStartTableIndex : _WDFFUNCENUM = 319 ; pub const _WDFFUNCENUM_WdfTimerStopTableIndex : _WDFFUNCENUM = 320 ; pub const _WDFFUNCENUM_WdfTimerGetParentObjectTableIndex : _WDFFUNCENUM = 321 ; pub const _WDFFUNCENUM_WdfUsbTargetDeviceCreateTableIndex : _WDFFUNCENUM = 322 ; pub const _WDFFUNCENUM_WdfUsbTargetDeviceRetrieveInformationTableIndex : _WDFFUNCENUM = 323 ; pub const _WDFFUNCENUM_WdfUsbTargetDeviceGetDeviceDescriptorTableIndex : _WDFFUNCENUM = 324 ; pub const _WDFFUNCENUM_WdfUsbTargetDeviceRetrieveConfigDescriptorTableIndex : _WDFFUNCENUM = 325 ; pub const _WDFFUNCENUM_WdfUsbTargetDeviceQueryStringTableIndex : _WDFFUNCENUM = 326 ; pub const _WDFFUNCENUM_WdfUsbTargetDeviceAllocAndQueryStringTableIndex : _WDFFUNCENUM = 327 ; pub const _WDFFUNCENUM_WdfUsbTargetDeviceFormatRequestForStringTableIndex : _WDFFUNCENUM = 328 ; pub const _WDFFUNCENUM_WdfUsbTargetDeviceGetNumInterfacesTableIndex : _WDFFUNCENUM = 329 ; pub const _WDFFUNCENUM_WdfUsbTargetDeviceSelectConfigTableIndex : _WDFFUNCENUM = 330 ; pub const _WDFFUNCENUM_WdfUsbTargetDeviceWdmGetConfigurationHandleTableIndex : _WDFFUNCENUM = 331 ; pub const _WDFFUNCENUM_WdfUsbTargetDeviceRetrieveCurrentFrameNumberTableIndex : _WDFFUNCENUM = 332 ; pub const _WDFFUNCENUM_WdfUsbTargetDeviceSendControlTransferSynchronouslyTableIndex : _WDFFUNCENUM = 333 ; pub const _WDFFUNCENUM_WdfUsbTargetDeviceFormatRequestForControlTransferTableIndex : _WDFFUNCENUM = 334 ; pub const _WDFFUNCENUM_WdfUsbTargetDeviceIsConnectedSynchronousTableIndex : _WDFFUNCENUM = 335 ; pub const _WDFFUNCENUM_WdfUsbTargetDeviceResetPortSynchronouslyTableIndex : _WDFFUNCENUM = 336 ; pub const _WDFFUNCENUM_WdfUsbTargetDeviceCyclePortSynchronouslyTableIndex : _WDFFUNCENUM = 337 ; pub const _WDFFUNCENUM_WdfUsbTargetDeviceFormatRequestForCyclePortTableIndex : _WDFFUNCENUM = 338 ; pub const _WDFFUNCENUM_WdfUsbTargetDeviceSendUrbSynchronouslyTableIndex : _WDFFUNCENUM = 339 ; pub const _WDFFUNCENUM_WdfUsbTargetDeviceFormatRequestForUrbTableIndex : _WDFFUNCENUM = 340 ; pub const _WDFFUNCENUM_WdfUsbTargetPipeGetInformationTableIndex : _WDFFUNCENUM = 341 ; pub const _WDFFUNCENUM_WdfUsbTargetPipeIsInEndpointTableIndex : _WDFFUNCENUM = 342 ; pub const _WDFFUNCENUM_WdfUsbTargetPipeIsOutEndpointTableIndex : _WDFFUNCENUM = 343 ; pub const _WDFFUNCENUM_WdfUsbTargetPipeGetTypeTableIndex : _WDFFUNCENUM = 344 ; pub const _WDFFUNCENUM_WdfUsbTargetPipeSetNoMaximumPacketSizeCheckTableIndex : _WDFFUNCENUM = 345 ; pub const _WDFFUNCENUM_WdfUsbTargetPipeWriteSynchronouslyTableIndex : _WDFFUNCENUM = 346 ; pub const _WDFFUNCENUM_WdfUsbTargetPipeFormatRequestForWriteTableIndex : _WDFFUNCENUM = 347 ; pub const _WDFFUNCENUM_WdfUsbTargetPipeReadSynchronouslyTableIndex : _WDFFUNCENUM = 348 ; pub const _WDFFUNCENUM_WdfUsbTargetPipeFormatRequestForReadTableIndex : _WDFFUNCENUM = 349 ; pub const _WDFFUNCENUM_WdfUsbTargetPipeConfigContinuousReaderTableIndex : _WDFFUNCENUM = 350 ; pub const _WDFFUNCENUM_WdfUsbTargetPipeAbortSynchronouslyTableIndex : _WDFFUNCENUM = 351 ; pub const _WDFFUNCENUM_WdfUsbTargetPipeFormatRequestForAbortTableIndex : _WDFFUNCENUM = 352 ; pub const _WDFFUNCENUM_WdfUsbTargetPipeResetSynchronouslyTableIndex : _WDFFUNCENUM = 353 ; pub const _WDFFUNCENUM_WdfUsbTargetPipeFormatRequestForResetTableIndex : _WDFFUNCENUM = 354 ; pub const _WDFFUNCENUM_WdfUsbTargetPipeSendUrbSynchronouslyTableIndex : _WDFFUNCENUM = 355 ; pub const _WDFFUNCENUM_WdfUsbTargetPipeFormatRequestForUrbTableIndex : _WDFFUNCENUM = 356 ; pub const _WDFFUNCENUM_WdfUsbInterfaceGetInterfaceNumberTableIndex : _WDFFUNCENUM = 357 ; pub const _WDFFUNCENUM_WdfUsbInterfaceGetNumEndpointsTableIndex : _WDFFUNCENUM = 358 ; pub const _WDFFUNCENUM_WdfUsbInterfaceGetDescriptorTableIndex : _WDFFUNCENUM = 359 ; pub const _WDFFUNCENUM_WdfUsbInterfaceSelectSettingTableIndex : _WDFFUNCENUM = 360 ; pub const _WDFFUNCENUM_WdfUsbInterfaceGetEndpointInformationTableIndex : _WDFFUNCENUM = 361 ; pub const _WDFFUNCENUM_WdfUsbTargetDeviceGetInterfaceTableIndex : _WDFFUNCENUM = 362 ; pub const _WDFFUNCENUM_WdfUsbInterfaceGetConfiguredSettingIndexTableIndex : _WDFFUNCENUM = 363 ; pub const _WDFFUNCENUM_WdfUsbInterfaceGetNumConfiguredPipesTableIndex : _WDFFUNCENUM = 364 ; pub const _WDFFUNCENUM_WdfUsbInterfaceGetConfiguredPipeTableIndex : _WDFFUNCENUM = 365 ; pub const _WDFFUNCENUM_WdfUsbTargetPipeWdmGetPipeHandleTableIndex : _WDFFUNCENUM = 366 ; pub const _WDFFUNCENUM_WdfVerifierDbgBreakPointTableIndex : _WDFFUNCENUM = 367 ; pub const _WDFFUNCENUM_WdfVerifierKeBugCheckTableIndex : _WDFFUNCENUM = 368 ; pub const _WDFFUNCENUM_WdfWmiProviderCreateTableIndex : _WDFFUNCENUM = 369 ; pub const _WDFFUNCENUM_WdfWmiProviderGetDeviceTableIndex : _WDFFUNCENUM = 370 ; pub const _WDFFUNCENUM_WdfWmiProviderIsEnabledTableIndex : _WDFFUNCENUM = 371 ; pub const _WDFFUNCENUM_WdfWmiProviderGetTracingHandleTableIndex : _WDFFUNCENUM = 372 ; pub const _WDFFUNCENUM_WdfWmiInstanceCreateTableIndex : _WDFFUNCENUM = 373 ; pub const _WDFFUNCENUM_WdfWmiInstanceRegisterTableIndex : _WDFFUNCENUM = 374 ; pub const _WDFFUNCENUM_WdfWmiInstanceDeregisterTableIndex : _WDFFUNCENUM = 375 ; pub const _WDFFUNCENUM_WdfWmiInstanceGetDeviceTableIndex : _WDFFUNCENUM = 376 ; pub const _WDFFUNCENUM_WdfWmiInstanceGetProviderTableIndex : _WDFFUNCENUM = 377 ; pub const _WDFFUNCENUM_WdfWmiInstanceFireEventTableIndex : _WDFFUNCENUM = 378 ; pub const _WDFFUNCENUM_WdfWorkItemCreateTableIndex : _WDFFUNCENUM = 379 ; pub const _WDFFUNCENUM_WdfWorkItemEnqueueTableIndex : _WDFFUNCENUM = 380 ; pub const _WDFFUNCENUM_WdfWorkItemGetParentObjectTableIndex : _WDFFUNCENUM = 381 ; pub const _WDFFUNCENUM_WdfWorkItemFlushTableIndex : _WDFFUNCENUM = 382 ; pub const _WDFFUNCENUM_WdfCommonBufferCreateWithConfigTableIndex : _WDFFUNCENUM = 383 ; pub const _WDFFUNCENUM_WdfDmaEnablerGetFragmentLengthTableIndex : _WDFFUNCENUM = 384 ; pub const _WDFFUNCENUM_WdfDmaEnablerWdmGetDmaAdapterTableIndex : _WDFFUNCENUM = 385 ; pub const _WDFFUNCENUM_WdfUsbInterfaceGetNumSettingsTableIndex : _WDFFUNCENUM = 386 ; pub const _WDFFUNCENUM_WdfDeviceRemoveDependentUsageDeviceObjectTableIndex : _WDFFUNCENUM = 387 ; pub const _WDFFUNCENUM_WdfDeviceGetSystemPowerActionTableIndex : _WDFFUNCENUM = 388 ; pub const _WDFFUNCENUM_WdfInterruptSetExtendedPolicyTableIndex : _WDFFUNCENUM = 389 ; pub const _WDFFUNCENUM_WdfIoQueueAssignForwardProgressPolicyTableIndex : _WDFFUNCENUM = 390 ; pub const _WDFFUNCENUM_WdfPdoInitAssignContainerIDTableIndex : _WDFFUNCENUM = 391 ; pub const _WDFFUNCENUM_WdfPdoInitAllowForwardingRequestToParentTableIndex : _WDFFUNCENUM = 392 ; pub const _WDFFUNCENUM_WdfRequestMarkCancelableExTableIndex : _WDFFUNCENUM = 393 ; pub const _WDFFUNCENUM_WdfRequestIsReservedTableIndex : _WDFFUNCENUM = 394 ; pub const _WDFFUNCENUM_WdfRequestForwardToParentDeviceIoQueueTableIndex : _WDFFUNCENUM = 395 ; pub const _WDFFUNCENUM_WdfCxDeviceInitAllocateTableIndex : _WDFFUNCENUM = 396 ; pub const _WDFFUNCENUM_WdfCxDeviceInitAssignWdmIrpPreprocessCallbackTableIndex : _WDFFUNCENUM = 397 ; pub const _WDFFUNCENUM_WdfCxDeviceInitSetIoInCallerContextCallbackTableIndex : _WDFFUNCENUM = 398 ; pub const _WDFFUNCENUM_WdfCxDeviceInitSetRequestAttributesTableIndex : _WDFFUNCENUM = 399 ; pub const _WDFFUNCENUM_WdfCxDeviceInitSetFileObjectConfigTableIndex : _WDFFUNCENUM = 400 ; pub const _WDFFUNCENUM_WdfDeviceWdmDispatchIrpTableIndex : _WDFFUNCENUM = 401 ; pub const _WDFFUNCENUM_WdfDeviceWdmDispatchIrpToIoQueueTableIndex : _WDFFUNCENUM = 402 ; pub const _WDFFUNCENUM_WdfDeviceInitSetRemoveLockOptionsTableIndex : _WDFFUNCENUM = 403 ; pub const _WDFFUNCENUM_WdfDeviceConfigureWdmIrpDispatchCallbackTableIndex : _WDFFUNCENUM = 404 ; pub const _WDFFUNCENUM_WdfDmaEnablerConfigureSystemProfileTableIndex : _WDFFUNCENUM = 405 ; pub const _WDFFUNCENUM_WdfDmaTransactionInitializeUsingOffsetTableIndex : _WDFFUNCENUM = 406 ; pub const _WDFFUNCENUM_WdfDmaTransactionGetTransferInfoTableIndex : _WDFFUNCENUM = 407 ; pub const _WDFFUNCENUM_WdfDmaTransactionSetChannelConfigurationCallbackTableIndex : _WDFFUNCENUM = 408 ; pub const _WDFFUNCENUM_WdfDmaTransactionSetTransferCompleteCallbackTableIndex : _WDFFUNCENUM = 409 ; pub const _WDFFUNCENUM_WdfDmaTransactionSetImmediateExecutionTableIndex : _WDFFUNCENUM = 410 ; pub const _WDFFUNCENUM_WdfDmaTransactionAllocateResourcesTableIndex : _WDFFUNCENUM = 411 ; pub const _WDFFUNCENUM_WdfDmaTransactionSetDeviceAddressOffsetTableIndex : _WDFFUNCENUM = 412 ; pub const _WDFFUNCENUM_WdfDmaTransactionFreeResourcesTableIndex : _WDFFUNCENUM = 413 ; pub const _WDFFUNCENUM_WdfDmaTransactionCancelTableIndex : _WDFFUNCENUM = 414 ; pub const _WDFFUNCENUM_WdfDmaTransactionWdmGetTransferContextTableIndex : _WDFFUNCENUM = 415 ; pub const _WDFFUNCENUM_WdfInterruptQueueWorkItemForIsrTableIndex : _WDFFUNCENUM = 416 ; pub const _WDFFUNCENUM_WdfInterruptTryToAcquireLockTableIndex : _WDFFUNCENUM = 417 ; pub const _WDFFUNCENUM_WdfIoQueueStopAndPurgeTableIndex : _WDFFUNCENUM = 418 ; pub const _WDFFUNCENUM_WdfIoQueueStopAndPurgeSynchronouslyTableIndex : _WDFFUNCENUM = 419 ; pub const _WDFFUNCENUM_WdfIoTargetPurgeTableIndex : _WDFFUNCENUM = 420 ; pub const _WDFFUNCENUM_WdfUsbTargetDeviceCreateWithParametersTableIndex : _WDFFUNCENUM = 421 ; pub const _WDFFUNCENUM_WdfUsbTargetDeviceQueryUsbCapabilityTableIndex : _WDFFUNCENUM = 422 ; pub const _WDFFUNCENUM_WdfUsbTargetDeviceCreateUrbTableIndex : _WDFFUNCENUM = 423 ; pub const _WDFFUNCENUM_WdfUsbTargetDeviceCreateIsochUrbTableIndex : _WDFFUNCENUM = 424 ; pub const _WDFFUNCENUM_WdfDeviceWdmAssignPowerFrameworkSettingsTableIndex : _WDFFUNCENUM = 425 ; pub const _WDFFUNCENUM_WdfDmaTransactionStopSystemTransferTableIndex : _WDFFUNCENUM = 426 ; pub const _WDFFUNCENUM_WdfCxVerifierKeBugCheckTableIndex : _WDFFUNCENUM = 427 ; pub const _WDFFUNCENUM_WdfInterruptReportActiveTableIndex : _WDFFUNCENUM = 428 ; pub const _WDFFUNCENUM_WdfInterruptReportInactiveTableIndex : _WDFFUNCENUM = 429 ; pub const _WDFFUNCENUM_WdfDeviceInitSetReleaseHardwareOrderOnFailureTableIndex : _WDFFUNCENUM = 430 ; pub const _WDFFUNCENUM_WdfGetTriageInfoTableIndex : _WDFFUNCENUM = 431 ; pub const _WDFFUNCENUM_WdfDeviceInitSetIoTypeExTableIndex : _WDFFUNCENUM = 432 ; pub const _WDFFUNCENUM_WdfDeviceQueryPropertyExTableIndex : _WDFFUNCENUM = 433 ; pub const _WDFFUNCENUM_WdfDeviceAllocAndQueryPropertyExTableIndex : _WDFFUNCENUM = 434 ; pub const _WDFFUNCENUM_WdfDeviceAssignPropertyTableIndex : _WDFFUNCENUM = 435 ; pub const _WDFFUNCENUM_WdfFdoInitQueryPropertyExTableIndex : _WDFFUNCENUM = 436 ; pub const _WDFFUNCENUM_WdfFdoInitAllocAndQueryPropertyExTableIndex : _WDFFUNCENUM = 437 ; pub const _WDFFUNCENUM_WdfDeviceStopIdleActualTableIndex : _WDFFUNCENUM = 438 ; pub const _WDFFUNCENUM_WdfDeviceResumeIdleActualTableIndex : _WDFFUNCENUM = 439 ; pub const _WDFFUNCENUM_WdfDeviceGetSelfIoTargetTableIndex : _WDFFUNCENUM = 440 ; pub const _WDFFUNCENUM_WdfDeviceInitAllowSelfIoTargetTableIndex : _WDFFUNCENUM = 441 ; pub const _WDFFUNCENUM_WdfIoTargetSelfAssignDefaultIoQueueTableIndex : _WDFFUNCENUM = 442 ; pub const _WDFFUNCENUM_WdfDeviceOpenDevicemapKeyTableIndex : _WDFFUNCENUM = 443 ; pub const _WDFFUNCENUM_WdfDmaTransactionSetSingleTransferRequirementTableIndex : _WDFFUNCENUM = 444 ; pub const _WDFFUNCENUM_WdfCxDeviceInitSetPnpPowerEventCallbacksTableIndex : _WDFFUNCENUM = 445 ; pub const _WDFFUNCENUM_WdfFileObjectGetInitiatorProcessIdTableIndex : _WDFFUNCENUM = 446 ; pub const _WDFFUNCENUM_WdfRequestGetRequestorProcessIdTableIndex : _WDFFUNCENUM = 447 ; pub const _WDFFUNCENUM_WdfDeviceRetrieveCompanionTargetTableIndex : _WDFFUNCENUM = 448 ; pub const _WDFFUNCENUM_WdfCompanionTargetSendTaskSynchronouslyTableIndex : _WDFFUNCENUM = 449 ; pub const _WDFFUNCENUM_WdfCompanionTargetWdmGetCompanionProcessTableIndex : _WDFFUNCENUM = 450 ; pub const _WDFFUNCENUM_WdfFunctionTableNumEntries : _WDFFUNCENUM = 451 ; pub type _WDFFUNCENUM = i32 ; pub use self :: _WDFFUNCENUM as WDFFUNCENUM ; pub type PFN_WDFVERIFIERDBGBREAKPOINT = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS ) > ; pub type PFN_WDFVERIFIERKEBUGCHECK = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , BugCheckCode : ULONG , BugCheckParameter1 : ULONG_PTR , BugCheckParameter2 : ULONG_PTR , BugCheckParameter3 : ULONG_PTR , BugCheckParameter4 : ULONG_PTR ) > ; pub type PFN_WDFGETTRIAGEINFO = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS ) -> PVOID > ; pub const _WDF_EXECUTION_LEVEL_WdfExecutionLevelInvalid : _WDF_EXECUTION_LEVEL = 0 ; pub const _WDF_EXECUTION_LEVEL_WdfExecutionLevelInheritFromParent : _WDF_EXECUTION_LEVEL = 1 ; pub const _WDF_EXECUTION_LEVEL_WdfExecutionLevelPassive : _WDF_EXECUTION_LEVEL = 2 ; pub const _WDF_EXECUTION_LEVEL_WdfExecutionLevelDispatch : _WDF_EXECUTION_LEVEL = 3 ; pub type _WDF_EXECUTION_LEVEL = i32 ; pub use self :: _WDF_EXECUTION_LEVEL as WDF_EXECUTION_LEVEL ; pub const _WDF_SYNCHRONIZATION_SCOPE_WdfSynchronizationScopeInvalid : _WDF_SYNCHRONIZATION_SCOPE = 0 ; pub const _WDF_SYNCHRONIZATION_SCOPE_WdfSynchronizationScopeInheritFromParent : _WDF_SYNCHRONIZATION_SCOPE = 1 ; pub const _WDF_SYNCHRONIZATION_SCOPE_WdfSynchronizationScopeDevice : _WDF_SYNCHRONIZATION_SCOPE = 2 ; pub const _WDF_SYNCHRONIZATION_SCOPE_WdfSynchronizationScopeQueue : _WDF_SYNCHRONIZATION_SCOPE = 3 ; pub const _WDF_SYNCHRONIZATION_SCOPE_WdfSynchronizationScopeNone : _WDF_SYNCHRONIZATION_SCOPE = 4 ; pub type _WDF_SYNCHRONIZATION_SCOPE = i32 ; pub use self :: _WDF_SYNCHRONIZATION_SCOPE as WDF_SYNCHRONIZATION_SCOPE ; pub type EVT_WDF_OBJECT_CONTEXT_CLEANUP = :: std :: option :: Option < unsafe extern "C" fn ( Object : WDFOBJECT ) > ; pub type PFN_WDF_OBJECT_CONTEXT_CLEANUP = EVT_WDF_OBJECT_CONTEXT_CLEANUP ; pub type EVT_WDF_OBJECT_CONTEXT_DESTROY = :: std :: option :: Option < unsafe extern "C" fn ( Object : WDFOBJECT ) > ; pub type PFN_WDF_OBJECT_CONTEXT_DESTROY = EVT_WDF_OBJECT_CONTEXT_DESTROY ; pub type PCWDF_OBJECT_CONTEXT_TYPE_INFO = * const _WDF_OBJECT_CONTEXT_TYPE_INFO ; # [ repr ( C ) ] pub struct _WDF_OBJECT_ATTRIBUTES { pub Size : ULONG , pub EvtCleanupCallback : PFN_WDF_OBJECT_CONTEXT_CLEANUP , pub EvtDestroyCallback : PFN_WDF_OBJECT_CONTEXT_DESTROY , pub ExecutionLevel : WDF_EXECUTION_LEVEL , pub SynchronizationScope : WDF_SYNCHRONIZATION_SCOPE , pub ParentObject : WDFOBJECT , pub ContextSizeOverride : usize , pub ContextTypeInfo : PCWDF_OBJECT_CONTEXT_TYPE_INFO , } pub type WDF_OBJECT_ATTRIBUTES = _WDF_OBJECT_ATTRIBUTES ; pub type PFN_GET_UNIQUE_CONTEXT_TYPE = :: std :: option :: Option < unsafe extern "C" fn ( ) -> PCWDF_OBJECT_CONTEXT_TYPE_INFO > ; # [ repr ( C ) ] pub struct _WDF_OBJECT_CONTEXT_TYPE_INFO { pub Size : ULONG , pub ContextName : LPCSTR , pub ContextSize : usize , pub UniqueType : PCWDF_OBJECT_CONTEXT_TYPE_INFO , pub EvtDriverGetUniqueContextType : PFN_GET_UNIQUE_CONTEXT_TYPE , } pub type WDF_OBJECT_CONTEXT_TYPE_INFO = _WDF_OBJECT_CONTEXT_TYPE_INFO ; pub type PWDF_OBJECT_CONTEXT_TYPE_INFO = * mut _WDF_OBJECT_CONTEXT_TYPE_INFO ; # [ repr ( C ) ] pub struct _WDF_CUSTOM_TYPE_CONTEXT { pub Size : ULONG , pub Data : ULONG_PTR , } pub type WDF_CUSTOM_TYPE_CONTEXT = _WDF_CUSTOM_TYPE_CONTEXT ; pub type PWDF_CUSTOM_TYPE_CONTEXT = * mut _WDF_CUSTOM_TYPE_CONTEXT ; pub type PFN_WDFOBJECTGETTYPEDCONTEXTWORKER = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Handle : WDFOBJECT , TypeInfo : PCWDF_OBJECT_CONTEXT_TYPE_INFO ) -> PVOID > ; pub type PFN_WDFOBJECTALLOCATECONTEXT = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Handle : WDFOBJECT , ContextAttributes : PWDF_OBJECT_ATTRIBUTES , Context : * mut PVOID ) -> NTSTATUS > ; pub type PFN_WDFOBJECTCONTEXTGETOBJECT = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , ContextPointer : PVOID ) -> WDFOBJECT > ; pub type PFN_WDFOBJECTREFERENCEACTUAL = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Handle : WDFOBJECT , Tag : PVOID , Line : LONG , File : PCCH ) > ; pub type PFN_WDFOBJECTDEREFERENCEACTUAL = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Handle : WDFOBJECT , Tag : PVOID , Line : LONG , File : PCCH ) > ; pub type PFN_WDFOBJECTCREATE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Attributes : PWDF_OBJECT_ATTRIBUTES , Object : * mut WDFOBJECT ) -> NTSTATUS > ; pub type PFN_WDFOBJECTDELETE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Object : WDFOBJECT ) > ; pub type PFN_WDFOBJECTQUERY = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Object : WDFOBJECT , Guid : * const GUID , QueryBufferLength : ULONG , QueryBuffer : PVOID ) -> NTSTATUS > ; pub type PFN_WDFOBJECTACQUIRELOCK = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Object : WDFOBJECT ) > ; pub type PFN_WDFOBJECTRELEASELOCK = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Object : WDFOBJECT ) > ; pub type PFN_WDFWAITLOCKCREATE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , LockAttributes : PWDF_OBJECT_ATTRIBUTES , Lock : * mut WDFWAITLOCK ) -> NTSTATUS > ; pub type PFN_WDFWAITLOCKACQUIRE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Lock : WDFWAITLOCK , Timeout : PLONGLONG ) -> NTSTATUS > ; pub type PFN_WDFWAITLOCKRELEASE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Lock : WDFWAITLOCK ) > ; pub type PFN_WDFSPINLOCKCREATE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , SpinLockAttributes : PWDF_OBJECT_ATTRIBUTES , SpinLock : * mut WDFSPINLOCK ) -> NTSTATUS > ; pub type PFN_WDFSPINLOCKACQUIRE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , SpinLock : WDFSPINLOCK ) > ; pub type PFN_WDFSPINLOCKRELEASE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , SpinLock : WDFSPINLOCK ) > ; pub const _WDF_DRIVER_INIT_FLAGS_WdfDriverInitNonPnpDriver : _WDF_DRIVER_INIT_FLAGS = 1 ; pub const _WDF_DRIVER_INIT_FLAGS_WdfDriverInitNoDispatchOverride : _WDF_DRIVER_INIT_FLAGS = 2 ; pub const _WDF_DRIVER_INIT_FLAGS_WdfVerifyOn : _WDF_DRIVER_INIT_FLAGS = 4 ; pub const _WDF_DRIVER_INIT_FLAGS_WdfVerifierOn : _WDF_DRIVER_INIT_FLAGS = 8 ; pub const _WDF_DRIVER_INIT_FLAGS_WdfDriverInitCompanion : _WDF_DRIVER_INIT_FLAGS = 16 ; pub type _WDF_DRIVER_INIT_FLAGS = i32 ; pub use self :: _WDF_DRIVER_INIT_FLAGS as WDF_DRIVER_INIT_FLAGS ; pub type EVT_WDF_DRIVER_DEVICE_ADD = :: std :: option :: Option < unsafe extern "C" fn ( Driver : WDFDRIVER , DeviceInit : PWDFDEVICE_INIT ) -> NTSTATUS > ; pub type PFN_WDF_DRIVER_DEVICE_ADD = EVT_WDF_DRIVER_DEVICE_ADD ; pub type EVT_WDF_DRIVER_UNLOAD = :: std :: option :: Option < unsafe extern "C" fn ( Driver : WDFDRIVER ) > ; pub type PFN_WDF_DRIVER_UNLOAD = EVT_WDF_DRIVER_UNLOAD ; pub type EVT_WDF_TRACE_CALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( minorFunction : UCHAR , dataPath : PVOID , bufferLength : ULONG , buffer : PVOID , context : PVOID , size : PULONG ) -> NTSTATUS > ; pub type PFN_WDF_TRACE_CALLBACK = EVT_WDF_TRACE_CALLBACK ; # [ repr ( C ) ] pub struct _WDF_DRIVER_CONFIG { pub Size : ULONG , pub EvtDriverDeviceAdd : PFN_WDF_DRIVER_DEVICE_ADD , pub EvtDriverUnload : PFN_WDF_DRIVER_UNLOAD , pub DriverInitFlags : ULONG , pub DriverPoolTag : ULONG , } pub type WDF_DRIVER_CONFIG = _WDF_DRIVER_CONFIG ; pub type PWDF_DRIVER_CONFIG = * mut _WDF_DRIVER_CONFIG ; # [ repr ( C ) ] pub struct _WDF_DRIVER_VERSION_AVAILABLE_PARAMS { pub Size : ULONG , pub MajorVersion : ULONG , pub MinorVersion : ULONG , } pub type WDF_DRIVER_VERSION_AVAILABLE_PARAMS = _WDF_DRIVER_VERSION_AVAILABLE_PARAMS ; pub type PWDF_DRIVER_VERSION_AVAILABLE_PARAMS = * mut _WDF_DRIVER_VERSION_AVAILABLE_PARAMS ; pub type PFN_WDFDRIVERCREATE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DriverObject : PDRIVER_OBJECT , RegistryPath : PCUNICODE_STRING , DriverAttributes : PWDF_OBJECT_ATTRIBUTES , DriverConfig : PWDF_DRIVER_CONFIG , Driver : * mut WDFDRIVER ) -> NTSTATUS > ; pub type PFN_WDFDRIVERGETREGISTRYPATH = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Driver : WDFDRIVER ) -> PWSTR > ; pub type PFN_WDFDRIVERWDMGETDRIVEROBJECT = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Driver : WDFDRIVER ) -> PDRIVER_OBJECT > ; pub type PFN_WDFDRIVEROPENPARAMETERSREGISTRYKEY = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Driver : WDFDRIVER , DesiredAccess : ACCESS_MASK , KeyAttributes : PWDF_OBJECT_ATTRIBUTES , Key : * mut WDFKEY ) -> NTSTATUS > ; pub type PFN_WDFWDMDRIVERGETWDFDRIVERHANDLE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DriverObject : PDRIVER_OBJECT ) -> WDFDRIVER > ; pub type PFN_WDFDRIVERREGISTERTRACEINFO = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DriverObject : PDRIVER_OBJECT , EvtTraceCallback : PFN_WDF_TRACE_CALLBACK , ControlBlock : PVOID ) -> NTSTATUS > ; pub type PFN_WDFDRIVERRETRIEVEVERSIONSTRING = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Driver : WDFDRIVER , String : WDFSTRING ) -> NTSTATUS > ; pub type PFN_WDFDRIVERISVERSIONAVAILABLE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Driver : WDFDRIVER , VersionAvailableParams : PWDF_DRIVER_VERSION_AVAILABLE_PARAMS ) -> BOOLEAN > ; pub type EVT_WDF_DEVICE_PROCESS_QUERY_INTERFACE_REQUEST = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE , InterfaceType : LPGUID , ExposedInterface : PINTERFACE , ExposedInterfaceSpecificData : PVOID ) -> NTSTATUS > ; pub type PFN_WDF_DEVICE_PROCESS_QUERY_INTERFACE_REQUEST = EVT_WDF_DEVICE_PROCESS_QUERY_INTERFACE_REQUEST ; # [ repr ( C ) ] pub struct _WDF_QUERY_INTERFACE_CONFIG { pub Size : ULONG , pub Interface : PINTERFACE , pub InterfaceType : * const GUID , pub SendQueryToParentStack : BOOLEAN , pub EvtDeviceProcessQueryInterfaceRequest : PFN_WDF_DEVICE_PROCESS_QUERY_INTERFACE_REQUEST , pub ImportInterface : BOOLEAN , } pub type WDF_QUERY_INTERFACE_CONFIG = _WDF_QUERY_INTERFACE_CONFIG ; pub type PWDF_QUERY_INTERFACE_CONFIG = * mut _WDF_QUERY_INTERFACE_CONFIG ; pub type PFN_WDFDEVICEADDQUERYINTERFACE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , InterfaceConfig : PWDF_QUERY_INTERFACE_CONFIG ) -> NTSTATUS > ; pub const _WDF_MEMORY_DESCRIPTOR_TYPE_WdfMemoryDescriptorTypeInvalid : _WDF_MEMORY_DESCRIPTOR_TYPE = 0 ; pub const _WDF_MEMORY_DESCRIPTOR_TYPE_WdfMemoryDescriptorTypeBuffer : _WDF_MEMORY_DESCRIPTOR_TYPE = 1 ; pub const _WDF_MEMORY_DESCRIPTOR_TYPE_WdfMemoryDescriptorTypeMdl : _WDF_MEMORY_DESCRIPTOR_TYPE = 2 ; pub const _WDF_MEMORY_DESCRIPTOR_TYPE_WdfMemoryDescriptorTypeHandle : _WDF_MEMORY_DESCRIPTOR_TYPE = 3 ; pub type _WDF_MEMORY_DESCRIPTOR_TYPE = i32 ; pub use self :: _WDF_MEMORY_DESCRIPTOR_TYPE as WDF_MEMORY_DESCRIPTOR_TYPE ; # [ repr ( C ) ] pub struct _WDFMEMORY_OFFSET { pub BufferOffset : usize , pub BufferLength : usize , } pub type WDFMEMORY_OFFSET = _WDFMEMORY_OFFSET ; pub type PWDFMEMORY_OFFSET = * mut _WDFMEMORY_OFFSET ; # [ repr ( C ) ] pub struct _WDF_MEMORY_DESCRIPTOR { pub Type : WDF_MEMORY_DESCRIPTOR_TYPE , pub u : _WDF_MEMORY_DESCRIPTOR__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _WDF_MEMORY_DESCRIPTOR__bindgen_ty_1 { pub BufferType : __BindgenUnionField < _WDF_MEMORY_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 > , pub MdlType : __BindgenUnionField < _WDF_MEMORY_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 > , pub HandleType : __BindgenUnionField < _WDF_MEMORY_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3 > , pub bindgen_union_field : [ u64 ; 2usize ] , } # [ repr ( C ) ] pub struct _WDF_MEMORY_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 { pub Buffer : PVOID , pub Length : ULONG , } # [ repr ( C ) ] pub struct _WDF_MEMORY_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 { pub Mdl : PMDL , pub BufferLength : ULONG , } # [ repr ( C ) ] pub struct _WDF_MEMORY_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3 { pub Memory : WDFMEMORY , pub Offsets : PWDFMEMORY_OFFSET , } pub type WDF_MEMORY_DESCRIPTOR = _WDF_MEMORY_DESCRIPTOR ; pub type PWDF_MEMORY_DESCRIPTOR = * mut _WDF_MEMORY_DESCRIPTOR ; pub type PFN_WDFMEMORYCREATE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Attributes : PWDF_OBJECT_ATTRIBUTES , PoolType : POOL_TYPE , PoolTag : ULONG , BufferSize : usize , Memory : * mut WDFMEMORY , Buffer : * mut PVOID ) -> NTSTATUS > ; pub type PFN_WDFMEMORYCREATEPREALLOCATED = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Attributes : PWDF_OBJECT_ATTRIBUTES , Buffer : PVOID , BufferSize : usize , Memory : * mut WDFMEMORY ) -> NTSTATUS > ; pub type PFN_WDFMEMORYGETBUFFER = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Memory : WDFMEMORY , BufferSize : * mut usize ) -> PVOID > ; pub type PFN_WDFMEMORYASSIGNBUFFER = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Memory : WDFMEMORY , Buffer : PVOID , BufferSize : usize ) -> NTSTATUS > ; pub type PFN_WDFMEMORYCOPYTOBUFFER = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , SourceMemory : WDFMEMORY , SourceOffset : usize , Buffer : PVOID , NumBytesToCopyTo : usize ) -> NTSTATUS > ; pub type PFN_WDFMEMORYCOPYFROMBUFFER = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DestinationMemory : WDFMEMORY , DestinationOffset : usize , Buffer : PVOID , NumBytesToCopyFrom : usize ) -> NTSTATUS > ; pub type PFN_WDFLOOKASIDELISTCREATE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , LookasideAttributes : PWDF_OBJECT_ATTRIBUTES , BufferSize : usize , PoolType : POOL_TYPE , MemoryAttributes : PWDF_OBJECT_ATTRIBUTES , PoolTag : ULONG , Lookaside : * mut WDFLOOKASIDE ) -> NTSTATUS > ; pub type PFN_WDFMEMORYCREATEFROMLOOKASIDE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Lookaside : WDFLOOKASIDE , Memory : * mut WDFMEMORY ) -> NTSTATUS > ; pub const _WDF_CHILD_LIST_RETRIEVE_DEVICE_STATUS_WdfChildListRetrieveDeviceUndefined : _WDF_CHILD_LIST_RETRIEVE_DEVICE_STATUS = 0 ; pub const _WDF_CHILD_LIST_RETRIEVE_DEVICE_STATUS_WdfChildListRetrieveDeviceSuccess : _WDF_CHILD_LIST_RETRIEVE_DEVICE_STATUS = 1 ; pub const _WDF_CHILD_LIST_RETRIEVE_DEVICE_STATUS_WdfChildListRetrieveDeviceNotYetCreated : _WDF_CHILD_LIST_RETRIEVE_DEVICE_STATUS = 2 ; pub const _WDF_CHILD_LIST_RETRIEVE_DEVICE_STATUS_WdfChildListRetrieveDeviceNoSuchDevice : _WDF_CHILD_LIST_RETRIEVE_DEVICE_STATUS = 3 ; pub type _WDF_CHILD_LIST_RETRIEVE_DEVICE_STATUS = i32 ; pub use self :: _WDF_CHILD_LIST_RETRIEVE_DEVICE_STATUS as WDF_CHILD_LIST_RETRIEVE_DEVICE_STATUS ; pub type PWDF_CHILD_LIST_RETRIEVE_DEVICE_STATUS = * mut _WDF_CHILD_LIST_RETRIEVE_DEVICE_STATUS ; pub const _WDF_RETRIEVE_CHILD_FLAGS_WdfRetrieveUnspecified : _WDF_RETRIEVE_CHILD_FLAGS = 0 ; pub const _WDF_RETRIEVE_CHILD_FLAGS_WdfRetrievePresentChildren : _WDF_RETRIEVE_CHILD_FLAGS = 1 ; pub const _WDF_RETRIEVE_CHILD_FLAGS_WdfRetrieveMissingChildren : _WDF_RETRIEVE_CHILD_FLAGS = 2 ; pub const _WDF_RETRIEVE_CHILD_FLAGS_WdfRetrievePendingChildren : _WDF_RETRIEVE_CHILD_FLAGS = 4 ; pub const _WDF_RETRIEVE_CHILD_FLAGS_WdfRetrieveAddedChildren : _WDF_RETRIEVE_CHILD_FLAGS = 5 ; pub const _WDF_RETRIEVE_CHILD_FLAGS_WdfRetrieveAllChildren : _WDF_RETRIEVE_CHILD_FLAGS = 7 ; pub type _WDF_RETRIEVE_CHILD_FLAGS = i32 ; pub use self :: _WDF_RETRIEVE_CHILD_FLAGS as WDF_RETRIEVE_CHILD_FLAGS ; # [ repr ( C ) ] pub struct _WDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER { pub IdentificationDescriptionSize : ULONG , } pub type WDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER = _WDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER ; pub type PWDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER = * mut _WDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER ; # [ repr ( C ) ] pub struct _WDF_CHILD_ADDRESS_DESCRIPTION_HEADER { pub AddressDescriptionSize : ULONG , } pub type WDF_CHILD_ADDRESS_DESCRIPTION_HEADER = _WDF_CHILD_ADDRESS_DESCRIPTION_HEADER ; pub type PWDF_CHILD_ADDRESS_DESCRIPTION_HEADER = * mut _WDF_CHILD_ADDRESS_DESCRIPTION_HEADER ; pub type EVT_WDF_CHILD_LIST_CREATE_DEVICE = :: std :: option :: Option < unsafe extern "C" fn ( ChildList : WDFCHILDLIST , IdentificationDescription : PWDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER , ChildInit : PWDFDEVICE_INIT ) -> NTSTATUS > ; pub type PFN_WDF_CHILD_LIST_CREATE_DEVICE = EVT_WDF_CHILD_LIST_CREATE_DEVICE ; pub type EVT_WDF_CHILD_LIST_SCAN_FOR_CHILDREN = :: std :: option :: Option < unsafe extern "C" fn ( ChildList : WDFCHILDLIST ) > ; pub type PFN_WDF_CHILD_LIST_SCAN_FOR_CHILDREN = EVT_WDF_CHILD_LIST_SCAN_FOR_CHILDREN ; pub type EVT_WDF_CHILD_LIST_IDENTIFICATION_DESCRIPTION_COPY = :: std :: option :: Option < unsafe extern "C" fn ( ChildList : WDFCHILDLIST , SourceIdentificationDescription : PWDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER , DestinationIdentificationDescription : PWDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER ) > ; pub type PFN_WDF_CHILD_LIST_IDENTIFICATION_DESCRIPTION_COPY = EVT_WDF_CHILD_LIST_IDENTIFICATION_DESCRIPTION_COPY ; pub type EVT_WDF_CHILD_LIST_IDENTIFICATION_DESCRIPTION_DUPLICATE = :: std :: option :: Option < unsafe extern "C" fn ( ChildList : WDFCHILDLIST , SourceIdentificationDescription : PWDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER , DestinationIdentificationDescription : PWDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER ) -> NTSTATUS > ; pub type PFN_WDF_CHILD_LIST_IDENTIFICATION_DESCRIPTION_DUPLICATE = EVT_WDF_CHILD_LIST_IDENTIFICATION_DESCRIPTION_DUPLICATE ; pub type EVT_WDF_CHILD_LIST_IDENTIFICATION_DESCRIPTION_COMPARE = :: std :: option :: Option < unsafe extern "C" fn ( ChildList : WDFCHILDLIST , FirstIdentificationDescription : PWDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER , SecondIdentificationDescription : PWDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER ) -> BOOLEAN > ; pub type PFN_WDF_CHILD_LIST_IDENTIFICATION_DESCRIPTION_COMPARE = EVT_WDF_CHILD_LIST_IDENTIFICATION_DESCRIPTION_COMPARE ; pub type EVT_WDF_CHILD_LIST_IDENTIFICATION_DESCRIPTION_CLEANUP = :: std :: option :: Option < unsafe extern "C" fn ( ChildList : WDFCHILDLIST , IdentificationDescription : PWDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER ) > ; pub type PFN_WDF_CHILD_LIST_IDENTIFICATION_DESCRIPTION_CLEANUP = EVT_WDF_CHILD_LIST_IDENTIFICATION_DESCRIPTION_CLEANUP ; pub type EVT_WDF_CHILD_LIST_ADDRESS_DESCRIPTION_COPY = :: std :: option :: Option < unsafe extern "C" fn ( ChildList : WDFCHILDLIST , SourceAddressDescription : PWDF_CHILD_ADDRESS_DESCRIPTION_HEADER , DestinationAddressDescription : PWDF_CHILD_ADDRESS_DESCRIPTION_HEADER ) > ; pub type PFN_WDF_CHILD_LIST_ADDRESS_DESCRIPTION_COPY = EVT_WDF_CHILD_LIST_ADDRESS_DESCRIPTION_COPY ; pub type EVT_WDF_CHILD_LIST_ADDRESS_DESCRIPTION_DUPLICATE = :: std :: option :: Option < unsafe extern "C" fn ( ChildList : WDFCHILDLIST , SourceAddressDescription : PWDF_CHILD_ADDRESS_DESCRIPTION_HEADER , DestinationAddressDescription : PWDF_CHILD_ADDRESS_DESCRIPTION_HEADER ) -> NTSTATUS > ; pub type PFN_WDF_CHILD_LIST_ADDRESS_DESCRIPTION_DUPLICATE = EVT_WDF_CHILD_LIST_ADDRESS_DESCRIPTION_DUPLICATE ; pub type EVT_WDF_CHILD_LIST_ADDRESS_DESCRIPTION_CLEANUP = :: std :: option :: Option < unsafe extern "C" fn ( ChildList : WDFCHILDLIST , AddressDescription : PWDF_CHILD_ADDRESS_DESCRIPTION_HEADER ) > ; pub type PFN_WDF_CHILD_LIST_ADDRESS_DESCRIPTION_CLEANUP = EVT_WDF_CHILD_LIST_ADDRESS_DESCRIPTION_CLEANUP ; pub type EVT_WDF_CHILD_LIST_DEVICE_REENUMERATED = :: std :: option :: Option < unsafe extern "C" fn ( ChildList : WDFCHILDLIST , OldDevice : WDFDEVICE , OldAddressDescription : PWDF_CHILD_ADDRESS_DESCRIPTION_HEADER , NewAddressDescription : PWDF_CHILD_ADDRESS_DESCRIPTION_HEADER ) -> BOOLEAN > ; pub type PFN_WDF_CHILD_LIST_DEVICE_REENUMERATED = EVT_WDF_CHILD_LIST_DEVICE_REENUMERATED ; # [ repr ( C ) ] pub struct _WDF_CHILD_RETRIEVE_INFO { pub Size : ULONG , pub IdentificationDescription : PWDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER , pub AddressDescription : PWDF_CHILD_ADDRESS_DESCRIPTION_HEADER , pub Status : WDF_CHILD_LIST_RETRIEVE_DEVICE_STATUS , pub EvtChildListIdentificationDescriptionCompare : PFN_WDF_CHILD_LIST_IDENTIFICATION_DESCRIPTION_COMPARE , } pub type WDF_CHILD_RETRIEVE_INFO = _WDF_CHILD_RETRIEVE_INFO ; pub type PWDF_CHILD_RETRIEVE_INFO = * mut _WDF_CHILD_RETRIEVE_INFO ; # [ repr ( C ) ] pub struct _WDF_CHILD_LIST_CONFIG { pub Size : ULONG , pub IdentificationDescriptionSize : ULONG , pub AddressDescriptionSize : ULONG , pub EvtChildListCreateDevice : PFN_WDF_CHILD_LIST_CREATE_DEVICE , pub EvtChildListScanForChildren : PFN_WDF_CHILD_LIST_SCAN_FOR_CHILDREN , pub EvtChildListIdentificationDescriptionCopy : PFN_WDF_CHILD_LIST_IDENTIFICATION_DESCRIPTION_COPY , pub EvtChildListIdentificationDescriptionDuplicate : PFN_WDF_CHILD_LIST_IDENTIFICATION_DESCRIPTION_DUPLICATE , pub EvtChildListIdentificationDescriptionCleanup : PFN_WDF_CHILD_LIST_IDENTIFICATION_DESCRIPTION_CLEANUP , pub EvtChildListIdentificationDescriptionCompare : PFN_WDF_CHILD_LIST_IDENTIFICATION_DESCRIPTION_COMPARE , pub EvtChildListAddressDescriptionCopy : PFN_WDF_CHILD_LIST_ADDRESS_DESCRIPTION_COPY , pub EvtChildListAddressDescriptionDuplicate : PFN_WDF_CHILD_LIST_ADDRESS_DESCRIPTION_DUPLICATE , pub EvtChildListAddressDescriptionCleanup : PFN_WDF_CHILD_LIST_ADDRESS_DESCRIPTION_CLEANUP , pub EvtChildListDeviceReenumerated : PFN_WDF_CHILD_LIST_DEVICE_REENUMERATED , } pub type WDF_CHILD_LIST_CONFIG = _WDF_CHILD_LIST_CONFIG ; pub type PWDF_CHILD_LIST_CONFIG = * mut _WDF_CHILD_LIST_CONFIG ; # [ repr ( C ) ] pub struct _WDF_CHILD_LIST_ITERATOR { pub Size : ULONG , pub Flags : ULONG , pub Reserved : [ PVOID ; 4usize ] , } pub type WDF_CHILD_LIST_ITERATOR = _WDF_CHILD_LIST_ITERATOR ; pub type PWDF_CHILD_LIST_ITERATOR = * mut _WDF_CHILD_LIST_ITERATOR ; pub type PFN_WDFCHILDLISTCREATE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , Config : PWDF_CHILD_LIST_CONFIG , ChildListAttributes : PWDF_OBJECT_ATTRIBUTES , ChildList : * mut WDFCHILDLIST ) -> NTSTATUS > ; pub type PFN_WDFCHILDLISTGETDEVICE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , ChildList : WDFCHILDLIST ) -> WDFDEVICE > ; pub type PFN_WDFCHILDLISTRETRIEVEPDO = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , ChildList : WDFCHILDLIST , RetrieveInfo : PWDF_CHILD_RETRIEVE_INFO ) -> WDFDEVICE > ; pub type PFN_WDFCHILDLISTRETRIEVEADDRESSDESCRIPTION = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , ChildList : WDFCHILDLIST , IdentificationDescription : PWDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER , AddressDescription : PWDF_CHILD_ADDRESS_DESCRIPTION_HEADER ) -> NTSTATUS > ; pub type PFN_WDFCHILDLISTBEGINSCAN = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , ChildList : WDFCHILDLIST ) > ; pub type PFN_WDFCHILDLISTENDSCAN = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , ChildList : WDFCHILDLIST ) > ; pub type PFN_WDFCHILDLISTBEGINITERATION = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , ChildList : WDFCHILDLIST , Iterator : PWDF_CHILD_LIST_ITERATOR ) > ; pub type PFN_WDFCHILDLISTRETRIEVENEXTDEVICE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , ChildList : WDFCHILDLIST , Iterator : PWDF_CHILD_LIST_ITERATOR , Device : * mut WDFDEVICE , Info : PWDF_CHILD_RETRIEVE_INFO ) -> NTSTATUS > ; pub type PFN_WDFCHILDLISTENDITERATION = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , ChildList : WDFCHILDLIST , Iterator : PWDF_CHILD_LIST_ITERATOR ) > ; pub type PFN_WDFCHILDLISTADDORUPDATECHILDDESCRIPTIONASPRESENT = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , ChildList : WDFCHILDLIST , IdentificationDescription : PWDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER , AddressDescription : PWDF_CHILD_ADDRESS_DESCRIPTION_HEADER ) -> NTSTATUS > ; pub type PFN_WDFCHILDLISTUPDATECHILDDESCRIPTIONASMISSING = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , ChildList : WDFCHILDLIST , IdentificationDescription : PWDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER ) -> NTSTATUS > ; pub type PFN_WDFCHILDLISTUPDATEALLCHILDDESCRIPTIONSASPRESENT = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , ChildList : WDFCHILDLIST ) > ; pub type PFN_WDFCHILDLISTREQUESTCHILDEJECT = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , ChildList : WDFCHILDLIST , IdentificationDescription : PWDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER ) -> BOOLEAN > ; pub type PFN_WDFFILEOBJECTGETFILENAME = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , FileObject : WDFFILEOBJECT ) -> PUNICODE_STRING > ; pub type PFN_WDFFILEOBJECTGETFLAGS = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , FileObject : WDFFILEOBJECT ) -> ULONG > ; pub type PFN_WDFFILEOBJECTGETDEVICE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , FileObject : WDFFILEOBJECT ) -> WDFDEVICE > ; pub type PFN_WDFFILEOBJECTGETINITIATORPROCESSID = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , FileObject : WDFFILEOBJECT ) -> ULONG > ; pub type PFN_WDFFILEOBJECTWDMGETFILEOBJECT = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , FileObject : WDFFILEOBJECT ) -> PFILE_OBJECT > ; pub const _WDF_DEVICE_STATE_FLAGS_WdfDevStateNP : _WDF_DEVICE_STATE_FLAGS = 32768 ; pub type _WDF_DEVICE_STATE_FLAGS = i32 ; pub use self :: _WDF_DEVICE_STATE_FLAGS as WDF_DEVICE_STATE_FLAGS ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpInvalid : _WDF_DEVICE_PNP_STATE = 0 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpObjectCreated : _WDF_DEVICE_PNP_STATE = 256 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpCheckForDevicePresence : _WDF_DEVICE_PNP_STATE = 257 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpEjectFailed : _WDF_DEVICE_PNP_STATE = 258 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpEjectHardware : _WDF_DEVICE_PNP_STATE = 259 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpEjectedWaitingForRemove : _WDF_DEVICE_PNP_STATE = 260 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpInit : _WDF_DEVICE_PNP_STATE = 261 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpInitStarting : _WDF_DEVICE_PNP_STATE = 262 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpInitSurpriseRemoved : _WDF_DEVICE_PNP_STATE = 263 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpHardwareAvailable : _WDF_DEVICE_PNP_STATE = 264 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpEnableInterfaces : _WDF_DEVICE_PNP_STATE = 265 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpHardwareAvailablePowerPolicyFailed : _WDF_DEVICE_PNP_STATE = 266 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpQueryRemoveAskDriver : _WDF_DEVICE_PNP_STATE = 267 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpQueryRemovePending : _WDF_DEVICE_PNP_STATE = 268 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpQueryRemoveStaticCheck : _WDF_DEVICE_PNP_STATE = 269 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpQueriedRemoving : _WDF_DEVICE_PNP_STATE = 270 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpQueryStopAskDriver : _WDF_DEVICE_PNP_STATE = 271 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpQueryStopPending : _WDF_DEVICE_PNP_STATE = 272 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpQueryStopStaticCheck : _WDF_DEVICE_PNP_STATE = 273 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpQueryCanceled : _WDF_DEVICE_PNP_STATE = 274 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpRemoved : _WDF_DEVICE_PNP_STATE = 275 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpPdoRemoved : _WDF_DEVICE_PNP_STATE = 276 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpRemovedPdoWait : _WDF_DEVICE_PNP_STATE = 277 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpRemovedPdoSurpriseRemoved : _WDF_DEVICE_PNP_STATE = 278 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpRemovingDisableInterfaces : _WDF_DEVICE_PNP_STATE = 279 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpRestarting : _WDF_DEVICE_PNP_STATE = 280 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpStarted : _WDF_DEVICE_PNP_STATE = 281 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpStartedCancelStop : _WDF_DEVICE_PNP_STATE = 282 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpStartedCancelRemove : _WDF_DEVICE_PNP_STATE = 283 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpStartedRemoving : _WDF_DEVICE_PNP_STATE = 284 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpStartingFromStopped : _WDF_DEVICE_PNP_STATE = 285 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpStopped : _WDF_DEVICE_PNP_STATE = 286 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpStoppedWaitForStartCompletion : _WDF_DEVICE_PNP_STATE = 287 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpStartedStopping : _WDF_DEVICE_PNP_STATE = 288 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpSurpriseRemove : _WDF_DEVICE_PNP_STATE = 289 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpInitQueryRemove : _WDF_DEVICE_PNP_STATE = 290 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpInitQueryRemoveCanceled : _WDF_DEVICE_PNP_STATE = 291 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpFdoRemoved : _WDF_DEVICE_PNP_STATE = 292 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpRemovedWaitForChildren : _WDF_DEVICE_PNP_STATE = 293 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpQueriedSurpriseRemove : _WDF_DEVICE_PNP_STATE = 294 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpSurpriseRemoveIoStarted : _WDF_DEVICE_PNP_STATE = 295 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpFailedPowerDown : _WDF_DEVICE_PNP_STATE = 296 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpFailedIoStarting : _WDF_DEVICE_PNP_STATE = 297 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpFailedOwnHardware : _WDF_DEVICE_PNP_STATE = 298 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpFailed : _WDF_DEVICE_PNP_STATE = 299 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpFailedSurpriseRemoved : _WDF_DEVICE_PNP_STATE = 300 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpFailedStarted : _WDF_DEVICE_PNP_STATE = 301 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpFailedWaitForRemove : _WDF_DEVICE_PNP_STATE = 302 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpFailedInit : _WDF_DEVICE_PNP_STATE = 303 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpPdoInitFailed : _WDF_DEVICE_PNP_STATE = 304 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpRestart : _WDF_DEVICE_PNP_STATE = 305 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpRestartReleaseHardware : _WDF_DEVICE_PNP_STATE = 306 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpRestartHardwareAvailable : _WDF_DEVICE_PNP_STATE = 307 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpPdoRestart : _WDF_DEVICE_PNP_STATE = 308 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpFinal : _WDF_DEVICE_PNP_STATE = 309 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpRemovedChildrenRemoved : _WDF_DEVICE_PNP_STATE = 310 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpQueryRemoveEnsureDeviceAwake : _WDF_DEVICE_PNP_STATE = 311 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpQueryStopEnsureDeviceAwake : _WDF_DEVICE_PNP_STATE = 312 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpFailedPowerPolicyRemoved : _WDF_DEVICE_PNP_STATE = 313 ; pub const _WDF_DEVICE_PNP_STATE_WdfDevStatePnpNull : _WDF_DEVICE_PNP_STATE = 314 ; pub type _WDF_DEVICE_PNP_STATE = i32 ; pub use self :: _WDF_DEVICE_PNP_STATE as WDF_DEVICE_PNP_STATE ; pub type PWDF_DEVICE_PNP_STATE = * mut _WDF_DEVICE_PNP_STATE ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerInvalid : _WDF_DEVICE_POWER_STATE = 0 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerObjectCreated : _WDF_DEVICE_POWER_STATE = 768 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerCheckDeviceType : _WDF_DEVICE_POWER_STATE = 769 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerCheckDeviceTypeNP : _WDF_DEVICE_POWER_STATE = 33538 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerCheckParentState : _WDF_DEVICE_POWER_STATE = 771 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerCheckParentStateNP : _WDF_DEVICE_POWER_STATE = 33540 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerEnablingWakeAtBus : _WDF_DEVICE_POWER_STATE = 773 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerEnablingWakeAtBusNP : _WDF_DEVICE_POWER_STATE = 33542 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerD0 : _WDF_DEVICE_POWER_STATE = 775 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerD0NP : _WDF_DEVICE_POWER_STATE = 33544 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerD0BusWakeOwner : _WDF_DEVICE_POWER_STATE = 777 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerD0BusWakeOwnerNP : _WDF_DEVICE_POWER_STATE = 33546 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerD0ArmedForWake : _WDF_DEVICE_POWER_STATE = 779 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerD0ArmedForWakeNP : _WDF_DEVICE_POWER_STATE = 33548 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerD0DisarmingWakeAtBus : _WDF_DEVICE_POWER_STATE = 781 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerD0DisarmingWakeAtBusNP : _WDF_DEVICE_POWER_STATE = 33550 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerD0Starting : _WDF_DEVICE_POWER_STATE = 783 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerD0StartingConnectInterrupt : _WDF_DEVICE_POWER_STATE = 784 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerD0StartingDmaEnable : _WDF_DEVICE_POWER_STATE = 785 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerD0StartingStartSelfManagedIo : _WDF_DEVICE_POWER_STATE = 786 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerDecideD0State : _WDF_DEVICE_POWER_STATE = 787 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerGotoD3Stopped : _WDF_DEVICE_POWER_STATE = 788 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerStopped : _WDF_DEVICE_POWER_STATE = 789 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerStartingCheckDeviceType : _WDF_DEVICE_POWER_STATE = 790 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerStartingChild : _WDF_DEVICE_POWER_STATE = 791 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerDxDisablingWakeAtBus : _WDF_DEVICE_POWER_STATE = 792 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerDxDisablingWakeAtBusNP : _WDF_DEVICE_POWER_STATE = 33561 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerGotoDx : _WDF_DEVICE_POWER_STATE = 794 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerGotoDxNP : _WDF_DEVICE_POWER_STATE = 33563 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerGotoDxIoStopped : _WDF_DEVICE_POWER_STATE = 796 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerGotoDxIoStoppedNP : _WDF_DEVICE_POWER_STATE = 33565 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerGotoDxNPFailed : _WDF_DEVICE_POWER_STATE = 33566 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerDx : _WDF_DEVICE_POWER_STATE = 799 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerDxNP : _WDF_DEVICE_POWER_STATE = 33568 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerGotoDxArmedForWake : _WDF_DEVICE_POWER_STATE = 801 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerGotoDxArmedForWakeNP : _WDF_DEVICE_POWER_STATE = 33570 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerGotoDxIoStoppedArmedForWake : _WDF_DEVICE_POWER_STATE = 803 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerGotoDxIoStoppedArmedForWakeNP : _WDF_DEVICE_POWER_STATE = 33572 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerDxArmedForWake : _WDF_DEVICE_POWER_STATE = 805 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerDxArmedForWakeNP : _WDF_DEVICE_POWER_STATE = 33574 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerCheckParentStateArmedForWake : _WDF_DEVICE_POWER_STATE = 807 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerCheckParentStateArmedForWakeNP : _WDF_DEVICE_POWER_STATE = 33576 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerWaitForParentArmedForWake : _WDF_DEVICE_POWER_STATE = 809 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerWaitForParentArmedForWakeNP : _WDF_DEVICE_POWER_STATE = 33578 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerStartSelfManagedIo : _WDF_DEVICE_POWER_STATE = 811 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerStartSelfManagedIoNP : _WDF_DEVICE_POWER_STATE = 33580 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerStartSelfManagedIoFailed : _WDF_DEVICE_POWER_STATE = 813 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerStartSelfManagedIoFailedNP : _WDF_DEVICE_POWER_STATE = 33582 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerWaitForParent : _WDF_DEVICE_POWER_STATE = 815 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerWaitForParentNP : _WDF_DEVICE_POWER_STATE = 33584 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerWakePending : _WDF_DEVICE_POWER_STATE = 817 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerWakePendingNP : _WDF_DEVICE_POWER_STATE = 33586 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerWaking : _WDF_DEVICE_POWER_STATE = 819 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerWakingNP : _WDF_DEVICE_POWER_STATE = 33588 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerWakingConnectInterrupt : _WDF_DEVICE_POWER_STATE = 821 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerWakingConnectInterruptNP : _WDF_DEVICE_POWER_STATE = 33590 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerWakingConnectInterruptFailed : _WDF_DEVICE_POWER_STATE = 823 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerWakingConnectInterruptFailedNP : _WDF_DEVICE_POWER_STATE = 33592 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerWakingDmaEnable : _WDF_DEVICE_POWER_STATE = 825 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerWakingDmaEnableNP : _WDF_DEVICE_POWER_STATE = 33594 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerWakingDmaEnableFailed : _WDF_DEVICE_POWER_STATE = 827 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerWakingDmaEnableFailedNP : _WDF_DEVICE_POWER_STATE = 33596 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerReportPowerUpFailedDerefParent : _WDF_DEVICE_POWER_STATE = 829 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerReportPowerUpFailed : _WDF_DEVICE_POWER_STATE = 830 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerPowerFailedPowerDown : _WDF_DEVICE_POWER_STATE = 831 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerReportPowerDownFailed : _WDF_DEVICE_POWER_STATE = 832 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerInitialConnectInterruptFailed : _WDF_DEVICE_POWER_STATE = 833 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerInitialDmaEnableFailed : _WDF_DEVICE_POWER_STATE = 834 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerInitialSelfManagedIoFailed : _WDF_DEVICE_POWER_STATE = 835 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerInitialPowerUpFailedDerefParent : _WDF_DEVICE_POWER_STATE = 836 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerInitialPowerUpFailed : _WDF_DEVICE_POWER_STATE = 837 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerDxStoppedDisarmWake : _WDF_DEVICE_POWER_STATE = 838 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerDxStoppedDisarmWakeNP : _WDF_DEVICE_POWER_STATE = 33607 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerGotoDxStoppedDisableInterruptNP : _WDF_DEVICE_POWER_STATE = 33608 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerGotoDxStopped : _WDF_DEVICE_POWER_STATE = 841 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerDxStopped : _WDF_DEVICE_POWER_STATE = 842 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerGotoStopped : _WDF_DEVICE_POWER_STATE = 843 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerStoppedCompleteDx : _WDF_DEVICE_POWER_STATE = 844 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerDxStoppedDecideDxState : _WDF_DEVICE_POWER_STATE = 845 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerDxStoppedArmForWake : _WDF_DEVICE_POWER_STATE = 846 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerDxStoppedArmForWakeNP : _WDF_DEVICE_POWER_STATE = 33615 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerFinalPowerDownFailed : _WDF_DEVICE_POWER_STATE = 848 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerFinal : _WDF_DEVICE_POWER_STATE = 849 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerGotoImplicitD3DisarmWakeAtBus : _WDF_DEVICE_POWER_STATE = 850 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerUpFailed : _WDF_DEVICE_POWER_STATE = 851 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerUpFailedDerefParent : _WDF_DEVICE_POWER_STATE = 852 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerGotoDxFailed : _WDF_DEVICE_POWER_STATE = 853 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerGotoDxStoppedDisableInterrupt : _WDF_DEVICE_POWER_STATE = 854 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerUpFailedNP : _WDF_DEVICE_POWER_STATE = 33623 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerUpFailedDerefParentNP : _WDF_DEVICE_POWER_STATE = 33624 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerNotifyingD0ExitToWakeInterrupts : _WDF_DEVICE_POWER_STATE = 857 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerNotifyingD0EntryToWakeInterrupts : _WDF_DEVICE_POWER_STATE = 858 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerNotifyingD0ExitToWakeInterruptsNP : _WDF_DEVICE_POWER_STATE = 33627 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerNotifyingD0EntryToWakeInterruptsNP : _WDF_DEVICE_POWER_STATE = 33628 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerInitialPowerUpFailedPowerDown : _WDF_DEVICE_POWER_STATE = 861 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerUpFailedPowerDown : _WDF_DEVICE_POWER_STATE = 862 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerUpFailedPowerDownNP : _WDF_DEVICE_POWER_STATE = 33631 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerInitialSelfManagedIoFailedStarted : _WDF_DEVICE_POWER_STATE = 864 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerStartSelfManagedIoFailedStarted : _WDF_DEVICE_POWER_STATE = 865 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerStartSelfManagedIoFailedStartedNP : _WDF_DEVICE_POWER_STATE = 33634 ; pub const _WDF_DEVICE_POWER_STATE_WdfDevStatePowerNull : _WDF_DEVICE_POWER_STATE = 867 ; pub type _WDF_DEVICE_POWER_STATE = i32 ; pub use self :: _WDF_DEVICE_POWER_STATE as WDF_DEVICE_POWER_STATE ; pub type PWDF_DEVICE_POWER_STATE = * mut _WDF_DEVICE_POWER_STATE ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolInvalid : _WDF_DEVICE_POWER_POLICY_STATE = 0 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolObjectCreated : _WDF_DEVICE_POWER_POLICY_STATE = 1280 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStarting : _WDF_DEVICE_POWER_POLICY_STATE = 1281 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStartingSucceeded : _WDF_DEVICE_POWER_POLICY_STATE = 1282 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStartingFailed : _WDF_DEVICE_POWER_POLICY_STATE = 1283 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStartingDecideS0Wake : _WDF_DEVICE_POWER_POLICY_STATE = 1284 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStartedIdleCapable : _WDF_DEVICE_POWER_POLICY_STATE = 1285 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolTimerExpiredNoWake : _WDF_DEVICE_POWER_POLICY_STATE = 1286 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolTimerExpiredNoWakeCompletePowerDown : _WDF_DEVICE_POWER_POLICY_STATE = 1287 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolWaitingUnarmed : _WDF_DEVICE_POWER_POLICY_STATE = 1288 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolWaitingUnarmedQueryIdle : _WDF_DEVICE_POWER_POLICY_STATE = 1289 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolS0NoWakePowerUp : _WDF_DEVICE_POWER_POLICY_STATE = 1290 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolS0NoWakeCompletePowerUp : _WDF_DEVICE_POWER_POLICY_STATE = 1291 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSystemSleepFromDeviceWaitingUnarmed : _WDF_DEVICE_POWER_POLICY_STATE = 1292 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSystemSleepNeedWake : _WDF_DEVICE_POWER_POLICY_STATE = 1293 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSystemSleepNeedWakeCompletePowerUp : _WDF_DEVICE_POWER_POLICY_STATE = 1294 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSystemSleepPowerRequestFailed : _WDF_DEVICE_POWER_POLICY_STATE = 1295 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolCheckPowerPageable : _WDF_DEVICE_POWER_POLICY_STATE = 1296 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSleepingWakeWakeArrived : _WDF_DEVICE_POWER_POLICY_STATE = 1297 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSleepingWakeRevertArmWake : _WDF_DEVICE_POWER_POLICY_STATE = 1298 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSystemAsleepWakeArmed : _WDF_DEVICE_POWER_POLICY_STATE = 1299 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSystemWakeDeviceWakeEnabled : _WDF_DEVICE_POWER_POLICY_STATE = 1300 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSystemWakeDeviceWakeEnabledWakeCanceled : _WDF_DEVICE_POWER_POLICY_STATE = 1301 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSystemWakeDeviceWakeDisarm : _WDF_DEVICE_POWER_POLICY_STATE = 1302 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSystemWakeDeviceWakeTriggered : _WDF_DEVICE_POWER_POLICY_STATE = 1303 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSystemWakeDeviceWakeTriggeredS0 : _WDF_DEVICE_POWER_POLICY_STATE = 1304 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSystemWakeDeviceWokeDisarm : _WDF_DEVICE_POWER_POLICY_STATE = 1305 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSleepingWakeWakeArrivedNP : _WDF_DEVICE_POWER_POLICY_STATE = 34074 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSleepingWakeRevertArmWakeNP : _WDF_DEVICE_POWER_POLICY_STATE = 34075 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSleepingWakePowerDownFailed : _WDF_DEVICE_POWER_POLICY_STATE = 1308 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSleepingWakePowerDownFailedWakeCanceled : _WDF_DEVICE_POWER_POLICY_STATE = 1309 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSystemAsleepWakeArmedNP : _WDF_DEVICE_POWER_POLICY_STATE = 34078 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSystemWakeDeviceWakeEnabledNP : _WDF_DEVICE_POWER_POLICY_STATE = 34079 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSystemWakeDeviceWakeEnabledWakeCanceledNP : _WDF_DEVICE_POWER_POLICY_STATE = 34080 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSystemWakeDeviceWakeDisarmNP : _WDF_DEVICE_POWER_POLICY_STATE = 34081 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSystemWakeDeviceWakeTriggeredNP : _WDF_DEVICE_POWER_POLICY_STATE = 34082 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSystemWakeDeviceWakeTriggeredS0NP : _WDF_DEVICE_POWER_POLICY_STATE = 34083 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSystemWakeDeviceWokeDisarmNP : _WDF_DEVICE_POWER_POLICY_STATE = 34084 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSystemWakeDeviceWakeCompletePowerUp : _WDF_DEVICE_POWER_POLICY_STATE = 1317 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSleeping : _WDF_DEVICE_POWER_POLICY_STATE = 1318 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSleepingNoWakePowerDown : _WDF_DEVICE_POWER_POLICY_STATE = 1319 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSleepingNoWakeCompletePowerDown : _WDF_DEVICE_POWER_POLICY_STATE = 1320 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSleepingNoWakeDxRequestFailed : _WDF_DEVICE_POWER_POLICY_STATE = 1321 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSleepingWakePowerDown : _WDF_DEVICE_POWER_POLICY_STATE = 1322 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSleepingSendWake : _WDF_DEVICE_POWER_POLICY_STATE = 1323 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSystemAsleepNoWake : _WDF_DEVICE_POWER_POLICY_STATE = 1324 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSystemWakeDeviceWakeDisabled : _WDF_DEVICE_POWER_POLICY_STATE = 1325 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSystemWakeDeviceToD0 : _WDF_DEVICE_POWER_POLICY_STATE = 1326 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSystemWakeDeviceToD0CompletePowerUp : _WDF_DEVICE_POWER_POLICY_STATE = 1327 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSystemWakeQueryIdle : _WDF_DEVICE_POWER_POLICY_STATE = 1328 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStartedWakeCapable : _WDF_DEVICE_POWER_POLICY_STATE = 1329 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolTimerExpiredDecideUsbSS : _WDF_DEVICE_POWER_POLICY_STATE = 1330 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolTimerExpiredWakeCapablePowerDown : _WDF_DEVICE_POWER_POLICY_STATE = 1331 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolTimerExpiredWakeCapableSendWake : _WDF_DEVICE_POWER_POLICY_STATE = 1332 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolTimerExpiredWakeCapableUsbSS : _WDF_DEVICE_POWER_POLICY_STATE = 1333 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolTimerExpiredWakeCapableWakeArrived : _WDF_DEVICE_POWER_POLICY_STATE = 1334 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolTimerExpiredWakeCapableCancelWake : _WDF_DEVICE_POWER_POLICY_STATE = 1335 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolTimerExpiredWakeCapableWakeCanceled : _WDF_DEVICE_POWER_POLICY_STATE = 1336 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolTimerExpiredWakeCapableCleanup : _WDF_DEVICE_POWER_POLICY_STATE = 1337 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolTimerExpiredWakeCapableDxAllocFailed : _WDF_DEVICE_POWER_POLICY_STATE = 1338 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolTimerExpiredWakeCompletedPowerDown : _WDF_DEVICE_POWER_POLICY_STATE = 1339 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolTimerExpiredWakeCompletedPowerUp : _WDF_DEVICE_POWER_POLICY_STATE = 1340 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolWaitingArmedUsbSS : _WDF_DEVICE_POWER_POLICY_STATE = 1341 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolWaitingArmed : _WDF_DEVICE_POWER_POLICY_STATE = 1342 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolWaitingArmedQueryIdle : _WDF_DEVICE_POWER_POLICY_STATE = 1343 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolIoPresentArmed : _WDF_DEVICE_POWER_POLICY_STATE = 1344 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolIoPresentArmedWakeCanceled : _WDF_DEVICE_POWER_POLICY_STATE = 1345 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolS0WakeDisarm : _WDF_DEVICE_POWER_POLICY_STATE = 1346 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolS0WakeCompletePowerUp : _WDF_DEVICE_POWER_POLICY_STATE = 1347 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolTimerExpiredWakeSucceeded : _WDF_DEVICE_POWER_POLICY_STATE = 1348 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolTimerExpiredWakeCompletedDisarm : _WDF_DEVICE_POWER_POLICY_STATE = 1349 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolTimerExpiredWakeCapableWakeSucceeded : _WDF_DEVICE_POWER_POLICY_STATE = 1350 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolTimerExpiredWakeCapableWakeFailed : _WDF_DEVICE_POWER_POLICY_STATE = 1351 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolWakeFailedUsbSS : _WDF_DEVICE_POWER_POLICY_STATE = 1352 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolTimerExpiredWakeCapablePowerDownFailedCancelWake : _WDF_DEVICE_POWER_POLICY_STATE = 1353 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolTimerExpiredWakeCapablePowerDownFailedWakeCanceled : _WDF_DEVICE_POWER_POLICY_STATE = 1354 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolTimerExpiredWakeCapablePowerDownFailedUsbSS : _WDF_DEVICE_POWER_POLICY_STATE = 1355 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolCancelingWakeForSystemSleep : _WDF_DEVICE_POWER_POLICY_STATE = 1356 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolCancelingWakeForSystemSleepWakeCanceled : _WDF_DEVICE_POWER_POLICY_STATE = 1357 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolDisarmingWakeForSystemSleepCompletePowerUp : _WDF_DEVICE_POWER_POLICY_STATE = 1358 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolPowerUpForSystemSleepFailed : _WDF_DEVICE_POWER_POLICY_STATE = 1359 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolWokeFromS0UsbSS : _WDF_DEVICE_POWER_POLICY_STATE = 1360 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolWokeFromS0 : _WDF_DEVICE_POWER_POLICY_STATE = 1361 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolWokeFromS0NotifyDriver : _WDF_DEVICE_POWER_POLICY_STATE = 1362 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStoppingResetDevice : _WDF_DEVICE_POWER_POLICY_STATE = 1363 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStoppingResetDeviceCompletePowerUp : _WDF_DEVICE_POWER_POLICY_STATE = 1364 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStoppingResetDeviceFailed : _WDF_DEVICE_POWER_POLICY_STATE = 1365 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStoppingD0 : _WDF_DEVICE_POWER_POLICY_STATE = 1366 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStoppingD0Failed : _WDF_DEVICE_POWER_POLICY_STATE = 1367 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStoppingDisarmWake : _WDF_DEVICE_POWER_POLICY_STATE = 1368 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStoppingDisarmWakeCancelWake : _WDF_DEVICE_POWER_POLICY_STATE = 1369 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStoppingDisarmWakeWakeCanceled : _WDF_DEVICE_POWER_POLICY_STATE = 1370 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStopping : _WDF_DEVICE_POWER_POLICY_STATE = 1371 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStoppingFailed : _WDF_DEVICE_POWER_POLICY_STATE = 1372 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStoppingSendStatus : _WDF_DEVICE_POWER_POLICY_STATE = 1373 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStoppingCancelTimer : _WDF_DEVICE_POWER_POLICY_STATE = 1374 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStoppingWaitForIdleTimeout : _WDF_DEVICE_POWER_POLICY_STATE = 1375 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStoppingCancelUsbSS : _WDF_DEVICE_POWER_POLICY_STATE = 1376 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStoppingWaitForUsbSSCompletion : _WDF_DEVICE_POWER_POLICY_STATE = 1377 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStoppingCancelWake : _WDF_DEVICE_POWER_POLICY_STATE = 1378 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStopped : _WDF_DEVICE_POWER_POLICY_STATE = 1379 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolCancelUsbSS : _WDF_DEVICE_POWER_POLICY_STATE = 1380 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStarted : _WDF_DEVICE_POWER_POLICY_STATE = 1381 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStartedCancelTimer : _WDF_DEVICE_POWER_POLICY_STATE = 1382 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStartedWaitForIdleTimeout : _WDF_DEVICE_POWER_POLICY_STATE = 1383 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStartedWakeCapableCancelTimerForSleep : _WDF_DEVICE_POWER_POLICY_STATE = 1384 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStartedWakeCapableWaitForIdleTimeout : _WDF_DEVICE_POWER_POLICY_STATE = 1385 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStartedWakeCapableSleepingUsbSS : _WDF_DEVICE_POWER_POLICY_STATE = 1386 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStartedIdleCapableCancelTimerForSleep : _WDF_DEVICE_POWER_POLICY_STATE = 1387 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStartedIdleCapableWaitForIdleTimeout : _WDF_DEVICE_POWER_POLICY_STATE = 1388 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolDeviceD0PowerRequestFailed : _WDF_DEVICE_POWER_POLICY_STATE = 1389 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolDevicePowerRequestFailed : _WDF_DEVICE_POWER_POLICY_STATE = 1390 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolGotoDx : _WDF_DEVICE_POWER_POLICY_STATE = 1391 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolGotoDxInDx : _WDF_DEVICE_POWER_POLICY_STATE = 1392 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolDx : _WDF_DEVICE_POWER_POLICY_STATE = 1393 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolGotoD0 : _WDF_DEVICE_POWER_POLICY_STATE = 1394 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolGotoD0InD0 : _WDF_DEVICE_POWER_POLICY_STATE = 1395 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolFinal : _WDF_DEVICE_POWER_POLICY_STATE = 1396 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSleepingPowerDownNotProcessed : _WDF_DEVICE_POWER_POLICY_STATE = 1397 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolTimerExpiredWakeCapablePowerDownNotProcessed : _WDF_DEVICE_POWER_POLICY_STATE = 1398 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolTimerExpiredNoWakePowerDownNotProcessed : _WDF_DEVICE_POWER_POLICY_STATE = 1399 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolTimerExpiredNoWakePoweredDownDisableIdleTimer : _WDF_DEVICE_POWER_POLICY_STATE = 1400 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStoppingWaitingForImplicitPowerDown : _WDF_DEVICE_POWER_POLICY_STATE = 1401 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStoppingPoweringUp : _WDF_DEVICE_POWER_POLICY_STATE = 1402 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStoppingPoweringDown : _WDF_DEVICE_POWER_POLICY_STATE = 1403 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolPowerUpForSystemSleepNotSeen : _WDF_DEVICE_POWER_POLICY_STATE = 1404 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolWaitingArmedStoppingCancelUsbSS : _WDF_DEVICE_POWER_POLICY_STATE = 1405 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolWaitingArmedWakeFailedCancelUsbSS : _WDF_DEVICE_POWER_POLICY_STATE = 1406 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolWaitingArmedIoPresentCancelUsbSS : _WDF_DEVICE_POWER_POLICY_STATE = 1407 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolWaitingArmedWakeSucceededCancelUsbSS : _WDF_DEVICE_POWER_POLICY_STATE = 1408 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolCancelingUsbSSForSystemSleep : _WDF_DEVICE_POWER_POLICY_STATE = 1409 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStoppingD0CancelUsbSS : _WDF_DEVICE_POWER_POLICY_STATE = 1410 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStartingPoweredUp : _WDF_DEVICE_POWER_POLICY_STATE = 1411 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolIdleCapableDeviceIdle : _WDF_DEVICE_POWER_POLICY_STATE = 1412 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolDeviceIdleReturnToActive : _WDF_DEVICE_POWER_POLICY_STATE = 1413 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolDeviceIdleSleeping : _WDF_DEVICE_POWER_POLICY_STATE = 1414 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolDeviceIdleStopping : _WDF_DEVICE_POWER_POLICY_STATE = 1415 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolTimerExpiredNoWakeUndoPowerDown : _WDF_DEVICE_POWER_POLICY_STATE = 1416 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolWakeCapableDeviceIdle : _WDF_DEVICE_POWER_POLICY_STATE = 1417 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolWakeCapableUsbSSCompleted : _WDF_DEVICE_POWER_POLICY_STATE = 1418 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolTimerExpiredWakeCapableUndoPowerDown : _WDF_DEVICE_POWER_POLICY_STATE = 1419 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolTimerExpiredWakeCompletedHardwareStarted : _WDF_DEVICE_POWER_POLICY_STATE = 1420 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStoppedRemoving : _WDF_DEVICE_POWER_POLICY_STATE = 1421 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolRemoved : _WDF_DEVICE_POWER_POLICY_STATE = 1422 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolRestarting : _WDF_DEVICE_POWER_POLICY_STATE = 1423 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolRestartingFailed : _WDF_DEVICE_POWER_POLICY_STATE = 1424 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolStartingPoweredUpFailed : _WDF_DEVICE_POWER_POLICY_STATE = 1425 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolTimerExpiredNoWakeReturnToActive : _WDF_DEVICE_POWER_POLICY_STATE = 1426 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolWaitingArmedWakeInterruptFired : _WDF_DEVICE_POWER_POLICY_STATE = 1427 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSystemWakeDeviceWakeInterruptFired : _WDF_DEVICE_POWER_POLICY_STATE = 1428 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolSystemWakeDeviceWakeInterruptFiredNP : _WDF_DEVICE_POWER_POLICY_STATE = 34197 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolTimerExpiredWakeCapableWakeInterruptArrived : _WDF_DEVICE_POWER_POLICY_STATE = 1430 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolTimerExpiredWakeCapablePowerDownFailedWakeInterruptArrived : _WDF_DEVICE_POWER_POLICY_STATE = 1431 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolWaitingArmedWakeInterruptFiredDuringPowerDown : _WDF_DEVICE_POWER_POLICY_STATE = 1432 ; pub const _WDF_DEVICE_POWER_POLICY_STATE_WdfDevStatePwrPolNull : _WDF_DEVICE_POWER_POLICY_STATE = 1433 ; pub type _WDF_DEVICE_POWER_POLICY_STATE = i32 ; pub use self :: _WDF_DEVICE_POWER_POLICY_STATE as WDF_DEVICE_POWER_POLICY_STATE ; pub type PWDF_DEVICE_POWER_POLICY_STATE = * mut _WDF_DEVICE_POWER_POLICY_STATE ; pub const _WDF_STATE_NOTIFICATION_TYPE_StateNotificationInvalid : _WDF_STATE_NOTIFICATION_TYPE = 0 ; pub const _WDF_STATE_NOTIFICATION_TYPE_StateNotificationEnterState : _WDF_STATE_NOTIFICATION_TYPE = 1 ; pub const _WDF_STATE_NOTIFICATION_TYPE_StateNotificationPostProcessState : _WDF_STATE_NOTIFICATION_TYPE = 2 ; pub const _WDF_STATE_NOTIFICATION_TYPE_StateNotificationLeaveState : _WDF_STATE_NOTIFICATION_TYPE = 4 ; pub const _WDF_STATE_NOTIFICATION_TYPE_StateNotificationAllStates : _WDF_STATE_NOTIFICATION_TYPE = 7 ; pub type _WDF_STATE_NOTIFICATION_TYPE = i32 ; pub use self :: _WDF_STATE_NOTIFICATION_TYPE as WDF_STATE_NOTIFICATION_TYPE ; pub const _WDF_POWER_POLICY_S0_IDLE_CAPABILITIES_IdleCapsInvalid : _WDF_POWER_POLICY_S0_IDLE_CAPABILITIES = 0 ; pub const _WDF_POWER_POLICY_S0_IDLE_CAPABILITIES_IdleCannotWakeFromS0 : _WDF_POWER_POLICY_S0_IDLE_CAPABILITIES = 1 ; pub const _WDF_POWER_POLICY_S0_IDLE_CAPABILITIES_IdleCanWakeFromS0 : _WDF_POWER_POLICY_S0_IDLE_CAPABILITIES = 2 ; pub const _WDF_POWER_POLICY_S0_IDLE_CAPABILITIES_IdleUsbSelectiveSuspend : _WDF_POWER_POLICY_S0_IDLE_CAPABILITIES = 3 ; pub type _WDF_POWER_POLICY_S0_IDLE_CAPABILITIES = i32 ; pub use self :: _WDF_POWER_POLICY_S0_IDLE_CAPABILITIES as WDF_POWER_POLICY_S0_IDLE_CAPABILITIES ; pub const _WDF_POWER_POLICY_S0_IDLE_USER_CONTROL_IdleUserControlInvalid : _WDF_POWER_POLICY_S0_IDLE_USER_CONTROL = 0 ; pub const _WDF_POWER_POLICY_S0_IDLE_USER_CONTROL_IdleDoNotAllowUserControl : _WDF_POWER_POLICY_S0_IDLE_USER_CONTROL = 1 ; pub const _WDF_POWER_POLICY_S0_IDLE_USER_CONTROL_IdleAllowUserControl : _WDF_POWER_POLICY_S0_IDLE_USER_CONTROL = 2 ; pub type _WDF_POWER_POLICY_S0_IDLE_USER_CONTROL = i32 ; pub use self :: _WDF_POWER_POLICY_S0_IDLE_USER_CONTROL as WDF_POWER_POLICY_S0_IDLE_USER_CONTROL ; pub const _WDF_POWER_POLICY_IDLE_TIMEOUT_CONSTANTS_IdleTimeoutDefaultConstant : _WDF_POWER_POLICY_IDLE_TIMEOUT_CONSTANTS = 0 ; pub type _WDF_POWER_POLICY_IDLE_TIMEOUT_CONSTANTS = i32 ; pub use self :: _WDF_POWER_POLICY_IDLE_TIMEOUT_CONSTANTS as WDF_POWER_POLICY_IDLE_TIMEOUT_CONSTANTS ; pub const _WDF_POWER_POLICY_SX_WAKE_USER_CONTROL_WakeUserControlInvalid : _WDF_POWER_POLICY_SX_WAKE_USER_CONTROL = 0 ; pub const _WDF_POWER_POLICY_SX_WAKE_USER_CONTROL_WakeDoNotAllowUserControl : _WDF_POWER_POLICY_SX_WAKE_USER_CONTROL = 1 ; pub const _WDF_POWER_POLICY_SX_WAKE_USER_CONTROL_WakeAllowUserControl : _WDF_POWER_POLICY_SX_WAKE_USER_CONTROL = 2 ; pub type _WDF_POWER_POLICY_SX_WAKE_USER_CONTROL = i32 ; pub use self :: _WDF_POWER_POLICY_SX_WAKE_USER_CONTROL as WDF_POWER_POLICY_SX_WAKE_USER_CONTROL ; pub const _WDF_POWER_DEVICE_STATE_WdfPowerDeviceInvalid : _WDF_POWER_DEVICE_STATE = 0 ; pub const _WDF_POWER_DEVICE_STATE_WdfPowerDeviceD0 : _WDF_POWER_DEVICE_STATE = 1 ; pub const _WDF_POWER_DEVICE_STATE_WdfPowerDeviceD1 : _WDF_POWER_DEVICE_STATE = 2 ; pub const _WDF_POWER_DEVICE_STATE_WdfPowerDeviceD2 : _WDF_POWER_DEVICE_STATE = 3 ; pub const _WDF_POWER_DEVICE_STATE_WdfPowerDeviceD3 : _WDF_POWER_DEVICE_STATE = 4 ; pub const _WDF_POWER_DEVICE_STATE_WdfPowerDeviceD3Final : _WDF_POWER_DEVICE_STATE = 5 ; pub const _WDF_POWER_DEVICE_STATE_WdfPowerDevicePrepareForHibernation : _WDF_POWER_DEVICE_STATE = 6 ; pub const _WDF_POWER_DEVICE_STATE_WdfPowerDeviceMaximum : _WDF_POWER_DEVICE_STATE = 7 ; pub type _WDF_POWER_DEVICE_STATE = i32 ; pub use self :: _WDF_POWER_DEVICE_STATE as WDF_POWER_DEVICE_STATE ; pub type PWDF_POWER_DEVICE_STATE = * mut _WDF_POWER_DEVICE_STATE ; pub const _WDF_DISPATCH_IRP_TO_IO_QUEUE_FLAGS_WDF_DISPATCH_IRP_TO_IO_QUEUE_NO_FLAGS : _WDF_DISPATCH_IRP_TO_IO_QUEUE_FLAGS = 0 ; pub const _WDF_DISPATCH_IRP_TO_IO_QUEUE_FLAGS_WDF_DISPATCH_IRP_TO_IO_QUEUE_INVOKE_INCALLERCTX_CALLBACK : _WDF_DISPATCH_IRP_TO_IO_QUEUE_FLAGS = 1 ; pub const _WDF_DISPATCH_IRP_TO_IO_QUEUE_FLAGS_WDF_DISPATCH_IRP_TO_IO_QUEUE_PREPROCESSED_IRP : _WDF_DISPATCH_IRP_TO_IO_QUEUE_FLAGS = 2 ; pub type _WDF_DISPATCH_IRP_TO_IO_QUEUE_FLAGS = i32 ; pub use self :: _WDF_DISPATCH_IRP_TO_IO_QUEUE_FLAGS as WDF_DISPATCH_IRP_TO_IO_QUEUE_FLAGS ; pub const _WDF_SPECIAL_FILE_TYPE_WdfSpecialFileUndefined : _WDF_SPECIAL_FILE_TYPE = 0 ; pub const _WDF_SPECIAL_FILE_TYPE_WdfSpecialFilePaging : _WDF_SPECIAL_FILE_TYPE = 1 ; pub const _WDF_SPECIAL_FILE_TYPE_WdfSpecialFileHibernation : _WDF_SPECIAL_FILE_TYPE = 2 ; pub const _WDF_SPECIAL_FILE_TYPE_WdfSpecialFileDump : _WDF_SPECIAL_FILE_TYPE = 3 ; pub const _WDF_SPECIAL_FILE_TYPE_WdfSpecialFileBoot : _WDF_SPECIAL_FILE_TYPE = 4 ; pub const _WDF_SPECIAL_FILE_TYPE_WdfSpecialFileMax : _WDF_SPECIAL_FILE_TYPE = 5 ; pub type _WDF_SPECIAL_FILE_TYPE = i32 ; pub use self :: _WDF_SPECIAL_FILE_TYPE as WDF_SPECIAL_FILE_TYPE ; pub type PWDF_SPECIAL_FILE_TYPE = * mut _WDF_SPECIAL_FILE_TYPE ; pub const _WDF_DEVICE_IO_TYPE_WdfDeviceIoUndefined : _WDF_DEVICE_IO_TYPE = 0 ; pub const _WDF_DEVICE_IO_TYPE_WdfDeviceIoNeither : _WDF_DEVICE_IO_TYPE = 1 ; pub const _WDF_DEVICE_IO_TYPE_WdfDeviceIoBuffered : _WDF_DEVICE_IO_TYPE = 2 ; pub const _WDF_DEVICE_IO_TYPE_WdfDeviceIoDirect : _WDF_DEVICE_IO_TYPE = 3 ; pub const _WDF_DEVICE_IO_TYPE_WdfDeviceIoBufferedOrDirect : _WDF_DEVICE_IO_TYPE = 4 ; pub const _WDF_DEVICE_IO_TYPE_WdfDeviceIoMaximum : _WDF_DEVICE_IO_TYPE = 5 ; pub type _WDF_DEVICE_IO_TYPE = i32 ; pub use self :: _WDF_DEVICE_IO_TYPE as WDF_DEVICE_IO_TYPE ; pub type PWDF_DEVICE_IO_TYPE = * mut _WDF_DEVICE_IO_TYPE ; pub const _WDF_FILEOBJECT_CLASS_WdfFileObjectInvalid : _WDF_FILEOBJECT_CLASS = 0 ; pub const _WDF_FILEOBJECT_CLASS_WdfFileObjectNotRequired : _WDF_FILEOBJECT_CLASS = 1 ; pub const _WDF_FILEOBJECT_CLASS_WdfFileObjectWdfCanUseFsContext : _WDF_FILEOBJECT_CLASS = 2 ; pub const _WDF_FILEOBJECT_CLASS_WdfFileObjectWdfCanUseFsContext2 : _WDF_FILEOBJECT_CLASS = 3 ; pub const _WDF_FILEOBJECT_CLASS_WdfFileObjectWdfCannotUseFsContexts : _WDF_FILEOBJECT_CLASS = 4 ; pub const _WDF_FILEOBJECT_CLASS_WdfFileObjectCanBeOptional : _WDF_FILEOBJECT_CLASS = -2147483648 ; pub type _WDF_FILEOBJECT_CLASS = i32 ; pub use self :: _WDF_FILEOBJECT_CLASS as WDF_FILEOBJECT_CLASS ; pub type PWDF_FILEOBJECT_CLASS = * mut _WDF_FILEOBJECT_CLASS ; pub const _WDF_DEVICE_FAILED_ACTION_WdfDeviceFailedUndefined : _WDF_DEVICE_FAILED_ACTION = 0 ; pub const _WDF_DEVICE_FAILED_ACTION_WdfDeviceFailedAttemptRestart : _WDF_DEVICE_FAILED_ACTION = 1 ; pub const _WDF_DEVICE_FAILED_ACTION_WdfDeviceFailedNoRestart : _WDF_DEVICE_FAILED_ACTION = 2 ; pub type _WDF_DEVICE_FAILED_ACTION = i32 ; pub use self :: _WDF_DEVICE_FAILED_ACTION as WDF_DEVICE_FAILED_ACTION ; pub const _WDF_RELEASE_HARDWARE_ORDER_ON_FAILURE_WdfReleaseHardwareOrderOnFailureInvalid : _WDF_RELEASE_HARDWARE_ORDER_ON_FAILURE = 0 ; pub const _WDF_RELEASE_HARDWARE_ORDER_ON_FAILURE_WdfReleaseHardwareOrderOnFailureEarly : _WDF_RELEASE_HARDWARE_ORDER_ON_FAILURE = 1 ; pub const _WDF_RELEASE_HARDWARE_ORDER_ON_FAILURE_WdfReleaseHardwareOrderOnFailureAfterDescendants : _WDF_RELEASE_HARDWARE_ORDER_ON_FAILURE = 2 ; pub type _WDF_RELEASE_HARDWARE_ORDER_ON_FAILURE = i32 ; pub use self :: _WDF_RELEASE_HARDWARE_ORDER_ON_FAILURE as WDF_RELEASE_HARDWARE_ORDER_ON_FAILURE ; pub type PWDF_RELEASE_HARDWARE_ORDER_ON_FAILURE = * mut _WDF_RELEASE_HARDWARE_ORDER_ON_FAILURE ; extern "C" { # [ link_name = "\u{1}SDDL_DEVOBJ_KERNEL_ONLY" ] pub static mut SDDL_DEVOBJ_KERNEL_ONLY : UNICODE_STRING ; } extern "C" { # [ link_name = "\u{1}SDDL_DEVOBJ_SYS_ALL" ] pub static mut SDDL_DEVOBJ_SYS_ALL : UNICODE_STRING ; } extern "C" { # [ link_name = "\u{1}SDDL_DEVOBJ_SYS_ALL_ADM_ALL" ] pub static mut SDDL_DEVOBJ_SYS_ALL_ADM_ALL : UNICODE_STRING ; } extern "C" { # [ link_name = "\u{1}SDDL_DEVOBJ_SYS_ALL_ADM_RX" ] pub static mut SDDL_DEVOBJ_SYS_ALL_ADM_RX : UNICODE_STRING ; } extern "C" { # [ link_name = "\u{1}SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_R" ] pub static mut SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_R : UNICODE_STRING ; } extern "C" { # [ link_name = "\u{1}SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_R_RES_R" ] pub static mut SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_R_RES_R : UNICODE_STRING ; } extern "C" { # [ link_name = "\u{1}SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_RW_RES_R" ] pub static mut SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_RW_RES_R : UNICODE_STRING ; } extern "C" { # [ link_name = "\u{1}SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_RWX_RES_RWX" ] pub static mut SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_RWX_RES_RWX : UNICODE_STRING ; } extern "C" { pub fn WdmlibIoCreateDeviceSecure ( DriverObject : PDRIVER_OBJECT , DeviceExtensionSize : ULONG , DeviceName : PUNICODE_STRING , DeviceType : ULONG , DeviceCharacteristics : ULONG , Exclusive : BOOLEAN , DefaultSDDLString : PCUNICODE_STRING , DeviceClassGuid : LPCGUID , DeviceObject : * mut PDEVICE_OBJECT ) -> NTSTATUS ; } extern "C" { pub fn WdmlibRtlInitUnicodeStringEx ( DestinationString : PUNICODE_STRING , SourceString : PCWSTR ) -> NTSTATUS ; } extern "C" { pub fn WdmlibIoValidateDeviceIoControlAccess ( Irp : PIRP , RequiredAccess : ULONG ) -> NTSTATUS ; } pub use self :: _WDF_REQUEST_TYPE as WDF_REQUEST_TYPE ; pub type EVT_WDF_DEVICE_FILE_CREATE = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE , Request : WDFREQUEST , FileObject : WDFFILEOBJECT ) > ; pub type PFN_WDF_DEVICE_FILE_CREATE = EVT_WDF_DEVICE_FILE_CREATE ; pub type EVT_WDF_FILE_CLOSE = :: std :: option :: Option < unsafe extern "C" fn ( FileObject : WDFFILEOBJECT ) > ; pub type PFN_WDF_FILE_CLOSE = EVT_WDF_FILE_CLOSE ; pub type EVT_WDF_FILE_CLEANUP = :: std :: option :: Option < unsafe extern "C" fn ( FileObject : WDFFILEOBJECT ) > ; pub type PFN_WDF_FILE_CLEANUP = EVT_WDF_FILE_CLEANUP ; # [ repr ( C ) ] pub struct _WDF_FILEOBJECT_CONFIG { pub Size : ULONG , pub EvtDeviceFileCreate : PFN_WDF_DEVICE_FILE_CREATE , pub EvtFileClose : PFN_WDF_FILE_CLOSE , pub EvtFileCleanup : PFN_WDF_FILE_CLEANUP , pub AutoForwardCleanupClose : WDF_TRI_STATE , pub FileObjectClass : WDF_FILEOBJECT_CLASS , } pub type WDF_FILEOBJECT_CONFIG = _WDF_FILEOBJECT_CONFIG ; pub type PWDF_FILEOBJECT_CONFIG = * mut _WDF_FILEOBJECT_CONFIG ; # [ repr ( C ) ] pub struct _WDF_DEVICE_PNP_NOTIFICATION_DATA { pub Type : WDF_STATE_NOTIFICATION_TYPE , pub Data : _WDF_DEVICE_PNP_NOTIFICATION_DATA__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _WDF_DEVICE_PNP_NOTIFICATION_DATA__bindgen_ty_1 { pub EnterState : __BindgenUnionField < _WDF_DEVICE_PNP_NOTIFICATION_DATA__bindgen_ty_1__bindgen_ty_1 > , pub PostProcessState : __BindgenUnionField < _WDF_DEVICE_PNP_NOTIFICATION_DATA__bindgen_ty_1__bindgen_ty_2 > , pub LeaveState : __BindgenUnionField < _WDF_DEVICE_PNP_NOTIFICATION_DATA__bindgen_ty_1__bindgen_ty_3 > , pub bindgen_union_field : [ u32 ; 2usize ] , } # [ repr ( C ) ] pub struct _WDF_DEVICE_PNP_NOTIFICATION_DATA__bindgen_ty_1__bindgen_ty_1 { pub CurrentState : WDF_DEVICE_PNP_STATE , pub NewState : WDF_DEVICE_PNP_STATE , } # [ repr ( C ) ] pub struct _WDF_DEVICE_PNP_NOTIFICATION_DATA__bindgen_ty_1__bindgen_ty_2 { pub CurrentState : WDF_DEVICE_PNP_STATE , } # [ repr ( C ) ] pub struct _WDF_DEVICE_PNP_NOTIFICATION_DATA__bindgen_ty_1__bindgen_ty_3 { pub CurrentState : WDF_DEVICE_PNP_STATE , pub NewState : WDF_DEVICE_PNP_STATE , } pub type WDF_DEVICE_PNP_NOTIFICATION_DATA = _WDF_DEVICE_PNP_NOTIFICATION_DATA ; pub type PCWDF_DEVICE_PNP_NOTIFICATION_DATA = * const WDF_DEVICE_PNP_NOTIFICATION_DATA ; # [ repr ( C ) ] pub struct _WDF_DEVICE_POWER_NOTIFICATION_DATA { pub Type : WDF_STATE_NOTIFICATION_TYPE , pub Data : _WDF_DEVICE_POWER_NOTIFICATION_DATA__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _WDF_DEVICE_POWER_NOTIFICATION_DATA__bindgen_ty_1 { pub EnterState : __BindgenUnionField < _WDF_DEVICE_POWER_NOTIFICATION_DATA__bindgen_ty_1__bindgen_ty_1 > , pub PostProcessState : __BindgenUnionField < _WDF_DEVICE_POWER_NOTIFICATION_DATA__bindgen_ty_1__bindgen_ty_2 > , pub LeaveState : __BindgenUnionField < _WDF_DEVICE_POWER_NOTIFICATION_DATA__bindgen_ty_1__bindgen_ty_3 > , pub bindgen_union_field : [ u32 ; 2usize ] , } # [ repr ( C ) ] pub struct _WDF_DEVICE_POWER_NOTIFICATION_DATA__bindgen_ty_1__bindgen_ty_1 { pub CurrentState : WDF_DEVICE_POWER_STATE , pub NewState : WDF_DEVICE_POWER_STATE , } # [ repr ( C ) ] pub struct _WDF_DEVICE_POWER_NOTIFICATION_DATA__bindgen_ty_1__bindgen_ty_2 { pub CurrentState : WDF_DEVICE_POWER_STATE , } # [ repr ( C ) ] pub struct _WDF_DEVICE_POWER_NOTIFICATION_DATA__bindgen_ty_1__bindgen_ty_3 { pub CurrentState : WDF_DEVICE_POWER_STATE , pub NewState : WDF_DEVICE_POWER_STATE , } pub type WDF_DEVICE_POWER_NOTIFICATION_DATA = _WDF_DEVICE_POWER_NOTIFICATION_DATA ; pub type PCWDF_DEVICE_POWER_NOTIFICATION_DATA = * const WDF_DEVICE_POWER_NOTIFICATION_DATA ; # [ repr ( C ) ] pub struct _WDF_DEVICE_POWER_POLICY_NOTIFICATION_DATA { pub Type : WDF_STATE_NOTIFICATION_TYPE , pub Data : _WDF_DEVICE_POWER_POLICY_NOTIFICATION_DATA__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _WDF_DEVICE_POWER_POLICY_NOTIFICATION_DATA__bindgen_ty_1 { pub EnterState : __BindgenUnionField < _WDF_DEVICE_POWER_POLICY_NOTIFICATION_DATA__bindgen_ty_1__bindgen_ty_1 > , pub PostProcessState : __BindgenUnionField < _WDF_DEVICE_POWER_POLICY_NOTIFICATION_DATA__bindgen_ty_1__bindgen_ty_2 > , pub LeaveState : __BindgenUnionField < _WDF_DEVICE_POWER_POLICY_NOTIFICATION_DATA__bindgen_ty_1__bindgen_ty_3 > , pub bindgen_union_field : [ u32 ; 2usize ] , } # [ repr ( C ) ] pub struct _WDF_DEVICE_POWER_POLICY_NOTIFICATION_DATA__bindgen_ty_1__bindgen_ty_1 { pub CurrentState : WDF_DEVICE_POWER_POLICY_STATE , pub NewState : WDF_DEVICE_POWER_POLICY_STATE , } # [ repr ( C ) ] pub struct _WDF_DEVICE_POWER_POLICY_NOTIFICATION_DATA__bindgen_ty_1__bindgen_ty_2 { pub CurrentState : WDF_DEVICE_POWER_POLICY_STATE , } # [ repr ( C ) ] pub struct _WDF_DEVICE_POWER_POLICY_NOTIFICATION_DATA__bindgen_ty_1__bindgen_ty_3 { pub CurrentState : WDF_DEVICE_POWER_POLICY_STATE , pub NewState : WDF_DEVICE_POWER_POLICY_STATE , } pub type WDF_DEVICE_POWER_POLICY_NOTIFICATION_DATA = _WDF_DEVICE_POWER_POLICY_NOTIFICATION_DATA ; pub type PCWDF_DEVICE_POWER_POLICY_NOTIFICATION_DATA = * const WDF_DEVICE_POWER_POLICY_NOTIFICATION_DATA ; pub type EVT_WDF_DEVICE_PNP_STATE_CHANGE_NOTIFICATION = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE , NotificationData : PCWDF_DEVICE_PNP_NOTIFICATION_DATA ) > ; pub type PFN_WDF_DEVICE_PNP_STATE_CHANGE_NOTIFICATION = EVT_WDF_DEVICE_PNP_STATE_CHANGE_NOTIFICATION ; pub type EVT_WDF_DEVICE_POWER_STATE_CHANGE_NOTIFICATION = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE , NotificationData : PCWDF_DEVICE_POWER_NOTIFICATION_DATA ) > ; pub type PFN_WDF_DEVICE_POWER_STATE_CHANGE_NOTIFICATION = EVT_WDF_DEVICE_POWER_STATE_CHANGE_NOTIFICATION ; pub type EVT_WDF_DEVICE_POWER_POLICY_STATE_CHANGE_NOTIFICATION = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE , NotificationData : PCWDF_DEVICE_POWER_POLICY_NOTIFICATION_DATA ) > ; pub type PFN_WDF_DEVICE_POWER_POLICY_STATE_CHANGE_NOTIFICATION = EVT_WDF_DEVICE_POWER_POLICY_STATE_CHANGE_NOTIFICATION ; pub type EVT_WDF_DEVICE_D0_ENTRY = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE , PreviousState : WDF_POWER_DEVICE_STATE ) -> NTSTATUS > ; pub type PFN_WDF_DEVICE_D0_ENTRY = EVT_WDF_DEVICE_D0_ENTRY ; pub type EVT_WDF_DEVICE_D0_ENTRY_POST_INTERRUPTS_ENABLED = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE , PreviousState : WDF_POWER_DEVICE_STATE ) -> NTSTATUS > ; pub type PFN_WDF_DEVICE_D0_ENTRY_POST_INTERRUPTS_ENABLED = EVT_WDF_DEVICE_D0_ENTRY_POST_INTERRUPTS_ENABLED ; pub type EVT_WDF_DEVICE_D0_EXIT = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE , TargetState : WDF_POWER_DEVICE_STATE ) -> NTSTATUS > ; pub type PFN_WDF_DEVICE_D0_EXIT = EVT_WDF_DEVICE_D0_EXIT ; pub type EVT_WDF_DEVICE_D0_EXIT_PRE_INTERRUPTS_DISABLED = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE , TargetState : WDF_POWER_DEVICE_STATE ) -> NTSTATUS > ; pub type PFN_WDF_DEVICE_D0_EXIT_PRE_INTERRUPTS_DISABLED = EVT_WDF_DEVICE_D0_EXIT_PRE_INTERRUPTS_DISABLED ; pub type EVT_WDF_DEVICE_PREPARE_HARDWARE = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE , ResourcesRaw : WDFCMRESLIST , ResourcesTranslated : WDFCMRESLIST ) -> NTSTATUS > ; pub type PFN_WDF_DEVICE_PREPARE_HARDWARE = EVT_WDF_DEVICE_PREPARE_HARDWARE ; pub type EVT_WDF_DEVICE_RELEASE_HARDWARE = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE , ResourcesTranslated : WDFCMRESLIST ) -> NTSTATUS > ; pub type PFN_WDF_DEVICE_RELEASE_HARDWARE = EVT_WDF_DEVICE_RELEASE_HARDWARE ; pub type EVT_WDF_DEVICE_SELF_MANAGED_IO_CLEANUP = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE ) > ; pub type PFN_WDF_DEVICE_SELF_MANAGED_IO_CLEANUP = EVT_WDF_DEVICE_SELF_MANAGED_IO_CLEANUP ; pub type EVT_WDF_DEVICE_SELF_MANAGED_IO_FLUSH = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE ) > ; pub type PFN_WDF_DEVICE_SELF_MANAGED_IO_FLUSH = EVT_WDF_DEVICE_SELF_MANAGED_IO_FLUSH ; pub type EVT_WDF_DEVICE_SELF_MANAGED_IO_INIT = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE ) -> NTSTATUS > ; pub type PFN_WDF_DEVICE_SELF_MANAGED_IO_INIT = EVT_WDF_DEVICE_SELF_MANAGED_IO_INIT ; pub type EVT_WDF_DEVICE_SELF_MANAGED_IO_SUSPEND = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE ) -> NTSTATUS > ; pub type PFN_WDF_DEVICE_SELF_MANAGED_IO_SUSPEND = EVT_WDF_DEVICE_SELF_MANAGED_IO_SUSPEND ; pub type EVT_WDF_DEVICE_SELF_MANAGED_IO_RESTART = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE ) -> NTSTATUS > ; pub type PFN_WDF_DEVICE_SELF_MANAGED_IO_RESTART = EVT_WDF_DEVICE_SELF_MANAGED_IO_RESTART ; pub type EVT_WDF_DEVICE_QUERY_STOP = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE ) -> NTSTATUS > ; pub type PFN_WDF_DEVICE_QUERY_STOP = EVT_WDF_DEVICE_QUERY_STOP ; pub type EVT_WDF_DEVICE_QUERY_REMOVE = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE ) -> NTSTATUS > ; pub type PFN_WDF_DEVICE_QUERY_REMOVE = EVT_WDF_DEVICE_QUERY_REMOVE ; pub type EVT_WDF_DEVICE_SURPRISE_REMOVAL = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE ) > ; pub type PFN_WDF_DEVICE_SURPRISE_REMOVAL = EVT_WDF_DEVICE_SURPRISE_REMOVAL ; pub type EVT_WDF_DEVICE_USAGE_NOTIFICATION = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE , NotificationType : WDF_SPECIAL_FILE_TYPE , IsInNotificationPath : BOOLEAN ) > ; pub type PFN_WDF_DEVICE_USAGE_NOTIFICATION = EVT_WDF_DEVICE_USAGE_NOTIFICATION ; pub type EVT_WDF_DEVICE_USAGE_NOTIFICATION_EX = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE , NotificationType : WDF_SPECIAL_FILE_TYPE , IsInNotificationPath : BOOLEAN ) -> NTSTATUS > ; pub type PFN_WDF_DEVICE_USAGE_NOTIFICATION_EX = EVT_WDF_DEVICE_USAGE_NOTIFICATION_EX ; pub type EVT_WDF_DEVICE_RELATIONS_QUERY = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE , RelationType : DEVICE_RELATION_TYPE ) > ; pub type PFN_WDF_DEVICE_RELATIONS_QUERY = EVT_WDF_DEVICE_RELATIONS_QUERY ; pub type EVT_WDF_DEVICE_ARM_WAKE_FROM_S0 = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE ) -> NTSTATUS > ; pub type PFN_WDF_DEVICE_ARM_WAKE_FROM_S0 = EVT_WDF_DEVICE_ARM_WAKE_FROM_S0 ; pub type EVT_WDF_DEVICE_ARM_WAKE_FROM_SX = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE ) -> NTSTATUS > ; pub type PFN_WDF_DEVICE_ARM_WAKE_FROM_SX = EVT_WDF_DEVICE_ARM_WAKE_FROM_SX ; pub type EVT_WDF_DEVICE_ARM_WAKE_FROM_SX_WITH_REASON = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE , DeviceWakeEnabled : BOOLEAN , ChildrenArmedForWake : BOOLEAN ) -> NTSTATUS > ; pub type PFN_WDF_DEVICE_ARM_WAKE_FROM_SX_WITH_REASON = EVT_WDF_DEVICE_ARM_WAKE_FROM_SX_WITH_REASON ; pub type EVT_WDF_DEVICE_DISARM_WAKE_FROM_S0 = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE ) > ; pub type PFN_WDF_DEVICE_DISARM_WAKE_FROM_S0 = EVT_WDF_DEVICE_DISARM_WAKE_FROM_S0 ; pub type EVT_WDF_DEVICE_DISARM_WAKE_FROM_SX = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE ) > ; pub type PFN_WDF_DEVICE_DISARM_WAKE_FROM_SX = EVT_WDF_DEVICE_DISARM_WAKE_FROM_SX ; pub type EVT_WDF_DEVICE_WAKE_FROM_S0_TRIGGERED = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE ) > ; pub type PFN_WDF_DEVICE_WAKE_FROM_S0_TRIGGERED = EVT_WDF_DEVICE_WAKE_FROM_S0_TRIGGERED ; pub type EVT_WDF_DEVICE_WAKE_FROM_SX_TRIGGERED = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE ) > ; pub type PFN_WDF_DEVICE_WAKE_FROM_SX_TRIGGERED = EVT_WDF_DEVICE_WAKE_FROM_SX_TRIGGERED ; # [ repr ( C ) ] pub struct _WDF_PNPPOWER_EVENT_CALLBACKS { pub Size : ULONG , pub EvtDeviceD0Entry : PFN_WDF_DEVICE_D0_ENTRY , pub EvtDeviceD0EntryPostInterruptsEnabled : PFN_WDF_DEVICE_D0_ENTRY_POST_INTERRUPTS_ENABLED , pub EvtDeviceD0Exit : PFN_WDF_DEVICE_D0_EXIT , pub EvtDeviceD0ExitPreInterruptsDisabled : PFN_WDF_DEVICE_D0_EXIT_PRE_INTERRUPTS_DISABLED , pub EvtDevicePrepareHardware : PFN_WDF_DEVICE_PREPARE_HARDWARE , pub EvtDeviceReleaseHardware : PFN_WDF_DEVICE_RELEASE_HARDWARE , pub EvtDeviceSelfManagedIoCleanup : PFN_WDF_DEVICE_SELF_MANAGED_IO_CLEANUP , pub EvtDeviceSelfManagedIoFlush : PFN_WDF_DEVICE_SELF_MANAGED_IO_FLUSH , pub EvtDeviceSelfManagedIoInit : PFN_WDF_DEVICE_SELF_MANAGED_IO_INIT , pub EvtDeviceSelfManagedIoSuspend : PFN_WDF_DEVICE_SELF_MANAGED_IO_SUSPEND , pub EvtDeviceSelfManagedIoRestart : PFN_WDF_DEVICE_SELF_MANAGED_IO_RESTART , pub EvtDeviceSurpriseRemoval : PFN_WDF_DEVICE_SURPRISE_REMOVAL , pub EvtDeviceQueryRemove : PFN_WDF_DEVICE_QUERY_REMOVE , pub EvtDeviceQueryStop : PFN_WDF_DEVICE_QUERY_STOP , pub EvtDeviceUsageNotification : PFN_WDF_DEVICE_USAGE_NOTIFICATION , pub EvtDeviceRelationsQuery : PFN_WDF_DEVICE_RELATIONS_QUERY , pub EvtDeviceUsageNotificationEx : PFN_WDF_DEVICE_USAGE_NOTIFICATION_EX , } pub type WDF_PNPPOWER_EVENT_CALLBACKS = _WDF_PNPPOWER_EVENT_CALLBACKS ; pub type PWDF_PNPPOWER_EVENT_CALLBACKS = * mut _WDF_PNPPOWER_EVENT_CALLBACKS ; # [ repr ( C ) ] pub struct _WDF_POWER_POLICY_EVENT_CALLBACKS { pub Size : ULONG , pub EvtDeviceArmWakeFromS0 : PFN_WDF_DEVICE_ARM_WAKE_FROM_S0 , pub EvtDeviceDisarmWakeFromS0 : PFN_WDF_DEVICE_DISARM_WAKE_FROM_S0 , pub EvtDeviceWakeFromS0Triggered : PFN_WDF_DEVICE_WAKE_FROM_S0_TRIGGERED , pub EvtDeviceArmWakeFromSx : PFN_WDF_DEVICE_ARM_WAKE_FROM_SX , pub EvtDeviceDisarmWakeFromSx : PFN_WDF_DEVICE_DISARM_WAKE_FROM_SX , pub EvtDeviceWakeFromSxTriggered : PFN_WDF_DEVICE_WAKE_FROM_SX_TRIGGERED , pub EvtDeviceArmWakeFromSxWithReason : PFN_WDF_DEVICE_ARM_WAKE_FROM_SX_WITH_REASON , } pub type WDF_POWER_POLICY_EVENT_CALLBACKS = _WDF_POWER_POLICY_EVENT_CALLBACKS ; pub type PWDF_POWER_POLICY_EVENT_CALLBACKS = * mut _WDF_POWER_POLICY_EVENT_CALLBACKS ; pub const _WDF_POWER_POLICY_IDLE_TIMEOUT_TYPE_DriverManagedIdleTimeout : _WDF_POWER_POLICY_IDLE_TIMEOUT_TYPE = 0 ; pub const _WDF_POWER_POLICY_IDLE_TIMEOUT_TYPE_SystemManagedIdleTimeout : _WDF_POWER_POLICY_IDLE_TIMEOUT_TYPE = 1 ; pub const _WDF_POWER_POLICY_IDLE_TIMEOUT_TYPE_SystemManagedIdleTimeoutWithHint : _WDF_POWER_POLICY_IDLE_TIMEOUT_TYPE = 2 ; pub type _WDF_POWER_POLICY_IDLE_TIMEOUT_TYPE = i32 ; pub use self :: _WDF_POWER_POLICY_IDLE_TIMEOUT_TYPE as WDF_POWER_POLICY_IDLE_TIMEOUT_TYPE ; pub type PWDF_POWER_POLICY_IDLE_TIMEOUT_TYPE = * mut _WDF_POWER_POLICY_IDLE_TIMEOUT_TYPE ; # [ repr ( C ) ] pub struct _WDF_DEVICE_POWER_POLICY_IDLE_SETTINGS { pub Size : ULONG , pub IdleCaps : WDF_POWER_POLICY_S0_IDLE_CAPABILITIES , pub DxState : DEVICE_POWER_STATE , pub IdleTimeout : ULONG , pub UserControlOfIdleSettings : WDF_POWER_POLICY_S0_IDLE_USER_CONTROL , pub Enabled : WDF_TRI_STATE , pub PowerUpIdleDeviceOnSystemWake : WDF_TRI_STATE , pub IdleTimeoutType : WDF_POWER_POLICY_IDLE_TIMEOUT_TYPE , pub ExcludeD3Cold : WDF_TRI_STATE , } pub type WDF_DEVICE_POWER_POLICY_IDLE_SETTINGS = _WDF_DEVICE_POWER_POLICY_IDLE_SETTINGS ; pub type PWDF_DEVICE_POWER_POLICY_IDLE_SETTINGS = * mut _WDF_DEVICE_POWER_POLICY_IDLE_SETTINGS ; # [ repr ( C ) ] pub struct _WDF_DEVICE_POWER_POLICY_WAKE_SETTINGS { pub Size : ULONG , pub DxState : DEVICE_POWER_STATE , pub UserControlOfWakeSettings : WDF_POWER_POLICY_SX_WAKE_USER_CONTROL , pub Enabled : WDF_TRI_STATE , pub ArmForWakeIfChildrenAreArmedForWake : BOOLEAN , pub IndicateChildWakeOnParentWake : BOOLEAN , } pub type WDF_DEVICE_POWER_POLICY_WAKE_SETTINGS = _WDF_DEVICE_POWER_POLICY_WAKE_SETTINGS ; pub type PWDF_DEVICE_POWER_POLICY_WAKE_SETTINGS = * mut _WDF_DEVICE_POWER_POLICY_WAKE_SETTINGS ; # [ repr ( C ) ] pub struct _WDF_DEVICE_STATE { pub Size : ULONG , pub Disabled : WDF_TRI_STATE , pub DontDisplayInUI : WDF_TRI_STATE , pub Failed : WDF_TRI_STATE , pub NotDisableable : WDF_TRI_STATE , pub Removed : WDF_TRI_STATE , pub ResourcesChanged : WDF_TRI_STATE , } pub type WDF_DEVICE_STATE = _WDF_DEVICE_STATE ; pub type PWDF_DEVICE_STATE = * mut _WDF_DEVICE_STATE ; # [ repr ( C ) ] pub struct _WDF_DEVICE_PNP_CAPABILITIES { pub Size : ULONG , pub LockSupported : WDF_TRI_STATE , pub EjectSupported : WDF_TRI_STATE , pub Removable : WDF_TRI_STATE , pub DockDevice : WDF_TRI_STATE , pub UniqueID : WDF_TRI_STATE , pub SilentInstall : WDF_TRI_STATE , pub SurpriseRemovalOK : WDF_TRI_STATE , pub HardwareDisabled : WDF_TRI_STATE , pub NoDisplayInUI : WDF_TRI_STATE , pub Address : ULONG , pub UINumber : ULONG , } pub type WDF_DEVICE_PNP_CAPABILITIES = _WDF_DEVICE_PNP_CAPABILITIES ; pub type PWDF_DEVICE_PNP_CAPABILITIES = * mut _WDF_DEVICE_PNP_CAPABILITIES ; # [ repr ( C ) ] pub struct _WDF_DEVICE_POWER_CAPABILITIES { pub Size : ULONG , pub DeviceD1 : WDF_TRI_STATE , pub DeviceD2 : WDF_TRI_STATE , pub WakeFromD0 : WDF_TRI_STATE , pub WakeFromD1 : WDF_TRI_STATE , pub WakeFromD2 : WDF_TRI_STATE , pub WakeFromD3 : WDF_TRI_STATE , pub DeviceState : [ DEVICE_POWER_STATE ; 7usize ] , pub DeviceWake : DEVICE_POWER_STATE , pub SystemWake : SYSTEM_POWER_STATE , pub D1Latency : ULONG , pub D2Latency : ULONG , pub D3Latency : ULONG , pub IdealDxStateForSx : DEVICE_POWER_STATE , } pub type WDF_DEVICE_POWER_CAPABILITIES = _WDF_DEVICE_POWER_CAPABILITIES ; pub type PWDF_DEVICE_POWER_CAPABILITIES = * mut _WDF_DEVICE_POWER_CAPABILITIES ; pub const _WDF_REMOVE_LOCK_OPTIONS_FLAGS_WDF_REMOVE_LOCK_OPTION_ACQUIRE_FOR_IO : _WDF_REMOVE_LOCK_OPTIONS_FLAGS = 1 ; pub type _WDF_REMOVE_LOCK_OPTIONS_FLAGS = i32 ; pub use self :: _WDF_REMOVE_LOCK_OPTIONS_FLAGS as WDF_REMOVE_LOCK_OPTIONS_FLAGS ; # [ repr ( C ) ] pub struct _WDF_REMOVE_LOCK_OPTIONS { pub Size : ULONG , pub Flags : ULONG , } pub type WDF_REMOVE_LOCK_OPTIONS = _WDF_REMOVE_LOCK_OPTIONS ; pub type PWDF_REMOVE_LOCK_OPTIONS = * mut _WDF_REMOVE_LOCK_OPTIONS ; pub type EVT_WDFDEVICE_WDM_IRP_PREPROCESS = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE , Irp : PIRP ) -> NTSTATUS > ; pub type PFN_WDFDEVICE_WDM_IRP_PREPROCESS = EVT_WDFDEVICE_WDM_IRP_PREPROCESS ; pub type EVT_WDFDEVICE_WDM_IRP_DISPATCH = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE , MajorFunction : UCHAR , MinorFunction : UCHAR , Code : ULONG , DriverContext : WDFCONTEXT , Irp : PIRP , DispatchContext : WDFCONTEXT ) -> NTSTATUS > ; pub type PFN_WDFDEVICE_WDM_IRP_DISPATCH = EVT_WDFDEVICE_WDM_IRP_DISPATCH ; pub type EVT_WDF_IO_IN_CALLER_CONTEXT = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE , Request : WDFREQUEST ) > ; pub type PFN_WDF_IO_IN_CALLER_CONTEXT = EVT_WDF_IO_IN_CALLER_CONTEXT ; pub type EVT_WDFDEVICE_WDM_POST_PO_FX_REGISTER_DEVICE = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE , PoHandle : POHANDLE ) -> NTSTATUS > ; pub type PFN_WDFDEVICE_WDM_POST_PO_FX_REGISTER_DEVICE = EVT_WDFDEVICE_WDM_POST_PO_FX_REGISTER_DEVICE ; pub type EVT_WDFDEVICE_WDM_PRE_PO_FX_UNREGISTER_DEVICE = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE , PoHandle : POHANDLE ) > ; pub type PFN_WDFDEVICE_WDM_PRE_PO_FX_UNREGISTER_DEVICE = EVT_WDFDEVICE_WDM_PRE_PO_FX_UNREGISTER_DEVICE ; # [ repr ( C ) ] pub struct _WDF_POWER_FRAMEWORK_SETTINGS { pub Size : ULONG , pub EvtDeviceWdmPostPoFxRegisterDevice : PFN_WDFDEVICE_WDM_POST_PO_FX_REGISTER_DEVICE , pub EvtDeviceWdmPrePoFxUnregisterDevice : PFN_WDFDEVICE_WDM_PRE_PO_FX_UNREGISTER_DEVICE , pub Component : PPO_FX_COMPONENT , pub ComponentActiveConditionCallback : PPO_FX_COMPONENT_ACTIVE_CONDITION_CALLBACK , pub ComponentIdleConditionCallback : PPO_FX_COMPONENT_IDLE_CONDITION_CALLBACK , pub ComponentIdleStateCallback : PPO_FX_COMPONENT_IDLE_STATE_CALLBACK , pub PowerControlCallback : PPO_FX_POWER_CONTROL_CALLBACK , pub PoFxDeviceContext : PVOID , } pub type WDF_POWER_FRAMEWORK_SETTINGS = _WDF_POWER_FRAMEWORK_SETTINGS ; pub type PWDF_POWER_FRAMEWORK_SETTINGS = * mut _WDF_POWER_FRAMEWORK_SETTINGS ; # [ repr ( C ) ] pub struct _WDF_IO_TYPE_CONFIG { pub Size : ULONG , pub ReadWriteIoType : WDF_DEVICE_IO_TYPE , pub DeviceControlIoType : WDF_DEVICE_IO_TYPE , pub DirectTransferThreshold : ULONG , } pub type WDF_IO_TYPE_CONFIG = _WDF_IO_TYPE_CONFIG ; pub type PWDF_IO_TYPE_CONFIG = * mut _WDF_IO_TYPE_CONFIG ; # [ repr ( C ) ] pub struct _WDF_DEVICE_PROPERTY_DATA { pub Size : ULONG , pub PropertyKey : * const DEVPROPKEY , pub Lcid : LCID , pub Flags : ULONG , } pub type WDF_DEVICE_PROPERTY_DATA = _WDF_DEVICE_PROPERTY_DATA ; pub type PWDF_DEVICE_PROPERTY_DATA = * mut _WDF_DEVICE_PROPERTY_DATA ; pub type PFN_WDFDEVICEGETDEVICESTATE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , DeviceState : PWDF_DEVICE_STATE ) > ; pub type PFN_WDFDEVICESETDEVICESTATE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , DeviceState : PWDF_DEVICE_STATE ) > ; pub type PFN_WDFWDMDEVICEGETWDFDEVICEHANDLE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceObject : PDEVICE_OBJECT ) -> WDFDEVICE > ; pub type PFN_WDFDEVICEWDMGETDEVICEOBJECT = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE ) -> PDEVICE_OBJECT > ; pub type PFN_WDFDEVICEWDMGETATTACHEDDEVICE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE ) -> PDEVICE_OBJECT > ; pub type PFN_WDFDEVICEWDMGETPHYSICALDEVICE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE ) -> PDEVICE_OBJECT > ; pub type PFN_WDFDEVICEWDMDISPATCHPREPROCESSEDIRP = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , Irp : PIRP ) -> NTSTATUS > ; pub type PFN_WDFDEVICEWDMDISPATCHIRP = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , Irp : PIRP , DispatchContext : WDFCONTEXT ) -> NTSTATUS > ; pub type PFN_WDFDEVICEWDMDISPATCHIRPTOIOQUEUE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , Irp : PIRP , Queue : WDFQUEUE , Flags : ULONG ) -> NTSTATUS > ; pub type PFN_WDFDEVICEADDDEPENDENTUSAGEDEVICEOBJECT = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , DependentDevice : PDEVICE_OBJECT ) -> NTSTATUS > ; pub type PFN_WDFDEVICEREMOVEDEPENDENTUSAGEDEVICEOBJECT = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , DependentDevice : PDEVICE_OBJECT ) > ; pub type PFN_WDFDEVICEADDREMOVALRELATIONSPHYSICALDEVICE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , PhysicalDevice : PDEVICE_OBJECT ) -> NTSTATUS > ; pub type PFN_WDFDEVICEREMOVEREMOVALRELATIONSPHYSICALDEVICE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , PhysicalDevice : PDEVICE_OBJECT ) > ; pub type PFN_WDFDEVICECLEARREMOVALRELATIONSDEVICES = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE ) > ; pub type PFN_WDFDEVICEGETDRIVER = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE ) -> WDFDRIVER > ; pub type PFN_WDFDEVICERETRIEVEDEVICENAME = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , String : WDFSTRING ) -> NTSTATUS > ; pub type PFN_WDFDEVICEASSIGNMOFRESOURCENAME = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , MofResourceName : PCUNICODE_STRING ) -> NTSTATUS > ; pub type PFN_WDFDEVICEGETIOTARGET = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE ) -> WDFIOTARGET > ; pub type PFN_WDFDEVICEGETDEVICEPNPSTATE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE ) -> WDF_DEVICE_PNP_STATE > ; pub type PFN_WDFDEVICEGETDEVICEPOWERSTATE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE ) -> WDF_DEVICE_POWER_STATE > ; pub type PFN_WDFDEVICEGETDEVICEPOWERPOLICYSTATE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE ) -> WDF_DEVICE_POWER_POLICY_STATE > ; pub type PFN_WDFDEVICEASSIGNS0IDLESETTINGS = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , Settings : PWDF_DEVICE_POWER_POLICY_IDLE_SETTINGS ) -> NTSTATUS > ; pub type PFN_WDFDEVICEASSIGNSXWAKESETTINGS = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , Settings : PWDF_DEVICE_POWER_POLICY_WAKE_SETTINGS ) -> NTSTATUS > ; pub type PFN_WDFDEVICEOPENREGISTRYKEY = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , DeviceInstanceKeyType : ULONG , DesiredAccess : ACCESS_MASK , KeyAttributes : PWDF_OBJECT_ATTRIBUTES , Key : * mut WDFKEY ) -> NTSTATUS > ; pub type PFN_WDFDEVICEOPENDEVICEMAPKEY = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , KeyName : PCUNICODE_STRING , DesiredAccess : ACCESS_MASK , KeyAttributes : PWDF_OBJECT_ATTRIBUTES , Key : * mut WDFKEY ) -> NTSTATUS > ; pub type PFN_WDFDEVICESETSPECIALFILESUPPORT = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , FileType : WDF_SPECIAL_FILE_TYPE , FileTypeIsSupported : BOOLEAN ) > ; pub type PFN_WDFDEVICESETCHARACTERISTICS = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , DeviceCharacteristics : ULONG ) > ; pub type PFN_WDFDEVICEGETCHARACTERISTICS = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE ) -> ULONG > ; pub type PFN_WDFDEVICEGETALIGNMENTREQUIREMENT = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE ) -> ULONG > ; pub type PFN_WDFDEVICESETALIGNMENTREQUIREMENT = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , AlignmentRequirement : ULONG ) > ; pub type PFN_WDFDEVICEINITFREE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT ) > ; pub type PFN_WDFDEVICEINITSETPNPPOWEREVENTCALLBACKS = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , PnpPowerEventCallbacks : PWDF_PNPPOWER_EVENT_CALLBACKS ) > ; pub type PFN_WDFDEVICEINITSETPOWERPOLICYEVENTCALLBACKS = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , PowerPolicyEventCallbacks : PWDF_POWER_POLICY_EVENT_CALLBACKS ) > ; pub type PFN_WDFDEVICEINITSETPOWERPOLICYOWNERSHIP = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , IsPowerPolicyOwner : BOOLEAN ) > ; pub type PFN_WDFDEVICEINITREGISTERPNPSTATECHANGECALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , PnpState : WDF_DEVICE_PNP_STATE , EvtDevicePnpStateChange : PFN_WDF_DEVICE_PNP_STATE_CHANGE_NOTIFICATION , CallbackTypes : ULONG ) -> NTSTATUS > ; pub type PFN_WDFDEVICEINITREGISTERPOWERSTATECHANGECALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , PowerState : WDF_DEVICE_POWER_STATE , EvtDevicePowerStateChange : PFN_WDF_DEVICE_POWER_STATE_CHANGE_NOTIFICATION , CallbackTypes : ULONG ) -> NTSTATUS > ; pub type PFN_WDFDEVICEINITREGISTERPOWERPOLICYSTATECHANGECALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , PowerPolicyState : WDF_DEVICE_POWER_POLICY_STATE , EvtDevicePowerPolicyStateChange : PFN_WDF_DEVICE_POWER_POLICY_STATE_CHANGE_NOTIFICATION , CallbackTypes : ULONG ) -> NTSTATUS > ; pub type PFN_WDFDEVICEINITSETEXCLUSIVE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , IsExclusive : BOOLEAN ) > ; pub type PFN_WDFDEVICEINITSETIOTYPE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , IoType : WDF_DEVICE_IO_TYPE ) > ; pub type PFN_WDFDEVICEINITSETPOWERNOTPAGEABLE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT ) > ; pub type PFN_WDFDEVICEINITSETPOWERPAGEABLE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT ) > ; pub type PFN_WDFDEVICEINITSETPOWERINRUSH = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT ) > ; pub type PFN_WDFDEVICEINITSETDEVICETYPE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , DeviceType : ULONG ) > ; pub type PFN_WDFDEVICEINITASSIGNNAME = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , DeviceName : PCUNICODE_STRING ) -> NTSTATUS > ; pub type PFN_WDFDEVICEINITASSIGNSDDLSTRING = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , SDDLString : PCUNICODE_STRING ) -> NTSTATUS > ; pub type PFN_WDFDEVICEINITSETDEVICECLASS = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , DeviceClassGuid : * const GUID ) > ; pub type PFN_WDFDEVICEINITSETCHARACTERISTICS = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , DeviceCharacteristics : ULONG , OrInValues : BOOLEAN ) > ; pub type PFN_WDFDEVICEINITSETFILEOBJECTCONFIG = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , FileObjectConfig : PWDF_FILEOBJECT_CONFIG , FileObjectAttributes : PWDF_OBJECT_ATTRIBUTES ) > ; pub type PFN_WDFDEVICEINITSETREQUESTATTRIBUTES = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , RequestAttributes : PWDF_OBJECT_ATTRIBUTES ) > ; pub type PFN_WDFDEVICEINITASSIGNWDMIRPPREPROCESSCALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , EvtDeviceWdmIrpPreprocess : PFN_WDFDEVICE_WDM_IRP_PREPROCESS , MajorFunction : UCHAR , MinorFunctions : PUCHAR , NumMinorFunctions : ULONG ) -> NTSTATUS > ; pub type PFN_WDFDEVICEINITSETIOINCALLERCONTEXTCALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , EvtIoInCallerContext : PFN_WDF_IO_IN_CALLER_CONTEXT ) > ; pub type PFN_WDFDEVICEINITSETREMOVELOCKOPTIONS = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , Options : PWDF_REMOVE_LOCK_OPTIONS ) > ; pub type PFN_WDFDEVICECREATE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : * mut PWDFDEVICE_INIT , DeviceAttributes : PWDF_OBJECT_ATTRIBUTES , Device : * mut WDFDEVICE ) -> NTSTATUS > ; pub type PFN_WDFDEVICESETSTATICSTOPREMOVE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , Stoppable : BOOLEAN ) > ; pub type PFN_WDFDEVICECREATEDEVICEINTERFACE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , InterfaceClassGUID : * const GUID , ReferenceString : PCUNICODE_STRING ) -> NTSTATUS > ; pub type PFN_WDFDEVICESETDEVICEINTERFACESTATE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , InterfaceClassGUID : * const GUID , ReferenceString : PCUNICODE_STRING , IsInterfaceEnabled : BOOLEAN ) > ; pub type PFN_WDFDEVICERETRIEVEDEVICEINTERFACESTRING = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , InterfaceClassGUID : * const GUID , ReferenceString : PCUNICODE_STRING , String : WDFSTRING ) -> NTSTATUS > ; pub type PFN_WDFDEVICECREATESYMBOLICLINK = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , SymbolicLinkName : PCUNICODE_STRING ) -> NTSTATUS > ; pub type PFN_WDFDEVICEQUERYPROPERTY = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , DeviceProperty : DEVICE_REGISTRY_PROPERTY , BufferLength : ULONG , PropertyBuffer : PVOID , ResultLength : PULONG ) -> NTSTATUS > ; pub type PFN_WDFDEVICEALLOCANDQUERYPROPERTY = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , DeviceProperty : DEVICE_REGISTRY_PROPERTY , PoolType : POOL_TYPE , PropertyMemoryAttributes : PWDF_OBJECT_ATTRIBUTES , PropertyMemory : * mut WDFMEMORY ) -> NTSTATUS > ; pub type PFN_WDFDEVICESETPNPCAPABILITIES = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , PnpCapabilities : PWDF_DEVICE_PNP_CAPABILITIES ) > ; pub type PFN_WDFDEVICESETPOWERCAPABILITIES = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , PowerCapabilities : PWDF_DEVICE_POWER_CAPABILITIES ) > ; pub type PFN_WDFDEVICESETBUSINFORMATIONFORCHILDREN = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , BusInformation : PPNP_BUS_INFORMATION ) > ; pub type PFN_WDFDEVICEINDICATEWAKESTATUS = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , WaitWakeStatus : NTSTATUS ) -> NTSTATUS > ; pub type PFN_WDFDEVICESETFAILED = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , FailedAction : WDF_DEVICE_FAILED_ACTION ) > ; pub type PFN_WDFDEVICESTOPIDLENOTRACK = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , WaitForD0 : BOOLEAN ) -> NTSTATUS > ; pub type PFN_WDFDEVICERESUMEIDLENOTRACK = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE ) > ; pub type PFN_WDFDEVICESTOPIDLEACTUAL = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , WaitForD0 : BOOLEAN , Tag : PVOID , Line : LONG , File : PCCH ) -> NTSTATUS > ; pub type PFN_WDFDEVICERESUMEIDLEACTUAL = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , Tag : PVOID , Line : LONG , File : PCCH ) > ; pub type PFN_WDFDEVICEGETFILEOBJECT = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , FileObject : PFILE_OBJECT ) -> WDFFILEOBJECT > ; pub type PFN_WDFDEVICEENQUEUEREQUEST = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , Request : WDFREQUEST ) -> NTSTATUS > ; pub type PFN_WDFDEVICEGETDEFAULTQUEUE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE ) -> WDFQUEUE > ; pub type PFN_WDFDEVICECONFIGUREREQUESTDISPATCHING = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , Queue : WDFQUEUE , RequestType : WDF_REQUEST_TYPE ) -> NTSTATUS > ; pub type PFN_WDFDEVICECONFIGUREWDMIRPDISPATCHCALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , Driver : WDFDRIVER , MajorFunction : UCHAR , EvtDeviceWdmIrpDisptach : PFN_WDFDEVICE_WDM_IRP_DISPATCH , DriverContext : WDFCONTEXT ) -> NTSTATUS > ; pub type PFN_WDFDEVICEGETSYSTEMPOWERACTION = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE ) -> POWER_ACTION > ; pub type PFN_WDFDEVICEWDMASSIGNPOWERFRAMEWORKSETTINGS = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , PowerFrameworkSettings : PWDF_POWER_FRAMEWORK_SETTINGS ) -> NTSTATUS > ; pub type PFN_WDFDEVICEINITSETRELEASEHARDWAREORDERONFAILURE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , ReleaseHardwareOrderOnFailure : WDF_RELEASE_HARDWARE_ORDER_ON_FAILURE ) > ; pub type PFN_WDFDEVICEINITSETIOTYPEEX = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , IoTypeConfig : PWDF_IO_TYPE_CONFIG ) > ; pub type PFN_WDFDEVICEQUERYPROPERTYEX = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , DeviceProperty : PWDF_DEVICE_PROPERTY_DATA , BufferLength : ULONG , PropertyBuffer : PVOID , RequiredSize : PULONG , Type : PDEVPROPTYPE ) -> NTSTATUS > ; pub type PFN_WDFDEVICEALLOCANDQUERYPROPERTYEX = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , DeviceProperty : PWDF_DEVICE_PROPERTY_DATA , PoolType : POOL_TYPE , PropertyMemoryAttributes : PWDF_OBJECT_ATTRIBUTES , PropertyMemory : * mut WDFMEMORY , Type : PDEVPROPTYPE ) -> NTSTATUS > ; pub type PFN_WDFDEVICEASSIGNPROPERTY = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , DeviceProperty : PWDF_DEVICE_PROPERTY_DATA , Type : DEVPROPTYPE , Size : ULONG , Data : PVOID ) -> NTSTATUS > ; pub type PFN_WDFDEVICERETRIEVECOMPANIONTARGET = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , CompanionTarget : * mut WDFCOMPANIONTARGET ) -> NTSTATUS > ; pub type PFN_WDFCOLLECTIONCREATE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , CollectionAttributes : PWDF_OBJECT_ATTRIBUTES , Collection : * mut WDFCOLLECTION ) -> NTSTATUS > ; pub type PFN_WDFCOLLECTIONGETCOUNT = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Collection : WDFCOLLECTION ) -> ULONG > ; pub type PFN_WDFCOLLECTIONADD = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Collection : WDFCOLLECTION , Object : WDFOBJECT ) -> NTSTATUS > ; pub type PFN_WDFCOLLECTIONREMOVE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Collection : WDFCOLLECTION , Item : WDFOBJECT ) > ; pub type PFN_WDFCOLLECTIONREMOVEITEM = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Collection : WDFCOLLECTION , Index : ULONG ) > ; pub type PFN_WDFCOLLECTIONGETITEM = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Collection : WDFCOLLECTION , Index : ULONG ) -> WDFOBJECT > ; pub type PFN_WDFCOLLECTIONGETFIRSTITEM = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Collection : WDFCOLLECTION ) -> WDFOBJECT > ; pub type PFN_WDFCOLLECTIONGETLASTITEM = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Collection : WDFCOLLECTION ) -> WDFOBJECT > ; pub type EVT_WDF_DPC = :: std :: option :: Option < unsafe extern "C" fn ( Dpc : WDFDPC ) > ; pub type PFN_WDF_DPC = EVT_WDF_DPC ; # [ repr ( C ) ] pub struct _WDF_DPC_CONFIG { pub Size : ULONG , pub EvtDpcFunc : PFN_WDF_DPC , pub AutomaticSerialization : BOOLEAN , } pub type WDF_DPC_CONFIG = _WDF_DPC_CONFIG ; pub type PWDF_DPC_CONFIG = * mut _WDF_DPC_CONFIG ; pub type PFN_WDFDPCCREATE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Config : PWDF_DPC_CONFIG , Attributes : PWDF_OBJECT_ATTRIBUTES , Dpc : * mut WDFDPC ) -> NTSTATUS > ; pub type PFN_WDFDPCENQUEUE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Dpc : WDFDPC ) -> BOOLEAN > ; pub type PFN_WDFDPCCANCEL = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Dpc : WDFDPC , Wait : BOOLEAN ) -> BOOLEAN > ; pub type PFN_WDFDPCGETPARENTOBJECT = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Dpc : WDFDPC ) -> WDFOBJECT > ; pub type PFN_WDFDPCWDMGETDPC = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Dpc : WDFDPC ) -> PKDPC > ; pub type EVT_WDF_TIMER = :: std :: option :: Option < unsafe extern "C" fn ( Timer : WDFTIMER ) > ; pub type PFN_WDF_TIMER = EVT_WDF_TIMER ; # [ repr ( C ) ] pub struct _WDF_TIMER_CONFIG { pub Size : ULONG , pub EvtTimerFunc : PFN_WDF_TIMER , pub Period : ULONG , pub AutomaticSerialization : BOOLEAN , pub TolerableDelay : ULONG , pub __bindgen_padding_0 : [ u8 ; 4usize ] , pub UseHighResolutionTimer : BOOLEAN , } pub type WDF_TIMER_CONFIG = _WDF_TIMER_CONFIG ; pub type PWDF_TIMER_CONFIG = * mut _WDF_TIMER_CONFIG ; pub type PFN_WDFTIMERCREATE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Config : PWDF_TIMER_CONFIG , Attributes : PWDF_OBJECT_ATTRIBUTES , Timer : * mut WDFTIMER ) -> NTSTATUS > ; pub type PFN_WDFTIMERSTART = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Timer : WDFTIMER , DueTime : LONGLONG ) -> BOOLEAN > ; pub type PFN_WDFTIMERSTOP = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Timer : WDFTIMER , Wait : BOOLEAN ) -> BOOLEAN > ; pub type PFN_WDFTIMERGETPARENTOBJECT = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Timer : WDFTIMER ) -> WDFOBJECT > ; pub type EVT_WDF_WORKITEM = :: std :: option :: Option < unsafe extern "C" fn ( WorkItem : WDFWORKITEM ) > ; pub type PFN_WDF_WORKITEM = EVT_WDF_WORKITEM ; # [ repr ( C ) ] pub struct _WDF_WORKITEM_CONFIG { pub Size : ULONG , pub EvtWorkItemFunc : PFN_WDF_WORKITEM , pub AutomaticSerialization : BOOLEAN , } pub type WDF_WORKITEM_CONFIG = _WDF_WORKITEM_CONFIG ; pub type PWDF_WORKITEM_CONFIG = * mut _WDF_WORKITEM_CONFIG ; pub type PFN_WDFWORKITEMCREATE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Config : PWDF_WORKITEM_CONFIG , Attributes : PWDF_OBJECT_ATTRIBUTES , WorkItem : * mut WDFWORKITEM ) -> NTSTATUS > ; pub type PFN_WDFWORKITEMENQUEUE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , WorkItem : WDFWORKITEM ) > ; pub type PFN_WDFWORKITEMGETPARENTOBJECT = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , WorkItem : WDFWORKITEM ) -> WDFOBJECT > ; pub type PFN_WDFWORKITEMFLUSH = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , WorkItem : WDFWORKITEM ) > ; pub const _WDF_INTERRUPT_POLARITY_WdfInterruptPolarityUnknown : _WDF_INTERRUPT_POLARITY = 0 ; pub const _WDF_INTERRUPT_POLARITY_WdfInterruptActiveHigh : _WDF_INTERRUPT_POLARITY = 1 ; pub const _WDF_INTERRUPT_POLARITY_WdfInterruptActiveLow : _WDF_INTERRUPT_POLARITY = 2 ; pub type _WDF_INTERRUPT_POLARITY = i32 ; pub use self :: _WDF_INTERRUPT_POLARITY as WDF_INTERRUPT_POLARITY ; pub type PWDF_INTERRUPT_POLARITY = * mut _WDF_INTERRUPT_POLARITY ; pub const _WDF_INTERRUPT_POLICY_WdfIrqPolicyMachineDefault : _WDF_INTERRUPT_POLICY = 0 ; pub const _WDF_INTERRUPT_POLICY_WdfIrqPolicyAllCloseProcessors : _WDF_INTERRUPT_POLICY = 1 ; pub const _WDF_INTERRUPT_POLICY_WdfIrqPolicyOneCloseProcessor : _WDF_INTERRUPT_POLICY = 2 ; pub const _WDF_INTERRUPT_POLICY_WdfIrqPolicyAllProcessorsInMachine : _WDF_INTERRUPT_POLICY = 3 ; pub const _WDF_INTERRUPT_POLICY_WdfIrqPolicySpecifiedProcessors : _WDF_INTERRUPT_POLICY = 4 ; pub const _WDF_INTERRUPT_POLICY_WdfIrqPolicySpreadMessagesAcrossAllProcessors : _WDF_INTERRUPT_POLICY = 5 ; pub type _WDF_INTERRUPT_POLICY = i32 ; pub use self :: _WDF_INTERRUPT_POLICY as WDF_INTERRUPT_POLICY ; pub type PWDF_INTERRUPT_POLICY = * mut _WDF_INTERRUPT_POLICY ; pub const _WDF_INTERRUPT_PRIORITY_WdfIrqPriorityUndefined : _WDF_INTERRUPT_PRIORITY = 0 ; pub const _WDF_INTERRUPT_PRIORITY_WdfIrqPriorityLow : _WDF_INTERRUPT_PRIORITY = 1 ; pub const _WDF_INTERRUPT_PRIORITY_WdfIrqPriorityNormal : _WDF_INTERRUPT_PRIORITY = 2 ; pub const _WDF_INTERRUPT_PRIORITY_WdfIrqPriorityHigh : _WDF_INTERRUPT_PRIORITY = 3 ; pub type _WDF_INTERRUPT_PRIORITY = i32 ; pub use self :: _WDF_INTERRUPT_PRIORITY as WDF_INTERRUPT_PRIORITY ; pub type PWDF_INTERRUPT_PRIORITY = * mut _WDF_INTERRUPT_PRIORITY ; pub type EVT_WDF_INTERRUPT_ISR = :: std :: option :: Option < unsafe extern "C" fn ( Interrupt : WDFINTERRUPT , MessageID : ULONG ) -> BOOLEAN > ; pub type PFN_WDF_INTERRUPT_ISR = EVT_WDF_INTERRUPT_ISR ; pub type EVT_WDF_INTERRUPT_SYNCHRONIZE = :: std :: option :: Option < unsafe extern "C" fn ( Interrupt : WDFINTERRUPT , Context : WDFCONTEXT ) -> BOOLEAN > ; pub type PFN_WDF_INTERRUPT_SYNCHRONIZE = EVT_WDF_INTERRUPT_SYNCHRONIZE ; pub type EVT_WDF_INTERRUPT_DPC = :: std :: option :: Option < unsafe extern "C" fn ( Interrupt : WDFINTERRUPT , AssociatedObject : WDFOBJECT ) > ; pub type PFN_WDF_INTERRUPT_DPC = EVT_WDF_INTERRUPT_DPC ; pub type EVT_WDF_INTERRUPT_WORKITEM = :: std :: option :: Option < unsafe extern "C" fn ( Interrupt : WDFINTERRUPT , AssociatedObject : WDFOBJECT ) > ; pub type PFN_WDF_INTERRUPT_WORKITEM = EVT_WDF_INTERRUPT_WORKITEM ; pub type EVT_WDF_INTERRUPT_ENABLE = :: std :: option :: Option < unsafe extern "C" fn ( Interrupt : WDFINTERRUPT , AssociatedDevice : WDFDEVICE ) -> NTSTATUS > ; pub type PFN_WDF_INTERRUPT_ENABLE = EVT_WDF_INTERRUPT_ENABLE ; pub type EVT_WDF_INTERRUPT_DISABLE = :: std :: option :: Option < unsafe extern "C" fn ( Interrupt : WDFINTERRUPT , AssociatedDevice : WDFDEVICE ) -> NTSTATUS > ; pub type PFN_WDF_INTERRUPT_DISABLE = EVT_WDF_INTERRUPT_DISABLE ; # [ repr ( C ) ] pub struct _WDF_INTERRUPT_CONFIG { pub Size : ULONG , pub SpinLock : WDFSPINLOCK , pub ShareVector : WDF_TRI_STATE , pub FloatingSave : BOOLEAN , pub AutomaticSerialization : BOOLEAN , pub EvtInterruptIsr : PFN_WDF_INTERRUPT_ISR , pub EvtInterruptDpc : PFN_WDF_INTERRUPT_DPC , pub EvtInterruptEnable : PFN_WDF_INTERRUPT_ENABLE , pub EvtInterruptDisable : PFN_WDF_INTERRUPT_DISABLE , pub EvtInterruptWorkItem : PFN_WDF_INTERRUPT_WORKITEM , pub InterruptRaw : PCM_PARTIAL_RESOURCE_DESCRIPTOR , pub InterruptTranslated : PCM_PARTIAL_RESOURCE_DESCRIPTOR , pub WaitLock : WDFWAITLOCK , pub PassiveHandling : BOOLEAN , pub ReportInactiveOnPowerDown : WDF_TRI_STATE , pub CanWakeDevice : BOOLEAN , } pub type WDF_INTERRUPT_CONFIG = _WDF_INTERRUPT_CONFIG ; pub type PWDF_INTERRUPT_CONFIG = * mut _WDF_INTERRUPT_CONFIG ; # [ repr ( C ) ] pub struct _WDF_INTERRUPT_INFO { pub Size : ULONG , pub Reserved1 : ULONG64 , pub TargetProcessorSet : KAFFINITY , pub Reserved2 : ULONG , pub MessageNumber : ULONG , pub Vector : ULONG , pub Irql : KIRQL , pub Mode : KINTERRUPT_MODE , pub Polarity : WDF_INTERRUPT_POLARITY , pub MessageSignaled : BOOLEAN , pub ShareDisposition : UCHAR , pub __bindgen_padding_0 : [ u16 ; 3usize ] , pub Group : USHORT , } pub type WDF_INTERRUPT_INFO = _WDF_INTERRUPT_INFO ; pub type PWDF_INTERRUPT_INFO = * mut _WDF_INTERRUPT_INFO ; # [ repr ( C ) ] pub struct _WDF_INTERRUPT_EXTENDED_POLICY { pub Size : ULONG , pub Policy : WDF_INTERRUPT_POLICY , pub Priority : WDF_INTERRUPT_PRIORITY , pub TargetProcessorSetAndGroup : GROUP_AFFINITY , } pub type WDF_INTERRUPT_EXTENDED_POLICY = _WDF_INTERRUPT_EXTENDED_POLICY ; pub type PWDF_INTERRUPT_EXTENDED_POLICY = * mut _WDF_INTERRUPT_EXTENDED_POLICY ; pub type PFN_WDFINTERRUPTCREATE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , Configuration : PWDF_INTERRUPT_CONFIG , Attributes : PWDF_OBJECT_ATTRIBUTES , Interrupt : * mut WDFINTERRUPT ) -> NTSTATUS > ; pub type PFN_WDFINTERRUPTQUEUEDPCFORISR = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Interrupt : WDFINTERRUPT ) -> BOOLEAN > ; pub type PFN_WDFINTERRUPTQUEUEWORKITEMFORISR = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Interrupt : WDFINTERRUPT ) -> BOOLEAN > ; pub type PFN_WDFINTERRUPTSYNCHRONIZE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Interrupt : WDFINTERRUPT , Callback : PFN_WDF_INTERRUPT_SYNCHRONIZE , Context : WDFCONTEXT ) -> BOOLEAN > ; pub type PFN_WDFINTERRUPTACQUIRELOCK = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Interrupt : WDFINTERRUPT ) > ; pub type PFN_WDFINTERRUPTRELEASELOCK = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Interrupt : WDFINTERRUPT ) > ; pub type PFN_WDFINTERRUPTENABLE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Interrupt : WDFINTERRUPT ) > ; pub type PFN_WDFINTERRUPTDISABLE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Interrupt : WDFINTERRUPT ) > ; pub type PFN_WDFINTERRUPTWDMGETINTERRUPT = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Interrupt : WDFINTERRUPT ) -> PKINTERRUPT > ; pub type PFN_WDFINTERRUPTGETINFO = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Interrupt : WDFINTERRUPT , Info : PWDF_INTERRUPT_INFO ) > ; pub type PFN_WDFINTERRUPTSETPOLICY = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Interrupt : WDFINTERRUPT , Policy : WDF_INTERRUPT_POLICY , Priority : WDF_INTERRUPT_PRIORITY , TargetProcessorSet : KAFFINITY ) > ; pub type PFN_WDFINTERRUPTSETEXTENDEDPOLICY = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Interrupt : WDFINTERRUPT , PolicyAndGroup : PWDF_INTERRUPT_EXTENDED_POLICY ) > ; pub type PFN_WDFINTERRUPTGETDEVICE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Interrupt : WDFINTERRUPT ) -> WDFDEVICE > ; pub type PFN_WDFINTERRUPTTRYTOACQUIRELOCK = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Interrupt : WDFINTERRUPT ) -> BOOLEAN > ; pub type PFN_WDFINTERRUPTREPORTACTIVE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Interrupt : WDFINTERRUPT ) > ; pub type PFN_WDFINTERRUPTREPORTINACTIVE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Interrupt : WDFINTERRUPT ) > ; pub type PFN_WDFIORESOURCEREQUIREMENTSLISTSETSLOTNUMBER = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , RequirementsList : WDFIORESREQLIST , SlotNumber : ULONG ) > ; pub type PFN_WDFIORESOURCEREQUIREMENTSLISTSETINTERFACETYPE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , RequirementsList : WDFIORESREQLIST , InterfaceType : INTERFACE_TYPE ) > ; pub type PFN_WDFIORESOURCEREQUIREMENTSLISTAPPENDIORESLIST = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , RequirementsList : WDFIORESREQLIST , IoResList : WDFIORESLIST ) -> NTSTATUS > ; pub type PFN_WDFIORESOURCEREQUIREMENTSLISTINSERTIORESLIST = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , RequirementsList : WDFIORESREQLIST , IoResList : WDFIORESLIST , Index : ULONG ) -> NTSTATUS > ; pub type PFN_WDFIORESOURCEREQUIREMENTSLISTGETCOUNT = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , RequirementsList : WDFIORESREQLIST ) -> ULONG > ; pub type PFN_WDFIORESOURCEREQUIREMENTSLISTGETIORESLIST = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , RequirementsList : WDFIORESREQLIST , Index : ULONG ) -> WDFIORESLIST > ; pub type PFN_WDFIORESOURCEREQUIREMENTSLISTREMOVE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , RequirementsList : WDFIORESREQLIST , Index : ULONG ) > ; pub type PFN_WDFIORESOURCEREQUIREMENTSLISTREMOVEBYIORESLIST = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , RequirementsList : WDFIORESREQLIST , IoResList : WDFIORESLIST ) > ; pub type PFN_WDFIORESOURCELISTCREATE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , RequirementsList : WDFIORESREQLIST , Attributes : PWDF_OBJECT_ATTRIBUTES , ResourceList : * mut WDFIORESLIST ) -> NTSTATUS > ; pub type PFN_WDFIORESOURCELISTAPPENDDESCRIPTOR = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , ResourceList : WDFIORESLIST , Descriptor : PIO_RESOURCE_DESCRIPTOR ) -> NTSTATUS > ; pub type PFN_WDFIORESOURCELISTINSERTDESCRIPTOR = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , ResourceList : WDFIORESLIST , Descriptor : PIO_RESOURCE_DESCRIPTOR , Index : ULONG ) -> NTSTATUS > ; pub type PFN_WDFIORESOURCELISTUPDATEDESCRIPTOR = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , ResourceList : WDFIORESLIST , Descriptor : PIO_RESOURCE_DESCRIPTOR , Index : ULONG ) > ; pub type PFN_WDFIORESOURCELISTGETCOUNT = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , ResourceList : WDFIORESLIST ) -> ULONG > ; pub type PFN_WDFIORESOURCELISTGETDESCRIPTOR = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , ResourceList : WDFIORESLIST , Index : ULONG ) -> PIO_RESOURCE_DESCRIPTOR > ; pub type PFN_WDFIORESOURCELISTREMOVE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , ResourceList : WDFIORESLIST , Index : ULONG ) > ; pub type PFN_WDFIORESOURCELISTREMOVEBYDESCRIPTOR = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , ResourceList : WDFIORESLIST , Descriptor : PIO_RESOURCE_DESCRIPTOR ) > ; pub type PFN_WDFCMRESOURCELISTAPPENDDESCRIPTOR = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , List : WDFCMRESLIST , Descriptor : PCM_PARTIAL_RESOURCE_DESCRIPTOR ) -> NTSTATUS > ; pub type PFN_WDFCMRESOURCELISTINSERTDESCRIPTOR = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , List : WDFCMRESLIST , Descriptor : PCM_PARTIAL_RESOURCE_DESCRIPTOR , Index : ULONG ) -> NTSTATUS > ; pub type PFN_WDFCMRESOURCELISTGETCOUNT = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , List : WDFCMRESLIST ) -> ULONG > ; pub type PFN_WDFCMRESOURCELISTGETDESCRIPTOR = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , List : WDFCMRESLIST , Index : ULONG ) -> PCM_PARTIAL_RESOURCE_DESCRIPTOR > ; pub type PFN_WDFCMRESOURCELISTREMOVE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , List : WDFCMRESLIST , Index : ULONG ) > ; pub type PFN_WDFCMRESOURCELISTREMOVEBYDESCRIPTOR = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , List : WDFCMRESLIST , Descriptor : PCM_PARTIAL_RESOURCE_DESCRIPTOR ) > ; pub const _WDF_REQUEST_TYPE_WdfRequestTypeCreate : _WDF_REQUEST_TYPE = 0 ; pub const _WDF_REQUEST_TYPE_WdfRequestTypeCreateNamedPipe : _WDF_REQUEST_TYPE = 1 ; pub const _WDF_REQUEST_TYPE_WdfRequestTypeClose : _WDF_REQUEST_TYPE = 2 ; pub const _WDF_REQUEST_TYPE_WdfRequestTypeRead : _WDF_REQUEST_TYPE = 3 ; pub const _WDF_REQUEST_TYPE_WdfRequestTypeWrite : _WDF_REQUEST_TYPE = 4 ; pub const _WDF_REQUEST_TYPE_WdfRequestTypeQueryInformation : _WDF_REQUEST_TYPE = 5 ; pub const _WDF_REQUEST_TYPE_WdfRequestTypeSetInformation : _WDF_REQUEST_TYPE = 6 ; pub const _WDF_REQUEST_TYPE_WdfRequestTypeQueryEA : _WDF_REQUEST_TYPE = 7 ; pub const _WDF_REQUEST_TYPE_WdfRequestTypeSetEA : _WDF_REQUEST_TYPE = 8 ; pub const _WDF_REQUEST_TYPE_WdfRequestTypeFlushBuffers : _WDF_REQUEST_TYPE = 9 ; pub const _WDF_REQUEST_TYPE_WdfRequestTypeQueryVolumeInformation : _WDF_REQUEST_TYPE = 10 ; pub const _WDF_REQUEST_TYPE_WdfRequestTypeSetVolumeInformation : _WDF_REQUEST_TYPE = 11 ; pub const _WDF_REQUEST_TYPE_WdfRequestTypeDirectoryControl : _WDF_REQUEST_TYPE = 12 ; pub const _WDF_REQUEST_TYPE_WdfRequestTypeFileSystemControl : _WDF_REQUEST_TYPE = 13 ; pub const _WDF_REQUEST_TYPE_WdfRequestTypeDeviceControl : _WDF_REQUEST_TYPE = 14 ; pub const _WDF_REQUEST_TYPE_WdfRequestTypeDeviceControlInternal : _WDF_REQUEST_TYPE = 15 ; pub const _WDF_REQUEST_TYPE_WdfRequestTypeShutdown : _WDF_REQUEST_TYPE = 16 ; pub const _WDF_REQUEST_TYPE_WdfRequestTypeLockControl : _WDF_REQUEST_TYPE = 17 ; pub const _WDF_REQUEST_TYPE_WdfRequestTypeCleanup : _WDF_REQUEST_TYPE = 18 ; pub const _WDF_REQUEST_TYPE_WdfRequestTypeCreateMailSlot : _WDF_REQUEST_TYPE = 19 ; pub const _WDF_REQUEST_TYPE_WdfRequestTypeQuerySecurity : _WDF_REQUEST_TYPE = 20 ; pub const _WDF_REQUEST_TYPE_WdfRequestTypeSetSecurity : _WDF_REQUEST_TYPE = 21 ; pub const _WDF_REQUEST_TYPE_WdfRequestTypePower : _WDF_REQUEST_TYPE = 22 ; pub const _WDF_REQUEST_TYPE_WdfRequestTypeSystemControl : _WDF_REQUEST_TYPE = 23 ; pub const _WDF_REQUEST_TYPE_WdfRequestTypeDeviceChange : _WDF_REQUEST_TYPE = 24 ; pub const _WDF_REQUEST_TYPE_WdfRequestTypeQueryQuota : _WDF_REQUEST_TYPE = 25 ; pub const _WDF_REQUEST_TYPE_WdfRequestTypeSetQuota : _WDF_REQUEST_TYPE = 26 ; pub const _WDF_REQUEST_TYPE_WdfRequestTypePnp : _WDF_REQUEST_TYPE = 27 ; pub const _WDF_REQUEST_TYPE_WdfRequestTypeOther : _WDF_REQUEST_TYPE = 28 ; pub const _WDF_REQUEST_TYPE_WdfRequestTypeUsb : _WDF_REQUEST_TYPE = 64 ; pub const _WDF_REQUEST_TYPE_WdfRequestTypeNoFormat : _WDF_REQUEST_TYPE = 255 ; pub const _WDF_REQUEST_TYPE_WdfRequestTypeMax : _WDF_REQUEST_TYPE = 256 ; pub type _WDF_REQUEST_TYPE = i32 ; pub const _WDF_REQUEST_REUSE_FLAGS_WDF_REQUEST_REUSE_NO_FLAGS : _WDF_REQUEST_REUSE_FLAGS = 0 ; pub const _WDF_REQUEST_REUSE_FLAGS_WDF_REQUEST_REUSE_SET_NEW_IRP : _WDF_REQUEST_REUSE_FLAGS = 1 ; pub type _WDF_REQUEST_REUSE_FLAGS = i32 ; pub use self :: _WDF_REQUEST_REUSE_FLAGS as WDF_REQUEST_REUSE_FLAGS ; pub const _WDF_REQUEST_STOP_ACTION_FLAGS_WdfRequestStopActionInvalid : _WDF_REQUEST_STOP_ACTION_FLAGS = 0 ; pub const _WDF_REQUEST_STOP_ACTION_FLAGS_WdfRequestStopActionSuspend : _WDF_REQUEST_STOP_ACTION_FLAGS = 1 ; pub const _WDF_REQUEST_STOP_ACTION_FLAGS_WdfRequestStopActionPurge : _WDF_REQUEST_STOP_ACTION_FLAGS = 2 ; pub const _WDF_REQUEST_STOP_ACTION_FLAGS_WdfRequestStopRequestCancelable : _WDF_REQUEST_STOP_ACTION_FLAGS = 268435456 ; pub type _WDF_REQUEST_STOP_ACTION_FLAGS = i32 ; pub use self :: _WDF_REQUEST_STOP_ACTION_FLAGS as WDF_REQUEST_STOP_ACTION_FLAGS ; pub const _WDF_REQUEST_SEND_OPTIONS_FLAGS_WDF_REQUEST_SEND_OPTION_TIMEOUT : _WDF_REQUEST_SEND_OPTIONS_FLAGS = 1 ; pub const _WDF_REQUEST_SEND_OPTIONS_FLAGS_WDF_REQUEST_SEND_OPTION_SYNCHRONOUS : _WDF_REQUEST_SEND_OPTIONS_FLAGS = 2 ; pub const _WDF_REQUEST_SEND_OPTIONS_FLAGS_WDF_REQUEST_SEND_OPTION_IGNORE_TARGET_STATE : _WDF_REQUEST_SEND_OPTIONS_FLAGS = 4 ; pub const _WDF_REQUEST_SEND_OPTIONS_FLAGS_WDF_REQUEST_SEND_OPTION_SEND_AND_FORGET : _WDF_REQUEST_SEND_OPTIONS_FLAGS = 8 ; pub const _WDF_REQUEST_SEND_OPTIONS_FLAGS_WDF_REQUEST_SEND_OPTION_IMPERSONATE_CLIENT : _WDF_REQUEST_SEND_OPTIONS_FLAGS = 65536 ; pub const _WDF_REQUEST_SEND_OPTIONS_FLAGS_WDF_REQUEST_SEND_OPTION_IMPERSONATION_IGNORE_FAILURE : _WDF_REQUEST_SEND_OPTIONS_FLAGS = 131072 ; pub type _WDF_REQUEST_SEND_OPTIONS_FLAGS = i32 ; pub use self :: _WDF_REQUEST_SEND_OPTIONS_FLAGS as WDF_REQUEST_SEND_OPTIONS_FLAGS ; pub type EVT_WDF_REQUEST_CANCEL = :: std :: option :: Option < unsafe extern "C" fn ( Request : WDFREQUEST ) > ; pub type PFN_WDF_REQUEST_CANCEL = EVT_WDF_REQUEST_CANCEL ; # [ repr ( C ) ] pub struct _WDF_REQUEST_PARAMETERS { pub Size : USHORT , pub MinorFunction : UCHAR , pub Type : WDF_REQUEST_TYPE , pub Parameters : _WDF_REQUEST_PARAMETERS__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _WDF_REQUEST_PARAMETERS__bindgen_ty_1 { pub Create : __BindgenUnionField < _WDF_REQUEST_PARAMETERS__bindgen_ty_1__bindgen_ty_1 > , pub Read : __BindgenUnionField < _WDF_REQUEST_PARAMETERS__bindgen_ty_1__bindgen_ty_2 > , pub Write : __BindgenUnionField < _WDF_REQUEST_PARAMETERS__bindgen_ty_1__bindgen_ty_3 > , pub DeviceIoControl : __BindgenUnionField < _WDF_REQUEST_PARAMETERS__bindgen_ty_1__bindgen_ty_4 > , pub Others : __BindgenUnionField < _WDF_REQUEST_PARAMETERS__bindgen_ty_1__bindgen_ty_5 > , pub bindgen_union_field : [ u64 ; 4usize ] , } # [ repr ( C ) ] pub struct _WDF_REQUEST_PARAMETERS__bindgen_ty_1__bindgen_ty_1 { pub SecurityContext : PIO_SECURITY_CONTEXT , pub Options : ULONG , pub __bindgen_padding_0 : [ u16 ; 2usize ] , pub FileAttributes : USHORT , pub ShareAccess : USHORT , pub __bindgen_padding_1 : u32 , pub EaLength : ULONG , } # [ repr ( C ) ] pub struct _WDF_REQUEST_PARAMETERS__bindgen_ty_1__bindgen_ty_2 { pub Length : usize , pub Key : ULONG , pub DeviceOffset : LONGLONG , } # [ repr ( C ) ] pub struct _WDF_REQUEST_PARAMETERS__bindgen_ty_1__bindgen_ty_3 { pub Length : usize , pub Key : ULONG , pub DeviceOffset : LONGLONG , } # [ repr ( C ) ] pub struct _WDF_REQUEST_PARAMETERS__bindgen_ty_1__bindgen_ty_4 { pub OutputBufferLength : usize , pub InputBufferLength : usize , pub IoControlCode : ULONG , pub Type3InputBuffer : PVOID , } # [ repr ( C ) ] pub struct _WDF_REQUEST_PARAMETERS__bindgen_ty_1__bindgen_ty_5 { pub Arg1 : PVOID , pub Arg2 : PVOID , pub IoControlCode : ULONG , pub Arg4 : PVOID , } pub type WDF_REQUEST_PARAMETERS = _WDF_REQUEST_PARAMETERS ; pub type PWDF_REQUEST_PARAMETERS = * mut _WDF_REQUEST_PARAMETERS ; # [ repr ( C ) ] pub struct _WDF_USB_REQUEST_COMPLETION_PARAMS { _unused : [ u8 ; 0 ] , } pub type PWDF_USB_REQUEST_COMPLETION_PARAMS = * mut _WDF_USB_REQUEST_COMPLETION_PARAMS ; # [ repr ( C ) ] pub struct _WDF_REQUEST_COMPLETION_PARAMS { pub Size : ULONG , pub Type : WDF_REQUEST_TYPE , pub IoStatus : IO_STATUS_BLOCK , pub Parameters : _WDF_REQUEST_COMPLETION_PARAMS__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _WDF_REQUEST_COMPLETION_PARAMS__bindgen_ty_1 { pub Write : __BindgenUnionField < _WDF_REQUEST_COMPLETION_PARAMS__bindgen_ty_1__bindgen_ty_1 > , pub Read : __BindgenUnionField < _WDF_REQUEST_COMPLETION_PARAMS__bindgen_ty_1__bindgen_ty_2 > , pub Ioctl : __BindgenUnionField < _WDF_REQUEST_COMPLETION_PARAMS__bindgen_ty_1__bindgen_ty_3 > , pub Others : __BindgenUnionField < _WDF_REQUEST_COMPLETION_PARAMS__bindgen_ty_1__bindgen_ty_4 > , pub Usb : __BindgenUnionField < _WDF_REQUEST_COMPLETION_PARAMS__bindgen_ty_1__bindgen_ty_5 > , pub bindgen_union_field : [ u64 ; 6usize ] , } # [ repr ( C ) ] pub struct _WDF_REQUEST_COMPLETION_PARAMS__bindgen_ty_1__bindgen_ty_1 { pub Buffer : WDFMEMORY , pub Length : usize , pub Offset : usize , } # [ repr ( C ) ] pub struct _WDF_REQUEST_COMPLETION_PARAMS__bindgen_ty_1__bindgen_ty_2 { pub Buffer : WDFMEMORY , pub Length : usize , pub Offset : usize , } # [ repr ( C ) ] pub struct _WDF_REQUEST_COMPLETION_PARAMS__bindgen_ty_1__bindgen_ty_3 { pub IoControlCode : ULONG , pub Input : _WDF_REQUEST_COMPLETION_PARAMS__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 , pub Output : _WDF_REQUEST_COMPLETION_PARAMS__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2 , } # [ repr ( C ) ] pub struct _WDF_REQUEST_COMPLETION_PARAMS__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 { pub Buffer : WDFMEMORY , pub Offset : usize , } # [ repr ( C ) ] pub struct _WDF_REQUEST_COMPLETION_PARAMS__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2 { pub Buffer : WDFMEMORY , pub Offset : usize , pub Length : usize , } # [ repr ( C ) ] pub struct _WDF_REQUEST_COMPLETION_PARAMS__bindgen_ty_1__bindgen_ty_4 { pub Argument1 : _WDF_REQUEST_COMPLETION_PARAMS__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 , pub Argument2 : _WDF_REQUEST_COMPLETION_PARAMS__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2 , pub Argument3 : _WDF_REQUEST_COMPLETION_PARAMS__bindgen_ty_1__bindgen_ty_4__bindgen_ty_3 , pub Argument4 : _WDF_REQUEST_COMPLETION_PARAMS__bindgen_ty_1__bindgen_ty_4__bindgen_ty_4 , } # [ repr ( C ) ] pub struct _WDF_REQUEST_COMPLETION_PARAMS__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 { pub Ptr : __BindgenUnionField < PVOID > , pub Value : __BindgenUnionField < ULONG_PTR > , pub bindgen_union_field : u64 , } # [ repr ( C ) ] pub struct _WDF_REQUEST_COMPLETION_PARAMS__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2 { pub Ptr : __BindgenUnionField < PVOID > , pub Value : __BindgenUnionField < ULONG_PTR > , pub bindgen_union_field : u64 , } # [ repr ( C ) ] pub struct _WDF_REQUEST_COMPLETION_PARAMS__bindgen_ty_1__bindgen_ty_4__bindgen_ty_3 { pub Ptr : __BindgenUnionField < PVOID > , pub Value : __BindgenUnionField < ULONG_PTR > , pub bindgen_union_field : u64 , } # [ repr ( C ) ] pub struct _WDF_REQUEST_COMPLETION_PARAMS__bindgen_ty_1__bindgen_ty_4__bindgen_ty_4 { pub Ptr : __BindgenUnionField < PVOID > , pub Value : __BindgenUnionField < ULONG_PTR > , pub bindgen_union_field : u64 , } # [ repr ( C ) ] pub struct _WDF_REQUEST_COMPLETION_PARAMS__bindgen_ty_1__bindgen_ty_5 { pub Completion : PWDF_USB_REQUEST_COMPLETION_PARAMS , } pub type WDF_REQUEST_COMPLETION_PARAMS = _WDF_REQUEST_COMPLETION_PARAMS ; pub type PWDF_REQUEST_COMPLETION_PARAMS = * mut _WDF_REQUEST_COMPLETION_PARAMS ; pub type EVT_WDF_REQUEST_COMPLETION_ROUTINE = :: std :: option :: Option < unsafe extern "C" fn ( Request : WDFREQUEST , Target : WDFIOTARGET , Params : PWDF_REQUEST_COMPLETION_PARAMS , Context : WDFCONTEXT ) > ; pub type PFN_WDF_REQUEST_COMPLETION_ROUTINE = EVT_WDF_REQUEST_COMPLETION_ROUTINE ; # [ repr ( C ) ] pub struct _WDF_REQUEST_REUSE_PARAMS { pub Size : ULONG , pub Flags : ULONG , pub Status : NTSTATUS , pub NewIrp : PIRP , } pub type WDF_REQUEST_REUSE_PARAMS = _WDF_REQUEST_REUSE_PARAMS ; pub type PWDF_REQUEST_REUSE_PARAMS = * mut _WDF_REQUEST_REUSE_PARAMS ; # [ repr ( C ) ] pub struct _WDF_REQUEST_SEND_OPTIONS { pub Size : ULONG , pub Flags : ULONG , pub Timeout : LONGLONG , } pub type WDF_REQUEST_SEND_OPTIONS = _WDF_REQUEST_SEND_OPTIONS ; pub type PWDF_REQUEST_SEND_OPTIONS = * mut _WDF_REQUEST_SEND_OPTIONS ; pub const _WDF_REQUEST_FORWARD_OPTIONS_FLAGS_WDF_REQUEST_FORWARD_OPTION_SEND_AND_FORGET : _WDF_REQUEST_FORWARD_OPTIONS_FLAGS = 1 ; pub type _WDF_REQUEST_FORWARD_OPTIONS_FLAGS = i32 ; pub use self :: _WDF_REQUEST_FORWARD_OPTIONS_FLAGS as WDF_REQUEST_FORWARD_OPTIONS_FLAGS ; # [ repr ( C ) ] pub struct _WDF_REQUEST_FORWARD_OPTIONS { pub Size : ULONG , pub Flags : ULONG , } pub type WDF_REQUEST_FORWARD_OPTIONS = _WDF_REQUEST_FORWARD_OPTIONS ; pub type PWDF_REQUEST_FORWARD_OPTIONS = * mut _WDF_REQUEST_FORWARD_OPTIONS ; pub type PFN_WDFREQUESTCREATE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , RequestAttributes : PWDF_OBJECT_ATTRIBUTES , IoTarget : WDFIOTARGET , Request : * mut WDFREQUEST ) -> NTSTATUS > ; pub type PFN_WDFREQUESTGETREQUESTORPROCESSID = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST ) -> ULONG > ; pub type PFN_WDFREQUESTCREATEFROMIRP = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , RequestAttributes : PWDF_OBJECT_ATTRIBUTES , Irp : PIRP , RequestFreesIrp : BOOLEAN , Request : * mut WDFREQUEST ) -> NTSTATUS > ; pub type PFN_WDFREQUESTREUSE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST , ReuseParams : PWDF_REQUEST_REUSE_PARAMS ) -> NTSTATUS > ; pub type PFN_WDFREQUESTCHANGETARGET = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST , IoTarget : WDFIOTARGET ) -> NTSTATUS > ; pub type PFN_WDFREQUESTFORMATREQUESTUSINGCURRENTTYPE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST ) > ; pub type PFN_WDFREQUESTWDMFORMATUSINGSTACKLOCATION = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST , Stack : PIO_STACK_LOCATION ) > ; pub type PFN_WDFREQUESTSEND = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST , Target : WDFIOTARGET , Options : PWDF_REQUEST_SEND_OPTIONS ) -> BOOLEAN > ; pub type PFN_WDFREQUESTGETSTATUS = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST ) -> NTSTATUS > ; pub type PFN_WDFREQUESTMARKCANCELABLE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST , EvtRequestCancel : PFN_WDF_REQUEST_CANCEL ) > ; pub type PFN_WDFREQUESTMARKCANCELABLEEX = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST , EvtRequestCancel : PFN_WDF_REQUEST_CANCEL ) -> NTSTATUS > ; pub type PFN_WDFREQUESTUNMARKCANCELABLE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST ) -> NTSTATUS > ; pub type PFN_WDFREQUESTISCANCELED = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST ) -> BOOLEAN > ; pub type PFN_WDFREQUESTCANCELSENTREQUEST = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST ) -> BOOLEAN > ; pub type PFN_WDFREQUESTISFROM32BITPROCESS = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST ) -> BOOLEAN > ; pub type PFN_WDFREQUESTSETCOMPLETIONROUTINE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST , CompletionRoutine : PFN_WDF_REQUEST_COMPLETION_ROUTINE , CompletionContext : WDFCONTEXT ) > ; pub type PFN_WDFREQUESTGETCOMPLETIONPARAMS = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST , Params : PWDF_REQUEST_COMPLETION_PARAMS ) > ; pub type PFN_WDFREQUESTALLOCATETIMER = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST ) -> NTSTATUS > ; pub type PFN_WDFREQUESTCOMPLETE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST , Status : NTSTATUS ) > ; pub type PFN_WDFREQUESTCOMPLETEWITHPRIORITYBOOST = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST , Status : NTSTATUS , PriorityBoost : CCHAR ) > ; pub type PFN_WDFREQUESTCOMPLETEWITHINFORMATION = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST , Status : NTSTATUS , Information : ULONG_PTR ) > ; pub type PFN_WDFREQUESTGETPARAMETERS = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST , Parameters : PWDF_REQUEST_PARAMETERS ) > ; pub type PFN_WDFREQUESTRETRIEVEINPUTMEMORY = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST , Memory : * mut WDFMEMORY ) -> NTSTATUS > ; pub type PFN_WDFREQUESTRETRIEVEOUTPUTMEMORY = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST , Memory : * mut WDFMEMORY ) -> NTSTATUS > ; pub type PFN_WDFREQUESTRETRIEVEINPUTBUFFER = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST , MinimumRequiredLength : usize , Buffer : * mut PVOID , Length : * mut usize ) -> NTSTATUS > ; pub type PFN_WDFREQUESTRETRIEVEOUTPUTBUFFER = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST , MinimumRequiredSize : usize , Buffer : * mut PVOID , Length : * mut usize ) -> NTSTATUS > ; pub type PFN_WDFREQUESTRETRIEVEINPUTWDMMDL = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST , Mdl : * mut PMDL ) -> NTSTATUS > ; pub type PFN_WDFREQUESTRETRIEVEOUTPUTWDMMDL = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST , Mdl : * mut PMDL ) -> NTSTATUS > ; pub type PFN_WDFREQUESTRETRIEVEUNSAFEUSERINPUTBUFFER = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST , MinimumRequiredLength : usize , InputBuffer : * mut PVOID , Length : * mut usize ) -> NTSTATUS > ; pub type PFN_WDFREQUESTRETRIEVEUNSAFEUSEROUTPUTBUFFER = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST , MinimumRequiredLength : usize , OutputBuffer : * mut PVOID , Length : * mut usize ) -> NTSTATUS > ; pub type PFN_WDFREQUESTSETINFORMATION = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST , Information : ULONG_PTR ) > ; pub type PFN_WDFREQUESTGETINFORMATION = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST ) -> ULONG_PTR > ; pub type PFN_WDFREQUESTGETFILEOBJECT = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST ) -> WDFFILEOBJECT > ; pub type PFN_WDFREQUESTPROBEANDLOCKUSERBUFFERFORREAD = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST , Buffer : PVOID , Length : usize , MemoryObject : * mut WDFMEMORY ) -> NTSTATUS > ; pub type PFN_WDFREQUESTPROBEANDLOCKUSERBUFFERFORWRITE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST , Buffer : PVOID , Length : usize , MemoryObject : * mut WDFMEMORY ) -> NTSTATUS > ; pub type PFN_WDFREQUESTGETREQUESTORMODE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST ) -> KPROCESSOR_MODE > ; pub type PFN_WDFREQUESTFORWARDTOIOQUEUE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST , DestinationQueue : WDFQUEUE ) -> NTSTATUS > ; pub type PFN_WDFREQUESTGETIOQUEUE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST ) -> WDFQUEUE > ; pub type PFN_WDFREQUESTREQUEUE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST ) -> NTSTATUS > ; pub type PFN_WDFREQUESTSTOPACKNOWLEDGE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST , Requeue : BOOLEAN ) > ; pub type PFN_WDFREQUESTWDMGETIRP = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST ) -> PIRP > ; pub type PFN_WDFREQUESTISRESERVED = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST ) -> BOOLEAN > ; pub type PFN_WDFREQUESTFORWARDTOPARENTDEVICEIOQUEUE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Request : WDFREQUEST , ParentDeviceQueue : WDFQUEUE , ForwardOptions : PWDF_REQUEST_FORWARD_OPTIONS ) -> NTSTATUS > ; pub const _WDF_IO_TARGET_STATE_WdfIoTargetStateUndefined : _WDF_IO_TARGET_STATE = 0 ; pub const _WDF_IO_TARGET_STATE_WdfIoTargetStarted : _WDF_IO_TARGET_STATE = 1 ; pub const _WDF_IO_TARGET_STATE_WdfIoTargetStopped : _WDF_IO_TARGET_STATE = 2 ; pub const _WDF_IO_TARGET_STATE_WdfIoTargetClosedForQueryRemove : _WDF_IO_TARGET_STATE = 3 ; pub const _WDF_IO_TARGET_STATE_WdfIoTargetClosed : _WDF_IO_TARGET_STATE = 4 ; pub const _WDF_IO_TARGET_STATE_WdfIoTargetDeleted : _WDF_IO_TARGET_STATE = 5 ; pub const _WDF_IO_TARGET_STATE_WdfIoTargetPurged : _WDF_IO_TARGET_STATE = 6 ; pub type _WDF_IO_TARGET_STATE = i32 ; pub use self :: _WDF_IO_TARGET_STATE as WDF_IO_TARGET_STATE ; pub type PWDF_IO_TARGET_STATE = * mut _WDF_IO_TARGET_STATE ; pub const _WDF_IO_TARGET_OPEN_TYPE_WdfIoTargetOpenUndefined : _WDF_IO_TARGET_OPEN_TYPE = 0 ; pub const _WDF_IO_TARGET_OPEN_TYPE_WdfIoTargetOpenUseExistingDevice : _WDF_IO_TARGET_OPEN_TYPE = 1 ; pub const _WDF_IO_TARGET_OPEN_TYPE_WdfIoTargetOpenByName : _WDF_IO_TARGET_OPEN_TYPE = 2 ; pub const _WDF_IO_TARGET_OPEN_TYPE_WdfIoTargetOpenReopen : _WDF_IO_TARGET_OPEN_TYPE = 3 ; pub const _WDF_IO_TARGET_OPEN_TYPE_WdfIoTargetOpenLocalTargetByFile : _WDF_IO_TARGET_OPEN_TYPE = 4 ; pub type _WDF_IO_TARGET_OPEN_TYPE = i32 ; pub use self :: _WDF_IO_TARGET_OPEN_TYPE as WDF_IO_TARGET_OPEN_TYPE ; pub const _WDF_IO_TARGET_SENT_IO_ACTION_WdfIoTargetSentIoUndefined : _WDF_IO_TARGET_SENT_IO_ACTION = 0 ; pub const _WDF_IO_TARGET_SENT_IO_ACTION_WdfIoTargetCancelSentIo : _WDF_IO_TARGET_SENT_IO_ACTION = 1 ; pub const _WDF_IO_TARGET_SENT_IO_ACTION_WdfIoTargetWaitForSentIoToComplete : _WDF_IO_TARGET_SENT_IO_ACTION = 2 ; pub const _WDF_IO_TARGET_SENT_IO_ACTION_WdfIoTargetLeaveSentIoPending : _WDF_IO_TARGET_SENT_IO_ACTION = 3 ; pub type _WDF_IO_TARGET_SENT_IO_ACTION = i32 ; pub use self :: _WDF_IO_TARGET_SENT_IO_ACTION as WDF_IO_TARGET_SENT_IO_ACTION ; pub const _WDF_IO_TARGET_PURGE_IO_ACTION_WdfIoTargetPurgeIoUndefined : _WDF_IO_TARGET_PURGE_IO_ACTION = 0 ; pub const _WDF_IO_TARGET_PURGE_IO_ACTION_WdfIoTargetPurgeIoAndWait : _WDF_IO_TARGET_PURGE_IO_ACTION = 1 ; pub const _WDF_IO_TARGET_PURGE_IO_ACTION_WdfIoTargetPurgeIo : _WDF_IO_TARGET_PURGE_IO_ACTION = 2 ; pub type _WDF_IO_TARGET_PURGE_IO_ACTION = i32 ; pub use self :: _WDF_IO_TARGET_PURGE_IO_ACTION as WDF_IO_TARGET_PURGE_IO_ACTION ; pub type EVT_WDF_IO_TARGET_QUERY_REMOVE = :: std :: option :: Option < unsafe extern "C" fn ( IoTarget : WDFIOTARGET ) -> NTSTATUS > ; pub type PFN_WDF_IO_TARGET_QUERY_REMOVE = EVT_WDF_IO_TARGET_QUERY_REMOVE ; pub type EVT_WDF_IO_TARGET_REMOVE_CANCELED = :: std :: option :: Option < unsafe extern "C" fn ( IoTarget : WDFIOTARGET ) > ; pub type PFN_WDF_IO_TARGET_REMOVE_CANCELED = EVT_WDF_IO_TARGET_REMOVE_CANCELED ; pub type EVT_WDF_IO_TARGET_REMOVE_COMPLETE = :: std :: option :: Option < unsafe extern "C" fn ( IoTarget : WDFIOTARGET ) > ; pub type PFN_WDF_IO_TARGET_REMOVE_COMPLETE = EVT_WDF_IO_TARGET_REMOVE_COMPLETE ; # [ repr ( C ) ] pub struct _WDF_IO_TARGET_OPEN_PARAMS { pub Size : ULONG , pub Type : WDF_IO_TARGET_OPEN_TYPE , pub EvtIoTargetQueryRemove : PFN_WDF_IO_TARGET_QUERY_REMOVE , pub EvtIoTargetRemoveCanceled : PFN_WDF_IO_TARGET_REMOVE_CANCELED , pub EvtIoTargetRemoveComplete : PFN_WDF_IO_TARGET_REMOVE_COMPLETE , pub TargetDeviceObject : PDEVICE_OBJECT , pub TargetFileObject : PFILE_OBJECT , pub TargetDeviceName : UNICODE_STRING , pub DesiredAccess : ACCESS_MASK , pub ShareAccess : ULONG , pub FileAttributes : ULONG , pub CreateDisposition : ULONG , pub CreateOptions : ULONG , pub EaBuffer : PVOID , pub EaBufferLength : ULONG , pub AllocationSize : PLONGLONG , pub FileInformation : ULONG , pub FileName : UNICODE_STRING , } pub type WDF_IO_TARGET_OPEN_PARAMS = _WDF_IO_TARGET_OPEN_PARAMS ; pub type PWDF_IO_TARGET_OPEN_PARAMS = * mut _WDF_IO_TARGET_OPEN_PARAMS ; pub type PFN_WDFIOTARGETCREATE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , IoTargetAttributes : PWDF_OBJECT_ATTRIBUTES , IoTarget : * mut WDFIOTARGET ) -> NTSTATUS > ; pub type PFN_WDFIOTARGETOPEN = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , IoTarget : WDFIOTARGET , OpenParams : PWDF_IO_TARGET_OPEN_PARAMS ) -> NTSTATUS > ; pub type PFN_WDFIOTARGETCLOSEFORQUERYREMOVE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , IoTarget : WDFIOTARGET ) > ; pub type PFN_WDFIOTARGETCLOSE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , IoTarget : WDFIOTARGET ) > ; pub type PFN_WDFIOTARGETSTART = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , IoTarget : WDFIOTARGET ) -> NTSTATUS > ; pub type PFN_WDFIOTARGETSTOP = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , IoTarget : WDFIOTARGET , Action : WDF_IO_TARGET_SENT_IO_ACTION ) > ; pub type PFN_WDFIOTARGETPURGE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , IoTarget : WDFIOTARGET , Action : WDF_IO_TARGET_PURGE_IO_ACTION ) > ; pub type PFN_WDFIOTARGETGETSTATE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , IoTarget : WDFIOTARGET ) -> WDF_IO_TARGET_STATE > ; pub type PFN_WDFIOTARGETGETDEVICE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , IoTarget : WDFIOTARGET ) -> WDFDEVICE > ; pub type PFN_WDFIOTARGETQUERYTARGETPROPERTY = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , IoTarget : WDFIOTARGET , DeviceProperty : DEVICE_REGISTRY_PROPERTY , BufferLength : ULONG , PropertyBuffer : PVOID , ResultLength : PULONG ) -> NTSTATUS > ; pub type PFN_WDFIOTARGETALLOCANDQUERYTARGETPROPERTY = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , IoTarget : WDFIOTARGET , DeviceProperty : DEVICE_REGISTRY_PROPERTY , PoolType : POOL_TYPE , PropertyMemoryAttributes : PWDF_OBJECT_ATTRIBUTES , PropertyMemory : * mut WDFMEMORY ) -> NTSTATUS > ; pub type PFN_WDFIOTARGETQUERYFORINTERFACE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , IoTarget : WDFIOTARGET , InterfaceType : LPCGUID , Interface : PINTERFACE , Size : USHORT , Version : USHORT , InterfaceSpecificData : PVOID ) -> NTSTATUS > ; pub type PFN_WDFIOTARGETWDMGETTARGETDEVICEOBJECT = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , IoTarget : WDFIOTARGET ) -> PDEVICE_OBJECT > ; pub type PFN_WDFIOTARGETWDMGETTARGETPHYSICALDEVICE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , IoTarget : WDFIOTARGET ) -> PDEVICE_OBJECT > ; pub type PFN_WDFIOTARGETWDMGETTARGETFILEOBJECT = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , IoTarget : WDFIOTARGET ) -> PFILE_OBJECT > ; pub type PFN_WDFIOTARGETWDMGETTARGETFILEHANDLE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , IoTarget : WDFIOTARGET ) -> HANDLE > ; pub type PFN_WDFIOTARGETSENDREADSYNCHRONOUSLY = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , IoTarget : WDFIOTARGET , Request : WDFREQUEST , OutputBuffer : PWDF_MEMORY_DESCRIPTOR , DeviceOffset : PLONGLONG , RequestOptions : PWDF_REQUEST_SEND_OPTIONS , BytesRead : PULONG_PTR ) -> NTSTATUS > ; pub type PFN_WDFIOTARGETFORMATREQUESTFORREAD = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , IoTarget : WDFIOTARGET , Request : WDFREQUEST , OutputBuffer : WDFMEMORY , OutputBufferOffset : PWDFMEMORY_OFFSET , DeviceOffset : PLONGLONG ) -> NTSTATUS > ; pub type PFN_WDFIOTARGETSENDWRITESYNCHRONOUSLY = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , IoTarget : WDFIOTARGET , Request : WDFREQUEST , InputBuffer : PWDF_MEMORY_DESCRIPTOR , DeviceOffset : PLONGLONG , RequestOptions : PWDF_REQUEST_SEND_OPTIONS , BytesWritten : PULONG_PTR ) -> NTSTATUS > ; pub type PFN_WDFIOTARGETFORMATREQUESTFORWRITE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , IoTarget : WDFIOTARGET , Request : WDFREQUEST , InputBuffer : WDFMEMORY , InputBufferOffset : PWDFMEMORY_OFFSET , DeviceOffset : PLONGLONG ) -> NTSTATUS > ; pub type PFN_WDFIOTARGETSENDIOCTLSYNCHRONOUSLY = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , IoTarget : WDFIOTARGET , Request : WDFREQUEST , IoctlCode : ULONG , InputBuffer : PWDF_MEMORY_DESCRIPTOR , OutputBuffer : PWDF_MEMORY_DESCRIPTOR , RequestOptions : PWDF_REQUEST_SEND_OPTIONS , BytesReturned : PULONG_PTR ) -> NTSTATUS > ; pub type PFN_WDFIOTARGETFORMATREQUESTFORIOCTL = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , IoTarget : WDFIOTARGET , Request : WDFREQUEST , IoctlCode : ULONG , InputBuffer : WDFMEMORY , InputBufferOffset : PWDFMEMORY_OFFSET , OutputBuffer : WDFMEMORY , OutputBufferOffset : PWDFMEMORY_OFFSET ) -> NTSTATUS > ; pub type PFN_WDFIOTARGETSENDINTERNALIOCTLSYNCHRONOUSLY = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , IoTarget : WDFIOTARGET , Request : WDFREQUEST , IoctlCode : ULONG , InputBuffer : PWDF_MEMORY_DESCRIPTOR , OutputBuffer : PWDF_MEMORY_DESCRIPTOR , RequestOptions : PWDF_REQUEST_SEND_OPTIONS , BytesReturned : PULONG_PTR ) -> NTSTATUS > ; pub type PFN_WDFIOTARGETFORMATREQUESTFORINTERNALIOCTL = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , IoTarget : WDFIOTARGET , Request : WDFREQUEST , IoctlCode : ULONG , InputBuffer : WDFMEMORY , InputBufferOffset : PWDFMEMORY_OFFSET , OutputBuffer : WDFMEMORY , OutputBufferOffset : PWDFMEMORY_OFFSET ) -> NTSTATUS > ; pub type PFN_WDFIOTARGETSENDINTERNALIOCTLOTHERSSYNCHRONOUSLY = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , IoTarget : WDFIOTARGET , Request : WDFREQUEST , IoctlCode : ULONG , OtherArg1 : PWDF_MEMORY_DESCRIPTOR , OtherArg2 : PWDF_MEMORY_DESCRIPTOR , OtherArg4 : PWDF_MEMORY_DESCRIPTOR , RequestOptions : PWDF_REQUEST_SEND_OPTIONS , BytesReturned : PULONG_PTR ) -> NTSTATUS > ; pub type PFN_WDFIOTARGETFORMATREQUESTFORINTERNALIOCTLOTHERS = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , IoTarget : WDFIOTARGET , Request : WDFREQUEST , IoctlCode : ULONG , OtherArg1 : WDFMEMORY , OtherArg1Offset : PWDFMEMORY_OFFSET , OtherArg2 : WDFMEMORY , OtherArg2Offset : PWDFMEMORY_OFFSET , OtherArg4 : WDFMEMORY , OtherArg4Offset : PWDFMEMORY_OFFSET ) -> NTSTATUS > ; pub const _WDF_IO_QUEUE_DISPATCH_TYPE_WdfIoQueueDispatchInvalid : _WDF_IO_QUEUE_DISPATCH_TYPE = 0 ; pub const _WDF_IO_QUEUE_DISPATCH_TYPE_WdfIoQueueDispatchSequential : _WDF_IO_QUEUE_DISPATCH_TYPE = 1 ; pub const _WDF_IO_QUEUE_DISPATCH_TYPE_WdfIoQueueDispatchParallel : _WDF_IO_QUEUE_DISPATCH_TYPE = 2 ; pub const _WDF_IO_QUEUE_DISPATCH_TYPE_WdfIoQueueDispatchManual : _WDF_IO_QUEUE_DISPATCH_TYPE = 3 ; pub const _WDF_IO_QUEUE_DISPATCH_TYPE_WdfIoQueueDispatchMax : _WDF_IO_QUEUE_DISPATCH_TYPE = 4 ; pub type _WDF_IO_QUEUE_DISPATCH_TYPE = i32 ; pub use self :: _WDF_IO_QUEUE_DISPATCH_TYPE as WDF_IO_QUEUE_DISPATCH_TYPE ; pub const _WDF_IO_QUEUE_STATE_WdfIoQueueAcceptRequests : _WDF_IO_QUEUE_STATE = 1 ; pub const _WDF_IO_QUEUE_STATE_WdfIoQueueDispatchRequests : _WDF_IO_QUEUE_STATE = 2 ; pub const _WDF_IO_QUEUE_STATE_WdfIoQueueNoRequests : _WDF_IO_QUEUE_STATE = 4 ; pub const _WDF_IO_QUEUE_STATE_WdfIoQueueDriverNoRequests : _WDF_IO_QUEUE_STATE = 8 ; pub const _WDF_IO_QUEUE_STATE_WdfIoQueuePnpHeld : _WDF_IO_QUEUE_STATE = 16 ; pub type _WDF_IO_QUEUE_STATE = i32 ; pub use self :: _WDF_IO_QUEUE_STATE as WDF_IO_QUEUE_STATE ; pub type EVT_WDF_IO_QUEUE_IO_DEFAULT = :: std :: option :: Option < unsafe extern "C" fn ( Queue : WDFQUEUE , Request : WDFREQUEST ) > ; pub type PFN_WDF_IO_QUEUE_IO_DEFAULT = EVT_WDF_IO_QUEUE_IO_DEFAULT ; pub type EVT_WDF_IO_QUEUE_IO_STOP = :: std :: option :: Option < unsafe extern "C" fn ( Queue : WDFQUEUE , Request : WDFREQUEST , ActionFlags : ULONG ) > ; pub type PFN_WDF_IO_QUEUE_IO_STOP = EVT_WDF_IO_QUEUE_IO_STOP ; pub type EVT_WDF_IO_QUEUE_IO_RESUME = :: std :: option :: Option < unsafe extern "C" fn ( Queue : WDFQUEUE , Request : WDFREQUEST ) > ; pub type PFN_WDF_IO_QUEUE_IO_RESUME = EVT_WDF_IO_QUEUE_IO_RESUME ; pub type EVT_WDF_IO_QUEUE_IO_READ = :: std :: option :: Option < unsafe extern "C" fn ( Queue : WDFQUEUE , Request : WDFREQUEST , Length : usize ) > ; pub type PFN_WDF_IO_QUEUE_IO_READ = EVT_WDF_IO_QUEUE_IO_READ ; pub type EVT_WDF_IO_QUEUE_IO_WRITE = :: std :: option :: Option < unsafe extern "C" fn ( Queue : WDFQUEUE , Request : WDFREQUEST , Length : usize ) > ; pub type PFN_WDF_IO_QUEUE_IO_WRITE = EVT_WDF_IO_QUEUE_IO_WRITE ; pub type EVT_WDF_IO_QUEUE_IO_DEVICE_CONTROL = :: std :: option :: Option < unsafe extern "C" fn ( Queue : WDFQUEUE , Request : WDFREQUEST , OutputBufferLength : usize , InputBufferLength : usize , IoControlCode : ULONG ) > ; pub type PFN_WDF_IO_QUEUE_IO_DEVICE_CONTROL = EVT_WDF_IO_QUEUE_IO_DEVICE_CONTROL ; pub type EVT_WDF_IO_QUEUE_IO_INTERNAL_DEVICE_CONTROL = :: std :: option :: Option < unsafe extern "C" fn ( Queue : WDFQUEUE , Request : WDFREQUEST , OutputBufferLength : usize , InputBufferLength : usize , IoControlCode : ULONG ) > ; pub type PFN_WDF_IO_QUEUE_IO_INTERNAL_DEVICE_CONTROL = EVT_WDF_IO_QUEUE_IO_INTERNAL_DEVICE_CONTROL ; pub type EVT_WDF_IO_QUEUE_IO_CANCELED_ON_QUEUE = :: std :: option :: Option < unsafe extern "C" fn ( Queue : WDFQUEUE , Request : WDFREQUEST ) > ; pub type PFN_WDF_IO_QUEUE_IO_CANCELED_ON_QUEUE = EVT_WDF_IO_QUEUE_IO_CANCELED_ON_QUEUE ; pub type EVT_WDF_IO_QUEUE_STATE = :: std :: option :: Option < unsafe extern "C" fn ( Queue : WDFQUEUE , Context : WDFCONTEXT ) > ; pub type PFN_WDF_IO_QUEUE_STATE = EVT_WDF_IO_QUEUE_STATE ; # [ repr ( C ) ] pub struct _WDF_IO_QUEUE_CONFIG { pub Size : ULONG , pub DispatchType : WDF_IO_QUEUE_DISPATCH_TYPE , pub PowerManaged : WDF_TRI_STATE , pub AllowZeroLengthRequests : BOOLEAN , pub DefaultQueue : BOOLEAN , pub EvtIoDefault : PFN_WDF_IO_QUEUE_IO_DEFAULT , pub EvtIoRead : PFN_WDF_IO_QUEUE_IO_READ , pub EvtIoWrite : PFN_WDF_IO_QUEUE_IO_WRITE , pub EvtIoDeviceControl : PFN_WDF_IO_QUEUE_IO_DEVICE_CONTROL , pub EvtIoInternalDeviceControl : PFN_WDF_IO_QUEUE_IO_INTERNAL_DEVICE_CONTROL , pub EvtIoStop : PFN_WDF_IO_QUEUE_IO_STOP , pub EvtIoResume : PFN_WDF_IO_QUEUE_IO_RESUME , pub EvtIoCanceledOnQueue : PFN_WDF_IO_QUEUE_IO_CANCELED_ON_QUEUE , pub Settings : _WDF_IO_QUEUE_CONFIG__bindgen_ty_1 , pub Driver : WDFDRIVER , } # [ repr ( C ) ] pub struct _WDF_IO_QUEUE_CONFIG__bindgen_ty_1 { pub Parallel : __BindgenUnionField < _WDF_IO_QUEUE_CONFIG__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct _WDF_IO_QUEUE_CONFIG__bindgen_ty_1__bindgen_ty_1 { pub NumberOfPresentedRequests : ULONG , } pub type WDF_IO_QUEUE_CONFIG = _WDF_IO_QUEUE_CONFIG ; pub type PWDF_IO_QUEUE_CONFIG = * mut _WDF_IO_QUEUE_CONFIG ; pub const _WDF_IO_FORWARD_PROGRESS_ACTION_WdfIoForwardProgressActionInvalid : _WDF_IO_FORWARD_PROGRESS_ACTION = 0 ; pub const _WDF_IO_FORWARD_PROGRESS_ACTION_WdfIoForwardProgressActionFailRequest : _WDF_IO_FORWARD_PROGRESS_ACTION = 1 ; pub const _WDF_IO_FORWARD_PROGRESS_ACTION_WdfIoForwardProgressActionUseReservedRequest : _WDF_IO_FORWARD_PROGRESS_ACTION = 2 ; pub type _WDF_IO_FORWARD_PROGRESS_ACTION = i32 ; pub use self :: _WDF_IO_FORWARD_PROGRESS_ACTION as WDF_IO_FORWARD_PROGRESS_ACTION ; pub const _WDF_IO_FORWARD_PROGRESS_RESERVED_POLICY_WdfIoForwardProgressInvalidPolicy : _WDF_IO_FORWARD_PROGRESS_RESERVED_POLICY = 0 ; pub const _WDF_IO_FORWARD_PROGRESS_RESERVED_POLICY_WdfIoForwardProgressReservedPolicyAlwaysUseReservedRequest : _WDF_IO_FORWARD_PROGRESS_RESERVED_POLICY = 1 ; pub const _WDF_IO_FORWARD_PROGRESS_RESERVED_POLICY_WdfIoForwardProgressReservedPolicyUseExamine : _WDF_IO_FORWARD_PROGRESS_RESERVED_POLICY = 2 ; pub const _WDF_IO_FORWARD_PROGRESS_RESERVED_POLICY_WdfIoForwardProgressReservedPolicyPagingIO : _WDF_IO_FORWARD_PROGRESS_RESERVED_POLICY = 3 ; pub type _WDF_IO_FORWARD_PROGRESS_RESERVED_POLICY = i32 ; pub use self :: _WDF_IO_FORWARD_PROGRESS_RESERVED_POLICY as WDF_IO_FORWARD_PROGRESS_RESERVED_POLICY ; pub type EVT_WDF_IO_ALLOCATE_RESOURCES_FOR_RESERVED_REQUEST = :: std :: option :: Option < unsafe extern "C" fn ( Queue : WDFQUEUE , Request : WDFREQUEST ) -> NTSTATUS > ; pub type PFN_WDF_IO_ALLOCATE_RESOURCES_FOR_RESERVED_REQUEST = EVT_WDF_IO_ALLOCATE_RESOURCES_FOR_RESERVED_REQUEST ; pub type EVT_WDF_IO_ALLOCATE_REQUEST_RESOURCES = :: std :: option :: Option < unsafe extern "C" fn ( Queue : WDFQUEUE , Request : WDFREQUEST ) -> NTSTATUS > ; pub type PFN_WDF_IO_ALLOCATE_REQUEST_RESOURCES = EVT_WDF_IO_ALLOCATE_REQUEST_RESOURCES ; pub type EVT_WDF_IO_WDM_IRP_FOR_FORWARD_PROGRESS = :: std :: option :: Option < unsafe extern "C" fn ( Queue : WDFQUEUE , Irp : PIRP ) -> WDF_IO_FORWARD_PROGRESS_ACTION > ; pub type PFN_WDF_IO_WDM_IRP_FOR_FORWARD_PROGRESS = EVT_WDF_IO_WDM_IRP_FOR_FORWARD_PROGRESS ; # [ repr ( C ) ] pub struct _WDF_IO_FORWARD_PROGRESS_RESERVED_POLICY_SETTINGS { pub Policy : _WDF_IO_FORWARD_PROGRESS_RESERVED_POLICY_SETTINGS__bindgen_ty_1 , } # [ repr ( C ) ] pub struct _WDF_IO_FORWARD_PROGRESS_RESERVED_POLICY_SETTINGS__bindgen_ty_1 { pub ExaminePolicy : __BindgenUnionField < _WDF_IO_FORWARD_PROGRESS_RESERVED_POLICY_SETTINGS__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : u64 , } # [ repr ( C ) ] pub struct _WDF_IO_FORWARD_PROGRESS_RESERVED_POLICY_SETTINGS__bindgen_ty_1__bindgen_ty_1 { pub EvtIoWdmIrpForForwardProgress : PFN_WDF_IO_WDM_IRP_FOR_FORWARD_PROGRESS , } pub type WDF_IO_FORWARD_PROGRESS_RESERVED_POLICY_SETTINGS = _WDF_IO_FORWARD_PROGRESS_RESERVED_POLICY_SETTINGS ; # [ repr ( C ) ] pub struct _WDF_IO_QUEUE_FORWARD_PROGRESS_POLICY { pub Size : ULONG , pub TotalForwardProgressRequests : ULONG , pub ForwardProgressReservedPolicy : WDF_IO_FORWARD_PROGRESS_RESERVED_POLICY , pub ForwardProgressReservePolicySettings : WDF_IO_FORWARD_PROGRESS_RESERVED_POLICY_SETTINGS , pub EvtIoAllocateResourcesForReservedRequest : PFN_WDF_IO_ALLOCATE_RESOURCES_FOR_RESERVED_REQUEST , pub EvtIoAllocateRequestResources : PFN_WDF_IO_ALLOCATE_REQUEST_RESOURCES , } pub type WDF_IO_QUEUE_FORWARD_PROGRESS_POLICY = _WDF_IO_QUEUE_FORWARD_PROGRESS_POLICY ; pub type PWDF_IO_QUEUE_FORWARD_PROGRESS_POLICY = * mut _WDF_IO_QUEUE_FORWARD_PROGRESS_POLICY ; pub type PFN_WDFIOQUEUECREATE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , Config : PWDF_IO_QUEUE_CONFIG , QueueAttributes : PWDF_OBJECT_ATTRIBUTES , Queue : * mut WDFQUEUE ) -> NTSTATUS > ; pub type PFN_WDFIOQUEUEGETSTATE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Queue : WDFQUEUE , QueueRequests : PULONG , DriverRequests : PULONG ) -> WDF_IO_QUEUE_STATE > ; pub type PFN_WDFIOQUEUESTART = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Queue : WDFQUEUE ) > ; pub type PFN_WDFIOQUEUESTOP = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Queue : WDFQUEUE , StopComplete : PFN_WDF_IO_QUEUE_STATE , Context : WDFCONTEXT ) > ; pub type PFN_WDFIOQUEUESTOPSYNCHRONOUSLY = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Queue : WDFQUEUE ) > ; pub type PFN_WDFIOQUEUEGETDEVICE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Queue : WDFQUEUE ) -> WDFDEVICE > ; pub type PFN_WDFIOQUEUERETRIEVENEXTREQUEST = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Queue : WDFQUEUE , OutRequest : * mut WDFREQUEST ) -> NTSTATUS > ; pub type PFN_WDFIOQUEUERETRIEVEREQUESTBYFILEOBJECT = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Queue : WDFQUEUE , FileObject : WDFFILEOBJECT , OutRequest : * mut WDFREQUEST ) -> NTSTATUS > ; pub type PFN_WDFIOQUEUEFINDREQUEST = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Queue : WDFQUEUE , FoundRequest : WDFREQUEST , FileObject : WDFFILEOBJECT , Parameters : PWDF_REQUEST_PARAMETERS , OutRequest : * mut WDFREQUEST ) -> NTSTATUS > ; pub type PFN_WDFIOQUEUERETRIEVEFOUNDREQUEST = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Queue : WDFQUEUE , FoundRequest : WDFREQUEST , OutRequest : * mut WDFREQUEST ) -> NTSTATUS > ; pub type PFN_WDFIOQUEUEDRAINSYNCHRONOUSLY = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Queue : WDFQUEUE ) > ; pub type PFN_WDFIOQUEUEDRAIN = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Queue : WDFQUEUE , DrainComplete : PFN_WDF_IO_QUEUE_STATE , Context : WDFCONTEXT ) > ; pub type PFN_WDFIOQUEUEPURGESYNCHRONOUSLY = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Queue : WDFQUEUE ) > ; pub type PFN_WDFIOQUEUEPURGE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Queue : WDFQUEUE , PurgeComplete : PFN_WDF_IO_QUEUE_STATE , Context : WDFCONTEXT ) > ; pub type PFN_WDFIOQUEUEREADYNOTIFY = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Queue : WDFQUEUE , QueueReady : PFN_WDF_IO_QUEUE_STATE , Context : WDFCONTEXT ) -> NTSTATUS > ; pub type PFN_WDFIOQUEUEASSIGNFORWARDPROGRESSPOLICY = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Queue : WDFQUEUE , ForwardProgressPolicy : PWDF_IO_QUEUE_FORWARD_PROGRESS_POLICY ) -> NTSTATUS > ; pub type PFN_WDFIOQUEUESTOPANDPURGE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Queue : WDFQUEUE , StopAndPurgeComplete : PFN_WDF_IO_QUEUE_STATE , Context : WDFCONTEXT ) > ; pub type PFN_WDFIOQUEUESTOPANDPURGESYNCHRONOUSLY = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Queue : WDFQUEUE ) > ; pub type EVT_WDF_DEVICE_FILTER_RESOURCE_REQUIREMENTS = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE , IoResourceRequirementsList : WDFIORESREQLIST ) -> NTSTATUS > ; pub type PFN_WDF_DEVICE_FILTER_RESOURCE_REQUIREMENTS = EVT_WDF_DEVICE_FILTER_RESOURCE_REQUIREMENTS ; pub type EVT_WDF_DEVICE_REMOVE_ADDED_RESOURCES = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE , ResourcesRaw : WDFCMRESLIST , ResourcesTranslated : WDFCMRESLIST ) -> NTSTATUS > ; pub type PFN_WDF_DEVICE_REMOVE_ADDED_RESOURCES = EVT_WDF_DEVICE_REMOVE_ADDED_RESOURCES ; # [ repr ( C ) ] pub struct _WDF_FDO_EVENT_CALLBACKS { pub Size : ULONG , pub EvtDeviceFilterAddResourceRequirements : PFN_WDF_DEVICE_FILTER_RESOURCE_REQUIREMENTS , pub EvtDeviceFilterRemoveResourceRequirements : PFN_WDF_DEVICE_FILTER_RESOURCE_REQUIREMENTS , pub EvtDeviceRemoveAddedResources : PFN_WDF_DEVICE_REMOVE_ADDED_RESOURCES , } pub type WDF_FDO_EVENT_CALLBACKS = _WDF_FDO_EVENT_CALLBACKS ; pub type PWDF_FDO_EVENT_CALLBACKS = * mut _WDF_FDO_EVENT_CALLBACKS ; pub type PFN_WDFFDOINITWDMGETPHYSICALDEVICE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT ) -> PDEVICE_OBJECT > ; pub type PFN_WDFFDOINITOPENREGISTRYKEY = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , DeviceInstanceKeyType : ULONG , DesiredAccess : ACCESS_MASK , KeyAttributes : PWDF_OBJECT_ATTRIBUTES , Key : * mut WDFKEY ) -> NTSTATUS > ; pub type PFN_WDFFDOINITQUERYPROPERTY = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , DeviceProperty : DEVICE_REGISTRY_PROPERTY , BufferLength : ULONG , PropertyBuffer : PVOID , ResultLength : PULONG ) -> NTSTATUS > ; pub type PFN_WDFFDOINITALLOCANDQUERYPROPERTY = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , DeviceProperty : DEVICE_REGISTRY_PROPERTY , PoolType : POOL_TYPE , PropertyMemoryAttributes : PWDF_OBJECT_ATTRIBUTES , PropertyMemory : * mut WDFMEMORY ) -> NTSTATUS > ; pub type PFN_WDFFDOINITQUERYPROPERTYEX = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , DeviceProperty : PWDF_DEVICE_PROPERTY_DATA , BufferLength : ULONG , PropertyBuffer : PVOID , ResultLength : PULONG , Type : PDEVPROPTYPE ) -> NTSTATUS > ; pub type PFN_WDFFDOINITALLOCANDQUERYPROPERTYEX = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , DeviceProperty : PWDF_DEVICE_PROPERTY_DATA , PoolType : POOL_TYPE , PropertyMemoryAttributes : PWDF_OBJECT_ATTRIBUTES , PropertyMemory : * mut WDFMEMORY , Type : PDEVPROPTYPE ) -> NTSTATUS > ; pub type PFN_WDFFDOINITSETEVENTCALLBACKS = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , FdoEventCallbacks : PWDF_FDO_EVENT_CALLBACKS ) > ; pub type PFN_WDFFDOINITSETFILTER = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT ) > ; pub type PFN_WDFFDOINITSETDEFAULTCHILDLISTCONFIG = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , Config : PWDF_CHILD_LIST_CONFIG , DefaultChildListAttributes : PWDF_OBJECT_ATTRIBUTES ) > ; pub type PFN_WDFFDOQUERYFORINTERFACE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Fdo : WDFDEVICE , InterfaceType : LPCGUID , Interface : PINTERFACE , Size : USHORT , Version : USHORT , InterfaceSpecificData : PVOID ) -> NTSTATUS > ; pub type PFN_WDFFDOGETDEFAULTCHILDLIST = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Fdo : WDFDEVICE ) -> WDFCHILDLIST > ; pub type PFN_WDFFDOADDSTATICCHILD = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Fdo : WDFDEVICE , Child : WDFDEVICE ) -> NTSTATUS > ; pub type PFN_WDFFDOLOCKSTATICCHILDLISTFORITERATION = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Fdo : WDFDEVICE ) > ; pub type PFN_WDFFDORETRIEVENEXTSTATICCHILD = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Fdo : WDFDEVICE , PreviousChild : WDFDEVICE , Flags : ULONG ) -> WDFDEVICE > ; pub type PFN_WDFFDOUNLOCKSTATICCHILDLISTFROMITERATION = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Fdo : WDFDEVICE ) > ; pub type EVT_WDF_DEVICE_RESOURCES_QUERY = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE , Resources : WDFCMRESLIST ) -> NTSTATUS > ; pub type PFN_WDF_DEVICE_RESOURCES_QUERY = EVT_WDF_DEVICE_RESOURCES_QUERY ; pub type EVT_WDF_DEVICE_RESOURCE_REQUIREMENTS_QUERY = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE , IoResourceRequirementsList : WDFIORESREQLIST ) -> NTSTATUS > ; pub type PFN_WDF_DEVICE_RESOURCE_REQUIREMENTS_QUERY = EVT_WDF_DEVICE_RESOURCE_REQUIREMENTS_QUERY ; pub type EVT_WDF_DEVICE_EJECT = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE ) -> NTSTATUS > ; pub type PFN_WDF_DEVICE_EJECT = EVT_WDF_DEVICE_EJECT ; pub type EVT_WDF_DEVICE_SET_LOCK = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE , IsLocked : BOOLEAN ) -> NTSTATUS > ; pub type PFN_WDF_DEVICE_SET_LOCK = EVT_WDF_DEVICE_SET_LOCK ; pub type EVT_WDF_DEVICE_ENABLE_WAKE_AT_BUS = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE , PowerState : SYSTEM_POWER_STATE ) -> NTSTATUS > ; pub type PFN_WDF_DEVICE_ENABLE_WAKE_AT_BUS = EVT_WDF_DEVICE_ENABLE_WAKE_AT_BUS ; pub type EVT_WDF_DEVICE_DISABLE_WAKE_AT_BUS = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE ) > ; pub type PFN_WDF_DEVICE_DISABLE_WAKE_AT_BUS = EVT_WDF_DEVICE_DISABLE_WAKE_AT_BUS ; pub type EVT_WDF_DEVICE_REPORTED_MISSING = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE ) > ; pub type PFN_WDF_DEVICE_REPORTED_MISSING = EVT_WDF_DEVICE_REPORTED_MISSING ; # [ repr ( C ) ] pub struct _WDF_PDO_EVENT_CALLBACKS { pub Size : ULONG , pub EvtDeviceResourcesQuery : PFN_WDF_DEVICE_RESOURCES_QUERY , pub EvtDeviceResourceRequirementsQuery : PFN_WDF_DEVICE_RESOURCE_REQUIREMENTS_QUERY , pub EvtDeviceEject : PFN_WDF_DEVICE_EJECT , pub EvtDeviceSetLock : PFN_WDF_DEVICE_SET_LOCK , pub EvtDeviceEnableWakeAtBus : PFN_WDF_DEVICE_ENABLE_WAKE_AT_BUS , pub EvtDeviceDisableWakeAtBus : PFN_WDF_DEVICE_DISABLE_WAKE_AT_BUS , pub EvtDeviceReportedMissing : PFN_WDF_DEVICE_REPORTED_MISSING , } pub type WDF_PDO_EVENT_CALLBACKS = _WDF_PDO_EVENT_CALLBACKS ; pub type PWDF_PDO_EVENT_CALLBACKS = * mut _WDF_PDO_EVENT_CALLBACKS ; pub type PFN_WDFPDOINITALLOCATE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , ParentDevice : WDFDEVICE ) -> PWDFDEVICE_INIT > ; pub type PFN_WDFPDOINITSETEVENTCALLBACKS = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , DispatchTable : PWDF_PDO_EVENT_CALLBACKS ) > ; pub type PFN_WDFPDOINITASSIGNDEVICEID = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , DeviceID : PCUNICODE_STRING ) -> NTSTATUS > ; pub type PFN_WDFPDOINITASSIGNINSTANCEID = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , InstanceID : PCUNICODE_STRING ) -> NTSTATUS > ; pub type PFN_WDFPDOINITADDHARDWAREID = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , HardwareID : PCUNICODE_STRING ) -> NTSTATUS > ; pub type PFN_WDFPDOINITADDCOMPATIBLEID = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , CompatibleID : PCUNICODE_STRING ) -> NTSTATUS > ; pub type PFN_WDFPDOINITASSIGNCONTAINERID = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , ContainerID : PCUNICODE_STRING ) -> NTSTATUS > ; pub type PFN_WDFPDOINITADDDEVICETEXT = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , DeviceDescription : PCUNICODE_STRING , DeviceLocation : PCUNICODE_STRING , LocaleId : LCID ) -> NTSTATUS > ; pub type PFN_WDFPDOINITSETDEFAULTLOCALE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , LocaleId : LCID ) > ; pub type PFN_WDFPDOINITASSIGNRAWDEVICE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , DeviceClassGuid : * const GUID ) -> NTSTATUS > ; pub type PFN_WDFPDOINITALLOWFORWARDINGREQUESTTOPARENT = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT ) > ; pub type PFN_WDFPDOMARKMISSING = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE ) -> NTSTATUS > ; pub type PFN_WDFPDOREQUESTEJECT = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE ) > ; pub type PFN_WDFPDOGETPARENT = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE ) -> WDFDEVICE > ; pub type PFN_WDFPDORETRIEVEIDENTIFICATIONDESCRIPTION = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , IdentificationDescription : PWDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER ) -> NTSTATUS > ; pub type PFN_WDFPDORETRIEVEADDRESSDESCRIPTION = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , AddressDescription : PWDF_CHILD_ADDRESS_DESCRIPTION_HEADER ) -> NTSTATUS > ; pub type PFN_WDFPDOUPDATEADDRESSDESCRIPTION = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , AddressDescription : PWDF_CHILD_ADDRESS_DESCRIPTION_HEADER ) -> NTSTATUS > ; pub type PFN_WDFPDOADDEJECTIONRELATIONSPHYSICALDEVICE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , PhysicalDevice : PDEVICE_OBJECT ) -> NTSTATUS > ; pub type PFN_WDFPDOREMOVEEJECTIONRELATIONSPHYSICALDEVICE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , PhysicalDevice : PDEVICE_OBJECT ) > ; pub type PFN_WDFPDOCLEAREJECTIONRELATIONSDEVICES = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE ) > ; pub type EVT_WDF_DEVICE_SHUTDOWN_NOTIFICATION = :: std :: option :: Option < unsafe extern "C" fn ( Device : WDFDEVICE ) > ; pub type PFN_WDF_DEVICE_SHUTDOWN_NOTIFICATION = EVT_WDF_DEVICE_SHUTDOWN_NOTIFICATION ; pub const _WDF_DEVICE_SHUTDOWN_FLAGS_WdfDeviceShutdown : _WDF_DEVICE_SHUTDOWN_FLAGS = 1 ; pub const _WDF_DEVICE_SHUTDOWN_FLAGS_WdfDeviceLastChanceShutdown : _WDF_DEVICE_SHUTDOWN_FLAGS = 2 ; pub type _WDF_DEVICE_SHUTDOWN_FLAGS = i32 ; pub use self :: _WDF_DEVICE_SHUTDOWN_FLAGS as WDF_DEVICE_SHUTDOWN_FLAGS ; pub type PFN_WDFCONTROLDEVICEINITALLOCATE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Driver : WDFDRIVER , SDDLString : * const UNICODE_STRING ) -> PWDFDEVICE_INIT > ; pub type PFN_WDFCONTROLDEVICEINITSETSHUTDOWNNOTIFICATION = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DeviceInit : PWDFDEVICE_INIT , Notification : PFN_WDF_DEVICE_SHUTDOWN_NOTIFICATION , Flags : UCHAR ) > ; pub type PFN_WDFCONTROLFINISHINITIALIZING = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE ) > ; pub const _WDF_WMI_PROVIDER_CONTROL_WdfWmiControlInvalid : _WDF_WMI_PROVIDER_CONTROL = 0 ; pub const _WDF_WMI_PROVIDER_CONTROL_WdfWmiEventControl : _WDF_WMI_PROVIDER_CONTROL = 1 ; pub const _WDF_WMI_PROVIDER_CONTROL_WdfWmiInstanceControl : _WDF_WMI_PROVIDER_CONTROL = 2 ; pub type _WDF_WMI_PROVIDER_CONTROL = i32 ; pub use self :: _WDF_WMI_PROVIDER_CONTROL as WDF_WMI_PROVIDER_CONTROL ; pub const _WDF_WMI_PROVIDER_FLAGS_WdfWmiProviderEventOnly : _WDF_WMI_PROVIDER_FLAGS = 1 ; pub const _WDF_WMI_PROVIDER_FLAGS_WdfWmiProviderExpensive : _WDF_WMI_PROVIDER_FLAGS = 2 ; pub const _WDF_WMI_PROVIDER_FLAGS_WdfWmiProviderTracing : _WDF_WMI_PROVIDER_FLAGS = 4 ; pub const _WDF_WMI_PROVIDER_FLAGS_WdfWmiProviderValidFlags : _WDF_WMI_PROVIDER_FLAGS = 7 ; pub type _WDF_WMI_PROVIDER_FLAGS = i32 ; pub use self :: _WDF_WMI_PROVIDER_FLAGS as WDF_WMI_PROVIDER_FLAGS ; pub type EVT_WDF_WMI_INSTANCE_QUERY_INSTANCE = :: std :: option :: Option < unsafe extern "C" fn ( WmiInstance : WDFWMIINSTANCE , OutBufferSize : ULONG , OutBuffer : PVOID , BufferUsed : PULONG ) -> NTSTATUS > ; pub type PFN_WDF_WMI_INSTANCE_QUERY_INSTANCE = EVT_WDF_WMI_INSTANCE_QUERY_INSTANCE ; pub type EVT_WDF_WMI_INSTANCE_SET_INSTANCE = :: std :: option :: Option < unsafe extern "C" fn ( WmiInstance : WDFWMIINSTANCE , InBufferSize : ULONG , InBuffer : PVOID ) -> NTSTATUS > ; pub type PFN_WDF_WMI_INSTANCE_SET_INSTANCE = EVT_WDF_WMI_INSTANCE_SET_INSTANCE ; pub type EVT_WDF_WMI_INSTANCE_SET_ITEM = :: std :: option :: Option < unsafe extern "C" fn ( WmiInstance : WDFWMIINSTANCE , DataItemId : ULONG , InBufferSize : ULONG , InBuffer : PVOID ) -> NTSTATUS > ; pub type PFN_WDF_WMI_INSTANCE_SET_ITEM = EVT_WDF_WMI_INSTANCE_SET_ITEM ; pub type EVT_WDF_WMI_INSTANCE_EXECUTE_METHOD = :: std :: option :: Option < unsafe extern "C" fn ( WmiInstance : WDFWMIINSTANCE , MethodId : ULONG , InBufferSize : ULONG , OutBufferSize : ULONG , Buffer : PVOID , BufferUsed : PULONG ) -> NTSTATUS > ; pub type PFN_WDF_WMI_INSTANCE_EXECUTE_METHOD = EVT_WDF_WMI_INSTANCE_EXECUTE_METHOD ; pub type EVT_WDF_WMI_PROVIDER_FUNCTION_CONTROL = :: std :: option :: Option < unsafe extern "C" fn ( WmiProvider : WDFWMIPROVIDER , Control : WDF_WMI_PROVIDER_CONTROL , Enable : BOOLEAN ) -> NTSTATUS > ; pub type PFN_WDF_WMI_PROVIDER_FUNCTION_CONTROL = EVT_WDF_WMI_PROVIDER_FUNCTION_CONTROL ; # [ repr ( C ) ] pub struct _WDF_WMI_PROVIDER_CONFIG { pub Size : ULONG , pub Guid : GUID , pub Flags : ULONG , pub MinInstanceBufferSize : ULONG , pub EvtWmiProviderFunctionControl : PFN_WDF_WMI_PROVIDER_FUNCTION_CONTROL , } pub type WDF_WMI_PROVIDER_CONFIG = _WDF_WMI_PROVIDER_CONFIG ; pub type PWDF_WMI_PROVIDER_CONFIG = * mut _WDF_WMI_PROVIDER_CONFIG ; # [ repr ( C ) ] pub struct _WDF_WMI_INSTANCE_CONFIG { pub Size : ULONG , pub Provider : WDFWMIPROVIDER , pub ProviderConfig : PWDF_WMI_PROVIDER_CONFIG , pub UseContextForQuery : BOOLEAN , pub Register : BOOLEAN , pub EvtWmiInstanceQueryInstance : PFN_WDF_WMI_INSTANCE_QUERY_INSTANCE , pub EvtWmiInstanceSetInstance : PFN_WDF_WMI_INSTANCE_SET_INSTANCE , pub EvtWmiInstanceSetItem : PFN_WDF_WMI_INSTANCE_SET_ITEM , pub EvtWmiInstanceExecuteMethod : PFN_WDF_WMI_INSTANCE_EXECUTE_METHOD , } pub type WDF_WMI_INSTANCE_CONFIG = _WDF_WMI_INSTANCE_CONFIG ; pub type PWDF_WMI_INSTANCE_CONFIG = * mut _WDF_WMI_INSTANCE_CONFIG ; pub type PFN_WDFWMIPROVIDERCREATE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , WmiProviderConfig : PWDF_WMI_PROVIDER_CONFIG , ProviderAttributes : PWDF_OBJECT_ATTRIBUTES , WmiProvider : * mut WDFWMIPROVIDER ) -> NTSTATUS > ; pub type PFN_WDFWMIPROVIDERGETDEVICE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , WmiProvider : WDFWMIPROVIDER ) -> WDFDEVICE > ; pub type PFN_WDFWMIPROVIDERISENABLED = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , WmiProvider : WDFWMIPROVIDER , ProviderControl : WDF_WMI_PROVIDER_CONTROL ) -> BOOLEAN > ; pub type PFN_WDFWMIPROVIDERGETTRACINGHANDLE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , WmiProvider : WDFWMIPROVIDER ) -> ULONGLONG > ; pub type PFN_WDFWMIINSTANCECREATE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , InstanceConfig : PWDF_WMI_INSTANCE_CONFIG , InstanceAttributes : PWDF_OBJECT_ATTRIBUTES , Instance : * mut WDFWMIINSTANCE ) -> NTSTATUS > ; pub type PFN_WDFWMIINSTANCEREGISTER = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , WmiInstance : WDFWMIINSTANCE ) -> NTSTATUS > ; pub type PFN_WDFWMIINSTANCEDEREGISTER = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , WmiInstance : WDFWMIINSTANCE ) > ; pub type PFN_WDFWMIINSTANCEGETDEVICE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , WmiInstance : WDFWMIINSTANCE ) -> WDFDEVICE > ; pub type PFN_WDFWMIINSTANCEGETPROVIDER = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , WmiInstance : WDFWMIINSTANCE ) -> WDFWMIPROVIDER > ; pub type PFN_WDFWMIINSTANCEFIREEVENT = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , WmiInstance : WDFWMIINSTANCE , EventDataSize : ULONG , EventData : PVOID ) -> NTSTATUS > ; pub type PFN_WDFSTRINGCREATE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , UnicodeString : PCUNICODE_STRING , StringAttributes : PWDF_OBJECT_ATTRIBUTES , String : * mut WDFSTRING ) -> NTSTATUS > ; pub type PFN_WDFSTRINGGETUNICODESTRING = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , String : WDFSTRING , UnicodeString : PUNICODE_STRING ) > ; pub type PFN_WDFREGISTRYOPENKEY = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , ParentKey : WDFKEY , KeyName : PCUNICODE_STRING , DesiredAccess : ACCESS_MASK , KeyAttributes : PWDF_OBJECT_ATTRIBUTES , Key : * mut WDFKEY ) -> NTSTATUS > ; pub type PFN_WDFREGISTRYCREATEKEY = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , ParentKey : WDFKEY , KeyName : PCUNICODE_STRING , DesiredAccess : ACCESS_MASK , CreateOptions : ULONG , CreateDisposition : PULONG , KeyAttributes : PWDF_OBJECT_ATTRIBUTES , Key : * mut WDFKEY ) -> NTSTATUS > ; pub type PFN_WDFREGISTRYCLOSE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Key : WDFKEY ) > ; pub type PFN_WDFREGISTRYWDMGETHANDLE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Key : WDFKEY ) -> HANDLE > ; pub type PFN_WDFREGISTRYREMOVEKEY = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Key : WDFKEY ) -> NTSTATUS > ; pub type PFN_WDFREGISTRYREMOVEVALUE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Key : WDFKEY , ValueName : PCUNICODE_STRING ) -> NTSTATUS > ; pub type PFN_WDFREGISTRYQUERYVALUE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Key : WDFKEY , ValueName : PCUNICODE_STRING , ValueLength : ULONG , Value : PVOID , ValueLengthQueried : PULONG , ValueType : PULONG ) -> NTSTATUS > ; pub type PFN_WDFREGISTRYQUERYMEMORY = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Key : WDFKEY , ValueName : PCUNICODE_STRING , PoolType : POOL_TYPE , MemoryAttributes : PWDF_OBJECT_ATTRIBUTES , Memory : * mut WDFMEMORY , ValueType : PULONG ) -> NTSTATUS > ; pub type PFN_WDFREGISTRYQUERYMULTISTRING = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Key : WDFKEY , ValueName : PCUNICODE_STRING , StringsAttributes : PWDF_OBJECT_ATTRIBUTES , Collection : WDFCOLLECTION ) -> NTSTATUS > ; pub type PFN_WDFREGISTRYQUERYUNICODESTRING = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Key : WDFKEY , ValueName : PCUNICODE_STRING , ValueByteLength : PUSHORT , Value : PUNICODE_STRING ) -> NTSTATUS > ; pub type PFN_WDFREGISTRYQUERYSTRING = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Key : WDFKEY , ValueName : PCUNICODE_STRING , String : WDFSTRING ) -> NTSTATUS > ; pub type PFN_WDFREGISTRYQUERYULONG = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Key : WDFKEY , ValueName : PCUNICODE_STRING , Value : PULONG ) -> NTSTATUS > ; pub type PFN_WDFREGISTRYASSIGNVALUE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Key : WDFKEY , ValueName : PCUNICODE_STRING , ValueType : ULONG , ValueLength : ULONG , Value : PVOID ) -> NTSTATUS > ; pub type PFN_WDFREGISTRYASSIGNMEMORY = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Key : WDFKEY , ValueName : PCUNICODE_STRING , ValueType : ULONG , Memory : WDFMEMORY , MemoryOffsets : PWDFMEMORY_OFFSET ) -> NTSTATUS > ; pub type PFN_WDFREGISTRYASSIGNMULTISTRING = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Key : WDFKEY , ValueName : PCUNICODE_STRING , StringsCollection : WDFCOLLECTION ) -> NTSTATUS > ; pub type PFN_WDFREGISTRYASSIGNUNICODESTRING = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Key : WDFKEY , ValueName : PCUNICODE_STRING , Value : PCUNICODE_STRING ) -> NTSTATUS > ; pub type PFN_WDFREGISTRYASSIGNSTRING = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Key : WDFKEY , ValueName : PCUNICODE_STRING , String : WDFSTRING ) -> NTSTATUS > ; pub type PFN_WDFREGISTRYASSIGNULONG = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Key : WDFKEY , ValueName : PCUNICODE_STRING , Value : ULONG ) -> NTSTATUS > ; pub const _WDF_DMA_PROFILE_WdfDmaProfileInvalid : _WDF_DMA_PROFILE = 0 ; pub const _WDF_DMA_PROFILE_WdfDmaProfilePacket : _WDF_DMA_PROFILE = 1 ; pub const _WDF_DMA_PROFILE_WdfDmaProfileScatterGather : _WDF_DMA_PROFILE = 2 ; pub const _WDF_DMA_PROFILE_WdfDmaProfilePacket64 : _WDF_DMA_PROFILE = 3 ; pub const _WDF_DMA_PROFILE_WdfDmaProfileScatterGather64 : _WDF_DMA_PROFILE = 4 ; pub const _WDF_DMA_PROFILE_WdfDmaProfileScatterGatherDuplex : _WDF_DMA_PROFILE = 5 ; pub const _WDF_DMA_PROFILE_WdfDmaProfileScatterGather64Duplex : _WDF_DMA_PROFILE = 6 ; pub const _WDF_DMA_PROFILE_WdfDmaProfileSystem : _WDF_DMA_PROFILE = 7 ; pub const _WDF_DMA_PROFILE_WdfDmaProfileSystemDuplex : _WDF_DMA_PROFILE = 8 ; pub type _WDF_DMA_PROFILE = i32 ; pub use self :: _WDF_DMA_PROFILE as WDF_DMA_PROFILE ; pub const _WDF_DMA_DIRECTION_WdfDmaDirectionReadFromDevice : _WDF_DMA_DIRECTION = 0 ; pub const _WDF_DMA_DIRECTION_WdfDmaDirectionWriteToDevice : _WDF_DMA_DIRECTION = 1 ; pub type _WDF_DMA_DIRECTION = i32 ; pub use self :: _WDF_DMA_DIRECTION as WDF_DMA_DIRECTION ; pub type EVT_WDF_DMA_ENABLER_FILL = :: std :: option :: Option < unsafe extern "C" fn ( DmaEnabler : WDFDMAENABLER ) -> NTSTATUS > ; pub type PFN_WDF_DMA_ENABLER_FILL = EVT_WDF_DMA_ENABLER_FILL ; pub type EVT_WDF_DMA_ENABLER_FLUSH = :: std :: option :: Option < unsafe extern "C" fn ( DmaEnabler : WDFDMAENABLER ) -> NTSTATUS > ; pub type PFN_WDF_DMA_ENABLER_FLUSH = EVT_WDF_DMA_ENABLER_FLUSH ; pub type EVT_WDF_DMA_ENABLER_ENABLE = :: std :: option :: Option < unsafe extern "C" fn ( DmaEnabler : WDFDMAENABLER ) -> NTSTATUS > ; pub type PFN_WDF_DMA_ENABLER_ENABLE = EVT_WDF_DMA_ENABLER_ENABLE ; pub type EVT_WDF_DMA_ENABLER_DISABLE = :: std :: option :: Option < unsafe extern "C" fn ( DmaEnabler : WDFDMAENABLER ) -> NTSTATUS > ; pub type PFN_WDF_DMA_ENABLER_DISABLE = EVT_WDF_DMA_ENABLER_DISABLE ; pub type EVT_WDF_DMA_ENABLER_SELFMANAGED_IO_START = :: std :: option :: Option < unsafe extern "C" fn ( DmaEnabler : WDFDMAENABLER ) -> NTSTATUS > ; pub type PFN_WDF_DMA_ENABLER_SELFMANAGED_IO_START = EVT_WDF_DMA_ENABLER_SELFMANAGED_IO_START ; pub type EVT_WDF_DMA_ENABLER_SELFMANAGED_IO_STOP = :: std :: option :: Option < unsafe extern "C" fn ( DmaEnabler : WDFDMAENABLER ) -> NTSTATUS > ; pub type PFN_WDF_DMA_ENABLER_SELFMANAGED_IO_STOP = EVT_WDF_DMA_ENABLER_SELFMANAGED_IO_STOP ; pub const _WDF_DMA_ENABLER_CONFIG_FLAGS_WDF_DMA_ENABLER_CONFIG_NO_SGLIST_PREALLOCATION : _WDF_DMA_ENABLER_CONFIG_FLAGS = 1 ; pub const _WDF_DMA_ENABLER_CONFIG_FLAGS_WDF_DMA_ENABLER_CONFIG_REQUIRE_SINGLE_TRANSFER : _WDF_DMA_ENABLER_CONFIG_FLAGS = 2 ; pub type _WDF_DMA_ENABLER_CONFIG_FLAGS = i32 ; pub use self :: _WDF_DMA_ENABLER_CONFIG_FLAGS as WDF_DMA_ENABLER_CONFIG_FLAGS ; # [ repr ( C ) ] pub struct _WDF_DMA_ENABLER_CONFIG { pub Size : ULONG , pub Profile : WDF_DMA_PROFILE , pub MaximumLength : usize , pub EvtDmaEnablerFill : PFN_WDF_DMA_ENABLER_FILL , pub EvtDmaEnablerFlush : PFN_WDF_DMA_ENABLER_FLUSH , pub EvtDmaEnablerDisable : PFN_WDF_DMA_ENABLER_DISABLE , pub EvtDmaEnablerEnable : PFN_WDF_DMA_ENABLER_ENABLE , pub EvtDmaEnablerSelfManagedIoStart : PFN_WDF_DMA_ENABLER_SELFMANAGED_IO_START , pub EvtDmaEnablerSelfManagedIoStop : PFN_WDF_DMA_ENABLER_SELFMANAGED_IO_STOP , pub AddressWidthOverride : ULONG , pub WdmDmaVersionOverride : ULONG , pub Flags : ULONG , } pub type WDF_DMA_ENABLER_CONFIG = _WDF_DMA_ENABLER_CONFIG ; pub type PWDF_DMA_ENABLER_CONFIG = * mut _WDF_DMA_ENABLER_CONFIG ; # [ repr ( C ) ] pub struct _WDF_DMA_SYSTEM_PROFILE_CONFIG { pub Size : ULONG , pub DemandMode : BOOLEAN , pub LoopedTransfer : BOOLEAN , pub DmaWidth : DMA_WIDTH , pub DeviceAddress : PHYSICAL_ADDRESS , pub DmaDescriptor : PCM_PARTIAL_RESOURCE_DESCRIPTOR , } pub type WDF_DMA_SYSTEM_PROFILE_CONFIG = _WDF_DMA_SYSTEM_PROFILE_CONFIG ; pub type PWDF_DMA_SYSTEM_PROFILE_CONFIG = * mut _WDF_DMA_SYSTEM_PROFILE_CONFIG ; pub type PFN_WDFDMAENABLERCREATE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , Device : WDFDEVICE , Config : PWDF_DMA_ENABLER_CONFIG , Attributes : PWDF_OBJECT_ATTRIBUTES , DmaEnablerHandle : * mut WDFDMAENABLER ) -> NTSTATUS > ; pub type PFN_WDFDMAENABLERCONFIGURESYSTEMPROFILE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DmaEnabler : WDFDMAENABLER , ProfileConfig : PWDF_DMA_SYSTEM_PROFILE_CONFIG , ConfigDirection : WDF_DMA_DIRECTION ) -> NTSTATUS > ; pub type PFN_WDFDMAENABLERGETMAXIMUMLENGTH = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DmaEnabler : WDFDMAENABLER ) -> usize > ; pub type PFN_WDFDMAENABLERGETMAXIMUMSCATTERGATHERELEMENTS = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DmaEnabler : WDFDMAENABLER ) -> usize > ; pub type PFN_WDFDMAENABLERSETMAXIMUMSCATTERGATHERELEMENTS = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DmaEnabler : WDFDMAENABLER , MaximumFragments : usize ) > ; pub type PFN_WDFDMAENABLERGETFRAGMENTLENGTH = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DmaEnabler : WDFDMAENABLER , DmaDirection : WDF_DMA_DIRECTION ) -> usize > ; pub type PFN_WDFDMAENABLERWDMGETDMAADAPTER = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DmaEnabler : WDFDMAENABLER , DmaDirection : WDF_DMA_DIRECTION ) -> PDMA_ADAPTER > ; pub type EVT_WDF_PROGRAM_DMA = :: std :: option :: Option < unsafe extern "C" fn ( Transaction : WDFDMATRANSACTION , Device : WDFDEVICE , Context : WDFCONTEXT , Direction : WDF_DMA_DIRECTION , SgList : PSCATTER_GATHER_LIST ) -> BOOLEAN > ; pub type PFN_WDF_PROGRAM_DMA = EVT_WDF_PROGRAM_DMA ; pub type EVT_WDF_DMA_TRANSACTION_CONFIGURE_DMA_CHANNEL = :: std :: option :: Option < unsafe extern "C" fn ( DmaTransaction : WDFDMATRANSACTION , Device : WDFDEVICE , Context : PVOID , Mdl : PMDL , Offset : usize , Length : usize ) -> BOOLEAN > ; pub type PFN_WDF_DMA_TRANSACTION_CONFIGURE_DMA_CHANNEL = EVT_WDF_DMA_TRANSACTION_CONFIGURE_DMA_CHANNEL ; pub type EVT_WDF_DMA_TRANSACTION_DMA_TRANSFER_COMPLETE = :: std :: option :: Option < unsafe extern "C" fn ( Transaction : WDFDMATRANSACTION , Device : WDFDEVICE , Context : WDFCONTEXT , Direction : WDF_DMA_DIRECTION , Status : DMA_COMPLETION_STATUS ) > ; pub type PFN_WDF_DMA_TRANSACTION_DMA_TRANSFER_COMPLETE = EVT_WDF_DMA_TRANSACTION_DMA_TRANSFER_COMPLETE ; pub type EVT_WDF_RESERVE_DMA = :: std :: option :: Option < unsafe extern "C" fn ( DmaTransaction : WDFDMATRANSACTION , Context : PVOID ) > ; pub type PFN_WDF_RESERVE_DMA = EVT_WDF_RESERVE_DMA ; pub type PFN_WDFDMATRANSACTIONCREATE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DmaEnabler : WDFDMAENABLER , Attributes : PWDF_OBJECT_ATTRIBUTES , DmaTransaction : * mut WDFDMATRANSACTION ) -> NTSTATUS > ; pub type PFN_WDFDMATRANSACTIONINITIALIZE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DmaTransaction : WDFDMATRANSACTION , EvtProgramDmaFunction : PFN_WDF_PROGRAM_DMA , DmaDirection : WDF_DMA_DIRECTION , Mdl : PMDL , VirtualAddress : PVOID , Length : usize ) -> NTSTATUS > ; pub type PFN_WDFDMATRANSACTIONINITIALIZEUSINGOFFSET = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DmaTransaction : WDFDMATRANSACTION , EvtProgramDmaFunction : PFN_WDF_PROGRAM_DMA , DmaDirection : WDF_DMA_DIRECTION , Mdl : PMDL , Offset : usize , Length : usize ) -> NTSTATUS > ; pub type PFN_WDFDMATRANSACTIONINITIALIZEUSINGREQUEST = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DmaTransaction : WDFDMATRANSACTION , Request : WDFREQUEST , EvtProgramDmaFunction : PFN_WDF_PROGRAM_DMA , DmaDirection : WDF_DMA_DIRECTION ) -> NTSTATUS > ; pub type PFN_WDFDMATRANSACTIONEXECUTE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DmaTransaction : WDFDMATRANSACTION , Context : WDFCONTEXT ) -> NTSTATUS > ; pub type PFN_WDFDMATRANSACTIONRELEASE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DmaTransaction : WDFDMATRANSACTION ) -> NTSTATUS > ; pub type PFN_WDFDMATRANSACTIONDMACOMPLETED = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DmaTransaction : WDFDMATRANSACTION , Status : * mut NTSTATUS ) -> BOOLEAN > ; pub type PFN_WDFDMATRANSACTIONDMACOMPLETEDWITHLENGTH = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DmaTransaction : WDFDMATRANSACTION , TransferredLength : usize , Status : * mut NTSTATUS ) -> BOOLEAN > ; pub type PFN_WDFDMATRANSACTIONDMACOMPLETEDFINAL = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DmaTransaction : WDFDMATRANSACTION , FinalTransferredLength : usize , Status : * mut NTSTATUS ) -> BOOLEAN > ; pub type PFN_WDFDMATRANSACTIONGETBYTESTRANSFERRED = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DmaTransaction : WDFDMATRANSACTION ) -> usize > ; pub type PFN_WDFDMATRANSACTIONSETMAXIMUMLENGTH = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DmaTransaction : WDFDMATRANSACTION , MaximumLength : usize ) > ; pub type PFN_WDFDMATRANSACTIONSETSINGLETRANSFERREQUIREMENT = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DmaTransaction : WDFDMATRANSACTION , RequireSingleTransfer : BOOLEAN ) > ; pub type PFN_WDFDMATRANSACTIONGETREQUEST = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DmaTransaction : WDFDMATRANSACTION ) -> WDFREQUEST > ; pub type PFN_WDFDMATRANSACTIONGETCURRENTDMATRANSFERLENGTH = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DmaTransaction : WDFDMATRANSACTION ) -> usize > ; pub type PFN_WDFDMATRANSACTIONGETDEVICE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DmaTransaction : WDFDMATRANSACTION ) -> WDFDEVICE > ; pub type PFN_WDFDMATRANSACTIONGETTRANSFERINFO = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DmaTransaction : WDFDMATRANSACTION , MapRegisterCount : * mut ULONG , ScatterGatherElementCount : * mut ULONG ) > ; pub type PFN_WDFDMATRANSACTIONSETCHANNELCONFIGURATIONCALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DmaTransaction : WDFDMATRANSACTION , ConfigureRoutine : PFN_WDF_DMA_TRANSACTION_CONFIGURE_DMA_CHANNEL , ConfigureContext : PVOID ) > ; pub type PFN_WDFDMATRANSACTIONSETTRANSFERCOMPLETECALLBACK = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DmaTransaction : WDFDMATRANSACTION , DmaCompletionRoutine : PFN_WDF_DMA_TRANSACTION_DMA_TRANSFER_COMPLETE , DmaCompletionContext : PVOID ) > ; pub type PFN_WDFDMATRANSACTIONSETIMMEDIATEEXECUTION = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DmaTransaction : WDFDMATRANSACTION , UseImmediateExecution : BOOLEAN ) > ; pub type PFN_WDFDMATRANSACTIONALLOCATERESOURCES = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DmaTransaction : WDFDMATRANSACTION , DmaDirection : WDF_DMA_DIRECTION , RequiredMapRegisters : ULONG , EvtReserveDmaFunction : PFN_WDF_RESERVE_DMA , EvtReserveDmaContext : PVOID ) -> NTSTATUS > ; pub type PFN_WDFDMATRANSACTIONSETDEVICEADDRESSOFFSET = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DmaTransaction : WDFDMATRANSACTION , Offset : ULONG ) > ; pub type PFN_WDFDMATRANSACTIONFREERESOURCES = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DmaTransaction : WDFDMATRANSACTION ) > ; pub type PFN_WDFDMATRANSACTIONCANCEL = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DmaTransaction : WDFDMATRANSACTION ) -> BOOLEAN > ; pub type PFN_WDFDMATRANSACTIONWDMGETTRANSFERCONTEXT = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DmaTransaction : WDFDMATRANSACTION ) -> PVOID > ; pub type PFN_WDFDMATRANSACTIONSTOPSYSTEMTRANSFER = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DmaTransaction : WDFDMATRANSACTION ) > ; # [ repr ( C ) ] pub struct _WDF_COMMON_BUFFER_CONFIG { pub Size : ULONG , pub AlignmentRequirement : ULONG , } pub type WDF_COMMON_BUFFER_CONFIG = _WDF_COMMON_BUFFER_CONFIG ; pub type PWDF_COMMON_BUFFER_CONFIG = * mut _WDF_COMMON_BUFFER_CONFIG ; pub type PFN_WDFCOMMONBUFFERCREATE = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DmaEnabler : WDFDMAENABLER , Length : usize , Attributes : PWDF_OBJECT_ATTRIBUTES , CommonBuffer : * mut WDFCOMMONBUFFER ) -> NTSTATUS > ; pub type PFN_WDFCOMMONBUFFERCREATEWITHCONFIG = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , DmaEnabler : WDFDMAENABLER , Length : usize , Config : PWDF_COMMON_BUFFER_CONFIG , Attributes : PWDF_OBJECT_ATTRIBUTES , CommonBuffer : * mut WDFCOMMONBUFFER ) -> NTSTATUS > ; pub type PFN_WDFCOMMONBUFFERGETALIGNEDVIRTUALADDRESS = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , CommonBuffer : WDFCOMMONBUFFER ) -> PVOID > ; pub type PFN_WDFCOMMONBUFFERGETALIGNEDLOGICALADDRESS = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , CommonBuffer : WDFCOMMONBUFFER ) -> PHYSICAL_ADDRESS > ; pub type PFN_WDFCOMMONBUFFERGETLENGTH = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , CommonBuffer : WDFCOMMONBUFFER ) -> usize > ; pub const _WDF_BUGCHECK_CODES_WDF_POWER_ROUTINE_TIMED_OUT : _WDF_BUGCHECK_CODES = 1 ; pub const _WDF_BUGCHECK_CODES_WDF_RECURSIVE_LOCK : _WDF_BUGCHECK_CODES = 2 ; pub const _WDF_BUGCHECK_CODES_WDF_VERIFIER_FATAL_ERROR : _WDF_BUGCHECK_CODES = 3 ; pub const _WDF_BUGCHECK_CODES_WDF_REQUIRED_PARAMETER_IS_NULL : _WDF_BUGCHECK_CODES = 4 ; pub const _WDF_BUGCHECK_CODES_WDF_INVALID_HANDLE : _WDF_BUGCHECK_CODES = 5 ; pub const _WDF_BUGCHECK_CODES_WDF_REQUEST_FATAL_ERROR : _WDF_BUGCHECK_CODES = 6 ; pub const _WDF_BUGCHECK_CODES_WDF_OBJECT_ERROR : _WDF_BUGCHECK_CODES = 7 ; pub const _WDF_BUGCHECK_CODES_WDF_DMA_FATAL_ERROR : _WDF_BUGCHECK_CODES = 8 ; pub const _WDF_BUGCHECK_CODES_WDF_INVALID_INTERRUPT : _WDF_BUGCHECK_CODES = 9 ; pub const _WDF_BUGCHECK_CODES_WDF_QUEUE_FATAL_ERROR : _WDF_BUGCHECK_CODES = 10 ; pub const _WDF_BUGCHECK_CODES_WDF_INVALID_LOCK_OPERATION : _WDF_BUGCHECK_CODES = 11 ; pub const _WDF_BUGCHECK_CODES_WDF_PNP_FATAL_ERROR : _WDF_BUGCHECK_CODES = 12 ; pub const _WDF_BUGCHECK_CODES_WDF_POWER_MULTIPLE_PPO : _WDF_BUGCHECK_CODES = 13 ; pub const _WDF_BUGCHECK_CODES_WDF_VERIFIER_IRQL_MISMATCH : _WDF_BUGCHECK_CODES = 14 ; pub const _WDF_BUGCHECK_CODES_WDF_VERIFIER_CRITICAL_REGION_MISMATCH : _WDF_BUGCHECK_CODES = 15 ; pub type _WDF_BUGCHECK_CODES = i32 ; pub use self :: _WDF_BUGCHECK_CODES as WDF_BUGCHECK_CODES ; pub const _WDF_REQUEST_FATAL_ERROR_CODES_WDF_REQUEST_FATAL_ERROR_NO_MORE_STACK_LOCATIONS : _WDF_REQUEST_FATAL_ERROR_CODES = 1 ; pub const _WDF_REQUEST_FATAL_ERROR_CODES_WDF_REQUEST_FATAL_ERROR_NULL_IRP : _WDF_REQUEST_FATAL_ERROR_CODES = 2 ; pub const _WDF_REQUEST_FATAL_ERROR_CODES_WDF_REQUEST_FATAL_ERROR_REQUEST_ALREADY_SENT : _WDF_REQUEST_FATAL_ERROR_CODES = 3 ; pub const _WDF_REQUEST_FATAL_ERROR_CODES_WDF_REQUEST_FATAL_ERROR_INFORMATION_LENGTH_MISMATCH : _WDF_REQUEST_FATAL_ERROR_CODES = 4 ; pub const _WDF_REQUEST_FATAL_ERROR_CODES_WDF_REQUEST_FATAL_ERROR_REQUEST_NOT_IN_QUEUE : _WDF_REQUEST_FATAL_ERROR_CODES = 5 ; pub type _WDF_REQUEST_FATAL_ERROR_CODES = i32 ; pub use self :: _WDF_REQUEST_FATAL_ERROR_CODES as WDF_REQUEST_FATAL_ERROR_CODES ; # [ repr ( C ) ] pub struct _WDF_POWER_ROUTINE_TIMED_OUT_DATA { pub PowerState : WDF_DEVICE_POWER_STATE , pub PowerPolicyState : WDF_DEVICE_POWER_POLICY_STATE , pub DeviceObject : PDEVICE_OBJECT , pub Device : WDFDEVICE , pub TimedOutThread : PKTHREAD , } pub type WDF_POWER_ROUTINE_TIMED_OUT_DATA = _WDF_POWER_ROUTINE_TIMED_OUT_DATA ; # [ repr ( C ) ] pub struct _WDF_REQUEST_FATAL_ERROR_INFORMATION_LENGTH_MISMATCH_DATA { pub Request : WDFREQUEST , pub Irp : PIRP , pub OutputBufferLength : ULONG , pub Information : ULONG_PTR , pub MajorFunction : UCHAR , } pub type WDF_REQUEST_FATAL_ERROR_INFORMATION_LENGTH_MISMATCH_DATA = _WDF_REQUEST_FATAL_ERROR_INFORMATION_LENGTH_MISMATCH_DATA ; pub type PWDF_REQUEST_FATAL_ERROR_INFORMATION_LENGTH_MISMATCH_DATA = * mut _WDF_REQUEST_FATAL_ERROR_INFORMATION_LENGTH_MISMATCH_DATA ; # [ repr ( C ) ] pub struct _WDF_QUEUE_FATAL_ERROR_DATA { pub Queue : WDFQUEUE , pub Request : WDFREQUEST , pub Status : NTSTATUS , } pub type WDF_QUEUE_FATAL_ERROR_DATA = _WDF_QUEUE_FATAL_ERROR_DATA ; pub type PWDF_QUEUE_FATAL_ERROR_DATA = * mut _WDF_QUEUE_FATAL_ERROR_DATA ; pub type EVT_WDF_DEVICE_CONTEXT_CLEANUP = EVT_WDF_OBJECT_CONTEXT_CLEANUP ; pub type EVT_WDF_DEVICE_CONTEXT_DESTROY = EVT_WDF_OBJECT_CONTEXT_DESTROY ; pub type EVT_WDF_IO_QUEUE_CONTEXT_CLEANUP_CALLBACK = EVT_WDF_OBJECT_CONTEXT_CLEANUP ; pub type EVT_WDF_IO_QUEUE_CONTEXT_DESTROY_CALLBACK = EVT_WDF_OBJECT_CONTEXT_DESTROY ; pub type EVT_WDF_FILE_CONTEXT_CLEANUP_CALLBACK = EVT_WDF_OBJECT_CONTEXT_CLEANUP ; pub type EVT_WDF_FILE_CONTEXT_DESTROY_CALLBACK = EVT_WDF_OBJECT_CONTEXT_DESTROY ; pub const _WDF_TASK_SEND_OPTIONS_FLAGS_WDF_TASK_SEND_OPTION_TIMEOUT : _WDF_TASK_SEND_OPTIONS_FLAGS = 1 ; pub const _WDF_TASK_SEND_OPTIONS_FLAGS_WDF_TASK_SEND_OPTION_SYNCHRONOUS : _WDF_TASK_SEND_OPTIONS_FLAGS = 2 ; pub type _WDF_TASK_SEND_OPTIONS_FLAGS = i32 ; pub use self :: _WDF_TASK_SEND_OPTIONS_FLAGS as WDF_TASK_SEND_OPTIONS_FLAGS ; # [ repr ( C ) ] pub struct _WDF_TASK_SEND_OPTIONS { pub Size : ULONG , pub Flags : ULONG , pub Timeout : LONGLONG , } pub type WDF_TASK_SEND_OPTIONS = _WDF_TASK_SEND_OPTIONS ; pub type PWDF_TASK_SEND_OPTIONS = * mut _WDF_TASK_SEND_OPTIONS ; pub type PFN_WDFCOMPANIONTARGETSENDTASKSYNCHRONOUSLY = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , CompanionTarget : WDFCOMPANIONTARGET , TaskQueueIdentifier : USHORT , TaskOperationCode : ULONG , InputBuffer : PWDF_MEMORY_DESCRIPTOR , OutputBuffer : PWDF_MEMORY_DESCRIPTOR , TaskOptions : PWDF_TASK_SEND_OPTIONS , BytesReturned : PULONG_PTR ) -> NTSTATUS > ; pub type PFN_WDFCOMPANIONTARGETWDMGETCOMPANIONPROCESS = :: std :: option :: Option < unsafe extern "C" fn ( DriverGlobals : PWDF_DRIVER_GLOBALS , CompanionTarget : WDFCOMPANIONTARGET ) -> PEPROCESS > ; # [ repr ( C ) ] pub struct __crt_locale_data { pub _address : u8 , } # [ repr ( C ) ] pub struct __crt_multibyte_data { pub _address : u8 , } # [ repr ( C ) ] pub struct _KQUEUE { pub _address : u8 , } # [ repr ( C ) ] pub struct _KPRCB { pub _address : u8 , } # [ repr ( C ) ] pub struct _KIDTENTRY { pub _address : u8 , } # [ repr ( C ) ] pub struct _KGDTENTRY { pub _address : u8 , } # [ repr ( C ) ] pub struct _KTSS { pub _address : u8 , } # [ repr ( C ) ] pub struct _CREATE_DISK { pub _address : u8 , } # [ repr ( C ) ] pub struct _DRIVE_LAYOUT_INFORMATION_EX { pub _address : u8 , } # [ repr ( C ) ] pub struct _DRIVE_LAYOUT_INFORMATION_EX { pub _address : u8 , } # [ repr ( C ) ] pub struct _SET_PARTITION_INFORMATION_EX { pub _address : u8 , } # [ repr ( C ) ] pub struct _ECP_LIST { pub _address : u8 , }