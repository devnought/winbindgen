#![no_std]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(improper_ctypes)]

extern crate libc;

#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::core::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::core::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::core::mem::transmute(self) }
}
impl <T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::core::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const _STRSAFE_USE_SECURE_CRT: libc::c_uint = 0;
pub const _SAL_VERSION: libc::c_uint = 20;
pub const __SAL_H_VERSION: libc::c_uint = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: libc::c_uint = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: libc::c_uint = 0;
pub const _CRT_PACKING: libc::c_uint = 8;
pub const _HAS_EXCEPTIONS: libc::c_uint = 1;
pub const EXCEPTION_EXECUTE_HANDLER: libc::c_uint = 1;
pub const EXCEPTION_CONTINUE_SEARCH: libc::c_uint = 0;
pub const _ARGMAX: libc::c_uint = 100;
pub const _CRT_INT_MAX: libc::c_uint = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: libc::c_uint = 1;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: libc::c_uint = 0;
pub const _CRT_BUILD_DESKTOP_APP: libc::c_uint = 1;
pub const __STDC_SECURE_LIB__: libc::c_uint = 200411;
pub const __GOT_SECURE_LIB__: libc::c_uint = 200411;
pub const __STDC_WANT_SECURE_LIB__: libc::c_uint = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: libc::c_uint = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: libc::c_uint = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: libc::c_uint = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: libc::c_uint = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: libc::c_uint = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: libc::c_uint = 0;
pub const _UPPER: libc::c_uint = 1;
pub const _LOWER: libc::c_uint = 2;
pub const _DIGIT: libc::c_uint = 4;
pub const _SPACE: libc::c_uint = 8;
pub const _PUNCT: libc::c_uint = 16;
pub const _CONTROL: libc::c_uint = 32;
pub const _BLANK: libc::c_uint = 64;
pub const _HEX: libc::c_uint = 128;
pub const _LEADBYTE: libc::c_uint = 32768;
pub const _ALPHA: libc::c_uint = 259;
pub const WINAPI_FAMILY_PC_APP: libc::c_uint = 2;
pub const WINAPI_FAMILY_PHONE_APP: libc::c_uint = 3;
pub const WINAPI_FAMILY_SYSTEM: libc::c_uint = 4;
pub const WINAPI_FAMILY_SERVER: libc::c_uint = 5;
pub const WINAPI_FAMILY_DESKTOP_APP: libc::c_uint = 100;
pub const WINAPI_FAMILY_APP: libc::c_uint = 2;
pub const WINAPI_FAMILY: libc::c_uint = 100;
pub const ANYSIZE_ARRAY: libc::c_uint = 1;
pub const __SAL_H_FULL_VER: libc::c_uint = 140050727;
pub const __SPECSTRINGS_STRICT_LEVEL: libc::c_uint = 1;
pub const __drv_typeConst: libc::c_uint = 0;
pub const __drv_typeCond: libc::c_uint = 1;
pub const __drv_typeBitset: libc::c_uint = 2;
pub const __drv_typeExpr: libc::c_uint = 3;
pub const DISPATCH_LEVEL: libc::c_uint = 2;
pub const APC_LEVEL: libc::c_uint = 1;
pub const PASSIVE_LEVEL: libc::c_uint = 0;
pub const HIGH_LEVEL: libc::c_uint = 31;
pub const MEMORY_ALLOCATION_ALIGNMENT: libc::c_uint = 16;
pub const SYSTEM_CACHE_ALIGNMENT_SIZE: libc::c_uint = 64;
pub const PRAGMA_DEPRECATED_DDK: libc::c_uint = 0;
pub const STRICT: libc::c_uint = 1;
pub const ALL_PROCESSOR_GROUPS: libc::c_uint = 65535;
pub const MAXIMUM_PROC_PER_GROUP: libc::c_uint = 64;
pub const MAXIMUM_PROCESSORS: libc::c_uint = 64;
pub const OBJ_HANDLE_TAGBITS: libc::c_uint = 3;
pub const APPLICATION_ERROR_MASK: libc::c_uint = 536870912;
pub const ERROR_SEVERITY_SUCCESS: libc::c_uint = 0;
pub const ERROR_SEVERITY_INFORMATIONAL: libc::c_uint = 1073741824;
pub const ERROR_SEVERITY_WARNING: libc::c_uint = 2147483648;
pub const ERROR_SEVERITY_ERROR: libc::c_uint = 3221225472;
pub const MAXLONGLONG: libc::c_ulonglong = 9223372036854775807;
pub const RTL_BALANCED_NODE_RESERVED_PARENT_MASK: libc::c_uint = 3;
pub const OBJ_INHERIT: libc::c_uint = 2;
pub const OBJ_PERMANENT: libc::c_uint = 16;
pub const OBJ_EXCLUSIVE: libc::c_uint = 32;
pub const OBJ_CASE_INSENSITIVE: libc::c_uint = 64;
pub const OBJ_OPENIF: libc::c_uint = 128;
pub const OBJ_OPENLINK: libc::c_uint = 256;
pub const OBJ_KERNEL_HANDLE: libc::c_uint = 512;
pub const OBJ_FORCE_ACCESS_CHECK: libc::c_uint = 1024;
pub const OBJ_IGNORE_IMPERSONATED_DEVICEMAP: libc::c_uint = 2048;
pub const OBJ_DONT_REPARSE: libc::c_uint = 4096;
pub const OBJ_VALID_ATTRIBUTES: libc::c_uint = 8178;
pub const FALSE: libc::c_uint = 0;
pub const TRUE: libc::c_uint = 1;
pub const EPERM: libc::c_uint = 1;
pub const ENOENT: libc::c_uint = 2;
pub const ESRCH: libc::c_uint = 3;
pub const EINTR: libc::c_uint = 4;
pub const EIO: libc::c_uint = 5;
pub const ENXIO: libc::c_uint = 6;
pub const E2BIG: libc::c_uint = 7;
pub const ENOEXEC: libc::c_uint = 8;
pub const EBADF: libc::c_uint = 9;
pub const ECHILD: libc::c_uint = 10;
pub const EAGAIN: libc::c_uint = 11;
pub const ENOMEM: libc::c_uint = 12;
pub const EACCES: libc::c_uint = 13;
pub const EFAULT: libc::c_uint = 14;
pub const EBUSY: libc::c_uint = 16;
pub const EEXIST: libc::c_uint = 17;
pub const EXDEV: libc::c_uint = 18;
pub const ENODEV: libc::c_uint = 19;
pub const ENOTDIR: libc::c_uint = 20;
pub const EISDIR: libc::c_uint = 21;
pub const ENFILE: libc::c_uint = 23;
pub const EMFILE: libc::c_uint = 24;
pub const ENOTTY: libc::c_uint = 25;
pub const EFBIG: libc::c_uint = 27;
pub const ENOSPC: libc::c_uint = 28;
pub const ESPIPE: libc::c_uint = 29;
pub const EROFS: libc::c_uint = 30;
pub const EMLINK: libc::c_uint = 31;
pub const EPIPE: libc::c_uint = 32;
pub const EDOM: libc::c_uint = 33;
pub const EDEADLK: libc::c_uint = 36;
pub const ENAMETOOLONG: libc::c_uint = 38;
pub const ENOLCK: libc::c_uint = 39;
pub const ENOSYS: libc::c_uint = 40;
pub const ENOTEMPTY: libc::c_uint = 41;
pub const EINVAL: libc::c_uint = 22;
pub const ERANGE: libc::c_uint = 34;
pub const EILSEQ: libc::c_uint = 42;
pub const STRUNCATE: libc::c_uint = 80;
pub const EDEADLOCK: libc::c_uint = 36;
pub const EADDRINUSE: libc::c_uint = 100;
pub const EADDRNOTAVAIL: libc::c_uint = 101;
pub const EAFNOSUPPORT: libc::c_uint = 102;
pub const EALREADY: libc::c_uint = 103;
pub const EBADMSG: libc::c_uint = 104;
pub const ECANCELED: libc::c_uint = 105;
pub const ECONNABORTED: libc::c_uint = 106;
pub const ECONNREFUSED: libc::c_uint = 107;
pub const ECONNRESET: libc::c_uint = 108;
pub const EDESTADDRREQ: libc::c_uint = 109;
pub const EHOSTUNREACH: libc::c_uint = 110;
pub const EIDRM: libc::c_uint = 111;
pub const EINPROGRESS: libc::c_uint = 112;
pub const EISCONN: libc::c_uint = 113;
pub const ELOOP: libc::c_uint = 114;
pub const EMSGSIZE: libc::c_uint = 115;
pub const ENETDOWN: libc::c_uint = 116;
pub const ENETRESET: libc::c_uint = 117;
pub const ENETUNREACH: libc::c_uint = 118;
pub const ENOBUFS: libc::c_uint = 119;
pub const ENODATA: libc::c_uint = 120;
pub const ENOLINK: libc::c_uint = 121;
pub const ENOMSG: libc::c_uint = 122;
pub const ENOPROTOOPT: libc::c_uint = 123;
pub const ENOSR: libc::c_uint = 124;
pub const ENOSTR: libc::c_uint = 125;
pub const ENOTCONN: libc::c_uint = 126;
pub const ENOTRECOVERABLE: libc::c_uint = 127;
pub const ENOTSOCK: libc::c_uint = 128;
pub const ENOTSUP: libc::c_uint = 129;
pub const EOPNOTSUPP: libc::c_uint = 130;
pub const EOTHER: libc::c_uint = 131;
pub const EOVERFLOW: libc::c_uint = 132;
pub const EOWNERDEAD: libc::c_uint = 133;
pub const EPROTO: libc::c_uint = 134;
pub const EPROTONOSUPPORT: libc::c_uint = 135;
pub const EPROTOTYPE: libc::c_uint = 136;
pub const ETIME: libc::c_uint = 137;
pub const ETIMEDOUT: libc::c_uint = 138;
pub const ETXTBSY: libc::c_uint = 139;
pub const EWOULDBLOCK: libc::c_uint = 140;
pub const _NLSCMPERROR: libc::c_uint = 2147483647;
pub const MINCHAR: libc::c_uint = 128;
pub const MAXCHAR: libc::c_uint = 127;
pub const MINSHORT: libc::c_uint = 32768;
pub const MAXSHORT: libc::c_uint = 32767;
pub const MINLONG: libc::c_uint = 2147483648;
pub const MAXLONG: libc::c_uint = 2147483647;
pub const MAXUCHAR: libc::c_uint = 255;
pub const MAXUSHORT: libc::c_uint = 65535;
pub const MAXULONG: libc::c_uint = 4294967295;
pub const VER_SERVER_NT: libc::c_uint = 2147483648;
pub const VER_WORKSTATION_NT: libc::c_uint = 1073741824;
pub const VER_SUITE_SMALLBUSINESS: libc::c_uint = 1;
pub const VER_SUITE_ENTERPRISE: libc::c_uint = 2;
pub const VER_SUITE_BACKOFFICE: libc::c_uint = 4;
pub const VER_SUITE_COMMUNICATIONS: libc::c_uint = 8;
pub const VER_SUITE_TERMINAL: libc::c_uint = 16;
pub const VER_SUITE_SMALLBUSINESS_RESTRICTED: libc::c_uint = 32;
pub const VER_SUITE_EMBEDDEDNT: libc::c_uint = 64;
pub const VER_SUITE_DATACENTER: libc::c_uint = 128;
pub const VER_SUITE_SINGLEUSERTS: libc::c_uint = 256;
pub const VER_SUITE_PERSONAL: libc::c_uint = 512;
pub const VER_SUITE_BLADE: libc::c_uint = 1024;
pub const VER_SUITE_EMBEDDED_RESTRICTED: libc::c_uint = 2048;
pub const VER_SUITE_SECURITY_APPLIANCE: libc::c_uint = 4096;
pub const VER_SUITE_STORAGE_SERVER: libc::c_uint = 8192;
pub const VER_SUITE_COMPUTE_SERVER: libc::c_uint = 16384;
pub const VER_SUITE_WH_SERVER: libc::c_uint = 32768;
pub const PRODUCT_UNDEFINED: libc::c_uint = 0;
pub const PRODUCT_ULTIMATE: libc::c_uint = 1;
pub const PRODUCT_HOME_BASIC: libc::c_uint = 2;
pub const PRODUCT_HOME_PREMIUM: libc::c_uint = 3;
pub const PRODUCT_ENTERPRISE: libc::c_uint = 4;
pub const PRODUCT_HOME_BASIC_N: libc::c_uint = 5;
pub const PRODUCT_BUSINESS: libc::c_uint = 6;
pub const PRODUCT_STANDARD_SERVER: libc::c_uint = 7;
pub const PRODUCT_DATACENTER_SERVER: libc::c_uint = 8;
pub const PRODUCT_SMALLBUSINESS_SERVER: libc::c_uint = 9;
pub const PRODUCT_ENTERPRISE_SERVER: libc::c_uint = 10;
pub const PRODUCT_STARTER: libc::c_uint = 11;
pub const PRODUCT_DATACENTER_SERVER_CORE: libc::c_uint = 12;
pub const PRODUCT_STANDARD_SERVER_CORE: libc::c_uint = 13;
pub const PRODUCT_ENTERPRISE_SERVER_CORE: libc::c_uint = 14;
pub const PRODUCT_ENTERPRISE_SERVER_IA64: libc::c_uint = 15;
pub const PRODUCT_BUSINESS_N: libc::c_uint = 16;
pub const PRODUCT_WEB_SERVER: libc::c_uint = 17;
pub const PRODUCT_CLUSTER_SERVER: libc::c_uint = 18;
pub const PRODUCT_HOME_SERVER: libc::c_uint = 19;
pub const PRODUCT_STORAGE_EXPRESS_SERVER: libc::c_uint = 20;
pub const PRODUCT_STORAGE_STANDARD_SERVER: libc::c_uint = 21;
pub const PRODUCT_STORAGE_WORKGROUP_SERVER: libc::c_uint = 22;
pub const PRODUCT_STORAGE_ENTERPRISE_SERVER: libc::c_uint = 23;
pub const PRODUCT_SERVER_FOR_SMALLBUSINESS: libc::c_uint = 24;
pub const PRODUCT_SMALLBUSINESS_SERVER_PREMIUM: libc::c_uint = 25;
pub const PRODUCT_HOME_PREMIUM_N: libc::c_uint = 26;
pub const PRODUCT_ENTERPRISE_N: libc::c_uint = 27;
pub const PRODUCT_ULTIMATE_N: libc::c_uint = 28;
pub const PRODUCT_WEB_SERVER_CORE: libc::c_uint = 29;
pub const PRODUCT_MEDIUMBUSINESS_SERVER_MANAGEMENT: libc::c_uint = 30;
pub const PRODUCT_MEDIUMBUSINESS_SERVER_SECURITY: libc::c_uint = 31;
pub const PRODUCT_MEDIUMBUSINESS_SERVER_MESSAGING: libc::c_uint = 32;
pub const PRODUCT_SERVER_FOUNDATION: libc::c_uint = 33;
pub const PRODUCT_HOME_PREMIUM_SERVER: libc::c_uint = 34;
pub const PRODUCT_SERVER_FOR_SMALLBUSINESS_V: libc::c_uint = 35;
pub const PRODUCT_STANDARD_SERVER_V: libc::c_uint = 36;
pub const PRODUCT_DATACENTER_SERVER_V: libc::c_uint = 37;
pub const PRODUCT_ENTERPRISE_SERVER_V: libc::c_uint = 38;
pub const PRODUCT_DATACENTER_SERVER_CORE_V: libc::c_uint = 39;
pub const PRODUCT_STANDARD_SERVER_CORE_V: libc::c_uint = 40;
pub const PRODUCT_ENTERPRISE_SERVER_CORE_V: libc::c_uint = 41;
pub const PRODUCT_HYPERV: libc::c_uint = 42;
pub const PRODUCT_STORAGE_EXPRESS_SERVER_CORE: libc::c_uint = 43;
pub const PRODUCT_STORAGE_STANDARD_SERVER_CORE: libc::c_uint = 44;
pub const PRODUCT_STORAGE_WORKGROUP_SERVER_CORE: libc::c_uint = 45;
pub const PRODUCT_STORAGE_ENTERPRISE_SERVER_CORE: libc::c_uint = 46;
pub const PRODUCT_STARTER_N: libc::c_uint = 47;
pub const PRODUCT_PROFESSIONAL: libc::c_uint = 48;
pub const PRODUCT_PROFESSIONAL_N: libc::c_uint = 49;
pub const PRODUCT_SB_SOLUTION_SERVER: libc::c_uint = 50;
pub const PRODUCT_SERVER_FOR_SB_SOLUTIONS: libc::c_uint = 51;
pub const PRODUCT_STANDARD_SERVER_SOLUTIONS: libc::c_uint = 52;
pub const PRODUCT_STANDARD_SERVER_SOLUTIONS_CORE: libc::c_uint = 53;
pub const PRODUCT_SB_SOLUTION_SERVER_EM: libc::c_uint = 54;
pub const PRODUCT_SERVER_FOR_SB_SOLUTIONS_EM: libc::c_uint = 55;
pub const PRODUCT_SOLUTION_EMBEDDEDSERVER: libc::c_uint = 56;
pub const PRODUCT_SOLUTION_EMBEDDEDSERVER_CORE: libc::c_uint = 57;
pub const PRODUCT_PROFESSIONAL_EMBEDDED: libc::c_uint = 58;
pub const PRODUCT_ESSENTIALBUSINESS_SERVER_MGMT: libc::c_uint = 59;
pub const PRODUCT_ESSENTIALBUSINESS_SERVER_ADDL: libc::c_uint = 60;
pub const PRODUCT_ESSENTIALBUSINESS_SERVER_MGMTSVC: libc::c_uint = 61;
pub const PRODUCT_ESSENTIALBUSINESS_SERVER_ADDLSVC: libc::c_uint = 62;
pub const PRODUCT_SMALLBUSINESS_SERVER_PREMIUM_CORE: libc::c_uint = 63;
pub const PRODUCT_CLUSTER_SERVER_V: libc::c_uint = 64;
pub const PRODUCT_EMBEDDED: libc::c_uint = 65;
pub const PRODUCT_STARTER_E: libc::c_uint = 66;
pub const PRODUCT_HOME_BASIC_E: libc::c_uint = 67;
pub const PRODUCT_HOME_PREMIUM_E: libc::c_uint = 68;
pub const PRODUCT_PROFESSIONAL_E: libc::c_uint = 69;
pub const PRODUCT_ENTERPRISE_E: libc::c_uint = 70;
pub const PRODUCT_ULTIMATE_E: libc::c_uint = 71;
pub const PRODUCT_ENTERPRISE_EVALUATION: libc::c_uint = 72;
pub const PRODUCT_MULTIPOINT_STANDARD_SERVER: libc::c_uint = 76;
pub const PRODUCT_MULTIPOINT_PREMIUM_SERVER: libc::c_uint = 77;
pub const PRODUCT_STANDARD_EVALUATION_SERVER: libc::c_uint = 79;
pub const PRODUCT_DATACENTER_EVALUATION_SERVER: libc::c_uint = 80;
pub const PRODUCT_ENTERPRISE_N_EVALUATION: libc::c_uint = 84;
pub const PRODUCT_EMBEDDED_AUTOMOTIVE: libc::c_uint = 85;
pub const PRODUCT_EMBEDDED_INDUSTRY_A: libc::c_uint = 86;
pub const PRODUCT_THINPC: libc::c_uint = 87;
pub const PRODUCT_EMBEDDED_A: libc::c_uint = 88;
pub const PRODUCT_EMBEDDED_INDUSTRY: libc::c_uint = 89;
pub const PRODUCT_EMBEDDED_E: libc::c_uint = 90;
pub const PRODUCT_EMBEDDED_INDUSTRY_E: libc::c_uint = 91;
pub const PRODUCT_EMBEDDED_INDUSTRY_A_E: libc::c_uint = 92;
pub const PRODUCT_STORAGE_WORKGROUP_EVALUATION_SERVER: libc::c_uint = 95;
pub const PRODUCT_STORAGE_STANDARD_EVALUATION_SERVER: libc::c_uint = 96;
pub const PRODUCT_CORE_ARM: libc::c_uint = 97;
pub const PRODUCT_CORE_N: libc::c_uint = 98;
pub const PRODUCT_CORE_COUNTRYSPECIFIC: libc::c_uint = 99;
pub const PRODUCT_CORE_SINGLELANGUAGE: libc::c_uint = 100;
pub const PRODUCT_CORE: libc::c_uint = 101;
pub const PRODUCT_PROFESSIONAL_WMC: libc::c_uint = 103;
pub const PRODUCT_MOBILE_CORE: libc::c_uint = 104;
pub const PRODUCT_EMBEDDED_INDUSTRY_EVAL: libc::c_uint = 105;
pub const PRODUCT_EMBEDDED_INDUSTRY_E_EVAL: libc::c_uint = 106;
pub const PRODUCT_EMBEDDED_EVAL: libc::c_uint = 107;
pub const PRODUCT_EMBEDDED_E_EVAL: libc::c_uint = 108;
pub const PRODUCT_NANO_SERVER: libc::c_uint = 109;
pub const PRODUCT_CLOUD_STORAGE_SERVER: libc::c_uint = 110;
pub const PRODUCT_CORE_CONNECTED: libc::c_uint = 111;
pub const PRODUCT_PROFESSIONAL_STUDENT: libc::c_uint = 112;
pub const PRODUCT_CORE_CONNECTED_N: libc::c_uint = 113;
pub const PRODUCT_PROFESSIONAL_STUDENT_N: libc::c_uint = 114;
pub const PRODUCT_CORE_CONNECTED_SINGLELANGUAGE: libc::c_uint = 115;
pub const PRODUCT_CORE_CONNECTED_COUNTRYSPECIFIC: libc::c_uint = 116;
pub const PRODUCT_CONNECTED_CAR: libc::c_uint = 117;
pub const PRODUCT_INDUSTRY_HANDHELD: libc::c_uint = 118;
pub const PRODUCT_PPI_PRO: libc::c_uint = 119;
pub const PRODUCT_ARM64_SERVER: libc::c_uint = 120;
pub const PRODUCT_EDUCATION: libc::c_uint = 121;
pub const PRODUCT_EDUCATION_N: libc::c_uint = 122;
pub const PRODUCT_IOTUAP: libc::c_uint = 123;
pub const PRODUCT_CLOUD_HOST_INFRASTRUCTURE_SERVER: libc::c_uint = 124;
pub const PRODUCT_ENTERPRISE_S: libc::c_uint = 125;
pub const PRODUCT_ENTERPRISE_S_N: libc::c_uint = 126;
pub const PRODUCT_PROFESSIONAL_S: libc::c_uint = 127;
pub const PRODUCT_PROFESSIONAL_S_N: libc::c_uint = 128;
pub const PRODUCT_ENTERPRISE_S_EVALUATION: libc::c_uint = 129;
pub const PRODUCT_ENTERPRISE_S_N_EVALUATION: libc::c_uint = 130;
pub const PRODUCT_HOLOGRAPHIC: libc::c_uint = 135;
pub const PRODUCT_PRO_SINGLE_LANGUAGE: libc::c_uint = 138;
pub const PRODUCT_PRO_CHINA: libc::c_uint = 139;
pub const PRODUCT_ENTERPRISE_SUBSCRIPTION: libc::c_uint = 140;
pub const PRODUCT_ENTERPRISE_SUBSCRIPTION_N: libc::c_uint = 141;
pub const PRODUCT_DATACENTER_NANO_SERVER: libc::c_uint = 143;
pub const PRODUCT_STANDARD_NANO_SERVER: libc::c_uint = 144;
pub const PRODUCT_DATACENTER_A_SERVER_CORE: libc::c_uint = 145;
pub const PRODUCT_STANDARD_A_SERVER_CORE: libc::c_uint = 146;
pub const PRODUCT_DATACENTER_WS_SERVER_CORE: libc::c_uint = 147;
pub const PRODUCT_STANDARD_WS_SERVER_CORE: libc::c_uint = 148;
pub const PRODUCT_UTILITY_VM: libc::c_uint = 149;
pub const PRODUCT_DATACENTER_EVALUATION_SERVER_CORE: libc::c_uint = 159;
pub const PRODUCT_STANDARD_EVALUATION_SERVER_CORE: libc::c_uint = 160;
pub const PRODUCT_PRO_WORKSTATION: libc::c_uint = 161;
pub const PRODUCT_PRO_WORKSTATION_N: libc::c_uint = 162;
pub const PRODUCT_PRO_FOR_EDUCATION: libc::c_uint = 164;
pub const PRODUCT_PRO_FOR_EDUCATION_N: libc::c_uint = 165;
pub const PRODUCT_AZURE_SERVER_CORE: libc::c_uint = 168;
pub const PRODUCT_AZURE_NANO_SERVER: libc::c_uint = 169;
pub const PRODUCT_UNLICENSED: libc::c_uint = 2882382797;
pub const _WIN32_WINNT_NT4: libc::c_uint = 1024;
pub const _WIN32_WINNT_WIN2K: libc::c_uint = 1280;
pub const _WIN32_WINNT_WINXP: libc::c_uint = 1281;
pub const _WIN32_WINNT_WS03: libc::c_uint = 1282;
pub const _WIN32_WINNT_WIN6: libc::c_uint = 1536;
pub const _WIN32_WINNT_VISTA: libc::c_uint = 1536;
pub const _WIN32_WINNT_WS08: libc::c_uint = 1536;
pub const _WIN32_WINNT_LONGHORN: libc::c_uint = 1536;
pub const _WIN32_WINNT_WIN7: libc::c_uint = 1537;
pub const _WIN32_WINNT_WIN8: libc::c_uint = 1538;
pub const _WIN32_WINNT_WINBLUE: libc::c_uint = 1539;
pub const _WIN32_WINNT_WINTHRESHOLD: libc::c_uint = 2560;
pub const _WIN32_WINNT_WIN10: libc::c_uint = 2560;
pub const _WIN32_IE_IE20: libc::c_uint = 512;
pub const _WIN32_IE_IE30: libc::c_uint = 768;
pub const _WIN32_IE_IE302: libc::c_uint = 770;
pub const _WIN32_IE_IE40: libc::c_uint = 1024;
pub const _WIN32_IE_IE401: libc::c_uint = 1025;
pub const _WIN32_IE_IE50: libc::c_uint = 1280;
pub const _WIN32_IE_IE501: libc::c_uint = 1281;
pub const _WIN32_IE_IE55: libc::c_uint = 1360;
pub const _WIN32_IE_IE60: libc::c_uint = 1536;
pub const _WIN32_IE_IE60SP1: libc::c_uint = 1537;
pub const _WIN32_IE_IE60SP2: libc::c_uint = 1539;
pub const _WIN32_IE_IE70: libc::c_uint = 1792;
pub const _WIN32_IE_IE80: libc::c_uint = 2048;
pub const _WIN32_IE_IE90: libc::c_uint = 2304;
pub const _WIN32_IE_IE100: libc::c_uint = 2560;
pub const _WIN32_IE_IE110: libc::c_uint = 2560;
pub const _WIN32_IE_NT4: libc::c_uint = 512;
pub const _WIN32_IE_NT4SP1: libc::c_uint = 512;
pub const _WIN32_IE_NT4SP2: libc::c_uint = 512;
pub const _WIN32_IE_NT4SP3: libc::c_uint = 770;
pub const _WIN32_IE_NT4SP4: libc::c_uint = 1025;
pub const _WIN32_IE_NT4SP5: libc::c_uint = 1025;
pub const _WIN32_IE_NT4SP6: libc::c_uint = 1280;
pub const _WIN32_IE_WIN98: libc::c_uint = 1025;
pub const _WIN32_IE_WIN98SE: libc::c_uint = 1280;
pub const _WIN32_IE_WINME: libc::c_uint = 1360;
pub const _WIN32_IE_WIN2K: libc::c_uint = 1281;
pub const _WIN32_IE_WIN2KSP1: libc::c_uint = 1281;
pub const _WIN32_IE_WIN2KSP2: libc::c_uint = 1281;
pub const _WIN32_IE_WIN2KSP3: libc::c_uint = 1281;
pub const _WIN32_IE_WIN2KSP4: libc::c_uint = 1281;
pub const _WIN32_IE_XP: libc::c_uint = 1536;
pub const _WIN32_IE_XPSP1: libc::c_uint = 1537;
pub const _WIN32_IE_XPSP2: libc::c_uint = 1539;
pub const _WIN32_IE_WS03: libc::c_uint = 1538;
pub const _WIN32_IE_WS03SP1: libc::c_uint = 1539;
pub const _WIN32_IE_WIN6: libc::c_uint = 1792;
pub const _WIN32_IE_LONGHORN: libc::c_uint = 1792;
pub const _WIN32_IE_WIN7: libc::c_uint = 2048;
pub const _WIN32_IE_WIN8: libc::c_uint = 2560;
pub const _WIN32_IE_WINBLUE: libc::c_uint = 2560;
pub const _WIN32_IE_WINTHRESHOLD: libc::c_uint = 2560;
pub const _WIN32_IE_WIN10: libc::c_uint = 2560;
pub const NTDDI_WIN2K: libc::c_uint = 83886080;
pub const NTDDI_WIN2KSP1: libc::c_uint = 83886336;
pub const NTDDI_WIN2KSP2: libc::c_uint = 83886592;
pub const NTDDI_WIN2KSP3: libc::c_uint = 83886848;
pub const NTDDI_WIN2KSP4: libc::c_uint = 83887104;
pub const NTDDI_WINXP: libc::c_uint = 83951616;
pub const NTDDI_WINXPSP1: libc::c_uint = 83951872;
pub const NTDDI_WINXPSP2: libc::c_uint = 83952128;
pub const NTDDI_WINXPSP3: libc::c_uint = 83952384;
pub const NTDDI_WINXPSP4: libc::c_uint = 83952640;
pub const NTDDI_WS03: libc::c_uint = 84017152;
pub const NTDDI_WS03SP1: libc::c_uint = 84017408;
pub const NTDDI_WS03SP2: libc::c_uint = 84017664;
pub const NTDDI_WS03SP3: libc::c_uint = 84017920;
pub const NTDDI_WS03SP4: libc::c_uint = 84018176;
pub const NTDDI_WIN6: libc::c_uint = 100663296;
pub const NTDDI_WIN6SP1: libc::c_uint = 100663552;
pub const NTDDI_WIN6SP2: libc::c_uint = 100663808;
pub const NTDDI_WIN6SP3: libc::c_uint = 100664064;
pub const NTDDI_WIN6SP4: libc::c_uint = 100664320;
pub const NTDDI_VISTA: libc::c_uint = 100663296;
pub const NTDDI_VISTASP1: libc::c_uint = 100663552;
pub const NTDDI_VISTASP2: libc::c_uint = 100663808;
pub const NTDDI_VISTASP3: libc::c_uint = 100664064;
pub const NTDDI_VISTASP4: libc::c_uint = 100664320;
pub const NTDDI_LONGHORN: libc::c_uint = 100663296;
pub const NTDDI_WS08: libc::c_uint = 100663552;
pub const NTDDI_WS08SP2: libc::c_uint = 100663808;
pub const NTDDI_WS08SP3: libc::c_uint = 100664064;
pub const NTDDI_WS08SP4: libc::c_uint = 100664320;
pub const NTDDI_WIN7: libc::c_uint = 100728832;
pub const NTDDI_WIN8: libc::c_uint = 100794368;
pub const NTDDI_WINBLUE: libc::c_uint = 100859904;
pub const NTDDI_WINTHRESHOLD: libc::c_uint = 167772160;
pub const NTDDI_WIN10: libc::c_uint = 167772160;
pub const NTDDI_WIN10_TH2: libc::c_uint = 167772161;
pub const NTDDI_WIN10_RS1: libc::c_uint = 167772162;
pub const OSVERSION_MASK: libc::c_uint = 4294901760;
pub const SPVERSION_MASK: libc::c_uint = 65280;
pub const SUBVERSION_MASK: libc::c_uint = 255;
pub const _WIN32_WINNT: libc::c_uint = 2560;
pub const WINVER: libc::c_uint = 2560;
pub const _WIN32_IE: libc::c_uint = 2560;
pub const LANG_NEUTRAL: libc::c_uint = 0;
pub const LANG_INVARIANT: libc::c_uint = 127;
pub const LANG_AFRIKAANS: libc::c_uint = 54;
pub const LANG_ALBANIAN: libc::c_uint = 28;
pub const LANG_ALSATIAN: libc::c_uint = 132;
pub const LANG_AMHARIC: libc::c_uint = 94;
pub const LANG_ARABIC: libc::c_uint = 1;
pub const LANG_ARMENIAN: libc::c_uint = 43;
pub const LANG_ASSAMESE: libc::c_uint = 77;
pub const LANG_AZERI: libc::c_uint = 44;
pub const LANG_AZERBAIJANI: libc::c_uint = 44;
pub const LANG_BANGLA: libc::c_uint = 69;
pub const LANG_BASHKIR: libc::c_uint = 109;
pub const LANG_BASQUE: libc::c_uint = 45;
pub const LANG_BELARUSIAN: libc::c_uint = 35;
pub const LANG_BENGALI: libc::c_uint = 69;
pub const LANG_BRETON: libc::c_uint = 126;
pub const LANG_BOSNIAN: libc::c_uint = 26;
pub const LANG_BOSNIAN_NEUTRAL: libc::c_uint = 30746;
pub const LANG_BULGARIAN: libc::c_uint = 2;
pub const LANG_CATALAN: libc::c_uint = 3;
pub const LANG_CENTRAL_KURDISH: libc::c_uint = 146;
pub const LANG_CHEROKEE: libc::c_uint = 92;
pub const LANG_CHINESE: libc::c_uint = 4;
pub const LANG_CHINESE_SIMPLIFIED: libc::c_uint = 4;
pub const LANG_CHINESE_TRADITIONAL: libc::c_uint = 31748;
pub const LANG_CORSICAN: libc::c_uint = 131;
pub const LANG_CROATIAN: libc::c_uint = 26;
pub const LANG_CZECH: libc::c_uint = 5;
pub const LANG_DANISH: libc::c_uint = 6;
pub const LANG_DARI: libc::c_uint = 140;
pub const LANG_DIVEHI: libc::c_uint = 101;
pub const LANG_DUTCH: libc::c_uint = 19;
pub const LANG_ENGLISH: libc::c_uint = 9;
pub const LANG_ESTONIAN: libc::c_uint = 37;
pub const LANG_FAEROESE: libc::c_uint = 56;
pub const LANG_FARSI: libc::c_uint = 41;
pub const LANG_FILIPINO: libc::c_uint = 100;
pub const LANG_FINNISH: libc::c_uint = 11;
pub const LANG_FRENCH: libc::c_uint = 12;
pub const LANG_FRISIAN: libc::c_uint = 98;
pub const LANG_FULAH: libc::c_uint = 103;
pub const LANG_GALICIAN: libc::c_uint = 86;
pub const LANG_GEORGIAN: libc::c_uint = 55;
pub const LANG_GERMAN: libc::c_uint = 7;
pub const LANG_GREEK: libc::c_uint = 8;
pub const LANG_GREENLANDIC: libc::c_uint = 111;
pub const LANG_GUJARATI: libc::c_uint = 71;
pub const LANG_HAUSA: libc::c_uint = 104;
pub const LANG_HAWAIIAN: libc::c_uint = 117;
pub const LANG_HEBREW: libc::c_uint = 13;
pub const LANG_HINDI: libc::c_uint = 57;
pub const LANG_HUNGARIAN: libc::c_uint = 14;
pub const LANG_ICELANDIC: libc::c_uint = 15;
pub const LANG_IGBO: libc::c_uint = 112;
pub const LANG_INDONESIAN: libc::c_uint = 33;
pub const LANG_INUKTITUT: libc::c_uint = 93;
pub const LANG_IRISH: libc::c_uint = 60;
pub const LANG_ITALIAN: libc::c_uint = 16;
pub const LANG_JAPANESE: libc::c_uint = 17;
pub const LANG_KANNADA: libc::c_uint = 75;
pub const LANG_KASHMIRI: libc::c_uint = 96;
pub const LANG_KAZAK: libc::c_uint = 63;
pub const LANG_KHMER: libc::c_uint = 83;
pub const LANG_KICHE: libc::c_uint = 134;
pub const LANG_KINYARWANDA: libc::c_uint = 135;
pub const LANG_KONKANI: libc::c_uint = 87;
pub const LANG_KOREAN: libc::c_uint = 18;
pub const LANG_KYRGYZ: libc::c_uint = 64;
pub const LANG_LAO: libc::c_uint = 84;
pub const LANG_LATVIAN: libc::c_uint = 38;
pub const LANG_LITHUANIAN: libc::c_uint = 39;
pub const LANG_LOWER_SORBIAN: libc::c_uint = 46;
pub const LANG_LUXEMBOURGISH: libc::c_uint = 110;
pub const LANG_MACEDONIAN: libc::c_uint = 47;
pub const LANG_MALAY: libc::c_uint = 62;
pub const LANG_MALAYALAM: libc::c_uint = 76;
pub const LANG_MALTESE: libc::c_uint = 58;
pub const LANG_MANIPURI: libc::c_uint = 88;
pub const LANG_MAORI: libc::c_uint = 129;
pub const LANG_MAPUDUNGUN: libc::c_uint = 122;
pub const LANG_MARATHI: libc::c_uint = 78;
pub const LANG_MOHAWK: libc::c_uint = 124;
pub const LANG_MONGOLIAN: libc::c_uint = 80;
pub const LANG_NEPALI: libc::c_uint = 97;
pub const LANG_NORWEGIAN: libc::c_uint = 20;
pub const LANG_OCCITAN: libc::c_uint = 130;
pub const LANG_ODIA: libc::c_uint = 72;
pub const LANG_ORIYA: libc::c_uint = 72;
pub const LANG_PASHTO: libc::c_uint = 99;
pub const LANG_PERSIAN: libc::c_uint = 41;
pub const LANG_POLISH: libc::c_uint = 21;
pub const LANG_PORTUGUESE: libc::c_uint = 22;
pub const LANG_PULAR: libc::c_uint = 103;
pub const LANG_PUNJABI: libc::c_uint = 70;
pub const LANG_QUECHUA: libc::c_uint = 107;
pub const LANG_ROMANIAN: libc::c_uint = 24;
pub const LANG_ROMANSH: libc::c_uint = 23;
pub const LANG_RUSSIAN: libc::c_uint = 25;
pub const LANG_SAKHA: libc::c_uint = 133;
pub const LANG_SAMI: libc::c_uint = 59;
pub const LANG_SANSKRIT: libc::c_uint = 79;
pub const LANG_SCOTTISH_GAELIC: libc::c_uint = 145;
pub const LANG_SERBIAN: libc::c_uint = 26;
pub const LANG_SERBIAN_NEUTRAL: libc::c_uint = 31770;
pub const LANG_SINDHI: libc::c_uint = 89;
pub const LANG_SINHALESE: libc::c_uint = 91;
pub const LANG_SLOVAK: libc::c_uint = 27;
pub const LANG_SLOVENIAN: libc::c_uint = 36;
pub const LANG_SOTHO: libc::c_uint = 108;
pub const LANG_SPANISH: libc::c_uint = 10;
pub const LANG_SWAHILI: libc::c_uint = 65;
pub const LANG_SWEDISH: libc::c_uint = 29;
pub const LANG_SYRIAC: libc::c_uint = 90;
pub const LANG_TAJIK: libc::c_uint = 40;
pub const LANG_TAMAZIGHT: libc::c_uint = 95;
pub const LANG_TAMIL: libc::c_uint = 73;
pub const LANG_TATAR: libc::c_uint = 68;
pub const LANG_TELUGU: libc::c_uint = 74;
pub const LANG_THAI: libc::c_uint = 30;
pub const LANG_TIBETAN: libc::c_uint = 81;
pub const LANG_TIGRIGNA: libc::c_uint = 115;
pub const LANG_TIGRINYA: libc::c_uint = 115;
pub const LANG_TSWANA: libc::c_uint = 50;
pub const LANG_TURKISH: libc::c_uint = 31;
pub const LANG_TURKMEN: libc::c_uint = 66;
pub const LANG_UIGHUR: libc::c_uint = 128;
pub const LANG_UKRAINIAN: libc::c_uint = 34;
pub const LANG_UPPER_SORBIAN: libc::c_uint = 46;
pub const LANG_URDU: libc::c_uint = 32;
pub const LANG_UZBEK: libc::c_uint = 67;
pub const LANG_VALENCIAN: libc::c_uint = 3;
pub const LANG_VIETNAMESE: libc::c_uint = 42;
pub const LANG_WELSH: libc::c_uint = 82;
pub const LANG_WOLOF: libc::c_uint = 136;
pub const LANG_XHOSA: libc::c_uint = 52;
pub const LANG_YAKUT: libc::c_uint = 133;
pub const LANG_YI: libc::c_uint = 120;
pub const LANG_YORUBA: libc::c_uint = 106;
pub const LANG_ZULU: libc::c_uint = 53;
pub const SUBLANG_NEUTRAL: libc::c_uint = 0;
pub const SUBLANG_DEFAULT: libc::c_uint = 1;
pub const SUBLANG_SYS_DEFAULT: libc::c_uint = 2;
pub const SUBLANG_CUSTOM_DEFAULT: libc::c_uint = 3;
pub const SUBLANG_CUSTOM_UNSPECIFIED: libc::c_uint = 4;
pub const SUBLANG_UI_CUSTOM_DEFAULT: libc::c_uint = 5;
pub const SUBLANG_AFRIKAANS_SOUTH_AFRICA: libc::c_uint = 1;
pub const SUBLANG_ALBANIAN_ALBANIA: libc::c_uint = 1;
pub const SUBLANG_ALSATIAN_FRANCE: libc::c_uint = 1;
pub const SUBLANG_AMHARIC_ETHIOPIA: libc::c_uint = 1;
pub const SUBLANG_ARABIC_SAUDI_ARABIA: libc::c_uint = 1;
pub const SUBLANG_ARABIC_IRAQ: libc::c_uint = 2;
pub const SUBLANG_ARABIC_EGYPT: libc::c_uint = 3;
pub const SUBLANG_ARABIC_LIBYA: libc::c_uint = 4;
pub const SUBLANG_ARABIC_ALGERIA: libc::c_uint = 5;
pub const SUBLANG_ARABIC_MOROCCO: libc::c_uint = 6;
pub const SUBLANG_ARABIC_TUNISIA: libc::c_uint = 7;
pub const SUBLANG_ARABIC_OMAN: libc::c_uint = 8;
pub const SUBLANG_ARABIC_YEMEN: libc::c_uint = 9;
pub const SUBLANG_ARABIC_SYRIA: libc::c_uint = 10;
pub const SUBLANG_ARABIC_JORDAN: libc::c_uint = 11;
pub const SUBLANG_ARABIC_LEBANON: libc::c_uint = 12;
pub const SUBLANG_ARABIC_KUWAIT: libc::c_uint = 13;
pub const SUBLANG_ARABIC_UAE: libc::c_uint = 14;
pub const SUBLANG_ARABIC_BAHRAIN: libc::c_uint = 15;
pub const SUBLANG_ARABIC_QATAR: libc::c_uint = 16;
pub const SUBLANG_ARMENIAN_ARMENIA: libc::c_uint = 1;
pub const SUBLANG_ASSAMESE_INDIA: libc::c_uint = 1;
pub const SUBLANG_AZERI_LATIN: libc::c_uint = 1;
pub const SUBLANG_AZERI_CYRILLIC: libc::c_uint = 2;
pub const SUBLANG_AZERBAIJANI_AZERBAIJAN_LATIN: libc::c_uint = 1;
pub const SUBLANG_AZERBAIJANI_AZERBAIJAN_CYRILLIC: libc::c_uint = 2;
pub const SUBLANG_BANGLA_INDIA: libc::c_uint = 1;
pub const SUBLANG_BANGLA_BANGLADESH: libc::c_uint = 2;
pub const SUBLANG_BASHKIR_RUSSIA: libc::c_uint = 1;
pub const SUBLANG_BASQUE_BASQUE: libc::c_uint = 1;
pub const SUBLANG_BELARUSIAN_BELARUS: libc::c_uint = 1;
pub const SUBLANG_BENGALI_INDIA: libc::c_uint = 1;
pub const SUBLANG_BENGALI_BANGLADESH: libc::c_uint = 2;
pub const SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN: libc::c_uint = 5;
pub const SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC: libc::c_uint = 8;
pub const SUBLANG_BRETON_FRANCE: libc::c_uint = 1;
pub const SUBLANG_BULGARIAN_BULGARIA: libc::c_uint = 1;
pub const SUBLANG_CATALAN_CATALAN: libc::c_uint = 1;
pub const SUBLANG_CENTRAL_KURDISH_IRAQ: libc::c_uint = 1;
pub const SUBLANG_CHEROKEE_CHEROKEE: libc::c_uint = 1;
pub const SUBLANG_CHINESE_TRADITIONAL: libc::c_uint = 1;
pub const SUBLANG_CHINESE_SIMPLIFIED: libc::c_uint = 2;
pub const SUBLANG_CHINESE_HONGKONG: libc::c_uint = 3;
pub const SUBLANG_CHINESE_SINGAPORE: libc::c_uint = 4;
pub const SUBLANG_CHINESE_MACAU: libc::c_uint = 5;
pub const SUBLANG_CORSICAN_FRANCE: libc::c_uint = 1;
pub const SUBLANG_CZECH_CZECH_REPUBLIC: libc::c_uint = 1;
pub const SUBLANG_CROATIAN_CROATIA: libc::c_uint = 1;
pub const SUBLANG_CROATIAN_BOSNIA_HERZEGOVINA_LATIN: libc::c_uint = 4;
pub const SUBLANG_DANISH_DENMARK: libc::c_uint = 1;
pub const SUBLANG_DARI_AFGHANISTAN: libc::c_uint = 1;
pub const SUBLANG_DIVEHI_MALDIVES: libc::c_uint = 1;
pub const SUBLANG_DUTCH: libc::c_uint = 1;
pub const SUBLANG_DUTCH_BELGIAN: libc::c_uint = 2;
pub const SUBLANG_ENGLISH_US: libc::c_uint = 1;
pub const SUBLANG_ENGLISH_UK: libc::c_uint = 2;
pub const SUBLANG_ENGLISH_AUS: libc::c_uint = 3;
pub const SUBLANG_ENGLISH_CAN: libc::c_uint = 4;
pub const SUBLANG_ENGLISH_NZ: libc::c_uint = 5;
pub const SUBLANG_ENGLISH_EIRE: libc::c_uint = 6;
pub const SUBLANG_ENGLISH_SOUTH_AFRICA: libc::c_uint = 7;
pub const SUBLANG_ENGLISH_JAMAICA: libc::c_uint = 8;
pub const SUBLANG_ENGLISH_CARIBBEAN: libc::c_uint = 9;
pub const SUBLANG_ENGLISH_BELIZE: libc::c_uint = 10;
pub const SUBLANG_ENGLISH_TRINIDAD: libc::c_uint = 11;
pub const SUBLANG_ENGLISH_ZIMBABWE: libc::c_uint = 12;
pub const SUBLANG_ENGLISH_PHILIPPINES: libc::c_uint = 13;
pub const SUBLANG_ENGLISH_INDIA: libc::c_uint = 16;
pub const SUBLANG_ENGLISH_MALAYSIA: libc::c_uint = 17;
pub const SUBLANG_ENGLISH_SINGAPORE: libc::c_uint = 18;
pub const SUBLANG_ESTONIAN_ESTONIA: libc::c_uint = 1;
pub const SUBLANG_FAEROESE_FAROE_ISLANDS: libc::c_uint = 1;
pub const SUBLANG_FILIPINO_PHILIPPINES: libc::c_uint = 1;
pub const SUBLANG_FINNISH_FINLAND: libc::c_uint = 1;
pub const SUBLANG_FRENCH: libc::c_uint = 1;
pub const SUBLANG_FRENCH_BELGIAN: libc::c_uint = 2;
pub const SUBLANG_FRENCH_CANADIAN: libc::c_uint = 3;
pub const SUBLANG_FRENCH_SWISS: libc::c_uint = 4;
pub const SUBLANG_FRENCH_LUXEMBOURG: libc::c_uint = 5;
pub const SUBLANG_FRENCH_MONACO: libc::c_uint = 6;
pub const SUBLANG_FRISIAN_NETHERLANDS: libc::c_uint = 1;
pub const SUBLANG_FULAH_SENEGAL: libc::c_uint = 2;
pub const SUBLANG_GALICIAN_GALICIAN: libc::c_uint = 1;
pub const SUBLANG_GEORGIAN_GEORGIA: libc::c_uint = 1;
pub const SUBLANG_GERMAN: libc::c_uint = 1;
pub const SUBLANG_GERMAN_SWISS: libc::c_uint = 2;
pub const SUBLANG_GERMAN_AUSTRIAN: libc::c_uint = 3;
pub const SUBLANG_GERMAN_LUXEMBOURG: libc::c_uint = 4;
pub const SUBLANG_GERMAN_LIECHTENSTEIN: libc::c_uint = 5;
pub const SUBLANG_GREEK_GREECE: libc::c_uint = 1;
pub const SUBLANG_GREENLANDIC_GREENLAND: libc::c_uint = 1;
pub const SUBLANG_GUJARATI_INDIA: libc::c_uint = 1;
pub const SUBLANG_HAUSA_NIGERIA_LATIN: libc::c_uint = 1;
pub const SUBLANG_HAWAIIAN_US: libc::c_uint = 1;
pub const SUBLANG_HEBREW_ISRAEL: libc::c_uint = 1;
pub const SUBLANG_HINDI_INDIA: libc::c_uint = 1;
pub const SUBLANG_HUNGARIAN_HUNGARY: libc::c_uint = 1;
pub const SUBLANG_ICELANDIC_ICELAND: libc::c_uint = 1;
pub const SUBLANG_IGBO_NIGERIA: libc::c_uint = 1;
pub const SUBLANG_INDONESIAN_INDONESIA: libc::c_uint = 1;
pub const SUBLANG_INUKTITUT_CANADA: libc::c_uint = 1;
pub const SUBLANG_INUKTITUT_CANADA_LATIN: libc::c_uint = 2;
pub const SUBLANG_IRISH_IRELAND: libc::c_uint = 2;
pub const SUBLANG_ITALIAN: libc::c_uint = 1;
pub const SUBLANG_ITALIAN_SWISS: libc::c_uint = 2;
pub const SUBLANG_JAPANESE_JAPAN: libc::c_uint = 1;
pub const SUBLANG_KANNADA_INDIA: libc::c_uint = 1;
pub const SUBLANG_KASHMIRI_SASIA: libc::c_uint = 2;
pub const SUBLANG_KASHMIRI_INDIA: libc::c_uint = 2;
pub const SUBLANG_KAZAK_KAZAKHSTAN: libc::c_uint = 1;
pub const SUBLANG_KHMER_CAMBODIA: libc::c_uint = 1;
pub const SUBLANG_KICHE_GUATEMALA: libc::c_uint = 1;
pub const SUBLANG_KINYARWANDA_RWANDA: libc::c_uint = 1;
pub const SUBLANG_KONKANI_INDIA: libc::c_uint = 1;
pub const SUBLANG_KOREAN: libc::c_uint = 1;
pub const SUBLANG_KYRGYZ_KYRGYZSTAN: libc::c_uint = 1;
pub const SUBLANG_LAO_LAO: libc::c_uint = 1;
pub const SUBLANG_LATVIAN_LATVIA: libc::c_uint = 1;
pub const SUBLANG_LITHUANIAN: libc::c_uint = 1;
pub const SUBLANG_LOWER_SORBIAN_GERMANY: libc::c_uint = 2;
pub const SUBLANG_LUXEMBOURGISH_LUXEMBOURG: libc::c_uint = 1;
pub const SUBLANG_MACEDONIAN_MACEDONIA: libc::c_uint = 1;
pub const SUBLANG_MALAY_MALAYSIA: libc::c_uint = 1;
pub const SUBLANG_MALAY_BRUNEI_DARUSSALAM: libc::c_uint = 2;
pub const SUBLANG_MALAYALAM_INDIA: libc::c_uint = 1;
pub const SUBLANG_MALTESE_MALTA: libc::c_uint = 1;
pub const SUBLANG_MAORI_NEW_ZEALAND: libc::c_uint = 1;
pub const SUBLANG_MAPUDUNGUN_CHILE: libc::c_uint = 1;
pub const SUBLANG_MARATHI_INDIA: libc::c_uint = 1;
pub const SUBLANG_MOHAWK_MOHAWK: libc::c_uint = 1;
pub const SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA: libc::c_uint = 1;
pub const SUBLANG_MONGOLIAN_PRC: libc::c_uint = 2;
pub const SUBLANG_NEPALI_INDIA: libc::c_uint = 2;
pub const SUBLANG_NEPALI_NEPAL: libc::c_uint = 1;
pub const SUBLANG_NORWEGIAN_BOKMAL: libc::c_uint = 1;
pub const SUBLANG_NORWEGIAN_NYNORSK: libc::c_uint = 2;
pub const SUBLANG_OCCITAN_FRANCE: libc::c_uint = 1;
pub const SUBLANG_ODIA_INDIA: libc::c_uint = 1;
pub const SUBLANG_ORIYA_INDIA: libc::c_uint = 1;
pub const SUBLANG_PASHTO_AFGHANISTAN: libc::c_uint = 1;
pub const SUBLANG_PERSIAN_IRAN: libc::c_uint = 1;
pub const SUBLANG_POLISH_POLAND: libc::c_uint = 1;
pub const SUBLANG_PORTUGUESE: libc::c_uint = 2;
pub const SUBLANG_PORTUGUESE_BRAZILIAN: libc::c_uint = 1;
pub const SUBLANG_PULAR_SENEGAL: libc::c_uint = 2;
pub const SUBLANG_PUNJABI_INDIA: libc::c_uint = 1;
pub const SUBLANG_PUNJABI_PAKISTAN: libc::c_uint = 2;
pub const SUBLANG_QUECHUA_BOLIVIA: libc::c_uint = 1;
pub const SUBLANG_QUECHUA_ECUADOR: libc::c_uint = 2;
pub const SUBLANG_QUECHUA_PERU: libc::c_uint = 3;
pub const SUBLANG_ROMANIAN_ROMANIA: libc::c_uint = 1;
pub const SUBLANG_ROMANSH_SWITZERLAND: libc::c_uint = 1;
pub const SUBLANG_RUSSIAN_RUSSIA: libc::c_uint = 1;
pub const SUBLANG_SAKHA_RUSSIA: libc::c_uint = 1;
pub const SUBLANG_SAMI_NORTHERN_NORWAY: libc::c_uint = 1;
pub const SUBLANG_SAMI_NORTHERN_SWEDEN: libc::c_uint = 2;
pub const SUBLANG_SAMI_NORTHERN_FINLAND: libc::c_uint = 3;
pub const SUBLANG_SAMI_LULE_NORWAY: libc::c_uint = 4;
pub const SUBLANG_SAMI_LULE_SWEDEN: libc::c_uint = 5;
pub const SUBLANG_SAMI_SOUTHERN_NORWAY: libc::c_uint = 6;
pub const SUBLANG_SAMI_SOUTHERN_SWEDEN: libc::c_uint = 7;
pub const SUBLANG_SAMI_SKOLT_FINLAND: libc::c_uint = 8;
pub const SUBLANG_SAMI_INARI_FINLAND: libc::c_uint = 9;
pub const SUBLANG_SANSKRIT_INDIA: libc::c_uint = 1;
pub const SUBLANG_SCOTTISH_GAELIC: libc::c_uint = 1;
pub const SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_LATIN: libc::c_uint = 6;
pub const SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_CYRILLIC: libc::c_uint = 7;
pub const SUBLANG_SERBIAN_MONTENEGRO_LATIN: libc::c_uint = 11;
pub const SUBLANG_SERBIAN_MONTENEGRO_CYRILLIC: libc::c_uint = 12;
pub const SUBLANG_SERBIAN_SERBIA_LATIN: libc::c_uint = 9;
pub const SUBLANG_SERBIAN_SERBIA_CYRILLIC: libc::c_uint = 10;
pub const SUBLANG_SERBIAN_CROATIA: libc::c_uint = 1;
pub const SUBLANG_SERBIAN_LATIN: libc::c_uint = 2;
pub const SUBLANG_SERBIAN_CYRILLIC: libc::c_uint = 3;
pub const SUBLANG_SINDHI_INDIA: libc::c_uint = 1;
pub const SUBLANG_SINDHI_PAKISTAN: libc::c_uint = 2;
pub const SUBLANG_SINDHI_AFGHANISTAN: libc::c_uint = 2;
pub const SUBLANG_SINHALESE_SRI_LANKA: libc::c_uint = 1;
pub const SUBLANG_SOTHO_NORTHERN_SOUTH_AFRICA: libc::c_uint = 1;
pub const SUBLANG_SLOVAK_SLOVAKIA: libc::c_uint = 1;
pub const SUBLANG_SLOVENIAN_SLOVENIA: libc::c_uint = 1;
pub const SUBLANG_SPANISH: libc::c_uint = 1;
pub const SUBLANG_SPANISH_MEXICAN: libc::c_uint = 2;
pub const SUBLANG_SPANISH_MODERN: libc::c_uint = 3;
pub const SUBLANG_SPANISH_GUATEMALA: libc::c_uint = 4;
pub const SUBLANG_SPANISH_COSTA_RICA: libc::c_uint = 5;
pub const SUBLANG_SPANISH_PANAMA: libc::c_uint = 6;
pub const SUBLANG_SPANISH_DOMINICAN_REPUBLIC: libc::c_uint = 7;
pub const SUBLANG_SPANISH_VENEZUELA: libc::c_uint = 8;
pub const SUBLANG_SPANISH_COLOMBIA: libc::c_uint = 9;
pub const SUBLANG_SPANISH_PERU: libc::c_uint = 10;
pub const SUBLANG_SPANISH_ARGENTINA: libc::c_uint = 11;
pub const SUBLANG_SPANISH_ECUADOR: libc::c_uint = 12;
pub const SUBLANG_SPANISH_CHILE: libc::c_uint = 13;
pub const SUBLANG_SPANISH_URUGUAY: libc::c_uint = 14;
pub const SUBLANG_SPANISH_PARAGUAY: libc::c_uint = 15;
pub const SUBLANG_SPANISH_BOLIVIA: libc::c_uint = 16;
pub const SUBLANG_SPANISH_EL_SALVADOR: libc::c_uint = 17;
pub const SUBLANG_SPANISH_HONDURAS: libc::c_uint = 18;
pub const SUBLANG_SPANISH_NICARAGUA: libc::c_uint = 19;
pub const SUBLANG_SPANISH_PUERTO_RICO: libc::c_uint = 20;
pub const SUBLANG_SPANISH_US: libc::c_uint = 21;
pub const SUBLANG_SWAHILI_KENYA: libc::c_uint = 1;
pub const SUBLANG_SWEDISH: libc::c_uint = 1;
pub const SUBLANG_SWEDISH_FINLAND: libc::c_uint = 2;
pub const SUBLANG_SYRIAC_SYRIA: libc::c_uint = 1;
pub const SUBLANG_TAJIK_TAJIKISTAN: libc::c_uint = 1;
pub const SUBLANG_TAMAZIGHT_ALGERIA_LATIN: libc::c_uint = 2;
pub const SUBLANG_TAMAZIGHT_MOROCCO_TIFINAGH: libc::c_uint = 4;
pub const SUBLANG_TAMIL_INDIA: libc::c_uint = 1;
pub const SUBLANG_TAMIL_SRI_LANKA: libc::c_uint = 2;
pub const SUBLANG_TATAR_RUSSIA: libc::c_uint = 1;
pub const SUBLANG_TELUGU_INDIA: libc::c_uint = 1;
pub const SUBLANG_THAI_THAILAND: libc::c_uint = 1;
pub const SUBLANG_TIBETAN_PRC: libc::c_uint = 1;
pub const SUBLANG_TIGRIGNA_ERITREA: libc::c_uint = 2;
pub const SUBLANG_TIGRINYA_ERITREA: libc::c_uint = 2;
pub const SUBLANG_TIGRINYA_ETHIOPIA: libc::c_uint = 1;
pub const SUBLANG_TSWANA_BOTSWANA: libc::c_uint = 2;
pub const SUBLANG_TSWANA_SOUTH_AFRICA: libc::c_uint = 1;
pub const SUBLANG_TURKISH_TURKEY: libc::c_uint = 1;
pub const SUBLANG_TURKMEN_TURKMENISTAN: libc::c_uint = 1;
pub const SUBLANG_UIGHUR_PRC: libc::c_uint = 1;
pub const SUBLANG_UKRAINIAN_UKRAINE: libc::c_uint = 1;
pub const SUBLANG_UPPER_SORBIAN_GERMANY: libc::c_uint = 1;
pub const SUBLANG_URDU_PAKISTAN: libc::c_uint = 1;
pub const SUBLANG_URDU_INDIA: libc::c_uint = 2;
pub const SUBLANG_UZBEK_LATIN: libc::c_uint = 1;
pub const SUBLANG_UZBEK_CYRILLIC: libc::c_uint = 2;
pub const SUBLANG_VALENCIAN_VALENCIA: libc::c_uint = 2;
pub const SUBLANG_VIETNAMESE_VIETNAM: libc::c_uint = 1;
pub const SUBLANG_WELSH_UNITED_KINGDOM: libc::c_uint = 1;
pub const SUBLANG_WOLOF_SENEGAL: libc::c_uint = 1;
pub const SUBLANG_XHOSA_SOUTH_AFRICA: libc::c_uint = 1;
pub const SUBLANG_YAKUT_RUSSIA: libc::c_uint = 1;
pub const SUBLANG_YI_PRC: libc::c_uint = 1;
pub const SUBLANG_YORUBA_NIGERIA: libc::c_uint = 1;
pub const SUBLANG_ZULU_SOUTH_AFRICA: libc::c_uint = 1;
pub const SORT_DEFAULT: libc::c_uint = 0;
pub const SORT_INVARIANT_MATH: libc::c_uint = 1;
pub const SORT_JAPANESE_XJIS: libc::c_uint = 0;
pub const SORT_JAPANESE_UNICODE: libc::c_uint = 1;
pub const SORT_JAPANESE_RADICALSTROKE: libc::c_uint = 4;
pub const SORT_CHINESE_BIG5: libc::c_uint = 0;
pub const SORT_CHINESE_PRCP: libc::c_uint = 0;
pub const SORT_CHINESE_UNICODE: libc::c_uint = 1;
pub const SORT_CHINESE_PRC: libc::c_uint = 2;
pub const SORT_CHINESE_BOPOMOFO: libc::c_uint = 3;
pub const SORT_CHINESE_RADICALSTROKE: libc::c_uint = 4;
pub const SORT_KOREAN_KSC: libc::c_uint = 0;
pub const SORT_KOREAN_UNICODE: libc::c_uint = 1;
pub const SORT_GERMAN_PHONE_BOOK: libc::c_uint = 1;
pub const SORT_HUNGARIAN_DEFAULT: libc::c_uint = 0;
pub const SORT_HUNGARIAN_TECHNICAL: libc::c_uint = 1;
pub const SORT_GEORGIAN_TRADITIONAL: libc::c_uint = 0;
pub const SORT_GEORGIAN_MODERN: libc::c_uint = 1;
pub const NLS_VALID_LOCALE_MASK: libc::c_uint = 1048575;
pub const LOCALE_NAME_MAX_LENGTH: libc::c_uint = 85;
pub const LOCALE_TRANSIENT_KEYBOARD1: libc::c_uint = 8192;
pub const LOCALE_TRANSIENT_KEYBOARD2: libc::c_uint = 9216;
pub const LOCALE_TRANSIENT_KEYBOARD3: libc::c_uint = 10240;
pub const LOCALE_TRANSIENT_KEYBOARD4: libc::c_uint = 11264;
pub const FACILITY_VSM: libc::c_uint = 69;
pub const FACILITY_VOLSNAP: libc::c_uint = 80;
pub const FACILITY_VOLMGR: libc::c_uint = 56;
pub const FACILITY_VIRTUALIZATION: libc::c_uint = 55;
pub const FACILITY_VIDEO: libc::c_uint = 27;
pub const FACILITY_USB_ERROR_CODE: libc::c_uint = 16;
pub const FACILITY_TRANSACTION: libc::c_uint = 25;
pub const FACILITY_TPM: libc::c_uint = 41;
pub const FACILITY_TERMINAL_SERVER: libc::c_uint = 10;
pub const FACILITY_SXS_ERROR_CODE: libc::c_uint = 21;
pub const FACILITY_NTSSPI: libc::c_uint = 9;
pub const FACILITY_SPACES: libc::c_uint = 231;
pub const FACILITY_SMB: libc::c_uint = 93;
pub const FACILITY_SYSTEM_INTEGRITY: libc::c_uint = 233;
pub const FACILITY_SHARED_VHDX: libc::c_uint = 92;
pub const FACILITY_SECUREBOOT: libc::c_uint = 67;
pub const FACILITY_SECURITY_CORE: libc::c_uint = 232;
pub const FACILITY_SDBUS: libc::c_uint = 81;
pub const FACILITY_RTPM: libc::c_uint = 42;
pub const FACILITY_RPC_STUBS: libc::c_uint = 3;
pub const FACILITY_RPC_RUNTIME: libc::c_uint = 2;
pub const FACILITY_RESUME_KEY_FILTER: libc::c_uint = 64;
pub const FACILITY_RDBSS: libc::c_uint = 65;
pub const FACILITY_PLATFORM_MANIFEST: libc::c_uint = 235;
pub const FACILITY_NTWIN32: libc::c_uint = 7;
pub const FACILITY_WIN32K_NTUSER: libc::c_uint = 62;
pub const FACILITY_WIN32K_NTGDI: libc::c_uint = 63;
pub const FACILITY_NDIS_ERROR_CODE: libc::c_uint = 35;
pub const FACILTIY_MUI_ERROR_CODE: libc::c_uint = 11;
pub const FACILITY_MONITOR: libc::c_uint = 29;
pub const FACILITY_MAXIMUM_VALUE: libc::c_uint = 236;
pub const FACILITY_LICENSING: libc::c_uint = 234;
pub const FACILITY_IPSEC: libc::c_uint = 54;
pub const FACILITY_IO_ERROR_CODE: libc::c_uint = 4;
pub const FACILITY_INTERIX: libc::c_uint = 153;
pub const FACILITY_HYPERVISOR: libc::c_uint = 53;
pub const FACILITY_HID_ERROR_CODE: libc::c_uint = 17;
pub const FACILITY_GRAPHICS_KERNEL: libc::c_uint = 30;
pub const FACILITY_FWP_ERROR_CODE: libc::c_uint = 34;
pub const FACILITY_FVE_ERROR_CODE: libc::c_uint = 33;
pub const FACILITY_FIREWIRE_ERROR_CODE: libc::c_uint = 18;
pub const FACILITY_FILTER_MANAGER: libc::c_uint = 28;
pub const FACILITY_DRIVER_FRAMEWORK: libc::c_uint = 32;
pub const FACILITY_DEBUGGER: libc::c_uint = 1;
pub const FACILITY_COMMONLOG: libc::c_uint = 26;
pub const FACILITY_CODCLASS_ERROR_CODE: libc::c_uint = 6;
pub const FACILITY_CLUSTER_ERROR_CODE: libc::c_uint = 19;
pub const FACILITY_NTCERT: libc::c_uint = 8;
pub const FACILITY_BTH_ATT: libc::c_uint = 66;
pub const FACILITY_BCD_ERROR_CODE: libc::c_uint = 57;
pub const FACILITY_AUDIO_KERNEL: libc::c_uint = 68;
pub const FACILITY_ACPI_ERROR_CODE: libc::c_uint = 20;
pub const STATUS_SEVERITY_WARNING: libc::c_uint = 2;
pub const STATUS_SEVERITY_SUCCESS: libc::c_uint = 0;
pub const STATUS_SEVERITY_INFORMATIONAL: libc::c_uint = 1;
pub const STATUS_SEVERITY_ERROR: libc::c_uint = 3;
pub const BUGCHECK_CONTEXT_MODIFIER: libc::c_uint = 2147483648;
pub const FACILITY_MCA_ERROR_CODE: libc::c_uint = 5;
pub const MCA_EXTREG_V2MAX: libc::c_uint = 24;
pub const LOW_LEVEL: libc::c_uint = 0;
pub const CMCI_LEVEL: libc::c_uint = 5;
pub const PROFILE_LEVEL: libc::c_uint = 27;
pub const CLOCK1_LEVEL: libc::c_uint = 28;
pub const CLOCK2_LEVEL: libc::c_uint = 28;
pub const IPI_LEVEL: libc::c_uint = 29;
pub const POWER_LEVEL: libc::c_uint = 30;
pub const CLOCK_LEVEL: libc::c_uint = 28;
pub const LOW_PRIORITY: libc::c_uint = 0;
pub const LOW_REALTIME_PRIORITY: libc::c_uint = 16;
pub const HIGH_PRIORITY: libc::c_uint = 31;
pub const MAXIMUM_PRIORITY: libc::c_uint = 32;
pub const MAXIMUM_WAIT_OBJECTS: libc::c_uint = 64;
pub const MAXIMUM_SUSPEND_COUNT: libc::c_uint = 127;
pub const LOCK_QUEUE_WAIT: libc::c_uint = 1;
pub const LOCK_QUEUE_WAIT_BIT: libc::c_uint = 0;
pub const LOCK_QUEUE_OWNER: libc::c_uint = 2;
pub const LOCK_QUEUE_OWNER_BIT: libc::c_uint = 1;
pub const MAXIMUM_SUPPORTED_EXTENSION: libc::c_uint = 512;
pub const DELETE: libc::c_uint = 65536;
pub const READ_CONTROL: libc::c_uint = 131072;
pub const WRITE_DAC: libc::c_uint = 262144;
pub const WRITE_OWNER: libc::c_uint = 524288;
pub const SYNCHRONIZE: libc::c_uint = 1048576;
pub const STANDARD_RIGHTS_REQUIRED: libc::c_uint = 983040;
pub const STANDARD_RIGHTS_READ: libc::c_uint = 131072;
pub const STANDARD_RIGHTS_WRITE: libc::c_uint = 131072;
pub const STANDARD_RIGHTS_EXECUTE: libc::c_uint = 131072;
pub const STANDARD_RIGHTS_ALL: libc::c_uint = 2031616;
pub const SPECIFIC_RIGHTS_ALL: libc::c_uint = 65535;
pub const ACCESS_SYSTEM_SECURITY: libc::c_uint = 16777216;
pub const MAXIMUM_ALLOWED: libc::c_uint = 33554432;
pub const GENERIC_READ: libc::c_uint = 2147483648;
pub const GENERIC_WRITE: libc::c_uint = 1073741824;
pub const GENERIC_EXECUTE: libc::c_uint = 536870912;
pub const GENERIC_ALL: libc::c_uint = 268435456;
pub const ACL_REVISION: libc::c_uint = 2;
pub const ACL_REVISION_DS: libc::c_uint = 4;
pub const ACL_REVISION1: libc::c_uint = 1;
pub const ACL_REVISION2: libc::c_uint = 2;
pub const ACL_REVISION3: libc::c_uint = 3;
pub const ACL_REVISION4: libc::c_uint = 4;
pub const MAX_ACL_REVISION: libc::c_uint = 4;
pub const SECURITY_DESCRIPTOR_REVISION: libc::c_uint = 1;
pub const SECURITY_DESCRIPTOR_REVISION1: libc::c_uint = 1;
pub const SE_PRIVILEGE_ENABLED_BY_DEFAULT: libc::c_uint = 1;
pub const SE_PRIVILEGE_ENABLED: libc::c_uint = 2;
pub const SE_PRIVILEGE_USED_FOR_ACCESS: libc::c_uint = 2147483648;
pub const PRIVILEGE_SET_ALL_NECESSARY: libc::c_uint = 1;
pub const SE_MIN_WELL_KNOWN_PRIVILEGE: libc::c_uint = 2;
pub const SE_CREATE_TOKEN_PRIVILEGE: libc::c_uint = 2;
pub const SE_ASSIGNPRIMARYTOKEN_PRIVILEGE: libc::c_uint = 3;
pub const SE_LOCK_MEMORY_PRIVILEGE: libc::c_uint = 4;
pub const SE_INCREASE_QUOTA_PRIVILEGE: libc::c_uint = 5;
pub const SE_MACHINE_ACCOUNT_PRIVILEGE: libc::c_uint = 6;
pub const SE_TCB_PRIVILEGE: libc::c_uint = 7;
pub const SE_SECURITY_PRIVILEGE: libc::c_uint = 8;
pub const SE_TAKE_OWNERSHIP_PRIVILEGE: libc::c_uint = 9;
pub const SE_LOAD_DRIVER_PRIVILEGE: libc::c_uint = 10;
pub const SE_SYSTEM_PROFILE_PRIVILEGE: libc::c_uint = 11;
pub const SE_SYSTEMTIME_PRIVILEGE: libc::c_uint = 12;
pub const SE_PROF_SINGLE_PROCESS_PRIVILEGE: libc::c_uint = 13;
pub const SE_INC_BASE_PRIORITY_PRIVILEGE: libc::c_uint = 14;
pub const SE_CREATE_PAGEFILE_PRIVILEGE: libc::c_uint = 15;
pub const SE_CREATE_PERMANENT_PRIVILEGE: libc::c_uint = 16;
pub const SE_BACKUP_PRIVILEGE: libc::c_uint = 17;
pub const SE_RESTORE_PRIVILEGE: libc::c_uint = 18;
pub const SE_SHUTDOWN_PRIVILEGE: libc::c_uint = 19;
pub const SE_DEBUG_PRIVILEGE: libc::c_uint = 20;
pub const SE_AUDIT_PRIVILEGE: libc::c_uint = 21;
pub const SE_SYSTEM_ENVIRONMENT_PRIVILEGE: libc::c_uint = 22;
pub const SE_CHANGE_NOTIFY_PRIVILEGE: libc::c_uint = 23;
pub const SE_REMOTE_SHUTDOWN_PRIVILEGE: libc::c_uint = 24;
pub const SE_UNDOCK_PRIVILEGE: libc::c_uint = 25;
pub const SE_SYNC_AGENT_PRIVILEGE: libc::c_uint = 26;
pub const SE_ENABLE_DELEGATION_PRIVILEGE: libc::c_uint = 27;
pub const SE_MANAGE_VOLUME_PRIVILEGE: libc::c_uint = 28;
pub const SE_IMPERSONATE_PRIVILEGE: libc::c_uint = 29;
pub const SE_CREATE_GLOBAL_PRIVILEGE: libc::c_uint = 30;
pub const SE_TRUSTED_CREDMAN_ACCESS_PRIVILEGE: libc::c_uint = 31;
pub const SE_RELABEL_PRIVILEGE: libc::c_uint = 32;
pub const SE_INC_WORKING_SET_PRIVILEGE: libc::c_uint = 33;
pub const SE_TIME_ZONE_PRIVILEGE: libc::c_uint = 34;
pub const SE_CREATE_SYMBOLIC_LINK_PRIVILEGE: libc::c_uint = 35;
pub const SE_DELEGATE_SESSION_USER_IMPERSONATE_PRIVILEGE: libc::c_uint = 36;
pub const SE_MAX_WELL_KNOWN_PRIVILEGE: libc::c_uint = 36;
pub const SECURITY_DYNAMIC_TRACKING: libc::c_uint = 1;
pub const SECURITY_STATIC_TRACKING: libc::c_uint = 0;
pub const OWNER_SECURITY_INFORMATION: libc::c_uint = 1;
pub const GROUP_SECURITY_INFORMATION: libc::c_uint = 2;
pub const DACL_SECURITY_INFORMATION: libc::c_uint = 4;
pub const SACL_SECURITY_INFORMATION: libc::c_uint = 8;
pub const LABEL_SECURITY_INFORMATION: libc::c_uint = 16;
pub const ATTRIBUTE_SECURITY_INFORMATION: libc::c_uint = 32;
pub const SCOPE_SECURITY_INFORMATION: libc::c_uint = 64;
pub const PROCESS_TRUST_LABEL_SECURITY_INFORMATION: libc::c_uint = 128;
pub const BACKUP_SECURITY_INFORMATION: libc::c_uint = 65536;
pub const PROTECTED_DACL_SECURITY_INFORMATION: libc::c_uint = 2147483648;
pub const PROTECTED_SACL_SECURITY_INFORMATION: libc::c_uint = 1073741824;
pub const UNPROTECTED_DACL_SECURITY_INFORMATION: libc::c_uint = 536870912;
pub const UNPROTECTED_SACL_SECURITY_INFORMATION: libc::c_uint = 268435456;
pub const SE_MAX_AUDIT_PARAMETERS: libc::c_uint = 32;
pub const SE_MAX_GENERIC_AUDIT_PARAMETERS: libc::c_uint = 28;
pub const SE_ADT_PARAMETERS_SELF_RELATIVE: libc::c_uint = 1;
pub const SE_ADT_PARAMETERS_SEND_TO_LSA: libc::c_uint = 2;
pub const SE_ADT_PARAMETER_EXTENSIBLE_AUDIT: libc::c_uint = 4;
pub const SE_ADT_PARAMETER_GENERIC_AUDIT: libc::c_uint = 8;
pub const SE_ADT_PARAMETER_WRITE_SYNCHRONOUS: libc::c_uint = 16;
pub const FILE_DEVICE_BEEP: libc::c_uint = 1;
pub const FILE_DEVICE_CD_ROM: libc::c_uint = 2;
pub const FILE_DEVICE_CD_ROM_FILE_SYSTEM: libc::c_uint = 3;
pub const FILE_DEVICE_CONTROLLER: libc::c_uint = 4;
pub const FILE_DEVICE_DATALINK: libc::c_uint = 5;
pub const FILE_DEVICE_DFS: libc::c_uint = 6;
pub const FILE_DEVICE_DISK: libc::c_uint = 7;
pub const FILE_DEVICE_DISK_FILE_SYSTEM: libc::c_uint = 8;
pub const FILE_DEVICE_FILE_SYSTEM: libc::c_uint = 9;
pub const FILE_DEVICE_INPORT_PORT: libc::c_uint = 10;
pub const FILE_DEVICE_KEYBOARD: libc::c_uint = 11;
pub const FILE_DEVICE_MAILSLOT: libc::c_uint = 12;
pub const FILE_DEVICE_MIDI_IN: libc::c_uint = 13;
pub const FILE_DEVICE_MIDI_OUT: libc::c_uint = 14;
pub const FILE_DEVICE_MOUSE: libc::c_uint = 15;
pub const FILE_DEVICE_MULTI_UNC_PROVIDER: libc::c_uint = 16;
pub const FILE_DEVICE_NAMED_PIPE: libc::c_uint = 17;
pub const FILE_DEVICE_NETWORK: libc::c_uint = 18;
pub const FILE_DEVICE_NETWORK_BROWSER: libc::c_uint = 19;
pub const FILE_DEVICE_NETWORK_FILE_SYSTEM: libc::c_uint = 20;
pub const FILE_DEVICE_NULL: libc::c_uint = 21;
pub const FILE_DEVICE_PARALLEL_PORT: libc::c_uint = 22;
pub const FILE_DEVICE_PHYSICAL_NETCARD: libc::c_uint = 23;
pub const FILE_DEVICE_PRINTER: libc::c_uint = 24;
pub const FILE_DEVICE_SCANNER: libc::c_uint = 25;
pub const FILE_DEVICE_SERIAL_MOUSE_PORT: libc::c_uint = 26;
pub const FILE_DEVICE_SERIAL_PORT: libc::c_uint = 27;
pub const FILE_DEVICE_SCREEN: libc::c_uint = 28;
pub const FILE_DEVICE_SOUND: libc::c_uint = 29;
pub const FILE_DEVICE_STREAMS: libc::c_uint = 30;
pub const FILE_DEVICE_TAPE: libc::c_uint = 31;
pub const FILE_DEVICE_TAPE_FILE_SYSTEM: libc::c_uint = 32;
pub const FILE_DEVICE_TRANSPORT: libc::c_uint = 33;
pub const FILE_DEVICE_UNKNOWN: libc::c_uint = 34;
pub const FILE_DEVICE_VIDEO: libc::c_uint = 35;
pub const FILE_DEVICE_VIRTUAL_DISK: libc::c_uint = 36;
pub const FILE_DEVICE_WAVE_IN: libc::c_uint = 37;
pub const FILE_DEVICE_WAVE_OUT: libc::c_uint = 38;
pub const FILE_DEVICE_8042_PORT: libc::c_uint = 39;
pub const FILE_DEVICE_NETWORK_REDIRECTOR: libc::c_uint = 40;
pub const FILE_DEVICE_BATTERY: libc::c_uint = 41;
pub const FILE_DEVICE_BUS_EXTENDER: libc::c_uint = 42;
pub const FILE_DEVICE_MODEM: libc::c_uint = 43;
pub const FILE_DEVICE_VDM: libc::c_uint = 44;
pub const FILE_DEVICE_MASS_STORAGE: libc::c_uint = 45;
pub const FILE_DEVICE_SMB: libc::c_uint = 46;
pub const FILE_DEVICE_KS: libc::c_uint = 47;
pub const FILE_DEVICE_CHANGER: libc::c_uint = 48;
pub const FILE_DEVICE_SMARTCARD: libc::c_uint = 49;
pub const FILE_DEVICE_ACPI: libc::c_uint = 50;
pub const FILE_DEVICE_DVD: libc::c_uint = 51;
pub const FILE_DEVICE_FULLSCREEN_VIDEO: libc::c_uint = 52;
pub const FILE_DEVICE_DFS_FILE_SYSTEM: libc::c_uint = 53;
pub const FILE_DEVICE_DFS_VOLUME: libc::c_uint = 54;
pub const FILE_DEVICE_SERENUM: libc::c_uint = 55;
pub const FILE_DEVICE_TERMSRV: libc::c_uint = 56;
pub const FILE_DEVICE_KSEC: libc::c_uint = 57;
pub const FILE_DEVICE_FIPS: libc::c_uint = 58;
pub const FILE_DEVICE_INFINIBAND: libc::c_uint = 59;
pub const FILE_DEVICE_VMBUS: libc::c_uint = 62;
pub const FILE_DEVICE_CRYPT_PROVIDER: libc::c_uint = 63;
pub const FILE_DEVICE_WPD: libc::c_uint = 64;
pub const FILE_DEVICE_BLUETOOTH: libc::c_uint = 65;
pub const FILE_DEVICE_MT_COMPOSITE: libc::c_uint = 66;
pub const FILE_DEVICE_MT_TRANSPORT: libc::c_uint = 67;
pub const FILE_DEVICE_BIOMETRIC: libc::c_uint = 68;
pub const FILE_DEVICE_PMI: libc::c_uint = 69;
pub const FILE_DEVICE_EHSTOR: libc::c_uint = 70;
pub const FILE_DEVICE_DEVAPI: libc::c_uint = 71;
pub const FILE_DEVICE_GPIO: libc::c_uint = 72;
pub const FILE_DEVICE_USBEX: libc::c_uint = 73;
pub const FILE_DEVICE_CONSOLE: libc::c_uint = 80;
pub const FILE_DEVICE_NFP: libc::c_uint = 81;
pub const FILE_DEVICE_SYSENV: libc::c_uint = 82;
pub const FILE_DEVICE_VIRTUAL_BLOCK: libc::c_uint = 83;
pub const FILE_DEVICE_POINT_OF_SERVICE: libc::c_uint = 84;
pub const FILE_DEVICE_STORAGE_REPLICATION: libc::c_uint = 85;
pub const FILE_DEVICE_TRUST_ENV: libc::c_uint = 86;
pub const FILE_DEVICE_UCM: libc::c_uint = 87;
pub const FILE_DEVICE_UCMTCPCI: libc::c_uint = 88;
pub const METHOD_BUFFERED: libc::c_uint = 0;
pub const METHOD_IN_DIRECT: libc::c_uint = 1;
pub const METHOD_OUT_DIRECT: libc::c_uint = 2;
pub const METHOD_NEITHER: libc::c_uint = 3;
pub const METHOD_DIRECT_TO_HARDWARE: libc::c_uint = 1;
pub const METHOD_DIRECT_FROM_HARDWARE: libc::c_uint = 2;
pub const FILE_ANY_ACCESS: libc::c_uint = 0;
pub const FILE_SPECIAL_ACCESS: libc::c_uint = 0;
pub const FILE_READ_ACCESS: libc::c_uint = 1;
pub const FILE_WRITE_ACCESS: libc::c_uint = 2;
pub const FILE_READ_DATA: libc::c_uint = 1;
pub const FILE_LIST_DIRECTORY: libc::c_uint = 1;
pub const FILE_WRITE_DATA: libc::c_uint = 2;
pub const FILE_ADD_FILE: libc::c_uint = 2;
pub const FILE_APPEND_DATA: libc::c_uint = 4;
pub const FILE_ADD_SUBDIRECTORY: libc::c_uint = 4;
pub const FILE_CREATE_PIPE_INSTANCE: libc::c_uint = 4;
pub const FILE_READ_EA: libc::c_uint = 8;
pub const FILE_WRITE_EA: libc::c_uint = 16;
pub const FILE_EXECUTE: libc::c_uint = 32;
pub const FILE_TRAVERSE: libc::c_uint = 32;
pub const FILE_DELETE_CHILD: libc::c_uint = 64;
pub const FILE_READ_ATTRIBUTES: libc::c_uint = 128;
pub const FILE_WRITE_ATTRIBUTES: libc::c_uint = 256;
pub const FILE_ALL_ACCESS: libc::c_uint = 2032127;
pub const FILE_GENERIC_READ: libc::c_uint = 1179785;
pub const FILE_GENERIC_WRITE: libc::c_uint = 1179926;
pub const FILE_GENERIC_EXECUTE: libc::c_uint = 1179808;
pub const FILE_SHARE_READ: libc::c_uint = 1;
pub const FILE_SHARE_WRITE: libc::c_uint = 2;
pub const FILE_SHARE_DELETE: libc::c_uint = 4;
pub const FILE_SHARE_VALID_FLAGS: libc::c_uint = 7;
pub const FILE_ATTRIBUTE_READONLY: libc::c_uint = 1;
pub const FILE_ATTRIBUTE_HIDDEN: libc::c_uint = 2;
pub const FILE_ATTRIBUTE_SYSTEM: libc::c_uint = 4;
pub const FILE_ATTRIBUTE_DIRECTORY: libc::c_uint = 16;
pub const FILE_ATTRIBUTE_ARCHIVE: libc::c_uint = 32;
pub const FILE_ATTRIBUTE_DEVICE: libc::c_uint = 64;
pub const FILE_ATTRIBUTE_NORMAL: libc::c_uint = 128;
pub const FILE_ATTRIBUTE_TEMPORARY: libc::c_uint = 256;
pub const FILE_ATTRIBUTE_SPARSE_FILE: libc::c_uint = 512;
pub const FILE_ATTRIBUTE_REPARSE_POINT: libc::c_uint = 1024;
pub const FILE_ATTRIBUTE_COMPRESSED: libc::c_uint = 2048;
pub const FILE_ATTRIBUTE_OFFLINE: libc::c_uint = 4096;
pub const FILE_ATTRIBUTE_NOT_CONTENT_INDEXED: libc::c_uint = 8192;
pub const FILE_ATTRIBUTE_ENCRYPTED: libc::c_uint = 16384;
pub const FILE_ATTRIBUTE_INTEGRITY_STREAM: libc::c_uint = 32768;
pub const FILE_ATTRIBUTE_VIRTUAL: libc::c_uint = 65536;
pub const FILE_ATTRIBUTE_NO_SCRUB_DATA: libc::c_uint = 131072;
pub const FILE_ATTRIBUTE_EA: libc::c_uint = 262144;
pub const FILE_ATTRIBUTE_VALID_FLAGS: libc::c_uint = 196535;
pub const FILE_ATTRIBUTE_VALID_SET_FLAGS: libc::c_uint = 143783;
pub const FILE_SUPERSEDE: libc::c_uint = 0;
pub const FILE_OPEN: libc::c_uint = 1;
pub const FILE_CREATE: libc::c_uint = 2;
pub const FILE_OPEN_IF: libc::c_uint = 3;
pub const FILE_OVERWRITE: libc::c_uint = 4;
pub const FILE_OVERWRITE_IF: libc::c_uint = 5;
pub const FILE_MAXIMUM_DISPOSITION: libc::c_uint = 5;
pub const FILE_DIRECTORY_FILE: libc::c_uint = 1;
pub const FILE_WRITE_THROUGH: libc::c_uint = 2;
pub const FILE_SEQUENTIAL_ONLY: libc::c_uint = 4;
pub const FILE_NO_INTERMEDIATE_BUFFERING: libc::c_uint = 8;
pub const FILE_SYNCHRONOUS_IO_ALERT: libc::c_uint = 16;
pub const FILE_SYNCHRONOUS_IO_NONALERT: libc::c_uint = 32;
pub const FILE_NON_DIRECTORY_FILE: libc::c_uint = 64;
pub const FILE_CREATE_TREE_CONNECTION: libc::c_uint = 128;
pub const FILE_COMPLETE_IF_OPLOCKED: libc::c_uint = 256;
pub const FILE_NO_EA_KNOWLEDGE: libc::c_uint = 512;
pub const FILE_OPEN_REMOTE_INSTANCE: libc::c_uint = 1024;
pub const FILE_RANDOM_ACCESS: libc::c_uint = 2048;
pub const FILE_DELETE_ON_CLOSE: libc::c_uint = 4096;
pub const FILE_OPEN_BY_FILE_ID: libc::c_uint = 8192;
pub const FILE_OPEN_FOR_BACKUP_INTENT: libc::c_uint = 16384;
pub const FILE_NO_COMPRESSION: libc::c_uint = 32768;
pub const FILE_OPEN_REQUIRING_OPLOCK: libc::c_uint = 65536;
pub const FILE_DISALLOW_EXCLUSIVE: libc::c_uint = 131072;
pub const FILE_SESSION_AWARE: libc::c_uint = 262144;
pub const FILE_RESERVE_OPFILTER: libc::c_uint = 1048576;
pub const FILE_OPEN_REPARSE_POINT: libc::c_uint = 2097152;
pub const FILE_OPEN_NO_RECALL: libc::c_uint = 4194304;
pub const FILE_OPEN_FOR_FREE_SPACE_QUERY: libc::c_uint = 8388608;
pub const FILE_VALID_OPTION_FLAGS: libc::c_uint = 16777215;
pub const FILE_VALID_PIPE_OPTION_FLAGS: libc::c_uint = 50;
pub const FILE_VALID_MAILSLOT_OPTION_FLAGS: libc::c_uint = 50;
pub const FILE_VALID_SET_FLAGS: libc::c_uint = 54;
pub const FILE_SUPERSEDED: libc::c_uint = 0;
pub const FILE_OPENED: libc::c_uint = 1;
pub const FILE_CREATED: libc::c_uint = 2;
pub const FILE_OVERWRITTEN: libc::c_uint = 3;
pub const FILE_EXISTS: libc::c_uint = 4;
pub const FILE_DOES_NOT_EXIST: libc::c_uint = 5;
pub const FILE_WRITE_TO_END_OF_FILE: libc::c_uint = 4294967295;
pub const FILE_USE_FILE_POINTER_POSITION: libc::c_uint = 4294967294;
pub const FILE_BYTE_ALIGNMENT: libc::c_uint = 0;
pub const FILE_WORD_ALIGNMENT: libc::c_uint = 1;
pub const FILE_LONG_ALIGNMENT: libc::c_uint = 3;
pub const FILE_QUAD_ALIGNMENT: libc::c_uint = 7;
pub const FILE_OCTA_ALIGNMENT: libc::c_uint = 15;
pub const FILE_32_BYTE_ALIGNMENT: libc::c_uint = 31;
pub const FILE_64_BYTE_ALIGNMENT: libc::c_uint = 63;
pub const FILE_128_BYTE_ALIGNMENT: libc::c_uint = 127;
pub const FILE_256_BYTE_ALIGNMENT: libc::c_uint = 255;
pub const FILE_512_BYTE_ALIGNMENT: libc::c_uint = 511;
pub const MAXIMUM_FILENAME_LENGTH: libc::c_uint = 256;
pub const FILE_REMOVABLE_MEDIA: libc::c_uint = 1;
pub const FILE_READ_ONLY_DEVICE: libc::c_uint = 2;
pub const FILE_FLOPPY_DISKETTE: libc::c_uint = 4;
pub const FILE_WRITE_ONCE_MEDIA: libc::c_uint = 8;
pub const FILE_REMOTE_DEVICE: libc::c_uint = 16;
pub const FILE_DEVICE_IS_MOUNTED: libc::c_uint = 32;
pub const FILE_VIRTUAL_VOLUME: libc::c_uint = 64;
pub const FILE_AUTOGENERATED_DEVICE_NAME: libc::c_uint = 128;
pub const FILE_DEVICE_SECURE_OPEN: libc::c_uint = 256;
pub const FILE_CHARACTERISTIC_PNP_DEVICE: libc::c_uint = 2048;
pub const FILE_CHARACTERISTIC_TS_DEVICE: libc::c_uint = 4096;
pub const FILE_CHARACTERISTIC_WEBDAV_DEVICE: libc::c_uint = 8192;
pub const FILE_CHARACTERISTIC_CSV: libc::c_uint = 65536;
pub const FILE_DEVICE_ALLOW_APPCONTAINER_TRAVERSAL: libc::c_uint = 131072;
pub const FILE_PORTABLE_DEVICE: libc::c_uint = 262144;
pub const IO_SESSION_STATE_ALL_EVENTS: libc::c_uint = 4294967295;
pub const IO_SESSION_STATE_CREATION_EVENT: libc::c_uint = 1;
pub const IO_SESSION_STATE_TERMINATION_EVENT: libc::c_uint = 2;
pub const IO_SESSION_STATE_CONNECT_EVENT: libc::c_uint = 4;
pub const IO_SESSION_STATE_DISCONNECT_EVENT: libc::c_uint = 8;
pub const IO_SESSION_STATE_LOGON_EVENT: libc::c_uint = 16;
pub const IO_SESSION_STATE_LOGOFF_EVENT: libc::c_uint = 32;
pub const IO_SESSION_STATE_VALID_EVENT_MASK: libc::c_uint = 63;
pub const IO_SESSION_MAX_PAYLOAD_SIZE: libc::c_uint = 256;
pub const FILE_SKIP_COMPLETION_PORT_ON_SUCCESS: libc::c_uint = 1;
pub const FILE_SKIP_SET_EVENT_ON_HANDLE: libc::c_uint = 2;
pub const FILE_SKIP_SET_USER_EVENT_ON_FAST_IO: libc::c_uint = 4;
pub const FLUSH_FLAGS_FILE_DATA_ONLY: libc::c_uint = 1;
pub const FLUSH_FLAGS_NO_SYNC: libc::c_uint = 2;
pub const ERROR_LOG_LIMIT_SIZE: libc::c_uint = 240;
pub const PORT_MAXIMUM_MESSAGE_LENGTH: libc::c_uint = 512;
pub const KEY_QUERY_VALUE: libc::c_uint = 1;
pub const KEY_SET_VALUE: libc::c_uint = 2;
pub const KEY_CREATE_SUB_KEY: libc::c_uint = 4;
pub const KEY_ENUMERATE_SUB_KEYS: libc::c_uint = 8;
pub const KEY_NOTIFY: libc::c_uint = 16;
pub const KEY_CREATE_LINK: libc::c_uint = 32;
pub const KEY_WOW64_32KEY: libc::c_uint = 512;
pub const KEY_WOW64_64KEY: libc::c_uint = 256;
pub const KEY_WOW64_RES: libc::c_uint = 768;
pub const KEY_READ: libc::c_uint = 131097;
pub const KEY_WRITE: libc::c_uint = 131078;
pub const KEY_EXECUTE: libc::c_uint = 131097;
pub const KEY_ALL_ACCESS: libc::c_uint = 983103;
pub const REG_OPTION_RESERVED: libc::c_uint = 0;
pub const REG_OPTION_NON_VOLATILE: libc::c_uint = 0;
pub const REG_OPTION_VOLATILE: libc::c_uint = 1;
pub const REG_OPTION_CREATE_LINK: libc::c_uint = 2;
pub const REG_OPTION_BACKUP_RESTORE: libc::c_uint = 4;
pub const REG_OPTION_OPEN_LINK: libc::c_uint = 8;
pub const REG_LEGAL_OPTION: libc::c_uint = 15;
pub const REG_OPEN_LEGAL_OPTION: libc::c_uint = 12;
pub const REG_CREATED_NEW_KEY: libc::c_uint = 1;
pub const REG_OPENED_EXISTING_KEY: libc::c_uint = 2;
pub const REG_STANDARD_FORMAT: libc::c_uint = 1;
pub const REG_LATEST_FORMAT: libc::c_uint = 2;
pub const REG_NO_COMPRESSION: libc::c_uint = 4;
pub const REG_WHOLE_HIVE_VOLATILE: libc::c_uint = 1;
pub const REG_REFRESH_HIVE: libc::c_uint = 2;
pub const REG_NO_LAZY_FLUSH: libc::c_uint = 4;
pub const REG_FORCE_RESTORE: libc::c_uint = 8;
pub const REG_APP_HIVE: libc::c_uint = 16;
pub const REG_PROCESS_PRIVATE: libc::c_uint = 32;
pub const REG_START_JOURNAL: libc::c_uint = 64;
pub const REG_HIVE_EXACT_FILE_GROWTH: libc::c_uint = 128;
pub const REG_HIVE_NO_RM: libc::c_uint = 256;
pub const REG_HIVE_SINGLE_LOG: libc::c_uint = 512;
pub const REG_BOOT_HIVE: libc::c_uint = 1024;
pub const REG_LOAD_HIVE_OPEN_HANDLE: libc::c_uint = 2048;
pub const REG_FLUSH_HIVE_FILE_GROWTH: libc::c_uint = 4096;
pub const REG_OPEN_READ_ONLY: libc::c_uint = 8192;
pub const REG_IMMUTABLE: libc::c_uint = 16384;
pub const REG_APP_HIVE_OPEN_READ_ONLY: libc::c_uint = 8192;
pub const REG_FORCE_UNLOAD: libc::c_uint = 1;
pub const REG_NOTIFY_CHANGE_NAME: libc::c_uint = 1;
pub const REG_NOTIFY_CHANGE_ATTRIBUTES: libc::c_uint = 2;
pub const REG_NOTIFY_CHANGE_LAST_SET: libc::c_uint = 4;
pub const REG_NOTIFY_CHANGE_SECURITY: libc::c_uint = 8;
pub const REG_NOTIFY_THREAD_AGNOSTIC: libc::c_uint = 268435456;
pub const REG_LEGAL_CHANGE_FILTER: libc::c_uint = 268435471;
pub const OBJECT_TYPE_CREATE: libc::c_uint = 1;
pub const OBJECT_TYPE_ALL_ACCESS: libc::c_uint = 983041;
pub const DIRECTORY_QUERY: libc::c_uint = 1;
pub const DIRECTORY_TRAVERSE: libc::c_uint = 2;
pub const DIRECTORY_CREATE_OBJECT: libc::c_uint = 4;
pub const DIRECTORY_CREATE_SUBDIRECTORY: libc::c_uint = 8;
pub const DIRECTORY_ALL_ACCESS: libc::c_uint = 983055;
pub const SYMBOLIC_LINK_QUERY: libc::c_uint = 1;
pub const SYMBOLIC_LINK_SET: libc::c_uint = 2;
pub const SYMBOLIC_LINK_ALL_ACCESS: libc::c_uint = 983041;
pub const SYMBOLIC_LINK_ALL_ACCESS_EX: libc::c_uint = 1048575;
pub const DUPLICATE_CLOSE_SOURCE: libc::c_uint = 1;
pub const DUPLICATE_SAME_ACCESS: libc::c_uint = 2;
pub const DUPLICATE_SAME_ATTRIBUTES: libc::c_uint = 4;
pub const SECTION_QUERY: libc::c_uint = 1;
pub const SECTION_MAP_WRITE: libc::c_uint = 2;
pub const SECTION_MAP_READ: libc::c_uint = 4;
pub const SECTION_MAP_EXECUTE: libc::c_uint = 8;
pub const SECTION_EXTEND_SIZE: libc::c_uint = 16;
pub const SECTION_MAP_EXECUTE_EXPLICIT: libc::c_uint = 32;
pub const SECTION_ALL_ACCESS: libc::c_uint = 983071;
pub const SESSION_QUERY_ACCESS: libc::c_uint = 1;
pub const SESSION_MODIFY_ACCESS: libc::c_uint = 2;
pub const SESSION_ALL_ACCESS: libc::c_uint = 983043;
pub const MEMORY_PARTITION_QUERY_ACCESS: libc::c_uint = 1;
pub const MEMORY_PARTITION_MODIFY_ACCESS: libc::c_uint = 2;
pub const MEMORY_PARTITION_ALL_ACCESS: libc::c_uint = 2031619;
pub const SEGMENT_ALL_ACCESS: libc::c_uint = 983071;
pub const PAGE_NOACCESS: libc::c_uint = 1;
pub const PAGE_READONLY: libc::c_uint = 2;
pub const PAGE_READWRITE: libc::c_uint = 4;
pub const PAGE_WRITECOPY: libc::c_uint = 8;
pub const PAGE_EXECUTE: libc::c_uint = 16;
pub const PAGE_EXECUTE_READ: libc::c_uint = 32;
pub const PAGE_EXECUTE_READWRITE: libc::c_uint = 64;
pub const PAGE_EXECUTE_WRITECOPY: libc::c_uint = 128;
pub const PAGE_GUARD: libc::c_uint = 256;
pub const PAGE_NOCACHE: libc::c_uint = 512;
pub const PAGE_WRITECOMBINE: libc::c_uint = 1024;
pub const PAGE_REVERT_TO_FILE_MAP: libc::c_uint = 2147483648;
pub const PAGE_ENCLAVE_THREAD_CONTROL: libc::c_uint = 2147483648;
pub const PAGE_TARGETS_NO_UPDATE: libc::c_uint = 1073741824;
pub const PAGE_TARGETS_INVALID: libc::c_uint = 1073741824;
pub const PAGE_ENCLAVE_UNVALIDATED: libc::c_uint = 536870912;
pub const PAGE_ENCLAVE_NO_CHANGE: libc::c_uint = 536870912;
pub const MEM_COMMIT: libc::c_uint = 4096;
pub const MEM_RESERVE: libc::c_uint = 8192;
pub const MEM_DECOMMIT: libc::c_uint = 16384;
pub const MEM_RELEASE: libc::c_uint = 32768;
pub const MEM_FREE: libc::c_uint = 65536;
pub const MEM_PRIVATE: libc::c_uint = 131072;
pub const MEM_MAPPED: libc::c_uint = 262144;
pub const MEM_RESET: libc::c_uint = 524288;
pub const MEM_TOP_DOWN: libc::c_uint = 1048576;
pub const MEM_RESET_UNDO: libc::c_uint = 16777216;
pub const MEM_LARGE_PAGES: libc::c_uint = 536870912;
pub const MEM_4MB_PAGES: libc::c_uint = 2147483648;
pub const SEC_64K_PAGES: libc::c_uint = 524288;
pub const SEC_FILE: libc::c_uint = 8388608;
pub const SEC_RESERVE: libc::c_uint = 67108864;
pub const SEC_COMMIT: libc::c_uint = 134217728;
pub const SEC_LARGE_PAGES: libc::c_uint = 2147483648;
pub const PROCESS_DUP_HANDLE: libc::c_uint = 64;
pub const PROCESS_ALL_ACCESS: libc::c_uint = 2097151;
pub const THREAD_TERMINATE: libc::c_uint = 1;
pub const THREAD_SUSPEND_RESUME: libc::c_uint = 2;
pub const THREAD_ALERT: libc::c_uint = 4;
pub const THREAD_GET_CONTEXT: libc::c_uint = 8;
pub const THREAD_SET_CONTEXT: libc::c_uint = 16;
pub const THREAD_SET_INFORMATION: libc::c_uint = 32;
pub const THREAD_SET_LIMITED_INFORMATION: libc::c_uint = 1024;
pub const THREAD_QUERY_LIMITED_INFORMATION: libc::c_uint = 2048;
pub const THREAD_RESUME: libc::c_uint = 4096;
pub const THREAD_ALL_ACCESS: libc::c_uint = 2097151;
pub const POWERBUTTON_ACTION_INDEX_NOTHING: libc::c_uint = 0;
pub const POWERBUTTON_ACTION_INDEX_SLEEP: libc::c_uint = 1;
pub const POWERBUTTON_ACTION_INDEX_HIBERNATE: libc::c_uint = 2;
pub const POWERBUTTON_ACTION_INDEX_SHUTDOWN: libc::c_uint = 3;
pub const POWERBUTTON_ACTION_INDEX_TURN_OFF_THE_DISPLAY: libc::c_uint = 4;
pub const POWERBUTTON_ACTION_VALUE_NOTHING: libc::c_uint = 0;
pub const POWERBUTTON_ACTION_VALUE_SLEEP: libc::c_uint = 2;
pub const POWERBUTTON_ACTION_VALUE_HIBERNATE: libc::c_uint = 3;
pub const POWERBUTTON_ACTION_VALUE_SHUTDOWN: libc::c_uint = 6;
pub const POWERBUTTON_ACTION_VALUE_TURN_OFF_THE_DISPLAY: libc::c_uint = 8;
pub const PERFSTATE_POLICY_CHANGE_IDEAL: libc::c_uint = 0;
pub const PERFSTATE_POLICY_CHANGE_SINGLE: libc::c_uint = 1;
pub const PERFSTATE_POLICY_CHANGE_ROCKET: libc::c_uint = 2;
pub const PERFSTATE_POLICY_CHANGE_IDEAL_AGGRESSIVE: libc::c_uint = 3;
pub const PERFSTATE_POLICY_CHANGE_DECREASE_MAX: libc::c_uint = 2;
pub const PERFSTATE_POLICY_CHANGE_INCREASE_MAX: libc::c_uint = 3;
pub const PROCESSOR_THROTTLE_DISABLED: libc::c_uint = 0;
pub const PROCESSOR_THROTTLE_ENABLED: libc::c_uint = 1;
pub const PROCESSOR_THROTTLE_AUTOMATIC: libc::c_uint = 2;
pub const PROCESSOR_PERF_BOOST_POLICY_DISABLED: libc::c_uint = 0;
pub const PROCESSOR_PERF_BOOST_POLICY_MAX: libc::c_uint = 100;
pub const PROCESSOR_PERF_BOOST_MODE_DISABLED: libc::c_uint = 0;
pub const PROCESSOR_PERF_BOOST_MODE_ENABLED: libc::c_uint = 1;
pub const PROCESSOR_PERF_BOOST_MODE_AGGRESSIVE: libc::c_uint = 2;
pub const PROCESSOR_PERF_BOOST_MODE_EFFICIENT_ENABLED: libc::c_uint = 3;
pub const PROCESSOR_PERF_BOOST_MODE_EFFICIENT_AGGRESSIVE: libc::c_uint = 4;
pub const PROCESSOR_PERF_BOOST_MODE_AGGRESSIVE_AT_GUARANTEED: libc::c_uint =
    5;
pub const PROCESSOR_PERF_BOOST_MODE_EFFICIENT_AGGRESSIVE_AT_GUARANTEED:
          libc::c_uint =
    6;
pub const PROCESSOR_PERF_BOOST_MODE_MAX: libc::c_uint = 6;
pub const PROCESSOR_PERF_AUTONOMOUS_MODE_DISABLED: libc::c_uint = 0;
pub const PROCESSOR_PERF_AUTONOMOUS_MODE_ENABLED: libc::c_uint = 1;
pub const PROCESSOR_PERF_PERFORMANCE_PREFERENCE: libc::c_uint = 255;
pub const PROCESSOR_PERF_ENERGY_PREFERENCE: libc::c_uint = 0;
pub const PROCESSOR_PERF_MINIMUM_ACTIVITY_WINDOW: libc::c_uint = 0;
pub const PROCESSOR_PERF_MAXIMUM_ACTIVITY_WINDOW: libc::c_uint = 1270000000;
pub const PROCESSOR_DUTY_CYCLING_DISABLED: libc::c_uint = 0;
pub const PROCESSOR_DUTY_CYCLING_ENABLED: libc::c_uint = 1;
pub const CORE_PARKING_POLICY_CHANGE_IDEAL: libc::c_uint = 0;
pub const CORE_PARKING_POLICY_CHANGE_SINGLE: libc::c_uint = 1;
pub const CORE_PARKING_POLICY_CHANGE_ROCKET: libc::c_uint = 2;
pub const CORE_PARKING_POLICY_CHANGE_MULTISTEP: libc::c_uint = 3;
pub const CORE_PARKING_POLICY_CHANGE_MAX: libc::c_uint = 3;
pub const POWER_DEVICE_IDLE_POLICY_PERFORMANCE: libc::c_uint = 0;
pub const POWER_DEVICE_IDLE_POLICY_CONSERVATIVE: libc::c_uint = 1;
pub const POWER_CONNECTIVITY_IN_STANDBY_DISABLED: libc::c_uint = 0;
pub const POWER_CONNECTIVITY_IN_STANDBY_ENABLED: libc::c_uint = 1;
pub const POWER_SYSTEM_MAXIMUM: libc::c_uint = 7;
pub const DIAGNOSTIC_REASON_VERSION: libc::c_uint = 0;
pub const DIAGNOSTIC_REASON_SIMPLE_STRING: libc::c_uint = 1;
pub const DIAGNOSTIC_REASON_DETAILED_STRING: libc::c_uint = 2;
pub const DIAGNOSTIC_REASON_NOT_SPECIFIED: libc::c_uint = 2147483648;
pub const DIAGNOSTIC_REASON_INVALID_FLAGS: libc::c_longlong = -2147483656;
pub const POWER_REQUEST_CONTEXT_VERSION: libc::c_uint = 0;
pub const POWER_REQUEST_CONTEXT_SIMPLE_STRING: libc::c_uint = 1;
pub const POWER_REQUEST_CONTEXT_DETAILED_STRING: libc::c_uint = 2;
pub const PDCAP_D0_SUPPORTED: libc::c_uint = 1;
pub const PDCAP_D1_SUPPORTED: libc::c_uint = 2;
pub const PDCAP_D2_SUPPORTED: libc::c_uint = 4;
pub const PDCAP_D3_SUPPORTED: libc::c_uint = 8;
pub const PDCAP_WAKE_FROM_D0_SUPPORTED: libc::c_uint = 16;
pub const PDCAP_WAKE_FROM_D1_SUPPORTED: libc::c_uint = 32;
pub const PDCAP_WAKE_FROM_D2_SUPPORTED: libc::c_uint = 64;
pub const PDCAP_WAKE_FROM_D3_SUPPORTED: libc::c_uint = 128;
pub const PDCAP_WARM_EJECT_SUPPORTED: libc::c_uint = 256;
pub const POWER_SETTING_VALUE_VERSION: libc::c_uint = 1;
pub const POWER_PLATFORM_ROLE_V1: libc::c_uint = 1;
pub const POWER_PLATFORM_ROLE_V2: libc::c_uint = 2;
pub const POWER_PLATFORM_ROLE_VERSION: libc::c_uint = 2;
pub const REG_NONE: libc::c_uint = 0;
pub const REG_SZ: libc::c_uint = 1;
pub const REG_EXPAND_SZ: libc::c_uint = 2;
pub const REG_BINARY: libc::c_uint = 3;
pub const REG_DWORD: libc::c_uint = 4;
pub const REG_DWORD_LITTLE_ENDIAN: libc::c_uint = 4;
pub const REG_DWORD_BIG_ENDIAN: libc::c_uint = 5;
pub const REG_LINK: libc::c_uint = 6;
pub const REG_MULTI_SZ: libc::c_uint = 7;
pub const REG_RESOURCE_LIST: libc::c_uint = 8;
pub const REG_FULL_RESOURCE_DESCRIPTOR: libc::c_uint = 9;
pub const REG_RESOURCE_REQUIREMENTS_LIST: libc::c_uint = 10;
pub const REG_QWORD: libc::c_uint = 11;
pub const REG_QWORD_LITTLE_ENDIAN: libc::c_uint = 11;
pub const SERVICE_KERNEL_DRIVER: libc::c_uint = 1;
pub const SERVICE_FILE_SYSTEM_DRIVER: libc::c_uint = 2;
pub const SERVICE_ADAPTER: libc::c_uint = 4;
pub const SERVICE_RECOGNIZER_DRIVER: libc::c_uint = 8;
pub const SERVICE_DRIVER: libc::c_uint = 11;
pub const SERVICE_WIN32_OWN_PROCESS: libc::c_uint = 16;
pub const SERVICE_WIN32_SHARE_PROCESS: libc::c_uint = 32;
pub const SERVICE_WIN32: libc::c_uint = 48;
pub const SERVICE_USER_SERVICE: libc::c_uint = 64;
pub const SERVICE_USERSERVICE_INSTANCE: libc::c_uint = 128;
pub const SERVICE_USER_SHARE_PROCESS: libc::c_uint = 96;
pub const SERVICE_USER_OWN_PROCESS: libc::c_uint = 80;
pub const SERVICE_INTERACTIVE_PROCESS: libc::c_uint = 256;
pub const SERVICE_PKG_SERVICE: libc::c_uint = 512;
pub const SERVICE_TYPE_ALL: libc::c_uint = 1023;
pub const SERVICE_BOOT_START: libc::c_uint = 0;
pub const SERVICE_SYSTEM_START: libc::c_uint = 1;
pub const SERVICE_AUTO_START: libc::c_uint = 2;
pub const SERVICE_DEMAND_START: libc::c_uint = 3;
pub const SERVICE_DISABLED: libc::c_uint = 4;
pub const SERVICE_ERROR_IGNORE: libc::c_uint = 0;
pub const SERVICE_ERROR_NORMAL: libc::c_uint = 1;
pub const SERVICE_ERROR_SEVERE: libc::c_uint = 2;
pub const SERVICE_ERROR_CRITICAL: libc::c_uint = 3;
pub const CM_SERVICE_NETWORK_BOOT_LOAD: libc::c_uint = 1;
pub const CM_SERVICE_VIRTUAL_DISK_BOOT_LOAD: libc::c_uint = 2;
pub const CM_SERVICE_USB_DISK_BOOT_LOAD: libc::c_uint = 4;
pub const CM_SERVICE_SD_DISK_BOOT_LOAD: libc::c_uint = 8;
pub const CM_SERVICE_USB3_DISK_BOOT_LOAD: libc::c_uint = 16;
pub const CM_SERVICE_MEASURED_BOOT_LOAD: libc::c_uint = 32;
pub const CM_SERVICE_VERIFIER_BOOT_LOAD: libc::c_uint = 64;
pub const CM_SERVICE_WINPE_BOOT_LOAD: libc::c_uint = 128;
pub const CM_SERVICE_VALID_PROMOTION_MASK: libc::c_uint = 255;
pub const CmResourceTypeNull: libc::c_uint = 0;
pub const CmResourceTypePort: libc::c_uint = 1;
pub const CmResourceTypeInterrupt: libc::c_uint = 2;
pub const CmResourceTypeMemory: libc::c_uint = 3;
pub const CmResourceTypeDma: libc::c_uint = 4;
pub const CmResourceTypeDeviceSpecific: libc::c_uint = 5;
pub const CmResourceTypeBusNumber: libc::c_uint = 6;
pub const CmResourceTypeMemoryLarge: libc::c_uint = 7;
pub const CmResourceTypeNonArbitrated: libc::c_uint = 128;
pub const CmResourceTypeConfigData: libc::c_uint = 128;
pub const CmResourceTypeDevicePrivate: libc::c_uint = 129;
pub const CmResourceTypePcCardConfig: libc::c_uint = 130;
pub const CmResourceTypeMfCardConfig: libc::c_uint = 131;
pub const CmResourceTypeConnection: libc::c_uint = 132;
pub const CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE: libc::c_uint = 0;
pub const CM_RESOURCE_INTERRUPT_LATCHED: libc::c_uint = 1;
pub const CM_RESOURCE_INTERRUPT_MESSAGE: libc::c_uint = 2;
pub const CM_RESOURCE_INTERRUPT_POLICY_INCLUDED: libc::c_uint = 4;
pub const CM_RESOURCE_INTERRUPT_SECONDARY_INTERRUPT: libc::c_uint = 16;
pub const CM_RESOURCE_INTERRUPT_WAKE_HINT: libc::c_uint = 32;
pub const CM_RESOURCE_INTERRUPT_LEVEL_LATCHED_BITS: libc::c_uint = 1;
pub const CM_RESOURCE_MEMORY_READ_WRITE: libc::c_uint = 0;
pub const CM_RESOURCE_MEMORY_READ_ONLY: libc::c_uint = 1;
pub const CM_RESOURCE_MEMORY_WRITE_ONLY: libc::c_uint = 2;
pub const CM_RESOURCE_MEMORY_WRITEABILITY_MASK: libc::c_uint = 3;
pub const CM_RESOURCE_MEMORY_PREFETCHABLE: libc::c_uint = 4;
pub const CM_RESOURCE_MEMORY_COMBINEDWRITE: libc::c_uint = 8;
pub const CM_RESOURCE_MEMORY_24: libc::c_uint = 16;
pub const CM_RESOURCE_MEMORY_CACHEABLE: libc::c_uint = 32;
pub const CM_RESOURCE_MEMORY_WINDOW_DECODE: libc::c_uint = 64;
pub const CM_RESOURCE_MEMORY_BAR: libc::c_uint = 128;
pub const CM_RESOURCE_MEMORY_COMPAT_FOR_INACCESSIBLE_RANGE: libc::c_uint =
    256;
pub const CM_RESOURCE_MEMORY_LARGE: libc::c_uint = 3584;
pub const CM_RESOURCE_MEMORY_LARGE_40: libc::c_uint = 512;
pub const CM_RESOURCE_MEMORY_LARGE_48: libc::c_uint = 1024;
pub const CM_RESOURCE_MEMORY_LARGE_64: libc::c_uint = 2048;
pub const CM_RESOURCE_MEMORY_LARGE_40_MAXLEN: libc::c_ulonglong =
    1099511627520;
pub const CM_RESOURCE_MEMORY_LARGE_48_MAXLEN: libc::c_ulonglong =
    281474976645120;
pub const CM_RESOURCE_MEMORY_LARGE_64_MAXLEN: libc::c_longlong = -4294967296;
pub const CM_RESOURCE_PORT_MEMORY: libc::c_uint = 0;
pub const CM_RESOURCE_PORT_IO: libc::c_uint = 1;
pub const CM_RESOURCE_PORT_10_BIT_DECODE: libc::c_uint = 4;
pub const CM_RESOURCE_PORT_12_BIT_DECODE: libc::c_uint = 8;
pub const CM_RESOURCE_PORT_16_BIT_DECODE: libc::c_uint = 16;
pub const CM_RESOURCE_PORT_POSITIVE_DECODE: libc::c_uint = 32;
pub const CM_RESOURCE_PORT_PASSIVE_DECODE: libc::c_uint = 64;
pub const CM_RESOURCE_PORT_WINDOW_DECODE: libc::c_uint = 128;
pub const CM_RESOURCE_PORT_BAR: libc::c_uint = 256;
pub const CM_RESOURCE_DMA_8: libc::c_uint = 0;
pub const CM_RESOURCE_DMA_16: libc::c_uint = 1;
pub const CM_RESOURCE_DMA_32: libc::c_uint = 2;
pub const CM_RESOURCE_DMA_8_AND_16: libc::c_uint = 4;
pub const CM_RESOURCE_DMA_BUS_MASTER: libc::c_uint = 8;
pub const CM_RESOURCE_DMA_TYPE_A: libc::c_uint = 16;
pub const CM_RESOURCE_DMA_TYPE_B: libc::c_uint = 32;
pub const CM_RESOURCE_DMA_TYPE_F: libc::c_uint = 64;
pub const CM_RESOURCE_DMA_V3: libc::c_uint = 128;
pub const DMAV3_TRANFER_WIDTH_8: libc::c_uint = 0;
pub const DMAV3_TRANFER_WIDTH_16: libc::c_uint = 1;
pub const DMAV3_TRANFER_WIDTH_32: libc::c_uint = 2;
pub const DMAV3_TRANFER_WIDTH_64: libc::c_uint = 3;
pub const DMAV3_TRANFER_WIDTH_128: libc::c_uint = 4;
pub const DMAV3_TRANFER_WIDTH_256: libc::c_uint = 5;
pub const CM_RESOURCE_CONNECTION_CLASS_GPIO: libc::c_uint = 1;
pub const CM_RESOURCE_CONNECTION_CLASS_SERIAL: libc::c_uint = 2;
pub const CM_RESOURCE_CONNECTION_CLASS_FUNCTION_CONFIG: libc::c_uint = 3;
pub const CM_RESOURCE_CONNECTION_TYPE_GPIO_IO: libc::c_uint = 2;
pub const CM_RESOURCE_CONNECTION_TYPE_SERIAL_I2C: libc::c_uint = 1;
pub const CM_RESOURCE_CONNECTION_TYPE_SERIAL_SPI: libc::c_uint = 2;
pub const CM_RESOURCE_CONNECTION_TYPE_SERIAL_UART: libc::c_uint = 3;
pub const CM_RESOURCE_CONNECTION_TYPE_FUNCTION_CONFIG: libc::c_uint = 1;
pub const EISA_FUNCTION_ENABLED: libc::c_uint = 128;
pub const EISA_FREE_FORM_DATA: libc::c_uint = 64;
pub const EISA_HAS_PORT_INIT_ENTRY: libc::c_uint = 32;
pub const EISA_HAS_PORT_RANGE: libc::c_uint = 16;
pub const EISA_HAS_DMA_ENTRY: libc::c_uint = 8;
pub const EISA_HAS_IRQ_ENTRY: libc::c_uint = 4;
pub const EISA_HAS_MEMORY_ENTRY: libc::c_uint = 2;
pub const EISA_HAS_TYPE_ENTRY: libc::c_uint = 1;
pub const EISA_HAS_INFORMATION: libc::c_uint = 31;
pub const EISA_MORE_ENTRIES: libc::c_uint = 128;
pub const EISA_SYSTEM_MEMORY: libc::c_uint = 0;
pub const EISA_MEMORY_TYPE_RAM: libc::c_uint = 1;
pub const EISA_INVALID_SLOT: libc::c_uint = 128;
pub const EISA_INVALID_FUNCTION: libc::c_uint = 129;
pub const EISA_INVALID_CONFIGURATION: libc::c_uint = 130;
pub const EISA_EMPTY_SLOT: libc::c_uint = 131;
pub const EISA_INVALID_BIOS_CALL: libc::c_uint = 134;
pub const IO_RESOURCE_PREFERRED: libc::c_uint = 1;
pub const IO_RESOURCE_DEFAULT: libc::c_uint = 2;
pub const IO_RESOURCE_ALTERNATIVE: libc::c_uint = 8;
pub const FAST_FAIL_LEGACY_GS_VIOLATION: libc::c_uint = 0;
pub const FAST_FAIL_VTGUARD_CHECK_FAILURE: libc::c_uint = 1;
pub const FAST_FAIL_STACK_COOKIE_CHECK_FAILURE: libc::c_uint = 2;
pub const FAST_FAIL_CORRUPT_LIST_ENTRY: libc::c_uint = 3;
pub const FAST_FAIL_INCORRECT_STACK: libc::c_uint = 4;
pub const FAST_FAIL_INVALID_ARG: libc::c_uint = 5;
pub const FAST_FAIL_GS_COOKIE_INIT: libc::c_uint = 6;
pub const FAST_FAIL_FATAL_APP_EXIT: libc::c_uint = 7;
pub const FAST_FAIL_RANGE_CHECK_FAILURE: libc::c_uint = 8;
pub const FAST_FAIL_UNSAFE_REGISTRY_ACCESS: libc::c_uint = 9;
pub const FAST_FAIL_GUARD_ICALL_CHECK_FAILURE: libc::c_uint = 10;
pub const FAST_FAIL_GUARD_WRITE_CHECK_FAILURE: libc::c_uint = 11;
pub const FAST_FAIL_INVALID_FIBER_SWITCH: libc::c_uint = 12;
pub const FAST_FAIL_INVALID_SET_OF_CONTEXT: libc::c_uint = 13;
pub const FAST_FAIL_INVALID_REFERENCE_COUNT: libc::c_uint = 14;
pub const FAST_FAIL_INVALID_JUMP_BUFFER: libc::c_uint = 18;
pub const FAST_FAIL_MRDATA_MODIFIED: libc::c_uint = 19;
pub const FAST_FAIL_CERTIFICATION_FAILURE: libc::c_uint = 20;
pub const FAST_FAIL_INVALID_EXCEPTION_CHAIN: libc::c_uint = 21;
pub const FAST_FAIL_CRYPTO_LIBRARY: libc::c_uint = 22;
pub const FAST_FAIL_INVALID_CALL_IN_DLL_CALLOUT: libc::c_uint = 23;
pub const FAST_FAIL_INVALID_IMAGE_BASE: libc::c_uint = 24;
pub const FAST_FAIL_DLOAD_PROTECTION_FAILURE: libc::c_uint = 25;
pub const FAST_FAIL_UNSAFE_EXTENSION_CALL: libc::c_uint = 26;
pub const FAST_FAIL_DEPRECATED_SERVICE_INVOKED: libc::c_uint = 27;
pub const FAST_FAIL_INVALID_BUFFER_ACCESS: libc::c_uint = 28;
pub const FAST_FAIL_INVALID_BALANCED_TREE: libc::c_uint = 29;
pub const FAST_FAIL_INVALID_NEXT_THREAD: libc::c_uint = 30;
pub const FAST_FAIL_GUARD_ICALL_CHECK_SUPPRESSED: libc::c_uint = 31;
pub const FAST_FAIL_APCS_DISABLED: libc::c_uint = 32;
pub const FAST_FAIL_INVALID_IDLE_STATE: libc::c_uint = 33;
pub const FAST_FAIL_MRDATA_PROTECTION_FAILURE: libc::c_uint = 34;
pub const FAST_FAIL_UNEXPECTED_HEAP_EXCEPTION: libc::c_uint = 35;
pub const FAST_FAIL_INVALID_LOCK_STATE: libc::c_uint = 36;
pub const FAST_FAIL_GUARD_JUMPTABLE: libc::c_uint = 37;
pub const FAST_FAIL_INVALID_LONGJUMP_TARGET: libc::c_uint = 38;
pub const FAST_FAIL_INVALID_DISPATCH_CONTEXT: libc::c_uint = 39;
pub const FAST_FAIL_INVALID_THREAD: libc::c_uint = 40;
pub const FAST_FAIL_INVALID_FAST_FAIL_CODE: libc::c_uint = 4294967295;
pub const RTL_QUERY_REGISTRY_SUBKEY: libc::c_uint = 1;
pub const RTL_QUERY_REGISTRY_TOPKEY: libc::c_uint = 2;
pub const RTL_QUERY_REGISTRY_REQUIRED: libc::c_uint = 4;
pub const RTL_QUERY_REGISTRY_NOVALUE: libc::c_uint = 8;
pub const RTL_QUERY_REGISTRY_NOEXPAND: libc::c_uint = 16;
pub const RTL_QUERY_REGISTRY_DIRECT: libc::c_uint = 32;
pub const RTL_QUERY_REGISTRY_DELETE: libc::c_uint = 64;
pub const RTL_QUERY_REGISTRY_NOSTRING: libc::c_uint = 128;
pub const RTL_QUERY_REGISTRY_TYPECHECK: libc::c_uint = 256;
pub const RTL_QUERY_REGISTRY_TYPECHECK_SHIFT: libc::c_uint = 24;
pub const RTL_QUERY_REGISTRY_TYPECHECK_MASK: libc::c_uint = 4278190080;
pub const RTL_REGISTRY_ABSOLUTE: libc::c_uint = 0;
pub const RTL_REGISTRY_SERVICES: libc::c_uint = 1;
pub const RTL_REGISTRY_CONTROL: libc::c_uint = 2;
pub const RTL_REGISTRY_WINDOWS_NT: libc::c_uint = 3;
pub const RTL_REGISTRY_DEVICEMAP: libc::c_uint = 4;
pub const RTL_REGISTRY_USER: libc::c_uint = 5;
pub const RTL_REGISTRY_MAXIMUM: libc::c_uint = 6;
pub const RTL_REGISTRY_HANDLE: libc::c_uint = 1073741824;
pub const RTL_REGISTRY_OPTIONAL: libc::c_uint = 2147483648;
pub const HASH_STRING_ALGORITHM_DEFAULT: libc::c_uint = 0;
pub const HASH_STRING_ALGORITHM_X65599: libc::c_uint = 1;
pub const HASH_STRING_ALGORITHM_INVALID: libc::c_uint = 4294967295;
pub const DBG_STATUS_CONTROL_C: libc::c_uint = 1;
pub const DBG_STATUS_SYSRQ: libc::c_uint = 2;
pub const DBG_STATUS_BUGCHECK_FIRST: libc::c_uint = 3;
pub const DBG_STATUS_BUGCHECK_SECOND: libc::c_uint = 4;
pub const DBG_STATUS_FATAL: libc::c_uint = 5;
pub const DBG_STATUS_DEBUG_CONTROL: libc::c_uint = 6;
pub const DBG_STATUS_WORKER: libc::c_uint = 7;
pub const LOWBYTE_MASK: libc::c_uint = 255;
pub const SHORT_LEAST_SIGNIFICANT_BIT: libc::c_uint = 0;
pub const SHORT_MOST_SIGNIFICANT_BIT: libc::c_uint = 1;
pub const LONG_LEAST_SIGNIFICANT_BIT: libc::c_uint = 0;
pub const LONG_3RD_MOST_SIGNIFICANT_BIT: libc::c_uint = 1;
pub const LONG_2ND_MOST_SIGNIFICANT_BIT: libc::c_uint = 2;
pub const LONG_MOST_SIGNIFICANT_BIT: libc::c_uint = 3;
pub const SEF_DACL_AUTO_INHERIT: libc::c_uint = 1;
pub const SEF_SACL_AUTO_INHERIT: libc::c_uint = 2;
pub const SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT: libc::c_uint = 4;
pub const SEF_AVOID_PRIVILEGE_CHECK: libc::c_uint = 8;
pub const SEF_AVOID_OWNER_CHECK: libc::c_uint = 16;
pub const SEF_DEFAULT_OWNER_FROM_PARENT: libc::c_uint = 32;
pub const SEF_DEFAULT_GROUP_FROM_PARENT: libc::c_uint = 64;
pub const SEF_MACL_NO_WRITE_UP: libc::c_uint = 256;
pub const SEF_MACL_NO_READ_UP: libc::c_uint = 512;
pub const SEF_MACL_NO_EXECUTE_UP: libc::c_uint = 1024;
pub const SEF_AI_USE_EXTRA_PARAMS: libc::c_uint = 2048;
pub const SEF_AVOID_OWNER_RESTRICTION: libc::c_uint = 4096;
pub const SEF_MACL_VALID_FLAGS: libc::c_uint = 1792;
pub const VER_EQUAL: libc::c_uint = 1;
pub const VER_GREATER: libc::c_uint = 2;
pub const VER_GREATER_EQUAL: libc::c_uint = 3;
pub const VER_LESS: libc::c_uint = 4;
pub const VER_LESS_EQUAL: libc::c_uint = 5;
pub const VER_AND: libc::c_uint = 6;
pub const VER_OR: libc::c_uint = 7;
pub const VER_CONDITION_MASK: libc::c_uint = 7;
pub const VER_NUM_BITS_PER_CONDITION_MASK: libc::c_uint = 3;
pub const VER_MINORVERSION: libc::c_uint = 1;
pub const VER_MAJORVERSION: libc::c_uint = 2;
pub const VER_BUILDNUMBER: libc::c_uint = 4;
pub const VER_PLATFORMID: libc::c_uint = 8;
pub const VER_SERVICEPACKMINOR: libc::c_uint = 16;
pub const VER_SERVICEPACKMAJOR: libc::c_uint = 32;
pub const VER_SUITENAME: libc::c_uint = 64;
pub const VER_PRODUCT_TYPE: libc::c_uint = 128;
pub const VER_NT_WORKSTATION: libc::c_uint = 1;
pub const VER_NT_DOMAIN_CONTROLLER: libc::c_uint = 2;
pub const VER_NT_SERVER: libc::c_uint = 3;
pub const VER_PLATFORM_WIN32s: libc::c_uint = 0;
pub const VER_PLATFORM_WIN32_WINDOWS: libc::c_uint = 1;
pub const VER_PLATFORM_WIN32_NT: libc::c_uint = 2;
pub const DPFLTR_ERROR_LEVEL: libc::c_uint = 0;
pub const DPFLTR_WARNING_LEVEL: libc::c_uint = 1;
pub const DPFLTR_TRACE_LEVEL: libc::c_uint = 2;
pub const DPFLTR_INFO_LEVEL: libc::c_uint = 3;
pub const DPFLTR_MASK: libc::c_uint = 2147483648;
pub const VRL_PREDEFINED_CLASS_BEGIN: libc::c_uint = 1;
pub const VRL_CUSTOM_CLASS_BEGIN: libc::c_uint = 256;
pub const VRL_CLASS_CONSISTENCY: libc::c_uint = 1;
pub const VRL_ENABLE_KERNEL_BREAKS: libc::c_uint = 2147483648;
pub const CTMF_INCLUDE_APPCONTAINER: libc::c_uint = 1;
pub const CTMF_VALID_FLAGS: libc::c_uint = 1;
pub const TRANSACTION_MANAGER_VOLATILE: libc::c_uint = 1;
pub const TRANSACTION_MANAGER_COMMIT_DEFAULT: libc::c_uint = 0;
pub const TRANSACTION_MANAGER_COMMIT_SYSTEM_VOLUME: libc::c_uint = 2;
pub const TRANSACTION_MANAGER_COMMIT_SYSTEM_HIVES: libc::c_uint = 4;
pub const TRANSACTION_MANAGER_COMMIT_LOWEST: libc::c_uint = 8;
pub const TRANSACTION_MANAGER_CORRUPT_FOR_RECOVERY: libc::c_uint = 16;
pub const TRANSACTION_MANAGER_CORRUPT_FOR_PROGRESS: libc::c_uint = 32;
pub const TRANSACTION_MANAGER_MAXIMUM_OPTION: libc::c_uint = 63;
pub const TRANSACTION_DO_NOT_PROMOTE: libc::c_uint = 1;
pub const TRANSACTION_MAXIMUM_OPTION: libc::c_uint = 1;
pub const RESOURCE_MANAGER_VOLATILE: libc::c_uint = 1;
pub const RESOURCE_MANAGER_COMMUNICATION: libc::c_uint = 2;
pub const RESOURCE_MANAGER_MAXIMUM_OPTION: libc::c_uint = 3;
pub const CRM_PROTOCOL_EXPLICIT_MARSHAL_ONLY: libc::c_uint = 1;
pub const CRM_PROTOCOL_DYNAMIC_MARSHAL_INFO: libc::c_uint = 2;
pub const CRM_PROTOCOL_MAXIMUM_OPTION: libc::c_uint = 3;
pub const ENLISTMENT_SUPERIOR: libc::c_uint = 1;
pub const ENLISTMENT_MAXIMUM_OPTION: libc::c_uint = 1;
pub const TRANSACTION_NOTIFY_MASK: libc::c_uint = 1073741823;
pub const TRANSACTION_NOTIFY_PREPREPARE: libc::c_uint = 1;
pub const TRANSACTION_NOTIFY_PREPARE: libc::c_uint = 2;
pub const TRANSACTION_NOTIFY_COMMIT: libc::c_uint = 4;
pub const TRANSACTION_NOTIFY_ROLLBACK: libc::c_uint = 8;
pub const TRANSACTION_NOTIFY_PREPREPARE_COMPLETE: libc::c_uint = 16;
pub const TRANSACTION_NOTIFY_PREPARE_COMPLETE: libc::c_uint = 32;
pub const TRANSACTION_NOTIFY_COMMIT_COMPLETE: libc::c_uint = 64;
pub const TRANSACTION_NOTIFY_ROLLBACK_COMPLETE: libc::c_uint = 128;
pub const TRANSACTION_NOTIFY_RECOVER: libc::c_uint = 256;
pub const TRANSACTION_NOTIFY_SINGLE_PHASE_COMMIT: libc::c_uint = 512;
pub const TRANSACTION_NOTIFY_DELEGATE_COMMIT: libc::c_uint = 1024;
pub const TRANSACTION_NOTIFY_RECOVER_QUERY: libc::c_uint = 2048;
pub const TRANSACTION_NOTIFY_ENLIST_PREPREPARE: libc::c_uint = 4096;
pub const TRANSACTION_NOTIFY_LAST_RECOVER: libc::c_uint = 8192;
pub const TRANSACTION_NOTIFY_INDOUBT: libc::c_uint = 16384;
pub const TRANSACTION_NOTIFY_PROPAGATE_PULL: libc::c_uint = 32768;
pub const TRANSACTION_NOTIFY_PROPAGATE_PUSH: libc::c_uint = 65536;
pub const TRANSACTION_NOTIFY_MARSHAL: libc::c_uint = 131072;
pub const TRANSACTION_NOTIFY_ENLIST_MASK: libc::c_uint = 262144;
pub const TRANSACTION_NOTIFY_RM_DISCONNECTED: libc::c_uint = 16777216;
pub const TRANSACTION_NOTIFY_TM_ONLINE: libc::c_uint = 33554432;
pub const TRANSACTION_NOTIFY_COMMIT_REQUEST: libc::c_uint = 67108864;
pub const TRANSACTION_NOTIFY_PROMOTE: libc::c_uint = 134217728;
pub const TRANSACTION_NOTIFY_PROMOTE_NEW: libc::c_uint = 268435456;
pub const TRANSACTION_NOTIFY_REQUEST_OUTCOME: libc::c_uint = 536870912;
pub const TRANSACTION_NOTIFY_COMMIT_FINALIZE: libc::c_uint = 1073741824;
pub const TRANSACTIONMANAGER_OBJECT_PATH: &'static [u8; 22usize] =
    b"\\TransactionManager\\\\\x00";
pub const TRANSACTION_OBJECT_PATH: &'static [u8; 15usize] =
    b"\\Transaction\\\\\x00";
pub const ENLISTMENT_OBJECT_PATH: &'static [u8; 14usize] =
    b"\\Enlistment\\\\\x00";
pub const RESOURCE_MANAGER_OBJECT_PATH: &'static [u8; 19usize] =
    b"\\ResourceManager\\\\\x00";
pub const TRANSACTION_NOTIFICATION_TM_ONLINE_FLAG_IS_CLUSTERED: libc::c_uint =
    1;
pub const KTM_MARSHAL_BLOB_VERSION_MAJOR: libc::c_uint = 1;
pub const KTM_MARSHAL_BLOB_VERSION_MINOR: libc::c_uint = 1;
pub const MAX_TRANSACTION_DESCRIPTION_LENGTH: libc::c_uint = 64;
pub const MAX_RESOURCEMANAGER_DESCRIPTION_LENGTH: libc::c_uint = 64;
pub const TRANSACTIONMANAGER_QUERY_INFORMATION: libc::c_uint = 1;
pub const TRANSACTIONMANAGER_SET_INFORMATION: libc::c_uint = 2;
pub const TRANSACTIONMANAGER_RECOVER: libc::c_uint = 4;
pub const TRANSACTIONMANAGER_RENAME: libc::c_uint = 8;
pub const TRANSACTIONMANAGER_CREATE_RM: libc::c_uint = 16;
pub const TRANSACTIONMANAGER_BIND_TRANSACTION: libc::c_uint = 32;
pub const TRANSACTIONMANAGER_GENERIC_READ: libc::c_uint = 131073;
pub const TRANSACTIONMANAGER_GENERIC_WRITE: libc::c_uint = 131102;
pub const TRANSACTIONMANAGER_GENERIC_EXECUTE: libc::c_uint = 131072;
pub const TRANSACTIONMANAGER_ALL_ACCESS: libc::c_uint = 983103;
pub const TRANSACTION_QUERY_INFORMATION: libc::c_uint = 1;
pub const TRANSACTION_SET_INFORMATION: libc::c_uint = 2;
pub const TRANSACTION_ENLIST: libc::c_uint = 4;
pub const TRANSACTION_COMMIT: libc::c_uint = 8;
pub const TRANSACTION_ROLLBACK: libc::c_uint = 16;
pub const TRANSACTION_PROPAGATE: libc::c_uint = 32;
pub const TRANSACTION_RIGHT_RESERVED1: libc::c_uint = 64;
pub const TRANSACTION_GENERIC_READ: libc::c_uint = 1179649;
pub const TRANSACTION_GENERIC_WRITE: libc::c_uint = 1179710;
pub const TRANSACTION_GENERIC_EXECUTE: libc::c_uint = 1179672;
pub const TRANSACTION_ALL_ACCESS: libc::c_uint = 2031679;
pub const TRANSACTION_RESOURCE_MANAGER_RIGHTS: libc::c_uint = 1179703;
pub const RESOURCEMANAGER_QUERY_INFORMATION: libc::c_uint = 1;
pub const RESOURCEMANAGER_SET_INFORMATION: libc::c_uint = 2;
pub const RESOURCEMANAGER_RECOVER: libc::c_uint = 4;
pub const RESOURCEMANAGER_ENLIST: libc::c_uint = 8;
pub const RESOURCEMANAGER_GET_NOTIFICATION: libc::c_uint = 16;
pub const RESOURCEMANAGER_REGISTER_PROTOCOL: libc::c_uint = 32;
pub const RESOURCEMANAGER_COMPLETE_PROPAGATION: libc::c_uint = 64;
pub const RESOURCEMANAGER_GENERIC_READ: libc::c_uint = 1179649;
pub const RESOURCEMANAGER_GENERIC_WRITE: libc::c_uint = 1179774;
pub const RESOURCEMANAGER_GENERIC_EXECUTE: libc::c_uint = 1179740;
pub const RESOURCEMANAGER_ALL_ACCESS: libc::c_uint = 2031743;
pub const ENLISTMENT_QUERY_INFORMATION: libc::c_uint = 1;
pub const ENLISTMENT_SET_INFORMATION: libc::c_uint = 2;
pub const ENLISTMENT_RECOVER: libc::c_uint = 4;
pub const ENLISTMENT_SUBORDINATE_RIGHTS: libc::c_uint = 8;
pub const ENLISTMENT_SUPERIOR_RIGHTS: libc::c_uint = 16;
pub const ENLISTMENT_GENERIC_READ: libc::c_uint = 131073;
pub const ENLISTMENT_GENERIC_WRITE: libc::c_uint = 131102;
pub const ENLISTMENT_GENERIC_EXECUTE: libc::c_uint = 131100;
pub const ENLISTMENT_ALL_ACCESS: libc::c_uint = 983071;
pub const POOL_TAGGING: libc::c_uint = 1;
pub const DPC_NORMAL: libc::c_uint = 0;
pub const DPC_THREADED: libc::c_uint = 1;
pub const PAGE_SIZE: libc::c_uint = 4096;
pub const PAGE_SHIFT: libc::c_uint = 12;
pub const MDL_MAPPED_TO_SYSTEM_VA: libc::c_uint = 1;
pub const MDL_PAGES_LOCKED: libc::c_uint = 2;
pub const MDL_SOURCE_IS_NONPAGED_POOL: libc::c_uint = 4;
pub const MDL_ALLOCATED_FIXED_SIZE: libc::c_uint = 8;
pub const MDL_PARTIAL: libc::c_uint = 16;
pub const MDL_PARTIAL_HAS_BEEN_MAPPED: libc::c_uint = 32;
pub const MDL_IO_PAGE_READ: libc::c_uint = 64;
pub const MDL_WRITE_OPERATION: libc::c_uint = 128;
pub const MDL_LOCKED_PAGE_TABLES: libc::c_uint = 256;
pub const MDL_PARENT_MAPPED_SYSTEM_VA: libc::c_uint = 256;
pub const MDL_FREE_EXTRA_PTES: libc::c_uint = 512;
pub const MDL_DESCRIBES_AWE: libc::c_uint = 1024;
pub const MDL_IO_SPACE: libc::c_uint = 2048;
pub const MDL_NETWORK_HEADER: libc::c_uint = 4096;
pub const MDL_MAPPING_CAN_FAIL: libc::c_uint = 8192;
pub const MDL_PAGE_CONTENTS_INVARIANT: libc::c_uint = 16384;
pub const MDL_ALLOCATED_MUST_SUCCEED: libc::c_uint = 16384;
pub const MDL_INTERNAL: libc::c_uint = 32768;
pub const KENCODED_TIMER_PROCESSOR: libc::c_uint = 1;
pub const TIMER_TOLERABLE_DELAY_BITS: libc::c_uint = 6;
pub const TIMER_EXPIRED_INDEX_BITS: libc::c_uint = 6;
pub const TIMER_PROCESSOR_INDEX_BITS: libc::c_uint = 5;
pub const FLUSH_MULTIPLE_MAXIMUM: libc::c_uint = 32;
pub const ALLOC_PRAGMA: libc::c_uint = 1;
pub const ALLOC_DATA_PRAGMA: libc::c_uint = 1;
pub const EFLAG_SIGN: libc::c_uint = 32768;
pub const EFLAG_ZERO: libc::c_uint = 16384;
pub const EFLAG_SELECT: libc::c_uint = 49152;
pub const RESULT_NEGATIVE: libc::c_uint = 32768;
pub const RESULT_ZERO: libc::c_uint = 16384;
pub const RESULT_POSITIVE: libc::c_uint = 0;
pub const EVENT_QUERY_STATE: libc::c_uint = 1;
pub const EVENT_MODIFY_STATE: libc::c_uint = 2;
pub const EVENT_ALL_ACCESS: libc::c_uint = 2031619;
pub const SEMAPHORE_QUERY_STATE: libc::c_uint = 1;
pub const SEMAPHORE_MODIFY_STATE: libc::c_uint = 2;
pub const SEMAPHORE_ALL_ACCESS: libc::c_uint = 2031619;
pub const LTP_PC_SMT: libc::c_uint = 1;
pub const CACHE_FULLY_ASSOCIATIVE: libc::c_uint = 255;
pub const SYSTEM_CPU_SET_INFORMATION_PARKED: libc::c_uint = 1;
pub const SYSTEM_CPU_SET_INFORMATION_ALLOCATED: libc::c_uint = 2;
pub const SYSTEM_CPU_SET_INFORMATION_ALLOCATED_TO_TARGET_PROCESS: libc::c_uint
          =
    4;
pub const PF_FLOATING_POINT_PRECISION_ERRATA: libc::c_uint = 0;
pub const PF_FLOATING_POINT_EMULATED: libc::c_uint = 1;
pub const PF_COMPARE_EXCHANGE_DOUBLE: libc::c_uint = 2;
pub const PF_MMX_INSTRUCTIONS_AVAILABLE: libc::c_uint = 3;
pub const PF_PPC_MOVEMEM_64BIT_OK: libc::c_uint = 4;
pub const PF_ALPHA_BYTE_INSTRUCTIONS: libc::c_uint = 5;
pub const PF_XMMI_INSTRUCTIONS_AVAILABLE: libc::c_uint = 6;
pub const PF_3DNOW_INSTRUCTIONS_AVAILABLE: libc::c_uint = 7;
pub const PF_RDTSC_INSTRUCTION_AVAILABLE: libc::c_uint = 8;
pub const PF_PAE_ENABLED: libc::c_uint = 9;
pub const PF_XMMI64_INSTRUCTIONS_AVAILABLE: libc::c_uint = 10;
pub const PF_SSE_DAZ_MODE_AVAILABLE: libc::c_uint = 11;
pub const PF_NX_ENABLED: libc::c_uint = 12;
pub const PF_SSE3_INSTRUCTIONS_AVAILABLE: libc::c_uint = 13;
pub const PF_COMPARE_EXCHANGE128: libc::c_uint = 14;
pub const PF_COMPARE64_EXCHANGE128: libc::c_uint = 15;
pub const PF_CHANNELS_ENABLED: libc::c_uint = 16;
pub const PF_XSAVE_ENABLED: libc::c_uint = 17;
pub const PF_ARM_VFP_32_REGISTERS_AVAILABLE: libc::c_uint = 18;
pub const PF_ARM_NEON_INSTRUCTIONS_AVAILABLE: libc::c_uint = 19;
pub const PF_SECOND_LEVEL_ADDRESS_TRANSLATION: libc::c_uint = 20;
pub const PF_VIRT_FIRMWARE_ENABLED: libc::c_uint = 21;
pub const PF_RDWRFSGSBASE_AVAILABLE: libc::c_uint = 22;
pub const PF_FASTFAIL_AVAILABLE: libc::c_uint = 23;
pub const PF_ARM_DIVIDE_INSTRUCTION_AVAILABLE: libc::c_uint = 24;
pub const PF_ARM_64BIT_LOADSTORE_ATOMIC: libc::c_uint = 25;
pub const PF_ARM_EXTERNAL_CACHE_AVAILABLE: libc::c_uint = 26;
pub const PF_ARM_FMAC_INSTRUCTIONS_AVAILABLE: libc::c_uint = 27;
pub const PF_RDRAND_INSTRUCTION_AVAILABLE: libc::c_uint = 28;
pub const PF_ARM_V8_INSTRUCTIONS_AVAILABLE: libc::c_uint = 29;
pub const PF_ARM_V8_CRYPTO_INSTRUCTIONS_AVAILABLE: libc::c_uint = 30;
pub const PF_ARM_V8_CRC32_INSTRUCTIONS_AVAILABLE: libc::c_uint = 31;
pub const PF_RDTSCP_INSTRUCTION_AVAILABLE: libc::c_uint = 32;
pub const PROCESSOR_FEATURE_MAX: libc::c_uint = 64;
pub const EXCEPTION_NONCONTINUABLE: libc::c_uint = 1;
pub const EXCEPTION_UNWINDING: libc::c_uint = 2;
pub const EXCEPTION_EXIT_UNWIND: libc::c_uint = 4;
pub const EXCEPTION_STACK_INVALID: libc::c_uint = 8;
pub const EXCEPTION_NESTED_CALL: libc::c_uint = 16;
pub const EXCEPTION_TARGET_UNWIND: libc::c_uint = 32;
pub const EXCEPTION_COLLIDED_UNWIND: libc::c_uint = 64;
pub const EXCEPTION_UNWIND: libc::c_uint = 102;
pub const EXCEPTION_MAXIMUM_PARAMETERS: libc::c_uint = 15;
pub const THREAD_WAIT_OBJECTS: libc::c_uint = 3;
pub const SINGLE_GROUP_LEGACY_API: libc::c_uint = 1;
pub const KB_SECONDARY_DATA_FLAG_ADDITIONAL_DATA: libc::c_uint = 1;
pub const KB_SECONDARY_DATA_FLAG_NO_DEVICE_ACCESS: libc::c_uint = 2;
pub const KB_ADD_PAGES_FLAG_VIRTUAL_ADDRESS: libc::c_uint = 1;
pub const KB_ADD_PAGES_FLAG_PHYSICAL_ADDRESS: libc::c_uint = 2;
pub const KB_ADD_PAGES_FLAG_ADDITIONAL_RANGES_EXIST: libc::c_uint =
    2147483648;
pub const KB_REMOVE_PAGES_FLAG_VIRTUAL_ADDRESS: libc::c_uint = 1;
pub const KB_REMOVE_PAGES_FLAG_PHYSICAL_ADDRESS: libc::c_uint = 2;
pub const KB_REMOVE_PAGES_FLAG_ADDITIONAL_RANGES_EXIST: libc::c_uint =
    2147483648;
pub const EXCEPTION_DIVIDED_BY_ZERO: libc::c_uint = 0;
pub const EXCEPTION_DEBUG: libc::c_uint = 1;
pub const EXCEPTION_NMI: libc::c_uint = 2;
pub const EXCEPTION_INT3: libc::c_uint = 3;
pub const EXCEPTION_BOUND_CHECK: libc::c_uint = 5;
pub const EXCEPTION_INVALID_OPCODE: libc::c_uint = 6;
pub const EXCEPTION_NPX_NOT_AVAILABLE: libc::c_uint = 7;
pub const EXCEPTION_DOUBLE_FAULT: libc::c_uint = 8;
pub const EXCEPTION_NPX_OVERRUN: libc::c_uint = 9;
pub const EXCEPTION_INVALID_TSS: libc::c_uint = 10;
pub const EXCEPTION_SEGMENT_NOT_PRESENT: libc::c_uint = 11;
pub const EXCEPTION_STACK_FAULT: libc::c_uint = 12;
pub const EXCEPTION_GP_FAULT: libc::c_uint = 13;
pub const EXCEPTION_RESERVED_TRAP: libc::c_uint = 15;
pub const EXCEPTION_NPX_ERROR: libc::c_uint = 16;
pub const EXCEPTION_ALIGNMENT_CHECK: libc::c_uint = 17;
pub const KE_PROCESSOR_CHANGE_ADD_EXISTING: libc::c_uint = 1;
pub const POOL_COLD_ALLOCATION: libc::c_uint = 256;
pub const POOL_NX_ALLOCATION: libc::c_uint = 512;
pub const POOL_QUOTA_FAIL_INSTEAD_OF_RAISE: libc::c_uint = 8;
pub const POOL_RAISE_IF_ALLOCATION_FAILURE: libc::c_uint = 16;
pub const FM_LOCK_BIT: libc::c_uint = 1;
pub const FM_LOCK_BIT_V: libc::c_uint = 0;
pub const EX_LOOKASIDE_LIST_EX_FLAGS_RAISE_ON_FAIL: libc::c_uint = 1;
pub const EX_LOOKASIDE_LIST_EX_FLAGS_FAIL_NO_RAISE: libc::c_uint = 2;
pub const EX_MAXIMUM_LOOKASIDE_DEPTH_BASE: libc::c_uint = 256;
pub const EX_MAXIMUM_LOOKASIDE_DEPTH_LIMIT: libc::c_uint = 1024;
pub const ResourceNeverExclusive: libc::c_uint = 16;
pub const ResourceReleaseByOtherThread: libc::c_uint = 32;
pub const ResourceOwnedExclusive: libc::c_uint = 128;
pub const RESOURCE_HASH_TABLE_SIZE: libc::c_uint = 64;
pub const FLAG_OWNER_POINTER_IS_THREAD: libc::c_uint = 1;
pub const EX_RUNDOWN_ACTIVE: libc::c_uint = 1;
pub const EX_RUNDOWN_COUNT_SHIFT: libc::c_uint = 1;
pub const EX_RUNDOWN_COUNT_INC: libc::c_uint = 2;
pub const EX_TIMER_HIGH_RESOLUTION: libc::c_uint = 4;
pub const EX_TIMER_NO_WAKE: libc::c_uint = 8;
pub const EX_CARR_ALLOCATE_PAGED_POOL: libc::c_uint = 0;
pub const EX_CARR_ALLOCATE_NONPAGED_POOL: libc::c_uint = 1;
pub const EX_CARR_DISABLE_EXPANSION: libc::c_uint = 2;
pub const EVENT_INCREMENT: libc::c_uint = 1;
pub const IO_NO_INCREMENT: libc::c_uint = 0;
pub const IO_CD_ROM_INCREMENT: libc::c_uint = 1;
pub const IO_DISK_INCREMENT: libc::c_uint = 1;
pub const IO_KEYBOARD_INCREMENT: libc::c_uint = 6;
pub const IO_MAILSLOT_INCREMENT: libc::c_uint = 2;
pub const IO_MOUSE_INCREMENT: libc::c_uint = 6;
pub const IO_NAMED_PIPE_INCREMENT: libc::c_uint = 2;
pub const IO_NETWORK_INCREMENT: libc::c_uint = 2;
pub const IO_PARALLEL_INCREMENT: libc::c_uint = 1;
pub const IO_SERIAL_INCREMENT: libc::c_uint = 2;
pub const IO_SOUND_INCREMENT: libc::c_uint = 8;
pub const IO_VIDEO_INCREMENT: libc::c_uint = 1;
pub const SEMAPHORE_INCREMENT: libc::c_uint = 1;
pub const MM_MAXIMUM_DISK_IO_SIZE: libc::c_uint = 65536;
pub const MdlMappingNoWrite: libc::c_uint = 2147483648;
pub const MdlMappingNoExecute: libc::c_uint = 1073741824;
pub const MM_DONT_ZERO_ALLOCATION: libc::c_uint = 1;
pub const MM_ALLOCATE_FROM_LOCAL_NODE_ONLY: libc::c_uint = 2;
pub const MM_ALLOCATE_FULLY_REQUIRED: libc::c_uint = 4;
pub const MM_ALLOCATE_NO_WAIT: libc::c_uint = 8;
pub const MM_ALLOCATE_PREFER_CONTIGUOUS: libc::c_uint = 16;
pub const MM_ALLOCATE_REQUIRE_CONTIGUOUS_CHUNKS: libc::c_uint = 32;
pub const MM_ALLOCATE_FAST_LARGE_PAGES: libc::c_uint = 64;
pub const MM_ALLOCATE_TRIM_IF_NECESSARY: libc::c_uint = 128;
pub const MM_ALLOCATE_AND_HOT_REMOVE: libc::c_uint = 256;
pub const MM_ANY_NODE_OK: libc::c_uint = 2147483648;
pub const INITIAL_PRIVILEGE_COUNT: libc::c_uint = 3;
pub const IO_TYPE_ADAPTER: libc::c_uint = 1;
pub const IO_TYPE_CONTROLLER: libc::c_uint = 2;
pub const IO_TYPE_DEVICE: libc::c_uint = 3;
pub const IO_TYPE_DRIVER: libc::c_uint = 4;
pub const IO_TYPE_FILE: libc::c_uint = 5;
pub const IO_TYPE_IRP: libc::c_uint = 6;
pub const IO_TYPE_MASTER_ADAPTER: libc::c_uint = 7;
pub const IO_TYPE_OPEN_PACKET: libc::c_uint = 8;
pub const IO_TYPE_TIMER: libc::c_uint = 9;
pub const IO_TYPE_VPB: libc::c_uint = 10;
pub const IO_TYPE_ERROR_LOG: libc::c_uint = 11;
pub const IO_TYPE_ERROR_MESSAGE: libc::c_uint = 12;
pub const IO_TYPE_DEVICE_OBJECT_EXTENSION: libc::c_uint = 13;
pub const IRP_MJ_CREATE: libc::c_uint = 0;
pub const IRP_MJ_CREATE_NAMED_PIPE: libc::c_uint = 1;
pub const IRP_MJ_CLOSE: libc::c_uint = 2;
pub const IRP_MJ_READ: libc::c_uint = 3;
pub const IRP_MJ_WRITE: libc::c_uint = 4;
pub const IRP_MJ_QUERY_INFORMATION: libc::c_uint = 5;
pub const IRP_MJ_SET_INFORMATION: libc::c_uint = 6;
pub const IRP_MJ_QUERY_EA: libc::c_uint = 7;
pub const IRP_MJ_SET_EA: libc::c_uint = 8;
pub const IRP_MJ_FLUSH_BUFFERS: libc::c_uint = 9;
pub const IRP_MJ_QUERY_VOLUME_INFORMATION: libc::c_uint = 10;
pub const IRP_MJ_SET_VOLUME_INFORMATION: libc::c_uint = 11;
pub const IRP_MJ_DIRECTORY_CONTROL: libc::c_uint = 12;
pub const IRP_MJ_FILE_SYSTEM_CONTROL: libc::c_uint = 13;
pub const IRP_MJ_DEVICE_CONTROL: libc::c_uint = 14;
pub const IRP_MJ_INTERNAL_DEVICE_CONTROL: libc::c_uint = 15;
pub const IRP_MJ_SHUTDOWN: libc::c_uint = 16;
pub const IRP_MJ_LOCK_CONTROL: libc::c_uint = 17;
pub const IRP_MJ_CLEANUP: libc::c_uint = 18;
pub const IRP_MJ_CREATE_MAILSLOT: libc::c_uint = 19;
pub const IRP_MJ_QUERY_SECURITY: libc::c_uint = 20;
pub const IRP_MJ_SET_SECURITY: libc::c_uint = 21;
pub const IRP_MJ_POWER: libc::c_uint = 22;
pub const IRP_MJ_SYSTEM_CONTROL: libc::c_uint = 23;
pub const IRP_MJ_DEVICE_CHANGE: libc::c_uint = 24;
pub const IRP_MJ_QUERY_QUOTA: libc::c_uint = 25;
pub const IRP_MJ_SET_QUOTA: libc::c_uint = 26;
pub const IRP_MJ_PNP: libc::c_uint = 27;
pub const IRP_MJ_PNP_POWER: libc::c_uint = 27;
pub const IRP_MJ_MAXIMUM_FUNCTION: libc::c_uint = 27;
pub const IRP_MJ_SCSI: libc::c_uint = 15;
pub const IRP_MN_SCSI_CLASS: libc::c_uint = 1;
pub const IRP_MN_START_DEVICE: libc::c_uint = 0;
pub const IRP_MN_QUERY_REMOVE_DEVICE: libc::c_uint = 1;
pub const IRP_MN_REMOVE_DEVICE: libc::c_uint = 2;
pub const IRP_MN_CANCEL_REMOVE_DEVICE: libc::c_uint = 3;
pub const IRP_MN_STOP_DEVICE: libc::c_uint = 4;
pub const IRP_MN_QUERY_STOP_DEVICE: libc::c_uint = 5;
pub const IRP_MN_CANCEL_STOP_DEVICE: libc::c_uint = 6;
pub const IRP_MN_QUERY_DEVICE_RELATIONS: libc::c_uint = 7;
pub const IRP_MN_QUERY_INTERFACE: libc::c_uint = 8;
pub const IRP_MN_QUERY_CAPABILITIES: libc::c_uint = 9;
pub const IRP_MN_QUERY_RESOURCES: libc::c_uint = 10;
pub const IRP_MN_QUERY_RESOURCE_REQUIREMENTS: libc::c_uint = 11;
pub const IRP_MN_QUERY_DEVICE_TEXT: libc::c_uint = 12;
pub const IRP_MN_FILTER_RESOURCE_REQUIREMENTS: libc::c_uint = 13;
pub const IRP_MN_READ_CONFIG: libc::c_uint = 15;
pub const IRP_MN_WRITE_CONFIG: libc::c_uint = 16;
pub const IRP_MN_EJECT: libc::c_uint = 17;
pub const IRP_MN_SET_LOCK: libc::c_uint = 18;
pub const IRP_MN_QUERY_ID: libc::c_uint = 19;
pub const IRP_MN_QUERY_PNP_DEVICE_STATE: libc::c_uint = 20;
pub const IRP_MN_QUERY_BUS_INFORMATION: libc::c_uint = 21;
pub const IRP_MN_DEVICE_USAGE_NOTIFICATION: libc::c_uint = 22;
pub const IRP_MN_SURPRISE_REMOVAL: libc::c_uint = 23;
pub const IRP_MN_DEVICE_ENUMERATED: libc::c_uint = 25;
pub const IRP_MN_WAIT_WAKE: libc::c_uint = 0;
pub const IRP_MN_POWER_SEQUENCE: libc::c_uint = 1;
pub const IRP_MN_SET_POWER: libc::c_uint = 2;
pub const IRP_MN_QUERY_POWER: libc::c_uint = 3;
pub const IRP_MN_QUERY_ALL_DATA: libc::c_uint = 0;
pub const IRP_MN_QUERY_SINGLE_INSTANCE: libc::c_uint = 1;
pub const IRP_MN_CHANGE_SINGLE_INSTANCE: libc::c_uint = 2;
pub const IRP_MN_CHANGE_SINGLE_ITEM: libc::c_uint = 3;
pub const IRP_MN_ENABLE_EVENTS: libc::c_uint = 4;
pub const IRP_MN_DISABLE_EVENTS: libc::c_uint = 5;
pub const IRP_MN_ENABLE_COLLECTION: libc::c_uint = 6;
pub const IRP_MN_DISABLE_COLLECTION: libc::c_uint = 7;
pub const IRP_MN_REGINFO: libc::c_uint = 8;
pub const IRP_MN_EXECUTE_METHOD: libc::c_uint = 9;
pub const IRP_MN_REGINFO_EX: libc::c_uint = 11;
pub const IO_FORCE_ACCESS_CHECK: libc::c_uint = 1;
pub const IO_NO_PARAMETER_CHECKING: libc::c_uint = 256;
pub const IO_REPARSE: libc::c_uint = 0;
pub const IO_REMOUNT: libc::c_uint = 1;
pub const IO_REPARSE_GLOBAL: libc::c_uint = 2;
pub const VPB_MOUNTED: libc::c_uint = 1;
pub const VPB_LOCKED: libc::c_uint = 2;
pub const VPB_PERSISTENT: libc::c_uint = 4;
pub const VPB_REMOVE_PENDING: libc::c_uint = 8;
pub const VPB_RAW_MOUNT: libc::c_uint = 16;
pub const VPB_DIRECT_WRITES_ALLOWED: libc::c_uint = 32;
pub const DO_VERIFY_VOLUME: libc::c_uint = 2;
pub const DO_BUFFERED_IO: libc::c_uint = 4;
pub const DO_EXCLUSIVE: libc::c_uint = 8;
pub const DO_DIRECT_IO: libc::c_uint = 16;
pub const DO_MAP_IO_BUFFER: libc::c_uint = 32;
pub const DO_DEVICE_INITIALIZING: libc::c_uint = 128;
pub const DO_SHUTDOWN_REGISTERED: libc::c_uint = 2048;
pub const DO_BUS_ENUMERATED_DEVICE: libc::c_uint = 4096;
pub const DO_POWER_PAGABLE: libc::c_uint = 8192;
pub const DO_POWER_INRUSH: libc::c_uint = 16384;
pub const DO_DEVICE_TO_BE_RESET: libc::c_uint = 67108864;
pub const DO_DAX_VOLUME: libc::c_uint = 268435456;
pub const DRVO_UNLOAD_INVOKED: libc::c_uint = 1;
pub const DRVO_LEGACY_DRIVER: libc::c_uint = 2;
pub const DRVO_BUILTIN_DRIVER: libc::c_uint = 4;
pub const FO_FILE_OPEN: libc::c_uint = 1;
pub const FO_SYNCHRONOUS_IO: libc::c_uint = 2;
pub const FO_ALERTABLE_IO: libc::c_uint = 4;
pub const FO_NO_INTERMEDIATE_BUFFERING: libc::c_uint = 8;
pub const FO_WRITE_THROUGH: libc::c_uint = 16;
pub const FO_SEQUENTIAL_ONLY: libc::c_uint = 32;
pub const FO_CACHE_SUPPORTED: libc::c_uint = 64;
pub const FO_NAMED_PIPE: libc::c_uint = 128;
pub const FO_STREAM_FILE: libc::c_uint = 256;
pub const FO_MAILSLOT: libc::c_uint = 512;
pub const FO_GENERATE_AUDIT_ON_CLOSE: libc::c_uint = 1024;
pub const FO_QUEUE_IRP_TO_THREAD: libc::c_uint = 1024;
pub const FO_DIRECT_DEVICE_OPEN: libc::c_uint = 2048;
pub const FO_FILE_MODIFIED: libc::c_uint = 4096;
pub const FO_FILE_SIZE_CHANGED: libc::c_uint = 8192;
pub const FO_CLEANUP_COMPLETE: libc::c_uint = 16384;
pub const FO_TEMPORARY_FILE: libc::c_uint = 32768;
pub const FO_DELETE_ON_CLOSE: libc::c_uint = 65536;
pub const FO_OPENED_CASE_SENSITIVE: libc::c_uint = 131072;
pub const FO_HANDLE_CREATED: libc::c_uint = 262144;
pub const FO_FILE_FAST_IO_READ: libc::c_uint = 524288;
pub const FO_RANDOM_ACCESS: libc::c_uint = 1048576;
pub const FO_FILE_OPEN_CANCELLED: libc::c_uint = 2097152;
pub const FO_VOLUME_OPEN: libc::c_uint = 4194304;
pub const FO_REMOTE_ORIGIN: libc::c_uint = 16777216;
pub const FO_DISALLOW_EXCLUSIVE: libc::c_uint = 33554432;
pub const FO_SKIP_COMPLETION_PORT: libc::c_uint = 33554432;
pub const FO_SKIP_SET_EVENT: libc::c_uint = 67108864;
pub const FO_SKIP_SET_FAST_IO: libc::c_uint = 134217728;
pub const FO_INDIRECT_WAIT_OBJECT: libc::c_uint = 268435456;
pub const FO_SECTION_MINSTORE_TREATMENT: libc::c_uint = 536870912;
pub const FO_FLAGS_VALID_ONLY_DURING_CREATE: libc::c_uint = 33554432;
pub const IRP_NOCACHE: libc::c_uint = 1;
pub const IRP_PAGING_IO: libc::c_uint = 2;
pub const IRP_MOUNT_COMPLETION: libc::c_uint = 2;
pub const IRP_SYNCHRONOUS_API: libc::c_uint = 4;
pub const IRP_ASSOCIATED_IRP: libc::c_uint = 8;
pub const IRP_BUFFERED_IO: libc::c_uint = 16;
pub const IRP_DEALLOCATE_BUFFER: libc::c_uint = 32;
pub const IRP_INPUT_OPERATION: libc::c_uint = 64;
pub const IRP_SYNCHRONOUS_PAGING_IO: libc::c_uint = 64;
pub const IRP_CREATE_OPERATION: libc::c_uint = 128;
pub const IRP_READ_OPERATION: libc::c_uint = 256;
pub const IRP_WRITE_OPERATION: libc::c_uint = 512;
pub const IRP_CLOSE_OPERATION: libc::c_uint = 1024;
pub const IRP_DEFER_IO_COMPLETION: libc::c_uint = 2048;
pub const IRP_OB_QUERY_NAME: libc::c_uint = 4096;
pub const IRP_HOLD_DEVICE_QUEUE: libc::c_uint = 8192;
pub const IRP_UM_DRIVER_INITIATED_IO: libc::c_uint = 4194304;
pub const IRP_QUOTA_CHARGED: libc::c_uint = 1;
pub const IRP_ALLOCATED_MUST_SUCCEED: libc::c_uint = 2;
pub const IRP_ALLOCATED_FIXED_SIZE: libc::c_uint = 4;
pub const IRP_LOOKASIDE_ALLOCATION: libc::c_uint = 8;
pub const SL_PENDING_RETURNED: libc::c_uint = 1;
pub const SL_ERROR_RETURNED: libc::c_uint = 2;
pub const SL_INVOKE_ON_CANCEL: libc::c_uint = 32;
pub const SL_INVOKE_ON_SUCCESS: libc::c_uint = 64;
pub const SL_INVOKE_ON_ERROR: libc::c_uint = 128;
pub const SL_FORCE_ACCESS_CHECK: libc::c_uint = 1;
pub const SL_OPEN_PAGING_FILE: libc::c_uint = 2;
pub const SL_OPEN_TARGET_DIRECTORY: libc::c_uint = 4;
pub const SL_STOP_ON_SYMLINK: libc::c_uint = 8;
pub const SL_CASE_SENSITIVE: libc::c_uint = 128;
pub const SL_KEY_SPECIFIED: libc::c_uint = 1;
pub const SL_OVERRIDE_VERIFY_VOLUME: libc::c_uint = 2;
pub const SL_WRITE_THROUGH: libc::c_uint = 4;
pub const SL_FT_SEQUENTIAL_WRITE: libc::c_uint = 8;
pub const SL_FORCE_DIRECT_WRITE: libc::c_uint = 16;
pub const SL_REALTIME_STREAM: libc::c_uint = 32;
pub const SL_PERSISTENT_MEMORY_FIXED_MAPPING: libc::c_uint = 32;
pub const SL_FORCE_ASYNCHRONOUS: libc::c_uint = 1;
pub const SL_READ_ACCESS_GRANTED: libc::c_uint = 1;
pub const SL_WRITE_ACCESS_GRANTED: libc::c_uint = 4;
pub const SL_FAIL_IMMEDIATELY: libc::c_uint = 1;
pub const SL_EXCLUSIVE_LOCK: libc::c_uint = 2;
pub const SL_RESTART_SCAN: libc::c_uint = 1;
pub const SL_RETURN_SINGLE_ENTRY: libc::c_uint = 2;
pub const SL_INDEX_SPECIFIED: libc::c_uint = 4;
pub const SL_WATCH_TREE: libc::c_uint = 1;
pub const SL_ALLOW_RAW_MOUNT: libc::c_uint = 1;
pub const SL_BYPASS_ACCESS_CHECK: libc::c_uint = 1;
pub const PNP_DEVICE_DISABLED: libc::c_uint = 1;
pub const PNP_DEVICE_DONT_DISPLAY_IN_UI: libc::c_uint = 2;
pub const PNP_DEVICE_FAILED: libc::c_uint = 4;
pub const PNP_DEVICE_REMOVED: libc::c_uint = 8;
pub const PNP_DEVICE_RESOURCE_REQUIREMENTS_CHANGED: libc::c_uint = 16;
pub const PNP_DEVICE_NOT_DISABLEABLE: libc::c_uint = 32;
pub const PNP_DEVICE_DISCONNECTED: libc::c_uint = 64;
pub const CONNECT_FULLY_SPECIFIED: libc::c_uint = 1;
pub const CONNECT_LINE_BASED: libc::c_uint = 2;
pub const CONNECT_MESSAGE_BASED: libc::c_uint = 3;
pub const CONNECT_FULLY_SPECIFIED_GROUP: libc::c_uint = 4;
pub const CONNECT_MESSAGE_BASED_PASSIVE: libc::c_uint = 5;
pub const CONNECT_CURRENT_VERSION: libc::c_uint = 5;
pub const WDM_MAJORVERSION: libc::c_uint = 6;
pub const WDM_MINORVERSION: libc::c_uint = 0;
pub const WMIREG_ACTION_REGISTER: libc::c_uint = 1;
pub const WMIREG_ACTION_DEREGISTER: libc::c_uint = 2;
pub const WMIREG_ACTION_REREGISTER: libc::c_uint = 3;
pub const WMIREG_ACTION_UPDATE_GUIDS: libc::c_uint = 4;
pub const WMIREG_ACTION_BLOCK_IRPS: libc::c_uint = 5;
pub const WMIREGISTER: libc::c_uint = 0;
pub const WMIUPDATE: libc::c_uint = 1;
pub const IO_TYPE_CSQ_IRP_CONTEXT: libc::c_uint = 1;
pub const IO_TYPE_CSQ: libc::c_uint = 2;
pub const IO_TYPE_CSQ_EX: libc::c_uint = 3;
pub const EVENT_MIN_LEVEL: libc::c_uint = 0;
pub const EVENT_MAX_LEVEL: libc::c_uint = 255;
pub const EVENT_ACTIVITY_CTRL_GET_ID: libc::c_uint = 1;
pub const EVENT_ACTIVITY_CTRL_SET_ID: libc::c_uint = 2;
pub const EVENT_ACTIVITY_CTRL_CREATE_ID: libc::c_uint = 3;
pub const EVENT_ACTIVITY_CTRL_GET_SET_ID: libc::c_uint = 4;
pub const EVENT_ACTIVITY_CTRL_CREATE_SET_ID: libc::c_uint = 5;
pub const MAX_EVENT_DATA_DESCRIPTORS: libc::c_uint = 128;
pub const MAX_EVENT_FILTER_DATA_SIZE: libc::c_uint = 1024;
pub const MAX_EVENT_FILTER_PAYLOAD_SIZE: libc::c_uint = 4096;
pub const MAX_EVENT_FILTER_EVENT_NAME_SIZE: libc::c_uint = 4096;
pub const MAX_EVENT_FILTERS_COUNT: libc::c_uint = 8;
pub const MAX_EVENT_FILTER_PID_COUNT: libc::c_uint = 8;
pub const MAX_EVENT_FILTER_EVENT_ID_COUNT: libc::c_uint = 64;
pub const EVENT_FILTER_TYPE_NONE: libc::c_uint = 0;
pub const EVENT_FILTER_TYPE_SCHEMATIZED: libc::c_uint = 2147483648;
pub const EVENT_FILTER_TYPE_SYSTEM_FLAGS: libc::c_uint = 2147483649;
pub const EVENT_FILTER_TYPE_TRACEHANDLE: libc::c_uint = 2147483650;
pub const EVENT_FILTER_TYPE_PID: libc::c_uint = 2147483652;
pub const EVENT_FILTER_TYPE_EXECUTABLE_NAME: libc::c_uint = 2147483656;
pub const EVENT_FILTER_TYPE_PACKAGE_ID: libc::c_uint = 2147483664;
pub const EVENT_FILTER_TYPE_PACKAGE_APP_ID: libc::c_uint = 2147483680;
pub const EVENT_FILTER_TYPE_PAYLOAD: libc::c_uint = 2147483904;
pub const EVENT_FILTER_TYPE_EVENT_ID: libc::c_uint = 2147484160;
pub const EVENT_FILTER_TYPE_EVENT_NAME: libc::c_uint = 2147484672;
pub const EVENT_FILTER_TYPE_STACKWALK: libc::c_uint = 2147487744;
pub const EVENT_DATA_DESCRIPTOR_TYPE_NONE: libc::c_uint = 0;
pub const EVENT_DATA_DESCRIPTOR_TYPE_EVENT_METADATA: libc::c_uint = 1;
pub const EVENT_DATA_DESCRIPTOR_TYPE_PROVIDER_METADATA: libc::c_uint = 2;
pub const EVENT_DATA_DESCRIPTOR_TYPE_TIMESTAMP_OVERRIDE: libc::c_uint = 3;
pub const EVENT_WRITE_FLAG_NO_FAULTING: libc::c_uint = 1;
pub const EVENT_WRITE_FLAG_INPRIVATE: libc::c_uint = 2;
pub const __string_type: libc::c_uint = 0;
pub const __guid_type: libc::c_uint = 0;
pub const __multiString_type: libc::c_uint = 0;
pub const PCI_SECURITY_INTERFACE_VERSION: libc::c_uint = 1;
pub const D3COLD_SUPPORT_INTERFACE_VERSION: libc::c_uint = 1;
pub const PLUGPLAY_REGKEY_DEVICE: libc::c_uint = 1;
pub const PLUGPLAY_REGKEY_DRIVER: libc::c_uint = 2;
pub const PLUGPLAY_REGKEY_CURRENT_HWPROFILE: libc::c_uint = 4;
pub const DEVICE_INTERFACE_INCLUDE_NONACTIVE: libc::c_uint = 1;
pub const PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES: libc::c_uint
          =
    1;
pub const DEVPROP_TYPEMOD_ARRAY: libc::c_uint = 4096;
pub const DEVPROP_TYPEMOD_LIST: libc::c_uint = 8192;
pub const DEVPROP_TYPE_EMPTY: libc::c_uint = 0;
pub const DEVPROP_TYPE_NULL: libc::c_uint = 1;
pub const DEVPROP_TYPE_SBYTE: libc::c_uint = 2;
pub const DEVPROP_TYPE_BYTE: libc::c_uint = 3;
pub const DEVPROP_TYPE_INT16: libc::c_uint = 4;
pub const DEVPROP_TYPE_UINT16: libc::c_uint = 5;
pub const DEVPROP_TYPE_INT32: libc::c_uint = 6;
pub const DEVPROP_TYPE_UINT32: libc::c_uint = 7;
pub const DEVPROP_TYPE_INT64: libc::c_uint = 8;
pub const DEVPROP_TYPE_UINT64: libc::c_uint = 9;
pub const DEVPROP_TYPE_FLOAT: libc::c_uint = 10;
pub const DEVPROP_TYPE_DOUBLE: libc::c_uint = 11;
pub const DEVPROP_TYPE_DECIMAL: libc::c_uint = 12;
pub const DEVPROP_TYPE_GUID: libc::c_uint = 13;
pub const DEVPROP_TYPE_CURRENCY: libc::c_uint = 14;
pub const DEVPROP_TYPE_DATE: libc::c_uint = 15;
pub const DEVPROP_TYPE_FILETIME: libc::c_uint = 16;
pub const DEVPROP_TYPE_BOOLEAN: libc::c_uint = 17;
pub const DEVPROP_TYPE_STRING: libc::c_uint = 18;
pub const DEVPROP_TYPE_STRING_LIST: libc::c_uint = 8210;
pub const DEVPROP_TYPE_SECURITY_DESCRIPTOR: libc::c_uint = 19;
pub const DEVPROP_TYPE_SECURITY_DESCRIPTOR_STRING: libc::c_uint = 20;
pub const DEVPROP_TYPE_DEVPROPKEY: libc::c_uint = 21;
pub const DEVPROP_TYPE_DEVPROPTYPE: libc::c_uint = 22;
pub const DEVPROP_TYPE_BINARY: libc::c_uint = 4099;
pub const DEVPROP_TYPE_ERROR: libc::c_uint = 23;
pub const DEVPROP_TYPE_NTSTATUS: libc::c_uint = 24;
pub const DEVPROP_TYPE_STRING_INDIRECT: libc::c_uint = 25;
pub const MAX_DEVPROP_TYPE: libc::c_uint = 25;
pub const MAX_DEVPROP_TYPEMOD: libc::c_uint = 8192;
pub const DEVPROP_MASK_TYPE: libc::c_uint = 4095;
pub const DEVPROP_MASK_TYPEMOD: libc::c_uint = 61440;
pub const DEVPROPID_FIRST_USABLE: libc::c_uint = 2;
pub const PLUGPLAY_PROPERTY_PERSISTENT: libc::c_uint = 1;
pub const PNP_REPLACE_NO_MAP: libc::c_ulonglong = 9223372036854775807;
pub const PNP_REPLACE_PARAMETERS_VERSION: libc::c_uint = 2;
pub const PNP_REPLACE_DRIVER_INTERFACE_VERSION: libc::c_uint = 1;
pub const PNP_REPLACE_MEMORY_SUPPORTED: libc::c_uint = 1;
pub const PNP_REPLACE_PROCESSOR_SUPPORTED: libc::c_uint = 2;
pub const PNP_REPLACE_HARDWARE_MEMORY_MIRRORING: libc::c_uint = 4;
pub const PNP_REPLACE_HARDWARE_PAGE_COPY: libc::c_uint = 8;
pub const PNP_REPLACE_HARDWARE_QUIESCE: libc::c_uint = 16;
pub const DEVICE_RESET_INTERFACE_VERSION: libc::c_uint = 1;
pub const DEVICE_RESET_IGNORE_OPEN_HANDLES: libc::c_uint = 1;
pub const DEVICE_DESCRIPTION_VERSION: libc::c_uint = 0;
pub const DEVICE_DESCRIPTION_VERSION1: libc::c_uint = 1;
pub const DEVICE_DESCRIPTION_VERSION2: libc::c_uint = 2;
pub const DEVICE_DESCRIPTION_VERSION3: libc::c_uint = 3;
pub const DMA_ADAPTER_INFO_VERSION1: libc::c_uint = 1;
pub const DMA_TRANSFER_INFO_VERSION1: libc::c_uint = 1;
pub const ADAPTER_INFO_SYNCHRONOUS_CALLBACK: libc::c_uint = 1;
pub const ADAPTER_INFO_API_BYPASS: libc::c_uint = 2;
pub const DMA_TRANSFER_CONTEXT_VERSION1: libc::c_uint = 1;
pub const DMA_TRANSFER_CONTEXT_SIZE_V1: libc::c_uint = 128;
pub const DMA_SYNCHRONOUS_CALLBACK: libc::c_uint = 1;
pub const HAL_MASK_UNMASK_FLAGS_NONE: libc::c_uint = 0;
pub const HAL_MASK_UNMASK_FLAGS_SERVICING_DEFERRED: libc::c_uint = 1;
pub const HAL_MASK_UNMASK_FLAGS_SERVICING_COMPLETE: libc::c_uint = 2;
pub const HAL_DMA_ADAPTER_VERSION_1: libc::c_uint = 1;
pub const DOMAIN_COMMON_BUFFER_LARGE_PAGE: libc::c_uint = 1;
pub const PO_MEM_PRESERVE: libc::c_uint = 1;
pub const PO_MEM_CLONE: libc::c_uint = 2;
pub const PO_MEM_CL_OR_NCHK: libc::c_uint = 4;
pub const PO_MEM_DISCARD: libc::c_uint = 32768;
pub const PO_MEM_PAGE_ADDRESS: libc::c_uint = 16384;
pub const PO_MEM_BOOT_PHASE: libc::c_uint = 65536;
pub const PO_CB_SYSTEM_POWER_POLICY: libc::c_uint = 0;
pub const PO_CB_AC_STATUS: libc::c_uint = 1;
pub const PO_CB_BUTTON_COLLISION: libc::c_uint = 2;
pub const PO_CB_SYSTEM_STATE_LOCK: libc::c_uint = 3;
pub const PO_CB_LID_SWITCH_STATE: libc::c_uint = 4;
pub const PO_CB_PROCESSOR_POWER_POLICY: libc::c_uint = 5;
pub const PO_FX_VERSION_V1: libc::c_uint = 1;
pub const PO_FX_VERSION_V2: libc::c_uint = 2;
pub const PO_FX_COMPONENT_FLAG_F0_ON_DX: libc::c_uint = 1;
pub const PO_FX_COMPONENT_FLAG_NO_DEBOUNCE: libc::c_uint = 2;
pub const PO_FX_UNKNOWN_POWER: libc::c_uint = 4294967295;
pub const PO_FX_UNKNOWN_TIME: libc::c_int = -1;
pub const PO_FX_FLAG_BLOCKING: libc::c_uint = 1;
pub const PO_FX_FLAG_ASYNC_ONLY: libc::c_uint = 2;
pub const PO_FX_FLAG_PERF_PEP_OPTIONAL: libc::c_uint = 1;
pub const PO_FX_FLAG_PERF_QUERY_ON_F0: libc::c_uint = 2;
pub const PO_FX_FLAG_PERF_QUERY_ON_ALL_IDLE_STATES: libc::c_uint = 4;
pub const OB_FLT_REGISTRATION_VERSION_0100: libc::c_uint = 256;
pub const OB_FLT_REGISTRATION_VERSION: libc::c_uint = 256;
pub const OB_OPERATION_HANDLE_CREATE: libc::c_uint = 1;
pub const OB_OPERATION_HANDLE_DUPLICATE: libc::c_uint = 2;
pub const PCI_TYPE0_ADDRESSES: libc::c_uint = 6;
pub const PCI_TYPE1_ADDRESSES: libc::c_uint = 2;
pub const PCI_TYPE2_ADDRESSES: libc::c_uint = 5;
pub const PCI_EXTENDED_CONFIG_LENGTH: libc::c_uint = 4096;
pub const PCI_MAX_DEVICES: libc::c_uint = 32;
pub const PCI_MAX_FUNCTION: libc::c_uint = 8;
pub const PCI_MAX_BRIDGE_NUMBER: libc::c_uint = 255;
pub const PCI_INVALID_VENDORID: libc::c_uint = 65535;
pub const PCI_MULTIFUNCTION: libc::c_uint = 128;
pub const PCI_DEVICE_TYPE: libc::c_uint = 0;
pub const PCI_BRIDGE_TYPE: libc::c_uint = 1;
pub const PCI_CARDBUS_BRIDGE_TYPE: libc::c_uint = 2;
pub const PCI_ENABLE_IO_SPACE: libc::c_uint = 1;
pub const PCI_ENABLE_MEMORY_SPACE: libc::c_uint = 2;
pub const PCI_ENABLE_BUS_MASTER: libc::c_uint = 4;
pub const PCI_ENABLE_SPECIAL_CYCLES: libc::c_uint = 8;
pub const PCI_ENABLE_WRITE_AND_INVALIDATE: libc::c_uint = 16;
pub const PCI_ENABLE_VGA_COMPATIBLE_PALETTE: libc::c_uint = 32;
pub const PCI_ENABLE_PARITY: libc::c_uint = 64;
pub const PCI_ENABLE_WAIT_CYCLE: libc::c_uint = 128;
pub const PCI_ENABLE_SERR: libc::c_uint = 256;
pub const PCI_ENABLE_FAST_BACK_TO_BACK: libc::c_uint = 512;
pub const PCI_DISABLE_LEVEL_INTERRUPT: libc::c_uint = 1024;
pub const PCI_STATUS_INTERRUPT_PENDING: libc::c_uint = 8;
pub const PCI_STATUS_CAPABILITIES_LIST: libc::c_uint = 16;
pub const PCI_STATUS_66MHZ_CAPABLE: libc::c_uint = 32;
pub const PCI_STATUS_UDF_SUPPORTED: libc::c_uint = 64;
pub const PCI_STATUS_FAST_BACK_TO_BACK: libc::c_uint = 128;
pub const PCI_STATUS_DATA_PARITY_DETECTED: libc::c_uint = 256;
pub const PCI_STATUS_DEVSEL: libc::c_uint = 1536;
pub const PCI_STATUS_SIGNALED_TARGET_ABORT: libc::c_uint = 2048;
pub const PCI_STATUS_RECEIVED_TARGET_ABORT: libc::c_uint = 4096;
pub const PCI_STATUS_RECEIVED_MASTER_ABORT: libc::c_uint = 8192;
pub const PCI_STATUS_SIGNALED_SYSTEM_ERROR: libc::c_uint = 16384;
pub const PCI_STATUS_DETECTED_PARITY_ERROR: libc::c_uint = 32768;
pub const PCI_WHICHSPACE_CONFIG: libc::c_uint = 0;
pub const PCI_WHICHSPACE_ROM: libc::c_uint = 1382638416;
pub const PCI_CAPABILITY_ID_POWER_MANAGEMENT: libc::c_uint = 1;
pub const PCI_CAPABILITY_ID_AGP: libc::c_uint = 2;
pub const PCI_CAPABILITY_ID_VPD: libc::c_uint = 3;
pub const PCI_CAPABILITY_ID_SLOT_ID: libc::c_uint = 4;
pub const PCI_CAPABILITY_ID_MSI: libc::c_uint = 5;
pub const PCI_CAPABILITY_ID_CPCI_HOTSWAP: libc::c_uint = 6;
pub const PCI_CAPABILITY_ID_PCIX: libc::c_uint = 7;
pub const PCI_CAPABILITY_ID_HYPERTRANSPORT: libc::c_uint = 8;
pub const PCI_CAPABILITY_ID_VENDOR_SPECIFIC: libc::c_uint = 9;
pub const PCI_CAPABILITY_ID_DEBUG_PORT: libc::c_uint = 10;
pub const PCI_CAPABILITY_ID_CPCI_RES_CTRL: libc::c_uint = 11;
pub const PCI_CAPABILITY_ID_SHPC: libc::c_uint = 12;
pub const PCI_CAPABILITY_ID_P2P_SSID: libc::c_uint = 13;
pub const PCI_CAPABILITY_ID_AGP_TARGET: libc::c_uint = 14;
pub const PCI_CAPABILITY_ID_SECURE: libc::c_uint = 15;
pub const PCI_CAPABILITY_ID_PCI_EXPRESS: libc::c_uint = 16;
pub const PCI_CAPABILITY_ID_MSIX: libc::c_uint = 17;
pub const PCI_CAPABILITY_ID_SATA_CONFIG: libc::c_uint = 18;
pub const PCI_CAPABILITY_ID_ADVANCED_FEATURES: libc::c_uint = 19;
pub const PCI_EXPRESS_ADVANCED_ERROR_REPORTING_CAP_ID: libc::c_uint = 1;
pub const PCI_EXPRESS_VIRTUAL_CHANNEL_CAP_ID: libc::c_uint = 2;
pub const PCI_EXPRESS_DEVICE_SERIAL_NUMBER_CAP_ID: libc::c_uint = 3;
pub const PCI_EXPRESS_POWER_BUDGETING_CAP_ID: libc::c_uint = 4;
pub const PCI_EXPRESS_RC_LINK_DECLARATION_CAP_ID: libc::c_uint = 5;
pub const PCI_EXPRESS_RC_INTERNAL_LINK_CONTROL_CAP_ID: libc::c_uint = 6;
pub const PCI_EXPRESS_RC_EVENT_COLLECTOR_ENDPOINT_ASSOCIATION_CAP_ID:
          libc::c_uint =
    7;
pub const PCI_EXPRESS_MFVC_CAP_ID: libc::c_uint = 8;
pub const PCI_EXPRESS_VC_AND_MFVC_CAP_ID: libc::c_uint = 9;
pub const PCI_EXPRESS_RCRB_HEADER_CAP_ID: libc::c_uint = 10;
pub const PCI_EXPRESS_VENDOR_SPECIFIC_CAP_ID: libc::c_uint = 11;
pub const PCI_EXPRESS_CONFIGURATION_ACCESS_CORRELATION_CAP_ID: libc::c_uint =
    12;
pub const PCI_EXPRESS_ACCESS_CONTROL_SERVICES_CAP_ID: libc::c_uint = 13;
pub const PCI_EXPRESS_ARI_CAP_ID: libc::c_uint = 14;
pub const PCI_EXPRESS_ATS_CAP_ID: libc::c_uint = 15;
pub const PCI_EXPRESS_SINGLE_ROOT_IO_VIRTUALIZATION_CAP_ID: libc::c_uint = 16;
pub const PCI_EXPRESS_MULTI_ROOT_IO_VIRTUALIZATION_CAP_ID: libc::c_uint = 17;
pub const PCI_EXPRESS_MULTICAST_CAP_ID: libc::c_uint = 18;
pub const PCI_EXPRESS_PAGE_REQUEST_CAP_ID: libc::c_uint = 19;
pub const PCI_EXPRESS_RESERVED_FOR_AMD_CAP_ID: libc::c_uint = 20;
pub const PCI_EXPRESS_RESIZABLE_BAR_CAP_ID: libc::c_uint = 21;
pub const PCI_EXPRESS_DPA_CAP_ID: libc::c_uint = 22;
pub const PCI_EXPRESS_TPH_REQUESTER_CAP_ID: libc::c_uint = 23;
pub const PCI_EXPRESS_LTR_CAP_ID: libc::c_uint = 24;
pub const PCI_EXPRESS_SECONDARY_PCI_EXPRESS_CAP_ID: libc::c_uint = 25;
pub const PCI_EXPRESS_PMUX_CAP_ID: libc::c_uint = 26;
pub const PCI_EXPRESS_PASID_CAP_ID: libc::c_uint = 27;
pub const PCI_EXPRESS_LN_REQUESTER_CAP_ID: libc::c_uint = 28;
pub const PCI_EXPRESS_DPC_CAP_ID: libc::c_uint = 29;
pub const PCI_EXPRESS_L1_PM_SS_CAP_ID: libc::c_uint = 30;
pub const PCI_EXPRESS_PTM_CAP_ID: libc::c_uint = 31;
pub const PCI_EXPRESS_MPCIE_CAP_ID: libc::c_uint = 32;
pub const PCI_EXPRESS_FRS_QUEUEING_CAP_ID: libc::c_uint = 33;
pub const PCI_EXPRESS_READINESS_TIME_REPORTING_CAP_ID: libc::c_uint = 34;
pub const ROOT_CMD_ENABLE_CORRECTABLE_ERROR_REPORTING: libc::c_uint = 1;
pub const ROOT_CMD_ENABLE_NONFATAL_ERROR_REPORTING: libc::c_uint = 2;
pub const ROOT_CMD_ENABLE_FATAL_ERROR_REPORTING: libc::c_uint = 4;
pub const ROOT_CMD_ERROR_REPORTING_ENABLE_MASK: libc::c_uint = 7;
pub const PCI_CLASS_PRE_20: libc::c_uint = 0;
pub const PCI_CLASS_MASS_STORAGE_CTLR: libc::c_uint = 1;
pub const PCI_CLASS_NETWORK_CTLR: libc::c_uint = 2;
pub const PCI_CLASS_DISPLAY_CTLR: libc::c_uint = 3;
pub const PCI_CLASS_MULTIMEDIA_DEV: libc::c_uint = 4;
pub const PCI_CLASS_MEMORY_CTLR: libc::c_uint = 5;
pub const PCI_CLASS_BRIDGE_DEV: libc::c_uint = 6;
pub const PCI_CLASS_SIMPLE_COMMS_CTLR: libc::c_uint = 7;
pub const PCI_CLASS_BASE_SYSTEM_DEV: libc::c_uint = 8;
pub const PCI_CLASS_INPUT_DEV: libc::c_uint = 9;
pub const PCI_CLASS_DOCKING_STATION: libc::c_uint = 10;
pub const PCI_CLASS_PROCESSOR: libc::c_uint = 11;
pub const PCI_CLASS_SERIAL_BUS_CTLR: libc::c_uint = 12;
pub const PCI_CLASS_WIRELESS_CTLR: libc::c_uint = 13;
pub const PCI_CLASS_INTELLIGENT_IO_CTLR: libc::c_uint = 14;
pub const PCI_CLASS_SATELLITE_COMMS_CTLR: libc::c_uint = 15;
pub const PCI_CLASS_ENCRYPTION_DECRYPTION: libc::c_uint = 16;
pub const PCI_CLASS_DATA_ACQ_SIGNAL_PROC: libc::c_uint = 17;
pub const PCI_CLASS_NOT_DEFINED: libc::c_uint = 255;
pub const PCI_SUBCLASS_PRE_20_NON_VGA: libc::c_uint = 0;
pub const PCI_SUBCLASS_PRE_20_VGA: libc::c_uint = 1;
pub const PCI_SUBCLASS_MSC_SCSI_BUS_CTLR: libc::c_uint = 0;
pub const PCI_SUBCLASS_MSC_IDE_CTLR: libc::c_uint = 1;
pub const PCI_SUBCLASS_MSC_FLOPPY_CTLR: libc::c_uint = 2;
pub const PCI_SUBCLASS_MSC_IPI_CTLR: libc::c_uint = 3;
pub const PCI_SUBCLASS_MSC_RAID_CTLR: libc::c_uint = 4;
pub const PCI_SUBCLASS_MSC_AHCI_CTLR: libc::c_uint = 6;
pub const PCI_SUBCLASS_MSC_NVM_CTLR: libc::c_uint = 8;
pub const PCI_SUBCLASS_MSC_OTHER: libc::c_uint = 128;
pub const PCI_PROGRAMMING_INTERFACE_MSC_NVM_EXPRESS: libc::c_uint = 2;
pub const PCI_SUBCLASS_NET_ETHERNET_CTLR: libc::c_uint = 0;
pub const PCI_SUBCLASS_NET_TOKEN_RING_CTLR: libc::c_uint = 1;
pub const PCI_SUBCLASS_NET_FDDI_CTLR: libc::c_uint = 2;
pub const PCI_SUBCLASS_NET_ATM_CTLR: libc::c_uint = 3;
pub const PCI_SUBCLASS_NET_ISDN_CTLR: libc::c_uint = 4;
pub const PCI_SUBCLASS_NET_OTHER: libc::c_uint = 128;
pub const PCI_SUBCLASS_VID_VGA_CTLR: libc::c_uint = 0;
pub const PCI_SUBCLASS_VID_XGA_CTLR: libc::c_uint = 1;
pub const PCI_SUBLCASS_VID_3D_CTLR: libc::c_uint = 2;
pub const PCI_SUBCLASS_VID_OTHER: libc::c_uint = 128;
pub const PCI_SUBCLASS_MM_VIDEO_DEV: libc::c_uint = 0;
pub const PCI_SUBCLASS_MM_AUDIO_DEV: libc::c_uint = 1;
pub const PCI_SUBCLASS_MM_TELEPHONY_DEV: libc::c_uint = 2;
pub const PCI_SUBCLASS_MM_OTHER: libc::c_uint = 128;
pub const PCI_SUBCLASS_MEM_RAM: libc::c_uint = 0;
pub const PCI_SUBCLASS_MEM_FLASH: libc::c_uint = 1;
pub const PCI_SUBCLASS_MEM_OTHER: libc::c_uint = 128;
pub const PCI_SUBCLASS_BR_HOST: libc::c_uint = 0;
pub const PCI_SUBCLASS_BR_ISA: libc::c_uint = 1;
pub const PCI_SUBCLASS_BR_EISA: libc::c_uint = 2;
pub const PCI_SUBCLASS_BR_MCA: libc::c_uint = 3;
pub const PCI_SUBCLASS_BR_PCI_TO_PCI: libc::c_uint = 4;
pub const PCI_SUBCLASS_BR_PCMCIA: libc::c_uint = 5;
pub const PCI_SUBCLASS_BR_NUBUS: libc::c_uint = 6;
pub const PCI_SUBCLASS_BR_CARDBUS: libc::c_uint = 7;
pub const PCI_SUBCLASS_BR_RACEWAY: libc::c_uint = 8;
pub const PCI_SUBCLASS_BR_OTHER: libc::c_uint = 128;
pub const PCI_SUBCLASS_COM_SERIAL: libc::c_uint = 0;
pub const PCI_SUBCLASS_COM_PARALLEL: libc::c_uint = 1;
pub const PCI_SUBCLASS_COM_MULTIPORT: libc::c_uint = 2;
pub const PCI_SUBCLASS_COM_MODEM: libc::c_uint = 3;
pub const PCI_SUBCLASS_COM_OTHER: libc::c_uint = 128;
pub const PCI_SUBCLASS_SYS_INTERRUPT_CTLR: libc::c_uint = 0;
pub const PCI_SUBCLASS_SYS_DMA_CTLR: libc::c_uint = 1;
pub const PCI_SUBCLASS_SYS_SYSTEM_TIMER: libc::c_uint = 2;
pub const PCI_SUBCLASS_SYS_REAL_TIME_CLOCK: libc::c_uint = 3;
pub const PCI_SUBCLASS_SYS_GEN_HOTPLUG_CTLR: libc::c_uint = 4;
pub const PCI_SUBCLASS_SYS_SDIO_CTRL: libc::c_uint = 5;
pub const PCI_SUBCLASS_SYS_OTHER: libc::c_uint = 128;
pub const PCI_SUBCLASS_INP_KEYBOARD: libc::c_uint = 0;
pub const PCI_SUBCLASS_INP_DIGITIZER: libc::c_uint = 1;
pub const PCI_SUBCLASS_INP_MOUSE: libc::c_uint = 2;
pub const PCI_SUBCLASS_INP_SCANNER: libc::c_uint = 3;
pub const PCI_SUBCLASS_INP_GAMEPORT: libc::c_uint = 4;
pub const PCI_SUBCLASS_INP_OTHER: libc::c_uint = 128;
pub const PCI_SUBCLASS_DOC_GENERIC: libc::c_uint = 0;
pub const PCI_SUBCLASS_DOC_OTHER: libc::c_uint = 128;
pub const PCI_SUBCLASS_PROC_386: libc::c_uint = 0;
pub const PCI_SUBCLASS_PROC_486: libc::c_uint = 1;
pub const PCI_SUBCLASS_PROC_PENTIUM: libc::c_uint = 2;
pub const PCI_SUBCLASS_PROC_ALPHA: libc::c_uint = 16;
pub const PCI_SUBCLASS_PROC_POWERPC: libc::c_uint = 32;
pub const PCI_SUBCLASS_PROC_COPROCESSOR: libc::c_uint = 64;
pub const PCI_SUBCLASS_SB_IEEE1394: libc::c_uint = 0;
pub const PCI_SUBCLASS_SB_ACCESS: libc::c_uint = 1;
pub const PCI_SUBCLASS_SB_SSA: libc::c_uint = 2;
pub const PCI_SUBCLASS_SB_USB: libc::c_uint = 3;
pub const PCI_SUBCLASS_SB_FIBRE_CHANNEL: libc::c_uint = 4;
pub const PCI_SUBCLASS_SB_SMBUS: libc::c_uint = 5;
pub const PCI_SUBCLASS_SB_THUNDERBOLT: libc::c_uint = 10;
pub const PCI_SUBCLASS_WIRELESS_IRDA: libc::c_uint = 0;
pub const PCI_SUBCLASS_WIRELESS_CON_IR: libc::c_uint = 1;
pub const PCI_SUBCLASS_WIRELESS_RF: libc::c_uint = 16;
pub const PCI_SUBCLASS_WIRELESS_OTHER: libc::c_uint = 128;
pub const PCI_SUBCLASS_INTIO_I2O: libc::c_uint = 0;
pub const PCI_SUBCLASS_SAT_TV: libc::c_uint = 1;
pub const PCI_SUBCLASS_SAT_AUDIO: libc::c_uint = 2;
pub const PCI_SUBCLASS_SAT_VOICE: libc::c_uint = 3;
pub const PCI_SUBCLASS_SAT_DATA: libc::c_uint = 4;
pub const PCI_SUBCLASS_CRYPTO_NET_COMP: libc::c_uint = 0;
pub const PCI_SUBCLASS_CRYPTO_ENTERTAINMENT: libc::c_uint = 16;
pub const PCI_SUBCLASS_CRYPTO_OTHER: libc::c_uint = 128;
pub const PCI_SUBCLASS_DASP_DPIO: libc::c_uint = 0;
pub const PCI_SUBCLASS_DASP_OTHER: libc::c_uint = 128;
pub const PCI_ADDRESS_IO_SPACE: libc::c_uint = 1;
pub const PCI_ADDRESS_MEMORY_TYPE_MASK: libc::c_uint = 6;
pub const PCI_ADDRESS_MEMORY_PREFETCHABLE: libc::c_uint = 8;
pub const PCI_ADDRESS_IO_ADDRESS_MASK: libc::c_uint = 4294967292;
pub const PCI_ADDRESS_MEMORY_ADDRESS_MASK: libc::c_uint = 4294967280;
pub const PCI_ADDRESS_ROM_ADDRESS_MASK: libc::c_uint = 4294965248;
pub const PCI_TYPE_32BIT: libc::c_uint = 0;
pub const PCI_TYPE_20BIT: libc::c_uint = 2;
pub const PCI_TYPE_64BIT: libc::c_uint = 4;
pub const PCI_ROMADDRESS_ENABLED: libc::c_uint = 1;
pub const PCI_DEVICE_PRESENT_INTERFACE_VERSION: libc::c_uint = 1;
pub const PCI_USE_SUBSYSTEM_IDS: libc::c_uint = 1;
pub const PCI_USE_REVISION: libc::c_uint = 2;
pub const PCI_USE_VENDEV_IDS: libc::c_uint = 4;
pub const PCI_USE_CLASS_SUBCLASS: libc::c_uint = 8;
pub const PCI_USE_PROGIF: libc::c_uint = 16;
pub const PCI_USE_LOCAL_BUS: libc::c_uint = 32;
pub const PCI_USE_LOCAL_DEVICE: libc::c_uint = 64;
pub const PCI_EXPRESS_ROOT_PORT_INTERFACE_VERSION: libc::c_uint = 1;
pub const FILE_ATTRIBUTE_DEDICATED: libc::c_uint = 256;
pub const EA_CONTAINER_NAME: &'static [u8; 14usize] = b"ContainerName\x00";
pub const EA_CONTAINER_SIZE: &'static [u8; 14usize] = b"ContainerSize\x00";
pub const CLFS_BASELOG_EXTENSION: &'static [u8; 5usize] = b".blf\x00";
pub const CLFS_FLAG_NO_FLAGS: libc::c_uint = 0;
pub const CLFS_FLAG_FORCE_APPEND: libc::c_uint = 1;
pub const CLFS_FLAG_FORCE_FLUSH: libc::c_uint = 2;
pub const CLFS_FLAG_USE_RESERVATION: libc::c_uint = 4;
pub const CLFS_FLAG_REENTRANT_FILE_SYSTEM: libc::c_uint = 8;
pub const CLFS_FLAG_NON_REENTRANT_FILTER: libc::c_uint = 16;
pub const CLFS_FLAG_REENTRANT_FILTER: libc::c_uint = 32;
pub const CLFS_FLAG_IGNORE_SHARE_ACCESS: libc::c_uint = 64;
pub const CLFS_FLAG_READ_IN_PROGRESS: libc::c_uint = 128;
pub const CLFS_FLAG_MINIFILTER_LEVEL: libc::c_uint = 256;
pub const CLFS_FLAG_HIDDEN_SYSTEM_LOG: libc::c_uint = 512;
pub const CLFS_FLAG_FILTER_INTERMEDIATE_LEVEL: libc::c_uint = 16;
pub const CLFS_FLAG_FILTER_TOP_LEVEL: libc::c_uint = 32;
pub const ClfsNullRecord: libc::c_uint = 0;
pub const ClfsDataRecord: libc::c_uint = 1;
pub const ClfsRestartRecord: libc::c_uint = 2;
pub const ClfsClientRecord: libc::c_uint = 3;
pub const CLFS_CONTAINER_STREAM_PREFIX: &'static [u8; 7usize] = b"%BLF%:\x00";
pub const CLFS_CONTAINER_RELATIVE_PREFIX: &'static [u8; 8usize] =
    b"%BLF%\\\\\x00";
pub const ClsContainerInitializing: libc::c_uint = 1;
pub const ClsContainerInactive: libc::c_uint = 2;
pub const ClsContainerActive: libc::c_uint = 4;
pub const ClsContainerActivePendingDelete: libc::c_uint = 8;
pub const ClsContainerPendingArchive: libc::c_uint = 16;
pub const ClsContainerPendingArchiveAndDelete: libc::c_uint = 32;
pub const ClfsContainerInitializing: libc::c_uint = 1;
pub const ClfsContainerInactive: libc::c_uint = 2;
pub const ClfsContainerActive: libc::c_uint = 4;
pub const ClfsContainerActivePendingDelete: libc::c_uint = 8;
pub const ClfsContainerPendingArchive: libc::c_uint = 16;
pub const ClfsContainerPendingArchiveAndDelete: libc::c_uint = 32;
pub const CLFS_MAX_CONTAINER_INFO: libc::c_uint = 256;
pub const CLFS_SCAN_INIT: libc::c_uint = 1;
pub const CLFS_SCAN_FORWARD: libc::c_uint = 2;
pub const CLFS_SCAN_BACKWARD: libc::c_uint = 4;
pub const CLFS_SCAN_CLOSE: libc::c_uint = 8;
pub const CLFS_SCAN_INITIALIZED: libc::c_uint = 16;
pub const CLFS_SCAN_BUFFERED: libc::c_uint = 32;
pub const CLFS_MGMT_POLICY_VERSION: libc::c_uint = 1;
pub const LOG_POLICY_OVERWRITE: libc::c_uint = 1;
pub const LOG_POLICY_PERSIST: libc::c_uint = 2;
pub const CLFS_MGMT_CLIENT_REGISTRATION_VERSION: libc::c_uint = 1;
pub const PCW_VERSION_1: libc::c_uint = 256;
pub const PCW_CURRENT_VERSION: libc::c_uint = 256;
pub const KERNEL_STACK_SIZE: libc::c_uint = 12288;
pub const KERNEL_LARGE_STACK_SIZE: libc::c_uint = 61440;
pub const KERNEL_LARGE_STACK_COMMIT: libc::c_uint = 12288;
pub const SIZE_OF_80387_REGISTERS: libc::c_uint = 80;
pub const CONTEXT_i386: libc::c_uint = 65536;
pub const CONTEXT_i486: libc::c_uint = 65536;
pub const CONTEXT_CONTROL: libc::c_uint = 65537;
pub const CONTEXT_INTEGER: libc::c_uint = 65538;
pub const CONTEXT_SEGMENTS: libc::c_uint = 65540;
pub const CONTEXT_FLOATING_POINT: libc::c_uint = 65544;
pub const CONTEXT_DEBUG_REGISTERS: libc::c_uint = 65552;
pub const CONTEXT_EXTENDED_REGISTERS: libc::c_uint = 65568;
pub const CONTEXT_FULL: libc::c_uint = 65543;
pub const CONTEXT_ALL: libc::c_uint = 65599;
pub const CONTEXT_XSTATE: libc::c_uint = 65600;
pub const CONTEXT_EXCEPTION_ACTIVE: libc::c_uint = 134217728;
pub const CONTEXT_SERVICE_ACTIVE: libc::c_uint = 268435456;
pub const CONTEXT_EXCEPTION_REQUEST: libc::c_uint = 1073741824;
pub const CONTEXT_EXCEPTION_REPORTING: libc::c_uint = 2147483648;
pub const SE_UNSOLICITED_INPUT_PRIVILEGE: libc::c_uint = 6;
pub const SE_SIGNING_LEVEL_UNCHECKED: libc::c_uint = 0;
pub const SE_SIGNING_LEVEL_UNSIGNED: libc::c_uint = 1;
pub const SE_SIGNING_LEVEL_ENTERPRISE: libc::c_uint = 2;
pub const SE_SIGNING_LEVEL_CUSTOM_1: libc::c_uint = 3;
pub const SE_SIGNING_LEVEL_AUTHENTICODE: libc::c_uint = 4;
pub const SE_SIGNING_LEVEL_CUSTOM_2: libc::c_uint = 5;
pub const SE_SIGNING_LEVEL_STORE: libc::c_uint = 6;
pub const SE_SIGNING_LEVEL_CUSTOM_3: libc::c_uint = 7;
pub const SE_SIGNING_LEVEL_ANTIMALWARE: libc::c_uint = 7;
pub const SE_SIGNING_LEVEL_MICROSOFT: libc::c_uint = 8;
pub const SE_SIGNING_LEVEL_CUSTOM_4: libc::c_uint = 9;
pub const SE_SIGNING_LEVEL_CUSTOM_5: libc::c_uint = 10;
pub const SE_SIGNING_LEVEL_DYNAMIC_CODEGEN: libc::c_uint = 11;
pub const SE_SIGNING_LEVEL_WINDOWS: libc::c_uint = 12;
pub const SE_SIGNING_LEVEL_CUSTOM_7: libc::c_uint = 13;
pub const SE_SIGNING_LEVEL_WINDOWS_TCB: libc::c_uint = 14;
pub const SE_SIGNING_LEVEL_CUSTOM_6: libc::c_uint = 15;
pub const RTL_RUN_ONCE_CHECK_ONLY: libc::c_uint = 1;
pub const RTL_RUN_ONCE_ASYNC: libc::c_uint = 2;
pub const RTL_RUN_ONCE_INIT_FAILED: libc::c_uint = 4;
pub const RTL_RUN_ONCE_CTX_RESERVED_BITS: libc::c_uint = 2;
pub const RTL_HASH_ALLOCATED_HEADER: libc::c_uint = 1;
pub const RTL_HASH_RESERVED_SIGNATURE: libc::c_uint = 0;
pub const FILE_CHARACTERISTICS_EXPECT_ORDERLY_REMOVAL_EX: libc::c_uint =
    16384;
pub const FILE_CHARACTERISTICS_EXPECT_SURPRISE_REMOVAL_EX: libc::c_uint =
    32768;
pub const FILE_CHARACTERISTICS_REMOVAL_POLICY_MASK_EX: libc::c_uint = 49152;
pub const FILE_CHARACTERISTICS_EXPECT_ORDERLY_REMOVAL_DEPRECATED: libc::c_uint
          =
    512;
pub const FILE_CHARACTERISTICS_EXPECT_SURPRISE_REMOVAL_DEPRECATED:
          libc::c_uint =
    768;
pub const FILE_CHARACTERISTICS_REMOVAL_POLICY_MASK_DEPRECATED: libc::c_uint =
    768;
pub const FILE_CHARACTERISTICS_PROPAGATED: libc::c_uint = 327951;
pub const FILE_DISPOSITION_DO_NOT_DELETE: libc::c_uint = 0;
pub const FILE_DISPOSITION_DELETE: libc::c_uint = 1;
pub const FILE_DISPOSITION_POSIX_SEMANTICS: libc::c_uint = 2;
pub const FILE_DISPOSITION_FORCE_IMAGE_SECTION_CHECK: libc::c_uint = 4;
pub const FILE_DISPOSITION_ON_CLOSE: libc::c_uint = 8;
pub const SSINFO_FLAGS_ALIGNED_DEVICE: libc::c_uint = 1;
pub const SSINFO_FLAGS_PARTITION_ALIGNED_ON_DEVICE: libc::c_uint = 2;
pub const SSINFO_FLAGS_NO_SEEK_PENALTY: libc::c_uint = 4;
pub const SSINFO_FLAGS_TRIM_ENABLED: libc::c_uint = 8;
pub const SSINFO_FLAGS_BYTE_ADDRESSABLE: libc::c_uint = 16;
pub const SSINFO_OFFSET_UNKNOWN: libc::c_uint = 4294967295;
pub const THREAD_CSWITCH_PMU_DISABLE: libc::c_uint = 0;
pub const THREAD_CSWITCH_PMU_ENABLE: libc::c_uint = 1;
pub const MEMORY_PRIORITY_LOWEST: libc::c_uint = 0;
pub const MEMORY_PRIORITY_VERY_LOW: libc::c_uint = 1;
pub const MEMORY_PRIORITY_LOW: libc::c_uint = 2;
pub const MEMORY_PRIORITY_MEDIUM: libc::c_uint = 3;
pub const MEMORY_PRIORITY_BELOW_NORMAL: libc::c_uint = 4;
pub const MEMORY_PRIORITY_NORMAL: libc::c_uint = 5;
pub const PROCESS_LUID_DOSDEVICES_ONLY: libc::c_uint = 1;
pub const PROCESS_HANDLE_EXCEPTIONS_ENABLED: libc::c_uint = 1;
pub const PROCESS_HANDLE_RAISE_UM_EXCEPTION_ON_INVALID_HANDLE_CLOSE_DISABLED:
          libc::c_uint =
    0;
pub const PROCESS_HANDLE_RAISE_UM_EXCEPTION_ON_INVALID_HANDLE_CLOSE_ENABLED:
          libc::c_uint =
    1;
pub const PROCESS_HANDLE_TRACING_MAX_STACKS: libc::c_uint = 16;
pub const QUOTA_LIMITS_HARDWS_MIN_ENABLE: libc::c_uint = 1;
pub const QUOTA_LIMITS_HARDWS_MIN_DISABLE: libc::c_uint = 2;
pub const QUOTA_LIMITS_HARDWS_MAX_ENABLE: libc::c_uint = 4;
pub const QUOTA_LIMITS_HARDWS_MAX_DISABLE: libc::c_uint = 8;
pub const QUOTA_LIMITS_USE_DEFAULT_LIMITS: libc::c_uint = 16;
pub const MAX_HW_COUNTERS: libc::c_uint = 16;
pub const THREAD_PROFILING_FLAG_DISPATCH: libc::c_uint = 1;
pub const PROCESS_EXCEPTION_PORT_ALL_STATE_BITS: libc::c_uint = 3;
pub const PCR_MINOR_VERSION: libc::c_uint = 1;
pub const PCR_MAJOR_VERSION: libc::c_uint = 1;
pub const PDI_SHIFT: libc::c_uint = 21;
pub const PPI_SHIFT: libc::c_uint = 30;
pub const PTI_SHIFT: libc::c_uint = 12;
pub const PTE_PER_PAGE: libc::c_uint = 512;
pub const PDE_PER_PAGE: libc::c_uint = 512;
pub const MM_SYSTEM_SPACE_END: libc::c_uint = 4294967295;
pub const DRIVER_VERIFIER_SPECIAL_POOLING: libc::c_uint = 1;
pub const DRIVER_VERIFIER_FORCE_IRQL_CHECKING: libc::c_uint = 2;
pub const DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES: libc::c_uint = 4;
pub const DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS: libc::c_uint = 8;
pub const DRIVER_VERIFIER_IO_CHECKING: libc::c_uint = 16;
pub const XSTATE_LEGACY_FLOATING_POINT: libc::c_uint = 0;
pub const XSTATE_LEGACY_SSE: libc::c_uint = 1;
pub const XSTATE_GSSE: libc::c_uint = 2;
pub const XSTATE_AVX: libc::c_uint = 2;
pub const XSTATE_MPX_BNDREGS: libc::c_uint = 3;
pub const XSTATE_MPX_BNDCSR: libc::c_uint = 4;
pub const XSTATE_AVX512_KMASK: libc::c_uint = 5;
pub const XSTATE_AVX512_ZMM_H: libc::c_uint = 6;
pub const XSTATE_AVX512_ZMM: libc::c_uint = 7;
pub const XSTATE_IPT: libc::c_uint = 8;
pub const XSTATE_LWP: libc::c_uint = 62;
pub const MAXIMUM_XSTATE_FEATURES: libc::c_uint = 64;
pub const XSTATE_COMPACTION_ENABLE: libc::c_uint = 63;
pub const XSTATE_ALIGN_BIT: libc::c_uint = 1;
pub const XSTATE_CONTROLFLAG_XSAVEOPT_MASK: libc::c_uint = 1;
pub const XSTATE_CONTROLFLAG_XSAVEC_MASK: libc::c_uint = 2;
pub const XSTATE_CONTROLFLAG_VALID_MASK: libc::c_uint = 3;
pub const NX_SUPPORT_POLICY_ALWAYSOFF: libc::c_uint = 0;
pub const NX_SUPPORT_POLICY_ALWAYSON: libc::c_uint = 1;
pub const NX_SUPPORT_POLICY_OPTIN: libc::c_uint = 2;
pub const NX_SUPPORT_POLICY_OPTOUT: libc::c_uint = 3;
pub const SEH_VALIDATION_POLICY_ON: libc::c_uint = 0;
pub const SEH_VALIDATION_POLICY_OFF: libc::c_uint = 1;
pub const SEH_VALIDATION_POLICY_TELEMETRY: libc::c_uint = 2;
pub const SEH_VALIDATION_POLICY_DEFER: libc::c_uint = 3;
pub const SHARED_GLOBAL_FLAGS_ERROR_PORT_V: libc::c_uint = 0;
pub const SHARED_GLOBAL_FLAGS_ERROR_PORT: libc::c_uint = 1;
pub const SHARED_GLOBAL_FLAGS_ELEVATION_ENABLED_V: libc::c_uint = 1;
pub const SHARED_GLOBAL_FLAGS_ELEVATION_ENABLED: libc::c_uint = 2;
pub const SHARED_GLOBAL_FLAGS_VIRT_ENABLED_V: libc::c_uint = 2;
pub const SHARED_GLOBAL_FLAGS_VIRT_ENABLED: libc::c_uint = 4;
pub const SHARED_GLOBAL_FLAGS_INSTALLER_DETECT_ENABLED_V: libc::c_uint = 3;
pub const SHARED_GLOBAL_FLAGS_INSTALLER_DETECT_ENABLED: libc::c_uint = 8;
pub const SHARED_GLOBAL_FLAGS_LKG_ENABLED_V: libc::c_uint = 4;
pub const SHARED_GLOBAL_FLAGS_LKG_ENABLED: libc::c_uint = 16;
pub const SHARED_GLOBAL_FLAGS_DYNAMIC_PROC_ENABLED_V: libc::c_uint = 5;
pub const SHARED_GLOBAL_FLAGS_DYNAMIC_PROC_ENABLED: libc::c_uint = 32;
pub const SHARED_GLOBAL_FLAGS_CONSOLE_BROKER_ENABLED_V: libc::c_uint = 6;
pub const SHARED_GLOBAL_FLAGS_CONSOLE_BROKER_ENABLED: libc::c_uint = 64;
pub const SHARED_GLOBAL_FLAGS_SECURE_BOOT_ENABLED_V: libc::c_uint = 7;
pub const SHARED_GLOBAL_FLAGS_SECURE_BOOT_ENABLED: libc::c_uint = 128;
pub const SHARED_GLOBAL_FLAGS_MULTI_SESSION_SKU_V: libc::c_uint = 8;
pub const SHARED_GLOBAL_FLAGS_MULTI_SESSION_SKU: libc::c_uint = 256;
pub const SHARED_GLOBAL_FLAGS_MULTIUSERS_IN_SESSION_SKU_V: libc::c_uint = 9;
pub const SHARED_GLOBAL_FLAGS_MULTIUSERS_IN_SESSION_SKU: libc::c_uint = 512;
pub const SYSTEM_CALL_SYSCALL: libc::c_uint = 0;
pub const SYSTEM_CALL_INT_2E: libc::c_uint = 1;
pub const CmResourceTypeMaximum: libc::c_uint = 8;
pub const PCCARD_MAP_ERROR: libc::c_uint = 1;
pub const PCCARD_DEVICE_PCI: libc::c_uint = 16;
pub const PCCARD_SCAN_DISABLED: libc::c_uint = 1;
pub const PCCARD_MAP_ZERO: libc::c_uint = 2;
pub const PCCARD_NO_TIMER: libc::c_uint = 3;
pub const PCCARD_NO_PIC: libc::c_uint = 4;
pub const PCCARD_NO_LEGACY_BASE: libc::c_uint = 5;
pub const PCCARD_DUP_LEGACY_BASE: libc::c_uint = 6;
pub const PCCARD_NO_CONTROLLERS: libc::c_uint = 7;
pub const MAXIMUM_EXPANSION_SIZE: libc::c_uint = 59392;
pub const CP_GET_SUCCESS: libc::c_uint = 0;
pub const CP_GET_NODATA: libc::c_uint = 1;
pub const CP_GET_ERROR: libc::c_uint = 2;
pub const PROTECTED_POOL: libc::c_uint = 0;
pub const MM_COPY_MEMORY_PHYSICAL: libc::c_uint = 1;
pub const IMAGE_ADDRESSING_MODE_32BIT: libc::c_uint = 3;
pub const IRP_MN_QUERY_DIRECTORY: libc::c_uint = 1;
pub const IRP_MN_NOTIFY_CHANGE_DIRECTORY: libc::c_uint = 2;
pub const IRP_MN_USER_FS_REQUEST: libc::c_uint = 0;
pub const IRP_MN_MOUNT_VOLUME: libc::c_uint = 1;
pub const IRP_MN_VERIFY_VOLUME: libc::c_uint = 2;
pub const IRP_MN_LOAD_FILE_SYSTEM: libc::c_uint = 3;
pub const IRP_MN_TRACK_LINK: libc::c_uint = 4;
pub const IRP_MN_KERNEL_CALL: libc::c_uint = 4;
pub const IRP_MN_LOCK: libc::c_uint = 1;
pub const IRP_MN_UNLOCK_SINGLE: libc::c_uint = 2;
pub const IRP_MN_UNLOCK_ALL: libc::c_uint = 3;
pub const IRP_MN_UNLOCK_ALL_BY_KEY: libc::c_uint = 4;
pub const IRP_MN_FLUSH_AND_PURGE: libc::c_uint = 1;
pub const IRP_MN_FLUSH_DATA_ONLY: libc::c_uint = 2;
pub const IRP_MN_FLUSH_NO_SYNC: libc::c_uint = 3;
pub const IRP_MN_NORMAL: libc::c_uint = 0;
pub const IRP_MN_DPC: libc::c_uint = 1;
pub const IRP_MN_MDL: libc::c_uint = 2;
pub const IRP_MN_COMPLETE: libc::c_uint = 4;
pub const IRP_MN_COMPRESSED: libc::c_uint = 8;
pub const IRP_MN_MDL_DPC: libc::c_uint = 3;
pub const IRP_MN_COMPLETE_MDL: libc::c_uint = 6;
pub const IRP_MN_COMPLETE_MDL_DPC: libc::c_uint = 7;
pub const IRP_MN_QUERY_LEGACY_BUS_INFORMATION: libc::c_uint = 24;
pub const IO_CHECK_CREATE_PARAMETERS: libc::c_uint = 512;
pub const IO_ATTACH_DEVICE: libc::c_uint = 1024;
pub const IO_IGNORE_SHARE_ACCESS_CHECK: libc::c_uint = 2048;
pub const DO_DEVICE_HAS_NAME: libc::c_uint = 64;
pub const DO_SYSTEM_BOOT_PARTITION: libc::c_uint = 256;
pub const DO_LONG_TERM_REQUESTS: libc::c_uint = 512;
pub const DO_NEVER_LAST_DEVICE: libc::c_uint = 1024;
pub const DO_LOW_PRIORITY_FILESYSTEM: libc::c_uint = 65536;
pub const DO_SUPPORTS_TRANSACTIONS: libc::c_uint = 262144;
pub const DO_FORCE_NEITHER_IO: libc::c_uint = 524288;
pub const DO_VOLUME_DEVICE_OBJECT: libc::c_uint = 1048576;
pub const DO_SYSTEM_SYSTEM_PARTITION: libc::c_uint = 2097152;
pub const DO_SYSTEM_CRITICAL_PARTITION: libc::c_uint = 4194304;
pub const DO_DISALLOW_EXECUTE: libc::c_uint = 8388608;
pub const DO_DEVICE_IRP_REQUIRES_EXTENSION: libc::c_uint = 134217728;
pub const DRVO_REINIT_REGISTERED: libc::c_uint = 8;
pub const DRVO_INITIALIZED: libc::c_uint = 16;
pub const DRVO_BOOTREINIT_REGISTERED: libc::c_uint = 32;
pub const DRVO_LEGACY_RESOURCES: libc::c_uint = 64;
pub const TXF_MINIVERSION_DEFAULT_VIEW: libc::c_uint = 65534;
pub const OPLOCK_KEY_VERSION_WIN7: libc::c_uint = 1;
pub const OPLOCK_KEY_VERSION_WIN8: libc::c_uint = 2;
pub const OPLOCK_KEY_FLAG_PARENT_KEY: libc::c_uint = 1;
pub const BDCB_IMAGEFLAGS_FAILED_CODE_INTEGRITY: libc::c_uint = 1;
pub const ARBITER_FLAG_BOOT_CONFIG: libc::c_uint = 1;
pub const ARBITER_FLAG_ROOT_ENUM: libc::c_uint = 2;
pub const ARBITER_FLAG_OTHER_ENUM: libc::c_uint = 4;
pub const ARBITER_PARTIAL: libc::c_uint = 1;
pub const MAXIMUM_DEBUG_BARS: libc::c_uint = 6;
pub const DBG_DEVICE_FLAG_HAL_SCRATCH_ALLOCATED: libc::c_uint = 1;
pub const DBG_DEVICE_FLAG_BARS_MAPPED: libc::c_uint = 2;
pub const DBG_DEVICE_FLAG_SCRATCH_ALLOCATED: libc::c_uint = 4;
pub const HAL_DISPATCH_VERSION: libc::c_uint = 4;
pub const HAL_PLATFORM_DISABLE_WRITE_COMBINING: libc::c_uint = 1;
pub const HAL_PLATFORM_DISABLE_PTCG: libc::c_uint = 4;
pub const HAL_PLATFORM_DISABLE_UC_MAIN_MEMORY: libc::c_uint = 8;
pub const HAL_PLATFORM_ENABLE_WRITE_COMBINING_MMIO: libc::c_uint = 16;
pub const HAL_PLATFORM_ACPI_TABLES_CACHED: libc::c_uint = 32;
pub const PCI_AGP_RATE_1X: libc::c_uint = 1;
pub const PCI_AGP_RATE_2X: libc::c_uint = 2;
pub const PCI_AGP_RATE_4X: libc::c_uint = 4;
pub const PCIX_MODE_CONVENTIONAL_PCI: libc::c_uint = 0;
pub const PCIX_MODE1_66MHZ: libc::c_uint = 1;
pub const PCIX_MODE1_100MHZ: libc::c_uint = 2;
pub const PCIX_MODE1_133MHZ: libc::c_uint = 3;
pub const PCIX_MODE2_266_66MHZ: libc::c_uint = 9;
pub const PCIX_MODE2_266_100MHZ: libc::c_uint = 10;
pub const PCIX_MODE2_266_133MHZ: libc::c_uint = 11;
pub const PCIX_MODE2_533_66MHZ: libc::c_uint = 13;
pub const PCIX_MODE2_533_100MHZ: libc::c_uint = 14;
pub const PCIX_MODE2_533_133MHZ: libc::c_uint = 15;
pub const PCIX_VERSION_MODE1_ONLY: libc::c_uint = 0;
pub const PCIX_VERSION_MODE2_ECC: libc::c_uint = 1;
pub const PCIX_VERSION_DUAL_MODE_ECC: libc::c_uint = 2;
pub const OSC_FIRMWARE_FAILURE: libc::c_uint = 2;
pub const OSC_UNRECOGNIZED_UUID: libc::c_uint = 4;
pub const OSC_UNRECOGNIZED_REVISION: libc::c_uint = 8;
pub const OSC_CAPABILITIES_MASKED: libc::c_uint = 16;
pub const PCI_ROOT_BUS_OSC_METHOD_CAPABILITY_REVISION: libc::c_uint = 1;
pub const PCI_DATA_VERSION: libc::c_uint = 1;
pub const PCI_EXPRESS_TPH_ST_LOCATION_NONE: libc::c_uint = 0;
pub const PCI_EXPRESS_TPH_ST_LOCATION_TPH_CAPABILITY: libc::c_uint = 1;
pub const PCI_EXPRESS_TPH_ST_LOCATION_MSIX_TABLE: libc::c_uint = 2;
pub const PCI_EXPRESS_TPH_ST_LOCATION_RESERVED: libc::c_uint = 3;
pub const PCI_BUS_INTERFACE_STANDARD_VERSION: libc::c_uint = 2;
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_VERSION_10: libc::c_uint = 10;
pub const WHEA_MAX_MC_BANKS: libc::c_uint = 32;
pub const WHEA_ERROR_SOURCE_FLAG_FIRMWAREFIRST: libc::c_uint = 1;
pub const WHEA_ERROR_SOURCE_FLAG_GLOBAL: libc::c_uint = 2;
pub const WHEA_ERROR_SOURCE_FLAG_PREALLOCATE_PER_PROCESSOR: libc::c_uint = 4;
pub const WHEA_ERROR_SOURCE_FLAG_DEFAULTSOURCE: libc::c_uint = 2147483648;
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_XPFMCE: libc::c_uint = 0;
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_XPFCMC: libc::c_uint = 1;
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_XPFNMI: libc::c_uint = 2;
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_IPFMCA: libc::c_uint = 3;
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_IPFCMC: libc::c_uint = 4;
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_IPFCPE: libc::c_uint = 5;
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_AERROOTPORT: libc::c_uint = 6;
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_AERENDPOINT: libc::c_uint = 7;
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_AERBRIDGE: libc::c_uint = 8;
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_GENERIC: libc::c_uint = 9;
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_GENERIC_V2: libc::c_uint = 10;
pub const WHEA_XPF_MC_BANK_STATUSFORMAT_IA32MCA: libc::c_uint = 0;
pub const WHEA_XPF_MC_BANK_STATUSFORMAT_Intel64MCA: libc::c_uint = 1;
pub const WHEA_XPF_MC_BANK_STATUSFORMAT_AMD64MCA: libc::c_uint = 2;
pub const WHEA_NOTIFICATION_TYPE_POLLED: libc::c_uint = 0;
pub const WHEA_NOTIFICATION_TYPE_EXTERNALINTERRUPT: libc::c_uint = 1;
pub const WHEA_NOTIFICATION_TYPE_LOCALINTERRUPT: libc::c_uint = 2;
pub const WHEA_NOTIFICATION_TYPE_SCI: libc::c_uint = 3;
pub const WHEA_NOTIFICATION_TYPE_NMI: libc::c_uint = 4;
pub const WHEA_NOTIFICATION_TYPE_CMCI: libc::c_uint = 5;
pub const WHEA_NOTIFICATION_TYPE_MCE: libc::c_uint = 6;
pub const WHEA_NOTIFICATION_TYPE_GPIO_SIGNAL: libc::c_uint = 7;
pub const WHEA_NOTIFICATION_TYPE_ARMV8_SEA: libc::c_uint = 8;
pub const WHEA_NOTIFICATION_TYPE_ARMV8_SEI: libc::c_uint = 9;
pub const WHEA_NOTIFICATION_TYPE_EXTERNALINTERRUPT_GSIV: libc::c_uint = 10;
pub const WHEA_DISABLE_OFFLINE: libc::c_uint = 0;
pub const WHEA_MEM_PERSISTOFFLINE: libc::c_uint = 1;
pub const WHEA_MEM_PFA_DISABLE: libc::c_uint = 2;
pub const WHEA_MEM_PFA_PAGECOUNT: libc::c_uint = 3;
pub const WHEA_MEM_PFA_THRESHOLD: libc::c_uint = 4;
pub const WHEA_MEM_PFA_TIMEOUT: libc::c_uint = 5;
pub const WHEA_DISABLE_DUMMY_WRITE: libc::c_uint = 6;
pub const ERRTYP_INTERNAL: libc::c_uint = 1;
pub const ERRTYP_BUS: libc::c_uint = 16;
pub const ERRTYP_MEM: libc::c_uint = 4;
pub const ERRTYP_TLB: libc::c_uint = 5;
pub const ERRTYP_CACHE: libc::c_uint = 6;
pub const ERRTYP_FUNCTION: libc::c_uint = 7;
pub const ERRTYP_SELFTEST: libc::c_uint = 8;
pub const ERRTYP_FLOW: libc::c_uint = 9;
pub const ERRTYP_MAP: libc::c_uint = 17;
pub const ERRTYP_IMPROPER: libc::c_uint = 18;
pub const ERRTYP_UNIMPL: libc::c_uint = 19;
pub const ERRTYP_LOSSOFLOCKSTEP: libc::c_uint = 20;
pub const ERRTYP_RESPONSE: libc::c_uint = 21;
pub const ERRTYP_PARITY: libc::c_uint = 22;
pub const ERRTYP_PROTOCOL: libc::c_uint = 23;
pub const ERRTYP_PATHERROR: libc::c_uint = 24;
pub const ERRTYP_TIMEOUT: libc::c_uint = 25;
pub const ERRTYP_POISONED: libc::c_uint = 26;
pub const WHEA_ERROR_RECORD_VALID_PLATFORMID: libc::c_uint = 1;
pub const WHEA_ERROR_RECORD_VALID_TIMESTAMP: libc::c_uint = 2;
pub const WHEA_ERROR_RECORD_VALID_PARTITIONID: libc::c_uint = 4;
pub const WHEA_ERROR_RECORD_FLAGS_RECOVERED: libc::c_uint = 1;
pub const WHEA_ERROR_RECORD_FLAGS_PREVIOUSERROR: libc::c_uint = 2;
pub const WHEA_ERROR_RECORD_FLAGS_SIMULATED: libc::c_uint = 4;
pub const WHEA_ERROR_RECORD_REVISION: libc::c_uint = 528;
pub const WHEA_ERROR_RECORD_SIGNATURE_END: libc::c_uint = 4294967295;
pub const WHEA_SECTION_DESCRIPTOR_FLAGS_PRIMARY: libc::c_uint = 1;
pub const WHEA_SECTION_DESCRIPTOR_FLAGS_CONTAINMENTWRN: libc::c_uint = 2;
pub const WHEA_SECTION_DESCRIPTOR_FLAGS_RESET: libc::c_uint = 4;
pub const WHEA_SECTION_DESCRIPTOR_FLAGS_THRESHOLDEXCEEDED: libc::c_uint = 8;
pub const WHEA_SECTION_DESCRIPTOR_FLAGS_RESOURCENA: libc::c_uint = 16;
pub const WHEA_SECTION_DESCRIPTOR_FLAGS_LATENTERROR: libc::c_uint = 32;
pub const WHEA_SECTION_DESCRIPTOR_FLAGS_PROPAGATED: libc::c_uint = 64;
pub const WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_REVISION: libc::c_uint = 768;
pub const GENPROC_PROCTYPE_XPF: libc::c_uint = 0;
pub const GENPROC_PROCTYPE_IPF: libc::c_uint = 1;
pub const GENPROC_PROCTYPE_ARM: libc::c_uint = 2;
pub const GENPROC_PROCISA_X86: libc::c_uint = 0;
pub const GENPROC_PROCISA_IPF: libc::c_uint = 1;
pub const GENPROC_PROCISA_X64: libc::c_uint = 2;
pub const GENPROC_PROCISA_ARM32: libc::c_uint = 4;
pub const GENPROC_PROCISA_ARM64: libc::c_uint = 8;
pub const GENPROC_PROCERRTYPE_UNKNOWN: libc::c_uint = 0;
pub const GENPROC_PROCERRTYPE_CACHE: libc::c_uint = 1;
pub const GENPROC_PROCERRTYPE_TLB: libc::c_uint = 2;
pub const GENPROC_PROCERRTYPE_BUS: libc::c_uint = 4;
pub const GENPROC_PROCERRTYPE_MAE: libc::c_uint = 8;
pub const GENPROC_OP_GENERIC: libc::c_uint = 0;
pub const GENPROC_OP_DATAREAD: libc::c_uint = 1;
pub const GENPROC_OP_DATAWRITE: libc::c_uint = 2;
pub const GENPROC_OP_INSTRUCTIONEXE: libc::c_uint = 3;
pub const GENPROC_FLAGS_RESTARTABLE: libc::c_uint = 1;
pub const GENPROC_FLAGS_PRECISEIP: libc::c_uint = 2;
pub const GENPROC_FLAGS_OVERFLOW: libc::c_uint = 4;
pub const GENPROC_FLAGS_CORRECTED: libc::c_uint = 8;
pub const XPF_CACHE_CHECK_TRANSACTIONTYPE_INSTRUCTION: libc::c_uint = 0;
pub const XPF_CACHE_CHECK_TRANSACTIONTYPE_DATAACCESS: libc::c_uint = 1;
pub const XPF_CACHE_CHECK_TRANSACTIONTYPE_GENERIC: libc::c_uint = 2;
pub const XPF_CACHE_CHECK_OPERATION_GENERIC: libc::c_uint = 0;
pub const XPF_CACHE_CHECK_OPERATION_GENREAD: libc::c_uint = 1;
pub const XPF_CACHE_CHECK_OPERATION_GENWRITE: libc::c_uint = 2;
pub const XPF_CACHE_CHECK_OPERATION_DATAREAD: libc::c_uint = 3;
pub const XPF_CACHE_CHECK_OPERATION_DATAWRITE: libc::c_uint = 4;
pub const XPF_CACHE_CHECK_OPERATION_INSTRUCTIONFETCH: libc::c_uint = 5;
pub const XPF_CACHE_CHECK_OPERATION_PREFETCH: libc::c_uint = 6;
pub const XPF_CACHE_CHECK_OPERATION_EVICTION: libc::c_uint = 7;
pub const XPF_CACHE_CHECK_OPERATION_SNOOP: libc::c_uint = 8;
pub const XPF_TLB_CHECK_TRANSACTIONTYPE_INSTRUCTION: libc::c_uint = 0;
pub const XPF_TLB_CHECK_TRANSACTIONTYPE_DATAACCESS: libc::c_uint = 1;
pub const XPF_TLB_CHECK_TRANSACTIONTYPE_GENERIC: libc::c_uint = 2;
pub const XPF_TLB_CHECK_OPERATION_GENERIC: libc::c_uint = 0;
pub const XPF_TLB_CHECK_OPERATION_GENREAD: libc::c_uint = 1;
pub const XPF_TLB_CHECK_OPERATION_GENWRITE: libc::c_uint = 2;
pub const XPF_TLB_CHECK_OPERATION_DATAREAD: libc::c_uint = 3;
pub const XPF_TLB_CHECK_OPERATION_DATAWRITE: libc::c_uint = 4;
pub const XPF_TLB_CHECK_OPERATION_INSTRUCTIONFETCH: libc::c_uint = 5;
pub const XPF_TLB_CHECK_OPERATION_PREFETCH: libc::c_uint = 6;
pub const XPF_BUS_CHECK_TRANSACTIONTYPE_INSTRUCTION: libc::c_uint = 0;
pub const XPF_BUS_CHECK_TRANSACTIONTYPE_DATAACCESS: libc::c_uint = 1;
pub const XPF_BUS_CHECK_TRANSACTIONTYPE_GENERIC: libc::c_uint = 2;
pub const XPF_BUS_CHECK_OPERATION_GENERIC: libc::c_uint = 0;
pub const XPF_BUS_CHECK_OPERATION_GENREAD: libc::c_uint = 1;
pub const XPF_BUS_CHECK_OPERATION_GENWRITE: libc::c_uint = 2;
pub const XPF_BUS_CHECK_OPERATION_DATAREAD: libc::c_uint = 3;
pub const XPF_BUS_CHECK_OPERATION_DATAWRITE: libc::c_uint = 4;
pub const XPF_BUS_CHECK_OPERATION_INSTRUCTIONFETCH: libc::c_uint = 5;
pub const XPF_BUS_CHECK_OPERATION_PREFETCH: libc::c_uint = 6;
pub const XPF_BUS_CHECK_PARTICIPATION_PROCORIGINATED: libc::c_uint = 0;
pub const XPF_BUS_CHECK_PARTICIPATION_PROCRESPONDED: libc::c_uint = 1;
pub const XPF_BUS_CHECK_PARTICIPATION_PROCOBSERVED: libc::c_uint = 2;
pub const XPF_BUS_CHECK_PARTICIPATION_GENERIC: libc::c_uint = 3;
pub const XPF_BUS_CHECK_ADDRESS_MEMORY: libc::c_uint = 0;
pub const XPF_BUS_CHECK_ADDRESS_RESERVED: libc::c_uint = 1;
pub const XPF_BUS_CHECK_ADDRESS_IO: libc::c_uint = 2;
pub const XPF_BUS_CHECK_ADDRESS_OTHER: libc::c_uint = 3;
pub const XPF_MS_CHECK_ERRORTYPE_NOERROR: libc::c_uint = 0;
pub const XPF_MS_CHECK_ERRORTYPE_UNCLASSIFIED: libc::c_uint = 1;
pub const XPF_MS_CHECK_ERRORTYPE_MCROMPARITY: libc::c_uint = 2;
pub const XPF_MS_CHECK_ERRORTYPE_EXTERNAL: libc::c_uint = 3;
pub const XPF_MS_CHECK_ERRORTYPE_FRC: libc::c_uint = 4;
pub const XPF_MS_CHECK_ERRORTYPE_INTERNALUNCLASSIFIED: libc::c_uint = 5;
pub const XPF_CONTEXT_INFO_UNCLASSIFIEDDATA: libc::c_uint = 0;
pub const XPF_CONTEXT_INFO_MSRREGISTERS: libc::c_uint = 1;
pub const XPF_CONTEXT_INFO_32BITCONTEXT: libc::c_uint = 2;
pub const XPF_CONTEXT_INFO_64BITCONTEXT: libc::c_uint = 3;
pub const XPF_CONTEXT_INFO_FXSAVE: libc::c_uint = 4;
pub const XPF_CONTEXT_INFO_32BITDEBUGREGS: libc::c_uint = 5;
pub const XPF_CONTEXT_INFO_64BITDEBUGREGS: libc::c_uint = 6;
pub const XPF_CONTEXT_INFO_MMREGISTERS: libc::c_uint = 7;
pub const WHEA_MEMERRTYPE_UNKNOWN: libc::c_uint = 0;
pub const WHEA_MEMERRTYPE_NOERROR: libc::c_uint = 1;
pub const WHEA_MEMERRTYPE_SINGLEBITECC: libc::c_uint = 2;
pub const WHEA_MEMERRTYPE_MULTIBITECC: libc::c_uint = 3;
pub const WHEA_MEMERRTYPE_SINGLESYMCHIPKILL: libc::c_uint = 4;
pub const WHEA_MEMERRTYPE_MULTISYMCHIPKILL: libc::c_uint = 5;
pub const WHEA_MEMERRTYPE_MASTERABORT: libc::c_uint = 6;
pub const WHEA_MEMERRTYPE_TARGETABORT: libc::c_uint = 7;
pub const WHEA_MEMERRTYPE_PARITYERROR: libc::c_uint = 8;
pub const WHEA_MEMERRTYPE_WATCHDOGTIMEOUT: libc::c_uint = 9;
pub const WHEA_MEMERRTYPE_INVALIDADDRESS: libc::c_uint = 10;
pub const WHEA_MEMERRTYPE_MIRRORBROKEN: libc::c_uint = 11;
pub const WHEA_MEMERRTYPE_MEMORYSPARING: libc::c_uint = 12;
pub const PCIXBUS_ERRTYPE_UNKNOWN: libc::c_uint = 0;
pub const PCIXBUS_ERRTYPE_DATAPARITY: libc::c_uint = 1;
pub const PCIXBUS_ERRTYPE_SYSTEM: libc::c_uint = 2;
pub const PCIXBUS_ERRTYPE_MASTERABORT: libc::c_uint = 3;
pub const PCIXBUS_ERRTYPE_BUSTIMEOUT: libc::c_uint = 4;
pub const PCIXBUS_ERRTYPE_MASTERDATAPARITY: libc::c_uint = 5;
pub const PCIXBUS_ERRTYPE_ADDRESSPARITY: libc::c_uint = 6;
pub const PCIXBUS_ERRTYPE_COMMANDPARITY: libc::c_uint = 7;
pub const WHEA_FIRMWARE_RECORD_TYPE_IPFSAL: libc::c_uint = 0;
pub const WHEA_XPF_MCA_EXTREG_MAX_COUNT: libc::c_uint = 24;
pub const WHEA_XPF_MCA_SECTION_VERSION: libc::c_uint = 1;
pub const WHEA_ERROR_PACKET_V1_VERSION: libc::c_uint = 2;
pub const WHEA_ERROR_PACKET_V2_VERSION: libc::c_uint = 3;
pub const WHEA_ERROR_PACKET_VERSION: libc::c_uint = 3;
pub const WHEA_GENERIC_ENTRY_V2_VERSION: libc::c_uint = 768;
pub const WHEA_GENERIC_ENTRY_VERSION: libc::c_uint = 768;
pub const INJECT_ERRTYPE_PROCESSOR_CORRECTABLE: libc::c_uint = 1;
pub const INJECT_ERRTYPE_PROCESSOR_UNCORRECTABLENONFATAL: libc::c_uint = 2;
pub const INJECT_ERRTYPE_PROCESSOR_UNCORRECTABLEFATAL: libc::c_uint = 4;
pub const INJECT_ERRTYPE_MEMORY_CORRECTABLE: libc::c_uint = 8;
pub const INJECT_ERRTYPE_MEMORY_UNCORRECTABLENONFATAL: libc::c_uint = 16;
pub const INJECT_ERRTYPE_MEMORY_UNCORRECTABLEFATAL: libc::c_uint = 32;
pub const INJECT_ERRTYPE_PCIEXPRESS_CORRECTABLE: libc::c_uint = 64;
pub const INJECT_ERRTYPE_PCIEXPRESS_UNCORRECTABLENONFATAL: libc::c_uint = 128;
pub const INJECT_ERRTYPE_PCIEXPRESS_UNCORRECTABLEFATAL: libc::c_uint = 256;
pub const INJECT_ERRTYPE_PLATFORM_CORRECTABLE: libc::c_uint = 512;
pub const INJECT_ERRTYPE_PLATFORM_UNCORRECTABLENONFATAL: libc::c_uint = 1024;
pub const INJECT_ERRTYPE_PLATFORM_UNCORRECTABLEFATAL: libc::c_uint = 2048;
pub const WHEA_PLUGIN_REGISTRATION_PACKET_VERSION: libc::c_uint = 65536;
pub const PshedFADiscovery: libc::c_uint = 1;
pub const PshedFAErrorSourceControl: libc::c_uint = 2;
pub const PshedFAErrorRecordPersistence: libc::c_uint = 4;
pub const PshedFAErrorInfoRetrieval: libc::c_uint = 8;
pub const PshedFAErrorRecovery: libc::c_uint = 16;
pub const PshedFAErrorInjection: libc::c_uint = 32;
pub const WHEA_WRITE_FLAG_DUMMY: libc::c_uint = 1;
pub type va_list = *mut libc::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut va_list, ...);
}
pub type __vcrt_bool = bool;
pub type wchar_t = libc::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize);
}
extern "C" {
    #[link_name = "__security_cookie"]
    pub static mut __security_cookie: usize;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _EXCEPTION_DISPOSITION {
    ExceptionContinueExecution = 0,
    ExceptionContinueSearch = 1,
    ExceptionNestedException = 2,
    ExceptionCollidedUnwind = 3,
}
pub use self::_EXCEPTION_DISPOSITION as EXCEPTION_DISPOSITION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _EXCEPTION_RECORD {
    pub ExceptionCode: NTSTATUS,
    pub ExceptionFlags: ULONG,
    pub ExceptionRecord: *mut _EXCEPTION_RECORD,
    pub ExceptionAddress: PVOID,
    pub NumberParameters: ULONG,
    pub ExceptionInformation: [ULONG_PTR; 15usize],
}
#[test]
fn bindgen_test_layout__EXCEPTION_RECORD() {
    assert_eq!(::core::mem::size_of::<_EXCEPTION_RECORD>() , 152usize);
    assert_eq!(::core::mem::align_of::<_EXCEPTION_RECORD>() , 8usize);
}
impl Clone for _EXCEPTION_RECORD {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _CONTEXT {
    pub ContextFlags: ULONG,
    pub Dr0: ULONG,
    pub Dr1: ULONG,
    pub Dr2: ULONG,
    pub Dr3: ULONG,
    pub Dr6: ULONG,
    pub Dr7: ULONG,
    pub FloatSave: FLOATING_SAVE_AREA,
    pub SegGs: ULONG,
    pub SegFs: ULONG,
    pub SegEs: ULONG,
    pub SegDs: ULONG,
    pub Edi: ULONG,
    pub Esi: ULONG,
    pub Ebx: ULONG,
    pub Edx: ULONG,
    pub Ecx: ULONG,
    pub Eax: ULONG,
    pub Ebp: ULONG,
    pub Eip: ULONG,
    pub SegCs: ULONG,
    pub EFlags: ULONG,
    pub Esp: ULONG,
    pub SegSs: ULONG,
    pub ExtendedRegisters: [UCHAR; 512usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DISPATCHER_CONTEXT {
    pub _address: u8,
}
impl Clone for _DISPATCHER_CONTEXT {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn __C_specific_handler(ExceptionRecord: *mut _EXCEPTION_RECORD,
                                EstablisherFrame: *mut libc::c_void,
                                ContextRecord: *mut _CONTEXT,
                                DispatcherContext: *mut _DISPATCHER_CONTEXT)
     -> EXCEPTION_DISPOSITION;
}
extern "C" {
    pub fn _exception_code() -> libc::c_ulong;
}
extern "C" {
    pub fn _exception_info() -> *mut libc::c_void;
}
extern "C" {
    pub fn _abnormal_termination() -> libc::c_int;
}
pub type __crt_bool = bool;
extern "C" {
    pub fn _invalid_parameter_noinfo();
}
extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn();
}
extern "C" {
    pub fn _invoke_watson(arg1: *const wchar_t, arg2: *const wchar_t,
                          arg3: *const wchar_t, arg4: libc::c_uint,
                          arg5: usize);
}
pub type errno_t = libc::c_int;
pub type wint_t = libc::c_ushort;
pub type wctype_t = libc::c_ushort;
pub type __time32_t = libc::c_long;
pub type __time64_t = libc::c_longlong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const libc::c_ushort,
    pub _locale_mb_cur_max: libc::c_int,
    pub _locale_lc_codepage: libc::c_uint,
}
impl Clone for __crt_locale_data_public {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_pointers___crt_locale_data,
    pub mbcinfo: *mut __crt_locale_pointers___crt_multibyte_data,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __crt_locale_pointers___crt_locale_data {
    pub _address: u8,
}
impl Clone for __crt_locale_pointers___crt_locale_data {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __crt_locale_pointers___crt_multibyte_data {
    pub _address: u8,
}
impl Clone for __crt_locale_pointers___crt_multibyte_data {
    fn clone(&self) -> Self { *self }
}
impl Clone for __crt_locale_pointers {
    fn clone(&self) -> Self { *self }
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _Mbstatet {
    pub _Wchar: libc::c_ulong,
    pub _Byte: libc::c_ushort,
    pub _State: libc::c_ushort,
}
impl Clone for _Mbstatet {
    fn clone(&self) -> Self { *self }
}
pub use self::_Mbstatet as mbstate_t;
pub type time_t = __time64_t;
pub type rsize_t = usize;
extern "C" {
    pub fn iswalnum(_C: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn iswalpha(_C: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn iswascii(_C: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn iswblank(_C: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn iswcntrl(_C: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn iswdigit(_C: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn iswgraph(_C: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn iswlower(_C: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn iswprint(_C: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn iswpunct(_C: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn iswspace(_C: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn iswupper(_C: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn iswxdigit(_C: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn __iswcsymf(_C: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn __iswcsym(_C: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn _iswalnum_l(_C: wint_t, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn _iswalpha_l(_C: wint_t, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn _iswblank_l(_C: wint_t, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn _iswcntrl_l(_C: wint_t, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn _iswdigit_l(_C: wint_t, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn _iswgraph_l(_C: wint_t, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn _iswlower_l(_C: wint_t, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn _iswprint_l(_C: wint_t, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn _iswpunct_l(_C: wint_t, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn _iswspace_l(_C: wint_t, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn _iswupper_l(_C: wint_t, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn _iswxdigit_l(_C: wint_t, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn _iswcsymf_l(_C: wint_t, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn _iswcsym_l(_C: wint_t, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn towupper(_C: wint_t) -> wint_t;
}
extern "C" {
    pub fn towlower(_C: wint_t) -> wint_t;
}
extern "C" {
    pub fn iswctype(_C: wint_t, _Type: wctype_t) -> libc::c_int;
}
extern "C" {
    pub fn _towupper_l(_C: wint_t, _Locale: _locale_t) -> wint_t;
}
extern "C" {
    pub fn _towlower_l(_C: wint_t, _Locale: _locale_t) -> wint_t;
}
extern "C" {
    pub fn _iswctype_l(_C: wint_t, _Type: wctype_t, _Locale: _locale_t)
     -> libc::c_int;
}
extern "C" {
    pub fn isleadbyte(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn _isleadbyte_l(_C: libc::c_int, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn is_wctype(_C: wint_t, _Type: wctype_t) -> libc::c_int;
}
extern "C" {
    pub fn _isctype(_C: libc::c_int, _Type: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn _isctype_l(_C: libc::c_int, _Type: libc::c_int, _Locale: _locale_t)
     -> libc::c_int;
}
extern "C" {
    pub fn isalpha(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn _isalpha_l(_C: libc::c_int, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn isupper(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn _isupper_l(_C: libc::c_int, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn islower(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn _islower_l(_C: libc::c_int, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn isdigit(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn _isdigit_l(_C: libc::c_int, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn isxdigit(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn _isxdigit_l(_C: libc::c_int, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn isspace(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn _isspace_l(_C: libc::c_int, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn ispunct(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn _ispunct_l(_C: libc::c_int, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn isblank(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn _isblank_l(_C: libc::c_int, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn isalnum(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn _isalnum_l(_C: libc::c_int, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn isprint(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn _isprint_l(_C: libc::c_int, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn isgraph(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn _isgraph_l(_C: libc::c_int, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn iscntrl(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn _iscntrl_l(_C: libc::c_int, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn toupper(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn tolower(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn _tolower(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn _tolower_l(_C: libc::c_int, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn _toupper(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn _toupper_l(_C: libc::c_int, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn __isascii(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn __toascii(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn __iscsymf(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn __iscsym(_C: libc::c_int) -> libc::c_int;
}
pub type POINTER_64_INT = libc::c_ulonglong;
pub type INT8 = libc::c_char;
pub type PINT8 = *mut libc::c_char;
pub type INT16 = libc::c_short;
pub type PINT16 = *mut libc::c_short;
pub type INT32 = libc::c_int;
pub type PINT32 = *mut libc::c_int;
pub type INT64 = libc::c_longlong;
pub type PINT64 = *mut libc::c_longlong;
pub type UINT8 = libc::c_uchar;
pub type PUINT8 = *mut libc::c_uchar;
pub type UINT16 = libc::c_ushort;
pub type PUINT16 = *mut libc::c_ushort;
pub type UINT32 = libc::c_uint;
pub type PUINT32 = *mut libc::c_uint;
pub type UINT64 = libc::c_ulonglong;
pub type PUINT64 = *mut libc::c_ulonglong;
pub type LONG32 = libc::c_int;
pub type PLONG32 = *mut libc::c_int;
pub type ULONG32 = libc::c_uint;
pub type PULONG32 = *mut libc::c_uint;
pub type DWORD32 = libc::c_uint;
pub type PDWORD32 = *mut libc::c_uint;
pub type INT_PTR = libc::c_longlong;
pub type PINT_PTR = *mut libc::c_longlong;
pub type UINT_PTR = libc::c_ulonglong;
pub type PUINT_PTR = *mut libc::c_ulonglong;
pub type LONG_PTR = libc::c_longlong;
pub type PLONG_PTR = *mut libc::c_longlong;
pub type ULONG_PTR = libc::c_ulonglong;
pub type PULONG_PTR = *mut libc::c_ulonglong;
pub type SHANDLE_PTR = libc::c_longlong;
pub type HANDLE_PTR = libc::c_ulonglong;
pub type UHALF_PTR = libc::c_uint;
pub type PUHALF_PTR = *mut libc::c_uint;
pub type HALF_PTR = libc::c_int;
pub type PHALF_PTR = *mut libc::c_int;
pub type SIZE_T = ULONG_PTR;
pub type PSIZE_T = *mut ULONG_PTR;
pub type SSIZE_T = LONG_PTR;
pub type PSSIZE_T = *mut LONG_PTR;
pub type DWORD_PTR = ULONG_PTR;
pub type PDWORD_PTR = *mut ULONG_PTR;
pub type LONG64 = libc::c_longlong;
pub type PLONG64 = *mut libc::c_longlong;
pub type ULONG64 = libc::c_ulonglong;
pub type PULONG64 = *mut libc::c_ulonglong;
pub type DWORD64 = libc::c_ulonglong;
pub type PDWORD64 = *mut libc::c_ulonglong;
pub type KAFFINITY = ULONG_PTR;
pub type PKAFFINITY = *mut KAFFINITY;
pub type PVOID = *mut libc::c_void;
pub type CHAR = libc::c_char;
pub type SHORT = libc::c_short;
pub type LONG = libc::c_long;
pub type INT = libc::c_int;
pub type WCHAR = wchar_t;
pub type PWCHAR = *mut WCHAR;
pub type LPWCH = *mut WCHAR;
pub type PWCH = *mut WCHAR;
pub type LPCWCH = *const WCHAR;
pub type PCWCH = *const WCHAR;
pub type NWPSTR = *mut WCHAR;
pub type LPWSTR = *mut WCHAR;
pub type PWSTR = *mut WCHAR;
pub type PZPWSTR = *mut PWSTR;
pub type PCZPWSTR = *const PWSTR;
pub type LPUWSTR = *mut WCHAR;
pub type PUWSTR = *mut WCHAR;
pub type LPCWSTR = *const WCHAR;
pub type PCWSTR = *const WCHAR;
pub type PZPCWSTR = *mut PCWSTR;
pub type PCZPCWSTR = *const PCWSTR;
pub type LPCUWSTR = *const WCHAR;
pub type PCUWSTR = *const WCHAR;
pub type PZZWSTR = *mut WCHAR;
pub type PCZZWSTR = *const WCHAR;
pub type PUZZWSTR = *mut WCHAR;
pub type PCUZZWSTR = *const WCHAR;
pub type PNZWCH = *mut WCHAR;
pub type PCNZWCH = *const WCHAR;
pub type PUNZWCH = *mut WCHAR;
pub type PCUNZWCH = *const WCHAR;
pub type PCHAR = *mut CHAR;
pub type LPCH = *mut CHAR;
pub type PCH = *mut CHAR;
pub type LPCCH = *const CHAR;
pub type PCCH = *const CHAR;
pub type NPSTR = *mut CHAR;
pub type LPSTR = *mut CHAR;
pub type PSTR = *mut CHAR;
pub type PZPSTR = *mut PSTR;
pub type PCZPSTR = *const PSTR;
pub type LPCSTR = *const CHAR;
pub type PCSTR = *const CHAR;
pub type PZPCSTR = *mut PCSTR;
pub type PCZPCSTR = *const PCSTR;
pub type PZZSTR = *mut CHAR;
pub type PCZZSTR = *const CHAR;
pub type PNZCH = *mut CHAR;
pub type PCNZCH = *const CHAR;
pub type TCHAR = libc::c_char;
pub type PTCHAR = *mut libc::c_char;
pub type TUCHAR = libc::c_uchar;
pub type PTUCHAR = *mut libc::c_uchar;
pub type LPTCH = LPCH;
pub type PTCH = LPCH;
pub type LPCTCH = LPCCH;
pub type PCTCH = LPCCH;
pub type PTSTR = LPSTR;
pub type LPTSTR = LPSTR;
pub type PUTSTR = LPSTR;
pub type LPUTSTR = LPSTR;
pub type PCTSTR = LPCSTR;
pub type LPCTSTR = LPCSTR;
pub type PCUTSTR = LPCSTR;
pub type LPCUTSTR = LPCSTR;
pub type PZZTSTR = PZZSTR;
pub type PUZZTSTR = PZZSTR;
pub type PCZZTSTR = PCZZSTR;
pub type PCUZZTSTR = PCZZSTR;
pub type PZPTSTR = PZPSTR;
pub type PNZTCH = PNZCH;
pub type PUNZTCH = PNZCH;
pub type PCNZTCH = PCNZCH;
pub type PCUNZTCH = PCNZCH;
pub type DOUBLE = f64;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _QUAD {
    pub __bindgen_anon_1: _QUAD__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _QUAD__bindgen_ty_1 {
    pub UseThisFieldToCopy: __BindgenUnionField<libc::c_longlong>,
    pub DoNotUseThisField: __BindgenUnionField<f64>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__QUAD__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_QUAD__bindgen_ty_1>() , 8usize);
    assert_eq!(::core::mem::align_of::<_QUAD__bindgen_ty_1>() , 8usize);
}
impl Clone for _QUAD__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__QUAD() {
    assert_eq!(::core::mem::size_of::<_QUAD>() , 8usize);
    assert_eq!(::core::mem::align_of::<_QUAD>() , 8usize);
}
impl Clone for _QUAD {
    fn clone(&self) -> Self { *self }
}
pub use self::_QUAD as QUAD;
pub type PSHORT = *mut SHORT;
pub type PLONG = *mut LONG;
pub type PQUAD = *mut QUAD;
pub type UCHAR = libc::c_uchar;
pub type USHORT = libc::c_ushort;
pub type ULONG = libc::c_ulong;
pub use self::QUAD as UQUAD;
pub type PUCHAR = *mut UCHAR;
pub type PUSHORT = *mut USHORT;
pub type PULONG = *mut ULONG;
pub type PUQUAD = *mut UQUAD;
pub type SCHAR = libc::c_char;
pub type PSCHAR = *mut SCHAR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESSOR_NUMBER {
    pub Group: USHORT,
    pub Number: UCHAR,
    pub Reserved: UCHAR,
}
#[test]
fn bindgen_test_layout__PROCESSOR_NUMBER() {
    assert_eq!(::core::mem::size_of::<_PROCESSOR_NUMBER>() , 4usize);
    assert_eq!(::core::mem::align_of::<_PROCESSOR_NUMBER>() , 2usize);
}
impl Clone for _PROCESSOR_NUMBER {
    fn clone(&self) -> Self { *self }
}
pub use self::_PROCESSOR_NUMBER as PROCESSOR_NUMBER;
pub type PPROCESSOR_NUMBER = *mut _PROCESSOR_NUMBER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GROUP_AFFINITY {
    pub Mask: KAFFINITY,
    pub Group: USHORT,
    pub Reserved: [USHORT; 3usize],
}
#[test]
fn bindgen_test_layout__GROUP_AFFINITY() {
    assert_eq!(::core::mem::size_of::<_GROUP_AFFINITY>() , 16usize);
    assert_eq!(::core::mem::align_of::<_GROUP_AFFINITY>() , 8usize);
}
impl Clone for _GROUP_AFFINITY {
    fn clone(&self) -> Self { *self }
}
pub use self::_GROUP_AFFINITY as GROUP_AFFINITY;
pub type PGROUP_AFFINITY = *mut _GROUP_AFFINITY;
pub type HANDLE = *mut libc::c_void;
pub type PHANDLE = *mut HANDLE;
pub type FCHAR = UCHAR;
pub type FSHORT = USHORT;
pub type FLONG = ULONG;
pub type HRESULT = libc::c_long;
pub type CCHAR = libc::c_char;
pub type CSHORT = libc::c_short;
pub type CLONG = ULONG;
pub type PCCHAR = *mut CCHAR;
pub type PCSHORT = *mut CSHORT;
pub type PCLONG = *mut CLONG;
pub type LCID = ULONG;
pub type PLCID = PULONG;
pub type LANGID = USHORT;
pub const UNSPECIFIED_COMPARTMENT_ID: _bindgen_ty_1 =
    _bindgen_ty_1::UNSPECIFIED_COMPARTMENT_ID;
pub const DEFAULT_COMPARTMENT_ID: _bindgen_ty_1 =
    _bindgen_ty_1::DEFAULT_COMPARTMENT_ID;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    UNSPECIFIED_COMPARTMENT_ID = 0,
    DEFAULT_COMPARTMENT_ID = 1,
}
pub use self::_bindgen_ty_1 as COMPARTMENT_ID;
pub type PCOMPARTMENT_ID = *mut _bindgen_ty_1;
pub type LOGICAL = ULONG;
pub type PLOGICAL = *mut ULONG;
pub type NTSTATUS = LONG;
pub type PNTSTATUS = *mut NTSTATUS;
pub type SECURITY_STATUS = libc::c_long;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _FLOAT128 {
    pub LowPart: libc::c_longlong,
    pub HighPart: libc::c_longlong,
}
#[test]
fn bindgen_test_layout__FLOAT128() {
    assert_eq!(::core::mem::size_of::<_FLOAT128>() , 16usize);
    assert_eq!(::core::mem::align_of::<_FLOAT128>() , 8usize);
}
impl Clone for _FLOAT128 {
    fn clone(&self) -> Self { *self }
}
pub use self::_FLOAT128 as FLOAT128;
pub type PFLOAT128 = *mut FLOAT128;
pub type LONGLONG = libc::c_longlong;
pub type ULONGLONG = libc::c_ulonglong;
pub type PLONGLONG = *mut LONGLONG;
pub type PULONGLONG = *mut ULONGLONG;
pub type USN = LONGLONG;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _LARGE_INTEGER {
    pub __bindgen_anon_1: __BindgenUnionField<_LARGE_INTEGER__bindgen_ty_1>,
    pub u: __BindgenUnionField<_LARGE_INTEGER__bindgen_ty_2>,
    pub QuadPart: __BindgenUnionField<LONGLONG>,
    pub bindgen_union_field: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _LARGE_INTEGER__bindgen_ty_1 {
    pub LowPart: ULONG,
    pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_LARGE_INTEGER__bindgen_ty_1>() ,
               8usize);
    assert_eq!(::core::mem::align_of::<_LARGE_INTEGER__bindgen_ty_1>() ,
               4usize);
}
impl Clone for _LARGE_INTEGER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _LARGE_INTEGER__bindgen_ty_2 {
    pub LowPart: ULONG,
    pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<_LARGE_INTEGER__bindgen_ty_2>() ,
               8usize);
    assert_eq!(::core::mem::align_of::<_LARGE_INTEGER__bindgen_ty_2>() ,
               4usize);
}
impl Clone for _LARGE_INTEGER__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER() {
    assert_eq!(::core::mem::size_of::<_LARGE_INTEGER>() , 8usize);
    assert_eq!(::core::mem::align_of::<_LARGE_INTEGER>() , 8usize);
}
impl Clone for _LARGE_INTEGER {
    fn clone(&self) -> Self { *self }
}
pub use self::_LARGE_INTEGER as LARGE_INTEGER;
pub type PLARGE_INTEGER = *mut LARGE_INTEGER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _ULARGE_INTEGER {
    pub __bindgen_anon_1: __BindgenUnionField<_ULARGE_INTEGER__bindgen_ty_1>,
    pub u: __BindgenUnionField<_ULARGE_INTEGER__bindgen_ty_2>,
    pub QuadPart: __BindgenUnionField<ULONGLONG>,
    pub bindgen_union_field: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _ULARGE_INTEGER__bindgen_ty_1 {
    pub LowPart: ULONG,
    pub HighPart: ULONG,
}
#[test]
fn bindgen_test_layout__ULARGE_INTEGER__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_ULARGE_INTEGER__bindgen_ty_1>() ,
               8usize);
    assert_eq!(::core::mem::align_of::<_ULARGE_INTEGER__bindgen_ty_1>() ,
               4usize);
}
impl Clone for _ULARGE_INTEGER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _ULARGE_INTEGER__bindgen_ty_2 {
    pub LowPart: ULONG,
    pub HighPart: ULONG,
}
#[test]
fn bindgen_test_layout__ULARGE_INTEGER__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<_ULARGE_INTEGER__bindgen_ty_2>() ,
               8usize);
    assert_eq!(::core::mem::align_of::<_ULARGE_INTEGER__bindgen_ty_2>() ,
               4usize);
}
impl Clone for _ULARGE_INTEGER__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__ULARGE_INTEGER() {
    assert_eq!(::core::mem::size_of::<_ULARGE_INTEGER>() , 8usize);
    assert_eq!(::core::mem::align_of::<_ULARGE_INTEGER>() , 8usize);
}
impl Clone for _ULARGE_INTEGER {
    fn clone(&self) -> Self { *self }
}
pub use self::_ULARGE_INTEGER as ULARGE_INTEGER;
pub type PULARGE_INTEGER = *mut ULARGE_INTEGER;
pub type RTL_REFERENCE_COUNT = LONG_PTR;
pub type PRTL_REFERENCE_COUNT = *mut LONG_PTR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _LUID {
    pub LowPart: ULONG,
    pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LUID() {
    assert_eq!(::core::mem::size_of::<_LUID>() , 8usize);
    assert_eq!(::core::mem::align_of::<_LUID>() , 4usize);
}
impl Clone for _LUID {
    fn clone(&self) -> Self { *self }
}
pub use self::_LUID as LUID;
pub type PLUID = *mut _LUID;
pub type DWORDLONG = ULONGLONG;
pub type PDWORDLONG = *mut DWORDLONG;
pub use self::LARGE_INTEGER as PHYSICAL_ADDRESS;
pub type PPHYSICAL_ADDRESS = *mut LARGE_INTEGER;
extern "C" {
    pub fn _rotl8(Value: libc::c_uchar, Shift: libc::c_uchar)
     -> libc::c_uchar;
}
extern "C" {
    pub fn _rotl16(Value: libc::c_ushort, Shift: libc::c_uchar)
     -> libc::c_ushort;
}
extern "C" {
    pub fn _rotr8(Value: libc::c_uchar, Shift: libc::c_uchar)
     -> libc::c_uchar;
}
extern "C" {
    pub fn _rotr16(Value: libc::c_ushort, Shift: libc::c_uchar)
     -> libc::c_ushort;
}
extern "C" {
    pub fn _rotl(Value: libc::c_uint, Shift: libc::c_int) -> libc::c_uint;
}
extern "C" {
    pub fn _rotl64(Value: libc::c_ulonglong, Shift: libc::c_int)
     -> libc::c_ulonglong;
}
extern "C" {
    pub fn _rotr(Value: libc::c_uint, Shift: libc::c_int) -> libc::c_uint;
}
extern "C" {
    pub fn _rotr64(Value: libc::c_ulonglong, Shift: libc::c_int)
     -> libc::c_ulonglong;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _EVENT_TYPE { NotificationEvent = 0, SynchronizationEvent = 1, }
pub use self::_EVENT_TYPE as EVENT_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _TIMER_TYPE { NotificationTimer = 0, SynchronizationTimer = 1, }
pub use self::_TIMER_TYPE as TIMER_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _WAIT_TYPE {
    WaitAll = 0,
    WaitAny = 1,
    WaitNotification = 2,
    WaitDequeue = 3,
}
pub use self::_WAIT_TYPE as WAIT_TYPE;
pub type PSZ = *mut CHAR;
pub type PCSZ = *const libc::c_char;
pub type RTL_STRING_LENGTH_TYPE = USHORT;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _STRING {
    pub Length: USHORT,
    pub MaximumLength: USHORT,
    pub Buffer: PCHAR,
}
#[test]
fn bindgen_test_layout__STRING() {
    assert_eq!(::core::mem::size_of::<_STRING>() , 16usize);
    assert_eq!(::core::mem::align_of::<_STRING>() , 8usize);
}
impl Clone for _STRING {
    fn clone(&self) -> Self { *self }
}
pub use self::_STRING as STRING;
pub type PSTRING = *mut STRING;
pub use self::STRING as ANSI_STRING;
pub type PANSI_STRING = PSTRING;
pub use self::STRING as OEM_STRING;
pub type POEM_STRING = PSTRING;
pub type PCOEM_STRING = *const STRING;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CSTRING {
    pub Length: USHORT,
    pub MaximumLength: USHORT,
    pub Buffer: *const libc::c_char,
}
#[test]
fn bindgen_test_layout__CSTRING() {
    assert_eq!(::core::mem::size_of::<_CSTRING>() , 16usize);
    assert_eq!(::core::mem::align_of::<_CSTRING>() , 8usize);
}
impl Clone for _CSTRING {
    fn clone(&self) -> Self { *self }
}
pub use self::_CSTRING as CSTRING;
pub type PCSTRING = *mut CSTRING;
pub use self::STRING as CANSI_STRING;
pub type PCANSI_STRING = PSTRING;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _UNICODE_STRING {
    pub Length: USHORT,
    pub MaximumLength: USHORT,
    pub Buffer: PWCH,
}
#[test]
fn bindgen_test_layout__UNICODE_STRING() {
    assert_eq!(::core::mem::size_of::<_UNICODE_STRING>() , 16usize);
    assert_eq!(::core::mem::align_of::<_UNICODE_STRING>() , 8usize);
}
impl Clone for _UNICODE_STRING {
    fn clone(&self) -> Self { *self }
}
pub use self::_UNICODE_STRING as UNICODE_STRING;
pub type PUNICODE_STRING = *mut UNICODE_STRING;
pub type PCUNICODE_STRING = *const UNICODE_STRING;
pub type BOOLEAN = UCHAR;
pub type PBOOLEAN = *mut BOOLEAN;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _LIST_ENTRY {
    pub Flink: *mut _LIST_ENTRY,
    pub Blink: *mut _LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__LIST_ENTRY() {
    assert_eq!(::core::mem::size_of::<_LIST_ENTRY>() , 16usize);
    assert_eq!(::core::mem::align_of::<_LIST_ENTRY>() , 8usize);
}
impl Clone for _LIST_ENTRY {
    fn clone(&self) -> Self { *self }
}
pub use self::_LIST_ENTRY as LIST_ENTRY;
pub type PLIST_ENTRY = *mut _LIST_ENTRY;
pub type PRLIST_ENTRY = *mut _LIST_ENTRY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SINGLE_LIST_ENTRY {
    pub Next: *mut _SINGLE_LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__SINGLE_LIST_ENTRY() {
    assert_eq!(::core::mem::size_of::<_SINGLE_LIST_ENTRY>() , 8usize);
    assert_eq!(::core::mem::align_of::<_SINGLE_LIST_ENTRY>() , 8usize);
}
impl Clone for _SINGLE_LIST_ENTRY {
    fn clone(&self) -> Self { *self }
}
pub use self::_SINGLE_LIST_ENTRY as SINGLE_LIST_ENTRY;
pub type PSINGLE_LIST_ENTRY = *mut _SINGLE_LIST_ENTRY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _RTL_BALANCED_NODE {
    pub __bindgen_anon_1: _RTL_BALANCED_NODE__bindgen_ty_1,
    pub __bindgen_anon_2: _RTL_BALANCED_NODE__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _RTL_BALANCED_NODE__bindgen_ty_1 {
    pub Children: __BindgenUnionField<[*mut _RTL_BALANCED_NODE; 2usize]>,
    pub __bindgen_anon_1: __BindgenUnionField<_RTL_BALANCED_NODE__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _RTL_BALANCED_NODE__bindgen_ty_1__bindgen_ty_1 {
    pub Left: *mut _RTL_BALANCED_NODE,
    pub Right: *mut _RTL_BALANCED_NODE,
}
#[test]
fn bindgen_test_layout__RTL_BALANCED_NODE__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_RTL_BALANCED_NODE__bindgen_ty_1__bindgen_ty_1>()
               , 16usize);
    assert_eq!(::core::mem::align_of::<_RTL_BALANCED_NODE__bindgen_ty_1__bindgen_ty_1>()
               , 8usize);
}
impl Clone for _RTL_BALANCED_NODE__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__RTL_BALANCED_NODE__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_RTL_BALANCED_NODE__bindgen_ty_1>() ,
               16usize);
    assert_eq!(::core::mem::align_of::<_RTL_BALANCED_NODE__bindgen_ty_1>() ,
               8usize);
}
impl Clone for _RTL_BALANCED_NODE__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _RTL_BALANCED_NODE__bindgen_ty_2 {
    pub _bitfield_1: u8,
    pub ParentValue: __BindgenUnionField<ULONG_PTR>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__RTL_BALANCED_NODE__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<_RTL_BALANCED_NODE__bindgen_ty_2>() ,
               8usize);
    assert_eq!(::core::mem::align_of::<_RTL_BALANCED_NODE__bindgen_ty_2>() ,
               8usize);
}
impl Clone for _RTL_BALANCED_NODE__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl _RTL_BALANCED_NODE__bindgen_ty_2 {
    #[inline]
    pub fn Red(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                        0u32) as u8)
        }
    }
    #[inline]
    pub fn set_Red(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 0u32) & (1usize as u8);
    }
    #[inline]
    pub fn Balance(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (6usize as u8)) >>
                                        1u32) as u8)
        }
    }
    #[inline]
    pub fn set_Balance(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(6usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 1u32) & (6usize as u8);
    }
}
#[test]
fn bindgen_test_layout__RTL_BALANCED_NODE() {
    assert_eq!(::core::mem::size_of::<_RTL_BALANCED_NODE>() , 24usize);
    assert_eq!(::core::mem::align_of::<_RTL_BALANCED_NODE>() , 8usize);
}
impl Clone for _RTL_BALANCED_NODE {
    fn clone(&self) -> Self { *self }
}
pub use self::_RTL_BALANCED_NODE as RTL_BALANCED_NODE;
pub type PRTL_BALANCED_NODE = *mut _RTL_BALANCED_NODE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct LIST_ENTRY32 {
    pub Flink: ULONG,
    pub Blink: ULONG,
}
#[test]
fn bindgen_test_layout_LIST_ENTRY32() {
    assert_eq!(::core::mem::size_of::<LIST_ENTRY32>() , 8usize);
    assert_eq!(::core::mem::align_of::<LIST_ENTRY32>() , 4usize);
}
impl Clone for LIST_ENTRY32 {
    fn clone(&self) -> Self { *self }
}
pub type PLIST_ENTRY32 = *mut LIST_ENTRY32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct LIST_ENTRY64 {
    pub Flink: ULONGLONG,
    pub Blink: ULONGLONG,
}
#[test]
fn bindgen_test_layout_LIST_ENTRY64() {
    assert_eq!(::core::mem::size_of::<LIST_ENTRY64>() , 16usize);
    assert_eq!(::core::mem::align_of::<LIST_ENTRY64>() , 8usize);
}
impl Clone for LIST_ENTRY64 {
    fn clone(&self) -> Self { *self }
}
pub type PLIST_ENTRY64 = *mut LIST_ENTRY64;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SINGLE_LIST_ENTRY32 {
    pub Next: ULONG,
}
#[test]
fn bindgen_test_layout__SINGLE_LIST_ENTRY32() {
    assert_eq!(::core::mem::size_of::<_SINGLE_LIST_ENTRY32>() , 4usize);
    assert_eq!(::core::mem::align_of::<_SINGLE_LIST_ENTRY32>() , 4usize);
}
impl Clone for _SINGLE_LIST_ENTRY32 {
    fn clone(&self) -> Self { *self }
}
pub use self::_SINGLE_LIST_ENTRY32 as SINGLE_LIST_ENTRY32;
pub type PSINGLE_LIST_ENTRY32 = *mut _SINGLE_LIST_ENTRY32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _STRING32 {
    pub Length: USHORT,
    pub MaximumLength: USHORT,
    pub Buffer: ULONG,
}
#[test]
fn bindgen_test_layout__STRING32() {
    assert_eq!(::core::mem::size_of::<_STRING32>() , 8usize);
    assert_eq!(::core::mem::align_of::<_STRING32>() , 4usize);
}
impl Clone for _STRING32 {
    fn clone(&self) -> Self { *self }
}
pub use self::_STRING32 as STRING32;
pub type PSTRING32 = *mut STRING32;
pub use self::STRING32 as UNICODE_STRING32;
pub type PUNICODE_STRING32 = *mut UNICODE_STRING32;
pub use self::STRING32 as ANSI_STRING32;
pub type PANSI_STRING32 = *mut ANSI_STRING32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _STRING64 {
    pub Length: USHORT,
    pub MaximumLength: USHORT,
    pub Buffer: ULONGLONG,
}
#[test]
fn bindgen_test_layout__STRING64() {
    assert_eq!(::core::mem::size_of::<_STRING64>() , 16usize);
    assert_eq!(::core::mem::align_of::<_STRING64>() , 8usize);
}
impl Clone for _STRING64 {
    fn clone(&self) -> Self { *self }
}
pub use self::_STRING64 as STRING64;
pub type PSTRING64 = *mut STRING64;
pub use self::STRING64 as UNICODE_STRING64;
pub type PUNICODE_STRING64 = *mut UNICODE_STRING64;
pub use self::STRING64 as ANSI_STRING64;
pub type PANSI_STRING64 = *mut ANSI_STRING64;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _OBJECT_ATTRIBUTES64 {
    pub Length: ULONG,
    pub RootDirectory: ULONG64,
    pub ObjectName: ULONG64,
    pub Attributes: ULONG,
    pub SecurityDescriptor: ULONG64,
    pub SecurityQualityOfService: ULONG64,
}
#[test]
fn bindgen_test_layout__OBJECT_ATTRIBUTES64() {
    assert_eq!(::core::mem::size_of::<_OBJECT_ATTRIBUTES64>() , 48usize);
    assert_eq!(::core::mem::align_of::<_OBJECT_ATTRIBUTES64>() , 8usize);
}
impl Clone for _OBJECT_ATTRIBUTES64 {
    fn clone(&self) -> Self { *self }
}
pub use self::_OBJECT_ATTRIBUTES64 as OBJECT_ATTRIBUTES64;
pub type POBJECT_ATTRIBUTES64 = *mut OBJECT_ATTRIBUTES64;
pub type PCOBJECT_ATTRIBUTES64 = *const OBJECT_ATTRIBUTES64;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _OBJECT_ATTRIBUTES32 {
    pub Length: ULONG,
    pub RootDirectory: ULONG,
    pub ObjectName: ULONG,
    pub Attributes: ULONG,
    pub SecurityDescriptor: ULONG,
    pub SecurityQualityOfService: ULONG,
}
#[test]
fn bindgen_test_layout__OBJECT_ATTRIBUTES32() {
    assert_eq!(::core::mem::size_of::<_OBJECT_ATTRIBUTES32>() , 24usize);
    assert_eq!(::core::mem::align_of::<_OBJECT_ATTRIBUTES32>() , 4usize);
}
impl Clone for _OBJECT_ATTRIBUTES32 {
    fn clone(&self) -> Self { *self }
}
pub use self::_OBJECT_ATTRIBUTES32 as OBJECT_ATTRIBUTES32;
pub type POBJECT_ATTRIBUTES32 = *mut OBJECT_ATTRIBUTES32;
pub type PCOBJECT_ATTRIBUTES32 = *const OBJECT_ATTRIBUTES32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _OBJECT_ATTRIBUTES {
    pub Length: ULONG,
    pub RootDirectory: HANDLE,
    pub ObjectName: PUNICODE_STRING,
    pub Attributes: ULONG,
    pub SecurityDescriptor: PVOID,
    pub SecurityQualityOfService: PVOID,
}
#[test]
fn bindgen_test_layout__OBJECT_ATTRIBUTES() {
    assert_eq!(::core::mem::size_of::<_OBJECT_ATTRIBUTES>() , 48usize);
    assert_eq!(::core::mem::align_of::<_OBJECT_ATTRIBUTES>() , 8usize);
}
impl Clone for _OBJECT_ATTRIBUTES {
    fn clone(&self) -> Self { *self }
}
pub use self::_OBJECT_ATTRIBUTES as OBJECT_ATTRIBUTES;
pub type POBJECT_ATTRIBUTES = *mut OBJECT_ATTRIBUTES;
pub type PCOBJECT_ATTRIBUTES = *const OBJECT_ATTRIBUTES;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GUID {
    pub Data1: libc::c_ulong,
    pub Data2: libc::c_ushort,
    pub Data3: libc::c_ushort,
    pub Data4: [libc::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout__GUID() {
    assert_eq!(::core::mem::size_of::<_GUID>() , 16usize);
    assert_eq!(::core::mem::align_of::<_GUID>() , 4usize);
}
impl Clone for _GUID {
    fn clone(&self) -> Self { *self }
}
pub use self::_GUID as GUID;
pub type LPGUID = *mut GUID;
pub type LPCGUID = *const GUID;
pub use self::GUID as IID;
pub type LPIID = *mut IID;
pub use self::GUID as CLSID;
pub type LPCLSID = *mut CLSID;
pub use self::GUID as FMTID;
pub type LPFMTID = *mut FMTID;
extern "C" {
    pub fn _errno() -> *mut libc::c_int;
}
extern "C" {
    pub fn _set_errno(_Value: libc::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_errno(_Value: *mut libc::c_int) -> errno_t;
}
extern "C" {
    pub fn __doserrno() -> *mut libc::c_ulong;
}
extern "C" {
    pub fn _set_doserrno(_Value: libc::c_ulong) -> errno_t;
}
extern "C" {
    pub fn _get_doserrno(_Value: *mut libc::c_ulong) -> errno_t;
}
extern "C" {
    pub fn memchr(_Buf: *const libc::c_void, _Val: libc::c_int,
                  _MaxCount: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn memcmp(_Buf1: *const libc::c_void, _Buf2: *const libc::c_void,
                  _Size: usize) -> libc::c_int;
}
extern "C" {
    pub fn memcpy(_Dst: *mut libc::c_void, _Src: *const libc::c_void,
                  _Size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn memmove(_Dst: *mut libc::c_void, _Src: *const libc::c_void,
                   _Size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn memset(_Dst: *mut libc::c_void, _Val: libc::c_int, _Size: usize)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn strchr(_Str: *const libc::c_char, _Val: libc::c_int)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn strrchr(_Str: *const libc::c_char, _Ch: libc::c_int)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn strstr(_Str: *const libc::c_char, _SubStr: *const libc::c_char)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn wcschr(_Str: *const wchar_t, _Ch: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsrchr(_Str: *const wchar_t, _Ch: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsstr(_Str: *const wchar_t, _SubStr: *const wchar_t)
     -> *mut wchar_t;
}
extern "C" {
    pub fn _memicmp(_Buf1: *const libc::c_void, _Buf2: *const libc::c_void,
                    _Size: usize) -> libc::c_int;
}
extern "C" {
    pub fn _memicmp_l(_Buf1: *const libc::c_void, _Buf2: *const libc::c_void,
                      _Size: usize, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn memccpy(_Dst: *mut libc::c_void, _Src: *const libc::c_void,
                   _Val: libc::c_int, _Size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn memicmp(_Buf1: *const libc::c_void, _Buf2: *const libc::c_void,
                   _Size: usize) -> libc::c_int;
}
extern "C" {
    pub fn wcscat_s(_Destination: *mut wchar_t, _SizeInWords: rsize_t,
                    _Source: *const wchar_t) -> errno_t;
}
extern "C" {
    pub fn wcscpy_s(_Destination: *mut wchar_t, _SizeInWords: rsize_t,
                    _Source: *const wchar_t) -> errno_t;
}
extern "C" {
    pub fn wcsncat_s(_Destination: *mut wchar_t, _SizeInWords: rsize_t,
                     _Source: *const wchar_t, _MaxCount: rsize_t) -> errno_t;
}
extern "C" {
    pub fn wcsncpy_s(_Destination: *mut wchar_t, _SizeInWords: rsize_t,
                     _Source: *const wchar_t, _MaxCount: rsize_t) -> errno_t;
}
extern "C" {
    pub fn wcstok_s(_String: *mut wchar_t, _Delimiter: *const wchar_t,
                    _Context: *mut *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsdup(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscat(_Destination: *mut wchar_t, _Source: *const wchar_t)
     -> *mut wchar_t;
}
extern "C" {
    pub fn wcscmp(_String1: *const wchar_t, _String2: *const wchar_t)
     -> libc::c_int;
}
extern "C" {
    pub fn wcscpy(_Destination: *mut wchar_t, _Source: *const wchar_t)
     -> *mut wchar_t;
}
extern "C" {
    pub fn wcscspn(_String: *const wchar_t, _Control: *const wchar_t)
     -> usize;
}
extern "C" {
    pub fn wcslen(_String: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcsnlen(_Source: *const wchar_t, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn wcsncat(_Destination: *mut wchar_t, _Source: *const wchar_t,
                   _Count: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncmp(_String1: *const wchar_t, _String2: *const wchar_t,
                   _MaxCount: usize) -> libc::c_int;
}
extern "C" {
    pub fn wcsncpy(_Destination: *mut wchar_t, _Source: *const wchar_t,
                   _Count: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn wcspbrk(_String: *const wchar_t, _Control: *const wchar_t)
     -> *mut wchar_t;
}
extern "C" {
    pub fn wcsspn(_String: *const wchar_t, _Control: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcstok(_String: *mut wchar_t, _Delimiter: *const wchar_t,
                  _Context: *mut *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcserror(_ErrorNumber: libc::c_int) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcserror_s(_Buffer: *mut wchar_t, _SizeInWords: usize,
                       _ErrorNumber: libc::c_int) -> errno_t;
}
extern "C" {
    pub fn __wcserror(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn __wcserror_s(_Buffer: *mut wchar_t, _SizeInWords: usize,
                        _ErrorMessage: *const wchar_t) -> errno_t;
}
extern "C" {
    pub fn _wcsicmp(_String1: *const wchar_t, _String2: *const wchar_t)
     -> libc::c_int;
}
extern "C" {
    pub fn _wcsicmp_l(_String1: *const wchar_t, _String2: *const wchar_t,
                      _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn _wcsnicmp(_String1: *const wchar_t, _String2: *const wchar_t,
                     _MaxCount: usize) -> libc::c_int;
}
extern "C" {
    pub fn _wcsnicmp_l(_String1: *const wchar_t, _String2: *const wchar_t,
                       _MaxCount: usize, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn _wcsnset_s(_Destination: *mut wchar_t, _SizeInWords: usize,
                      _Value: wchar_t, _MaxCount: usize) -> errno_t;
}
extern "C" {
    pub fn _wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: usize)
     -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsset_s(_Destination: *mut wchar_t, _SizeInWords: usize,
                     _Value: wchar_t) -> errno_t;
}
extern "C" {
    pub fn _wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcslwr_s(_String: *mut wchar_t, _SizeInWords: usize) -> errno_t;
}
extern "C" {
    pub fn _wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcslwr_s_l(_String: *mut wchar_t, _SizeInWords: usize,
                       _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcslwr_l(_String: *mut wchar_t, _Locale: _locale_t)
     -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsupr_s(_String: *mut wchar_t, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsupr_s_l(_String: *mut wchar_t, _Size: usize,
                       _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcsupr_l(_String: *mut wchar_t, _Locale: _locale_t)
     -> *mut wchar_t;
}
extern "C" {
    pub fn wcsxfrm(_Destination: *mut wchar_t, _Source: *const wchar_t,
                   _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _wcsxfrm_l(_Destination: *mut wchar_t, _Source: *const wchar_t,
                      _MaxCount: usize, _Locale: _locale_t) -> usize;
}
extern "C" {
    pub fn wcscoll(_String1: *const wchar_t, _String2: *const wchar_t)
     -> libc::c_int;
}
extern "C" {
    pub fn _wcscoll_l(_String1: *const wchar_t, _String2: *const wchar_t,
                      _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn _wcsicoll(_String1: *const wchar_t, _String2: *const wchar_t)
     -> libc::c_int;
}
extern "C" {
    pub fn _wcsicoll_l(_String1: *const wchar_t, _String2: *const wchar_t,
                       _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn _wcsncoll(_String1: *const wchar_t, _String2: *const wchar_t,
                     _MaxCount: usize) -> libc::c_int;
}
extern "C" {
    pub fn _wcsncoll_l(_String1: *const wchar_t, _String2: *const wchar_t,
                       _MaxCount: usize, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn _wcsnicoll(_String1: *const wchar_t, _String2: *const wchar_t,
                      _MaxCount: usize) -> libc::c_int;
}
extern "C" {
    pub fn _wcsnicoll_l(_String1: *const wchar_t, _String2: *const wchar_t,
                        _MaxCount: usize, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn wcsdup(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsicmp(_String1: *const wchar_t, _String2: *const wchar_t)
     -> libc::c_int;
}
extern "C" {
    pub fn wcsnicmp(_String1: *const wchar_t, _String2: *const wchar_t,
                    _MaxCount: usize) -> libc::c_int;
}
extern "C" {
    pub fn wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: usize)
     -> *mut wchar_t;
}
extern "C" {
    pub fn wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsicoll(_String1: *const wchar_t, _String2: *const wchar_t)
     -> libc::c_int;
}
extern "C" {
    pub fn strcpy_s(_Destination: *mut libc::c_char, _SizeInBytes: rsize_t,
                    _Source: *const libc::c_char) -> errno_t;
}
extern "C" {
    pub fn strcat_s(_Destination: *mut libc::c_char, _SizeInBytes: rsize_t,
                    _Source: *const libc::c_char) -> errno_t;
}
extern "C" {
    pub fn strerror_s(_Buffer: *mut libc::c_char, _SizeInBytes: usize,
                      _ErrorNumber: libc::c_int) -> errno_t;
}
extern "C" {
    pub fn strncat_s(_Destination: *mut libc::c_char, _SizeInBytes: rsize_t,
                     _Source: *const libc::c_char, _MaxCount: rsize_t)
     -> errno_t;
}
extern "C" {
    pub fn strncpy_s(_Destination: *mut libc::c_char, _SizeInBytes: rsize_t,
                     _Source: *const libc::c_char, _MaxCount: rsize_t)
     -> errno_t;
}
extern "C" {
    pub fn strtok_s(_String: *mut libc::c_char,
                    _Delimiter: *const libc::c_char,
                    _Context: *mut *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn _memccpy(_Dst: *mut libc::c_void, _Src: *const libc::c_void,
                    _Val: libc::c_int, _MaxCount: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn strcat(_Destination: *mut libc::c_char,
                  _Source: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strcmp(_Str1: *const libc::c_char, _Str2: *const libc::c_char)
     -> libc::c_int;
}
extern "C" {
    pub fn _strcmpi(_String1: *const libc::c_char,
                    _String2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn strcoll(_String1: *const libc::c_char,
                   _String2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn _strcoll_l(_String1: *const libc::c_char,
                      _String2: *const libc::c_char, _Locale: _locale_t)
     -> libc::c_int;
}
extern "C" {
    pub fn strcpy(_Destination: *mut libc::c_char,
                  _Source: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strcspn(_Str: *const libc::c_char, _Control: *const libc::c_char)
     -> libc::c_ulonglong;
}
extern "C" {
    pub fn _strdup(_Source: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn _strerror(_ErrorMessage: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn _strerror_s(_Buffer: *mut libc::c_char, _SizeInBytes: usize,
                       _ErrorMessage: *const libc::c_char) -> errno_t;
}
extern "C" {
    pub fn strerror(_ErrorMessage: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn _stricmp(_String1: *const libc::c_char,
                    _String2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn _stricoll(_String1: *const libc::c_char,
                     _String2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn _stricoll_l(_String1: *const libc::c_char,
                       _String2: *const libc::c_char, _Locale: _locale_t)
     -> libc::c_int;
}
extern "C" {
    pub fn _stricmp_l(_String1: *const libc::c_char,
                      _String2: *const libc::c_char, _Locale: _locale_t)
     -> libc::c_int;
}
extern "C" {
    pub fn strlen(_Str: *const libc::c_char) -> libc::c_ulonglong;
}
extern "C" {
    pub fn _strlwr_s(_String: *mut libc::c_char, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _strlwr(_String: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn _strlwr_s_l(_String: *mut libc::c_char, _Size: usize,
                       _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _strlwr_l(_String: *mut libc::c_char, _Locale: _locale_t)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn strncat(_Destination: *mut libc::c_char,
                   _Source: *const libc::c_char, _Count: usize)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn strncmp(_Str1: *const libc::c_char, _Str2: *const libc::c_char,
                   _MaxCount: usize) -> libc::c_int;
}
extern "C" {
    pub fn _strnicmp(_String1: *const libc::c_char,
                     _String2: *const libc::c_char, _MaxCount: usize)
     -> libc::c_int;
}
extern "C" {
    pub fn _strnicmp_l(_String1: *const libc::c_char,
                       _String2: *const libc::c_char, _MaxCount: usize,
                       _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn _strnicoll(_String1: *const libc::c_char,
                      _String2: *const libc::c_char, _MaxCount: usize)
     -> libc::c_int;
}
extern "C" {
    pub fn _strnicoll_l(_String1: *const libc::c_char,
                        _String2: *const libc::c_char, _MaxCount: usize,
                        _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn _strncoll(_String1: *const libc::c_char,
                     _String2: *const libc::c_char, _MaxCount: usize)
     -> libc::c_int;
}
extern "C" {
    pub fn _strncoll_l(_String1: *const libc::c_char,
                       _String2: *const libc::c_char, _MaxCount: usize,
                       _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
    pub fn __strncnt(_String: *const libc::c_char, _Count: usize) -> usize;
}
extern "C" {
    pub fn strncpy(_Destination: *mut libc::c_char,
                   _Source: *const libc::c_char, _Count: usize)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn strnlen(_String: *const libc::c_char, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _strnset_s(_String: *mut libc::c_char, _SizeInBytes: usize,
                      _Value: libc::c_int, _MaxCount: usize) -> errno_t;
}
extern "C" {
    pub fn _strnset(_Destination: *mut libc::c_char, _Value: libc::c_int,
                    _Count: usize) -> *mut libc::c_char;
}
extern "C" {
    pub fn strpbrk(_Str: *const libc::c_char, _Control: *const libc::c_char)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn _strrev(_Str: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn _strset_s(_Destination: *mut libc::c_char, _DestinationSize: usize,
                     _Value: libc::c_int) -> errno_t;
}
extern "C" {
    pub fn _strset(_Destination: *mut libc::c_char, _Value: libc::c_int)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn strspn(_Str: *const libc::c_char, _Control: *const libc::c_char)
     -> libc::c_ulonglong;
}
extern "C" {
    pub fn strtok(_String: *mut libc::c_char, _Delimiter: *const libc::c_char)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn _strupr_s(_String: *mut libc::c_char, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _strupr(_String: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn _strupr_s_l(_String: *mut libc::c_char, _Size: usize,
                       _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _strupr_l(_String: *mut libc::c_char, _Locale: _locale_t)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn strxfrm(_Destination: *mut libc::c_char,
                   _Source: *const libc::c_char, _MaxCount: usize)
     -> libc::c_ulonglong;
}
extern "C" {
    pub fn _strxfrm_l(_Destination: *mut libc::c_char,
                      _Source: *const libc::c_char, _MaxCount: usize,
                      _Locale: _locale_t) -> usize;
}
extern "C" {
    pub fn strdup(_String: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strcmpi(_String1: *const libc::c_char,
                   _String2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn stricmp(_String1: *const libc::c_char,
                   _String2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn strlwr(_String: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strnicmp(_String1: *const libc::c_char,
                    _String2: *const libc::c_char, _MaxCount: usize)
     -> libc::c_int;
}
extern "C" {
    pub fn strnset(_String: *mut libc::c_char, _Value: libc::c_int,
                   _MaxCount: usize) -> *mut libc::c_char;
}
extern "C" {
    pub fn strrev(_String: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strset(_String: *mut libc::c_char, _Value: libc::c_int)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn strupr(_String: *mut libc::c_char) -> *mut libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _OBJECTID {
    pub Lineage: GUID,
    pub Uniquifier: ULONG,
}
#[test]
fn bindgen_test_layout__OBJECTID() {
    assert_eq!(::core::mem::size_of::<_OBJECTID>() , 20usize);
    assert_eq!(::core::mem::align_of::<_OBJECTID>() , 4usize);
}
impl Clone for _OBJECTID {
    fn clone(&self) -> Self { *self }
}
pub use self::_OBJECTID as OBJECTID;
extern "C" {
    pub fn _RTL_CONSTANT_STRING_type_check(s: *const libc::c_void)
     -> libc::c_char;
}
pub type PEXCEPTION_ROUTINE =
    ::core::option::Option<unsafe extern "C" fn() -> EXCEPTION_DISPOSITION>;
pub type KIRQL = UCHAR;
pub type PKIRQL = *mut KIRQL;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _NT_PRODUCT_TYPE {
    NtProductWinNt = 1,
    NtProductLanManNt = 2,
    NtProductServer = 3,
}
pub use self::_NT_PRODUCT_TYPE as NT_PRODUCT_TYPE;
pub type PNT_PRODUCT_TYPE = *mut _NT_PRODUCT_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _SUITE_TYPE {
    SmallBusiness = 0,
    Enterprise = 1,
    BackOffice = 2,
    CommunicationServer = 3,
    TerminalServer = 4,
    SmallBusinessRestricted = 5,
    EmbeddedNT = 6,
    DataCenter = 7,
    SingleUserTS = 8,
    Personal = 9,
    Blade = 10,
    EmbeddedRestricted = 11,
    SecurityAppliance = 12,
    StorageServer = 13,
    ComputeServer = 14,
    WHServer = 15,
    PhoneNT = 16,
    MaxSuiteType = 17,
}
pub use self::_SUITE_TYPE as SUITE_TYPE;
pub type __prefast_analysis_mode_flag0 = libc::c_int;
pub type __prefast_analysis_mode_flag1 = libc::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _ACCESS_STATE {
    pub OperationID: LUID,
    pub SecurityEvaluated: BOOLEAN,
    pub GenerateAudit: BOOLEAN,
    pub GenerateOnClose: BOOLEAN,
    pub PrivilegesAllocated: BOOLEAN,
    pub Flags: ULONG,
    pub RemainingDesiredAccess: ACCESS_MASK,
    pub PreviouslyGrantedAccess: ACCESS_MASK,
    pub OriginalDesiredAccess: ACCESS_MASK,
    pub SubjectSecurityContext: SECURITY_SUBJECT_CONTEXT,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
    pub AuxData: PVOID,
    pub Privileges: _ACCESS_STATE__bindgen_ty_1,
    pub AuditPrivileges: BOOLEAN,
    pub ObjectName: UNICODE_STRING,
    pub ObjectTypeName: UNICODE_STRING,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _ACCESS_STATE__bindgen_ty_1 {
    pub InitialPrivilegeSet: __BindgenUnionField<INITIAL_PRIVILEGE_SET>,
    pub PrivilegeSet: __BindgenUnionField<PRIVILEGE_SET>,
    pub bindgen_union_field: [u32; 11usize],
}
#[test]
fn bindgen_test_layout__ACCESS_STATE__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_ACCESS_STATE__bindgen_ty_1>() ,
               44usize);
    assert_eq!(::core::mem::align_of::<_ACCESS_STATE__bindgen_ty_1>() ,
               4usize);
}
impl Clone for _ACCESS_STATE__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__ACCESS_STATE() {
    assert_eq!(::core::mem::size_of::<_ACCESS_STATE>() , 160usize);
    assert_eq!(::core::mem::align_of::<_ACCESS_STATE>() , 8usize);
}
impl Clone for _ACCESS_STATE {
    fn clone(&self) -> Self { *self }
}
pub type PACCESS_STATE = *mut _ACCESS_STATE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CALLBACK_OBJECT {
    pub _address: u8,
}
impl Clone for _CALLBACK_OBJECT {
    fn clone(&self) -> Self { *self }
}
pub type PCALLBACK_OBJECT = *mut _CALLBACK_OBJECT;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _EPROCESS {
    pub _address: u8,
}
impl Clone for _EPROCESS {
    fn clone(&self) -> Self { *self }
}
pub type PEPROCESS = *mut _EPROCESS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _ETHREAD {
    pub _address: u8,
}
impl Clone for _ETHREAD {
    fn clone(&self) -> Self { *self }
}
pub type PETHREAD = *mut _ETHREAD;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_TIMER {
    pub _address: u8,
}
impl Clone for _IO_TIMER {
    fn clone(&self) -> Self { *self }
}
pub type PIO_TIMER = *mut _IO_TIMER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KINTERRUPT {
    pub _address: u8,
}
impl Clone for _KINTERRUPT {
    fn clone(&self) -> Self { *self }
}
pub type PKINTERRUPT = *mut _KINTERRUPT;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KTHREAD {
    pub _address: u8,
}
impl Clone for _KTHREAD {
    fn clone(&self) -> Self { *self }
}
pub type PKTHREAD = *mut _KTHREAD;
pub type PRKTHREAD = *mut _KTHREAD;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KPROCESS {
    pub _address: u8,
}
impl Clone for _KPROCESS {
    fn clone(&self) -> Self { *self }
}
pub type PKPROCESS = *mut _KPROCESS;
pub type PRKPROCESS = *mut _KPROCESS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _OBJECT_TYPE {
    pub _address: u8,
}
impl Clone for _OBJECT_TYPE {
    fn clone(&self) -> Self { *self }
}
pub type POBJECT_TYPE = *mut _OBJECT_TYPE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SECURITY_QUALITY_OF_SERVICE {
    pub Length: ULONG,
    pub ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    pub ContextTrackingMode: SECURITY_CONTEXT_TRACKING_MODE,
    pub EffectiveOnly: BOOLEAN,
}
#[test]
fn bindgen_test_layout__SECURITY_QUALITY_OF_SERVICE() {
    assert_eq!(::core::mem::size_of::<_SECURITY_QUALITY_OF_SERVICE>() ,
               12usize);
    assert_eq!(::core::mem::align_of::<_SECURITY_QUALITY_OF_SERVICE>() ,
               4usize);
}
impl Clone for _SECURITY_QUALITY_OF_SERVICE {
    fn clone(&self) -> Self { *self }
}
pub type PSECURITY_QUALITY_OF_SERVICE = *mut _SECURITY_QUALITY_OF_SERVICE;
pub type PCONTEXT = *mut _CONTEXT;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION {
    pub MajorFunction: UCHAR,
    pub MinorFunction: UCHAR,
    pub Flags: UCHAR,
    pub Control: UCHAR,
    pub Parameters: _IO_STACK_LOCATION__bindgen_ty_1,
    pub DeviceObject: PDEVICE_OBJECT,
    pub FileObject: PFILE_OBJECT,
    pub CompletionRoutine: PIO_COMPLETION_ROUTINE,
    pub Context: PVOID,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1 {
    pub Create: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1>,
    pub CreatePipe: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2>,
    pub CreateMailslot: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3>,
    pub Read: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4>,
    pub Write: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5>,
    pub QueryDirectory: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6>,
    pub NotifyDirectory: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_7>,
    pub QueryFile: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8>,
    pub SetFile: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9>,
    pub QueryEa: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10>,
    pub SetEa: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11>,
    pub QueryVolume: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_12>,
    pub SetVolume: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13>,
    pub FileSystemControl: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14>,
    pub LockControl: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15>,
    pub DeviceIoControl: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16>,
    pub QuerySecurity: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17>,
    pub SetSecurity: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18>,
    pub MountVolume: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19>,
    pub VerifyVolume: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20>,
    pub Scsi: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21>,
    pub QueryQuota: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_22>,
    pub SetQuota: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23>,
    pub QueryDeviceRelations: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_24>,
    pub QueryInterface: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_25>,
    pub DeviceCapabilities: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26>,
    pub FilterResourceRequirements: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_27>,
    pub ReadWriteConfig: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_28>,
    pub SetLock: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29>,
    pub QueryId: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_30>,
    pub QueryDeviceText: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_31>,
    pub UsageNotification: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32>,
    pub WaitWake: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33>,
    pub PowerSequence: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_34>,
    pub Power: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35>,
    pub StartDevice: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36>,
    pub WMI: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37>,
    pub Others: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38>,
    pub bindgen_union_field: [u64; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1 {
    pub SecurityContext: PIO_SECURITY_CONTEXT,
    pub Options: ULONG,
    pub FileAttributes: USHORT,
    pub ShareAccess: USHORT,
    pub EaLength: ULONG,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2 {
    pub SecurityContext: PIO_SECURITY_CONTEXT,
    pub Options: ULONG,
    pub Reserved: USHORT,
    pub ShareAccess: USHORT,
    pub Parameters: PNAMED_PIPE_CREATE_PARAMETERS,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3 {
    pub SecurityContext: PIO_SECURITY_CONTEXT,
    pub Options: ULONG,
    pub Reserved: USHORT,
    pub ShareAccess: USHORT,
    pub Parameters: PMAILSLOT_CREATE_PARAMETERS,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4 {
    pub Length: ULONG,
    pub Key: ULONG,
    pub ByteOffset: LARGE_INTEGER,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5 {
    pub Length: ULONG,
    pub Key: ULONG,
    pub ByteOffset: LARGE_INTEGER,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6 {
    pub Length: ULONG,
    pub FileName: PUNICODE_STRING,
    pub FileInformationClass: FILE_INFORMATION_CLASS,
    pub FileIndex: ULONG,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_7 {
    pub Length: ULONG,
    pub CompletionFilter: ULONG,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_7 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8 {
    pub Length: ULONG,
    pub FileInformationClass: FILE_INFORMATION_CLASS,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9 {
    pub Length: ULONG,
    pub FileInformationClass: FILE_INFORMATION_CLASS,
    pub FileObject: PFILE_OBJECT,
    pub __bindgen_anon_1: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9__bindgen_ty_1 {
    pub __bindgen_anon_1: __BindgenUnionField<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9__bindgen_ty_1__bindgen_ty_1>,
    pub ClusterCount: __BindgenUnionField<ULONG>,
    pub DeleteHandle: __BindgenUnionField<HANDLE>,
    pub bindgen_union_field: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9__bindgen_ty_1__bindgen_ty_1 {
    pub ReplaceIfExists: BOOLEAN,
    pub AdvanceOnly: BOOLEAN,
}
impl Clone for
 _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10 {
    pub Length: ULONG,
    pub EaList: PVOID,
    pub EaListLength: ULONG,
    pub EaIndex: ULONG,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11 {
    pub Length: ULONG,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_12 {
    pub Length: ULONG,
    pub FsInformationClass: FS_INFORMATION_CLASS,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_12 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13 {
    pub Length: ULONG,
    pub FsInformationClass: FS_INFORMATION_CLASS,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14 {
    pub OutputBufferLength: ULONG,
    pub InputBufferLength: ULONG,
    pub FsControlCode: ULONG,
    pub Type3InputBuffer: PVOID,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15 {
    pub Length: PLARGE_INTEGER,
    pub Key: ULONG,
    pub ByteOffset: LARGE_INTEGER,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16 {
    pub OutputBufferLength: ULONG,
    pub InputBufferLength: ULONG,
    pub IoControlCode: ULONG,
    pub Type3InputBuffer: PVOID,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17 {
    pub SecurityInformation: SECURITY_INFORMATION,
    pub Length: ULONG,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18 {
    pub SecurityInformation: SECURITY_INFORMATION,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19 {
    pub Vpb: PVPB,
    pub DeviceObject: PDEVICE_OBJECT,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20 {
    pub Vpb: PVPB,
    pub DeviceObject: PDEVICE_OBJECT,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21 {
    pub Srb: *mut _SCSI_REQUEST_BLOCK,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_22 {
    pub Length: ULONG,
    pub StartSid: PSID,
    pub SidList: PFILE_GET_QUOTA_INFORMATION,
    pub SidListLength: ULONG,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_22 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23 {
    pub Length: ULONG,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_24 {
    pub Type: DEVICE_RELATION_TYPE,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_24 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_25 {
    pub InterfaceType: *const GUID,
    pub Size: USHORT,
    pub Version: USHORT,
    pub Interface: PINTERFACE,
    pub InterfaceSpecificData: PVOID,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_25 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26 {
    pub Capabilities: PDEVICE_CAPABILITIES,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_27 {
    pub IoResourceRequirementList: PIO_RESOURCE_REQUIREMENTS_LIST,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_27 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_28 {
    pub WhichSpace: ULONG,
    pub Buffer: PVOID,
    pub Offset: ULONG,
    pub Length: ULONG,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_28 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29 {
    pub Lock: BOOLEAN,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_30 {
    pub IdType: BUS_QUERY_ID_TYPE,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_30 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_31 {
    pub DeviceTextType: DEVICE_TEXT_TYPE,
    pub LocaleId: LCID,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_31 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32 {
    pub InPath: BOOLEAN,
    pub Reserved: [BOOLEAN; 3usize],
    pub Type: DEVICE_USAGE_NOTIFICATION_TYPE,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33 {
    pub PowerState: SYSTEM_POWER_STATE,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_34 {
    pub PowerSequence: PPOWER_SEQUENCE,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_34 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35 {
    pub __bindgen_anon_1: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35__bindgen_ty_1,
    pub Type: POWER_STATE_TYPE,
    pub State: POWER_STATE,
    pub ShutdownType: POWER_ACTION,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35__bindgen_ty_1 {
    pub SystemContext: __BindgenUnionField<ULONG>,
    pub SystemPowerStateContext: __BindgenUnionField<SYSTEM_POWER_STATE_CONTEXT>,
    pub bindgen_union_field: u32,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36 {
    pub AllocatedResources: PCM_RESOURCE_LIST,
    pub AllocatedResourcesTranslated: PCM_RESOURCE_LIST,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37 {
    pub ProviderId: ULONG_PTR,
    pub DataPath: PVOID,
    pub BufferSize: ULONG,
    pub Buffer: PVOID,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38 {
    pub Argument1: PVOID,
    pub Argument2: PVOID,
    pub Argument3: PVOID,
    pub Argument4: PVOID,
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38 {
    fn clone(&self) -> Self { *self }
}
impl Clone for _IO_STACK_LOCATION__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Clone for _IO_STACK_LOCATION {
    fn clone(&self) -> Self { *self }
}
pub type PIO_STACK_LOCATION = *mut _IO_STACK_LOCATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VPB {
    pub Type: CSHORT,
    pub Size: CSHORT,
    pub Flags: USHORT,
    pub VolumeLabelLength: USHORT,
    pub DeviceObject: *mut _DEVICE_OBJECT,
    pub RealDevice: *mut _DEVICE_OBJECT,
    pub SerialNumber: ULONG,
    pub ReferenceCount: ULONG,
    pub VolumeLabel: [WCHAR; 32usize],
}
#[test]
fn bindgen_test_layout__VPB() {
    assert_eq!(::core::mem::size_of::<_VPB>() , 96usize);
    assert_eq!(::core::mem::align_of::<_VPB>() , 8usize);
}
impl Clone for _VPB {
    fn clone(&self) -> Self { *self }
}
pub type PVPB = *mut _VPB;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _FILE_GET_QUOTA_INFORMATION {
    pub _address: u8,
}
impl Clone for _FILE_GET_QUOTA_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub type PFILE_GET_QUOTA_INFORMATION = *mut _FILE_GET_QUOTA_INFORMATION;
extern "C" {
    pub fn __readgsqword(Offset: ULONG) -> ULONG64;
}
pub const HAL_MCE_RECORD: _bindgen_ty_2 = _bindgen_ty_2::HAL_MCE_RECORD;
pub const HAL_MCA_RECORD: _bindgen_ty_2 = _bindgen_ty_2::HAL_MCA_RECORD;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 { HAL_MCE_RECORD = 0, HAL_MCA_RECORD = 1, }
pub use self::_bindgen_ty_2 as MCA_EXCEPTION_TYPE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _MCI_ADDR {
    pub __bindgen_anon_1: __BindgenUnionField<_MCI_ADDR__bindgen_ty_1>,
    pub QuadPart: __BindgenUnionField<ULONGLONG>,
    pub bindgen_union_field: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _MCI_ADDR__bindgen_ty_1 {
    pub Address: ULONG,
    pub Reserved: ULONG,
}
#[test]
fn bindgen_test_layout__MCI_ADDR__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_MCI_ADDR__bindgen_ty_1>() , 8usize);
    assert_eq!(::core::mem::align_of::<_MCI_ADDR__bindgen_ty_1>() , 4usize);
}
impl Clone for _MCI_ADDR__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__MCI_ADDR() {
    assert_eq!(::core::mem::size_of::<_MCI_ADDR>() , 8usize);
    assert_eq!(::core::mem::align_of::<_MCI_ADDR>() , 8usize);
}
impl Clone for _MCI_ADDR {
    fn clone(&self) -> Self { *self }
}
pub use self::_MCI_ADDR as MCI_ADDR;
pub type PMCI_ADDR = *mut _MCI_ADDR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _MCI_STATS {
    pub MciStats: __BindgenUnionField<_MCI_STATS__bindgen_ty_1>,
    pub QuadPart: __BindgenUnionField<ULONGLONG>,
    pub bindgen_union_field: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _MCI_STATS__bindgen_ty_1 {
    pub McaCod: USHORT,
    pub MsCod: USHORT,
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__MCI_STATS__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_MCI_STATS__bindgen_ty_1>() , 8usize);
    assert_eq!(::core::mem::align_of::<_MCI_STATS__bindgen_ty_1>() , 4usize);
}
impl Clone for _MCI_STATS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _MCI_STATS__bindgen_ty_1 {
    #[inline]
    pub fn OtherInfo(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (33554431usize as u32)) >> 0u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_OtherInfo(&mut self, val: ULONG) {
        self._bitfield_1 &= !(33554431usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 0u32) & (33554431usize as u32);
    }
    #[inline]
    pub fn Damage(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (33554432usize as u32)) >> 25u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_Damage(&mut self, val: ULONG) {
        self._bitfield_1 &= !(33554432usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 25u32) & (33554432usize as u32);
    }
    #[inline]
    pub fn AddressValid(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (67108864usize as u32)) >> 26u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_AddressValid(&mut self, val: ULONG) {
        self._bitfield_1 &= !(67108864usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 26u32) & (67108864usize as u32);
    }
    #[inline]
    pub fn MiscValid(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (134217728usize as u32)) >> 27u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_MiscValid(&mut self, val: ULONG) {
        self._bitfield_1 &= !(134217728usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 27u32) & (134217728usize as u32);
    }
    #[inline]
    pub fn Enabled(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (268435456usize as u32)) >> 28u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_Enabled(&mut self, val: ULONG) {
        self._bitfield_1 &= !(268435456usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 28u32) & (268435456usize as u32);
    }
    #[inline]
    pub fn UnCorrected(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (536870912usize as u32)) >> 29u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_UnCorrected(&mut self, val: ULONG) {
        self._bitfield_1 &= !(536870912usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 29u32) & (536870912usize as u32);
    }
    #[inline]
    pub fn OverFlow(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (1073741824usize as u32)) >> 30u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_OverFlow(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1073741824usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 30u32) & (1073741824usize as u32);
    }
    #[inline]
    pub fn Valid(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (2147483648usize as u32)) >> 31u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_Valid(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2147483648usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 31u32) & (2147483648usize as u32);
    }
}
#[test]
fn bindgen_test_layout__MCI_STATS() {
    assert_eq!(::core::mem::size_of::<_MCI_STATS>() , 8usize);
    assert_eq!(::core::mem::align_of::<_MCI_STATS>() , 8usize);
}
impl Clone for _MCI_STATS {
    fn clone(&self) -> Self { *self }
}
pub use self::_MCI_STATS as MCI_STATS;
pub type PMCI_STATS = *mut _MCI_STATS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _MCA_EXCEPTION {
    pub VersionNumber: ULONG,
    pub ExceptionType: MCA_EXCEPTION_TYPE,
    pub TimeStamp: LARGE_INTEGER,
    pub ProcessorNumber: ULONG,
    pub Reserved1: ULONG,
    pub u: _MCA_EXCEPTION__bindgen_ty_1,
    pub ExtCnt: ULONG,
    pub Reserved3: ULONG,
    pub ExtReg: [ULONGLONG; 24usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _MCA_EXCEPTION__bindgen_ty_1 {
    pub Mca: __BindgenUnionField<_MCA_EXCEPTION__bindgen_ty_1__bindgen_ty_1>,
    pub Mce: __BindgenUnionField<_MCA_EXCEPTION__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: [u64; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _MCA_EXCEPTION__bindgen_ty_1__bindgen_ty_1 {
    pub BankNumber: UCHAR,
    pub Reserved2: [UCHAR; 7usize],
    pub Status: MCI_STATS,
    pub Address: MCI_ADDR,
    pub Misc: ULONGLONG,
}
#[test]
fn bindgen_test_layout__MCA_EXCEPTION__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_MCA_EXCEPTION__bindgen_ty_1__bindgen_ty_1>()
               , 32usize);
    assert_eq!(::core::mem::align_of::<_MCA_EXCEPTION__bindgen_ty_1__bindgen_ty_1>()
               , 8usize);
}
impl Clone for _MCA_EXCEPTION__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _MCA_EXCEPTION__bindgen_ty_1__bindgen_ty_2 {
    pub Address: ULONGLONG,
    pub Type: ULONGLONG,
}
#[test]
fn bindgen_test_layout__MCA_EXCEPTION__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<_MCA_EXCEPTION__bindgen_ty_1__bindgen_ty_2>()
               , 16usize);
    assert_eq!(::core::mem::align_of::<_MCA_EXCEPTION__bindgen_ty_1__bindgen_ty_2>()
               , 8usize);
}
impl Clone for _MCA_EXCEPTION__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__MCA_EXCEPTION__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_MCA_EXCEPTION__bindgen_ty_1>() ,
               32usize);
    assert_eq!(::core::mem::align_of::<_MCA_EXCEPTION__bindgen_ty_1>() ,
               8usize);
}
impl Clone for _MCA_EXCEPTION__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__MCA_EXCEPTION() {
    assert_eq!(::core::mem::size_of::<_MCA_EXCEPTION>() , 256usize);
    assert_eq!(::core::mem::align_of::<_MCA_EXCEPTION>() , 8usize);
}
impl Clone for _MCA_EXCEPTION {
    fn clone(&self) -> Self { *self }
}
pub use self::_MCA_EXCEPTION as MCA_EXCEPTION;
pub type PMCA_EXCEPTION = *mut _MCA_EXCEPTION;
pub use self::MCA_EXCEPTION as CMC_EXCEPTION;
pub type PCMC_EXCEPTION = *mut MCA_EXCEPTION;
pub use self::MCA_EXCEPTION as CPE_EXCEPTION;
pub type PCPE_EXCEPTION = *mut MCA_EXCEPTION;
extern "C" {
    #[link_name = "KeNumberProcessors"]
    pub static mut KeNumberProcessors: CCHAR;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KSYSTEM_TIME {
    pub LowPart: ULONG,
    pub High1Time: LONG,
    pub High2Time: LONG,
}
#[test]
fn bindgen_test_layout__KSYSTEM_TIME() {
    assert_eq!(::core::mem::size_of::<_KSYSTEM_TIME>() , 12usize);
    assert_eq!(::core::mem::align_of::<_KSYSTEM_TIME>() , 4usize);
}
impl Clone for _KSYSTEM_TIME {
    fn clone(&self) -> Self { *self }
}
pub use self::_KSYSTEM_TIME as KSYSTEM_TIME;
pub type PKSYSTEM_TIME = *mut _KSYSTEM_TIME;
pub type KPRIORITY = LONG;
pub type KSPIN_LOCK = ULONG_PTR;
pub type PKSPIN_LOCK = *mut KSPIN_LOCK;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _KSPIN_LOCK_QUEUE_NUMBER {
    LockQueueUnusedSpare0 = 0,
    LockQueueUnusedSpare1 = 1,
    LockQueueUnusedSpare2 = 2,
    LockQueueUnusedSpare3 = 3,
    LockQueueVacbLock = 4,
    LockQueueMasterLock = 5,
    LockQueueNonPagedPoolLock = 6,
    LockQueueIoCancelLock = 7,
    LockQueueWorkQueueLock = 8,
    LockQueueIoVpbLock = 9,
    LockQueueIoDatabaseLock = 10,
    LockQueueIoCompletionLock = 11,
    LockQueueNtfsStructLock = 12,
    LockQueueAfdWorkQueueLock = 13,
    LockQueueBcbLock = 14,
    LockQueueUnusedSpare15 = 15,
    LockQueueUnusedSpare16 = 16,
    LockQueueMaximumLock = 17,
}
pub use self::_KSPIN_LOCK_QUEUE_NUMBER as KSPIN_LOCK_QUEUE_NUMBER;
pub type PKSPIN_LOCK_QUEUE_NUMBER = *mut _KSPIN_LOCK_QUEUE_NUMBER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KSPIN_LOCK_QUEUE {
    pub Next: *mut _KSPIN_LOCK_QUEUE,
    pub Lock: PKSPIN_LOCK,
}
#[test]
fn bindgen_test_layout__KSPIN_LOCK_QUEUE() {
    assert_eq!(::core::mem::size_of::<_KSPIN_LOCK_QUEUE>() , 16usize);
    assert_eq!(::core::mem::align_of::<_KSPIN_LOCK_QUEUE>() , 8usize);
}
impl Clone for _KSPIN_LOCK_QUEUE {
    fn clone(&self) -> Self { *self }
}
pub use self::_KSPIN_LOCK_QUEUE as KSPIN_LOCK_QUEUE;
pub type PKSPIN_LOCK_QUEUE = *mut _KSPIN_LOCK_QUEUE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KLOCK_QUEUE_HANDLE {
    pub LockQueue: KSPIN_LOCK_QUEUE,
    pub OldIrql: KIRQL,
}
#[test]
fn bindgen_test_layout__KLOCK_QUEUE_HANDLE() {
    assert_eq!(::core::mem::size_of::<_KLOCK_QUEUE_HANDLE>() , 24usize);
    assert_eq!(::core::mem::align_of::<_KLOCK_QUEUE_HANDLE>() , 8usize);
}
impl Clone for _KLOCK_QUEUE_HANDLE {
    fn clone(&self) -> Self { *self }
}
pub use self::_KLOCK_QUEUE_HANDLE as KLOCK_QUEUE_HANDLE;
pub type PKLOCK_QUEUE_HANDLE = *mut _KLOCK_QUEUE_HANDLE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _KPROFILE_SOURCE {
    ProfileTime = 0,
    ProfileAlignmentFixup = 1,
    ProfileTotalIssues = 2,
    ProfilePipelineDry = 3,
    ProfileLoadInstructions = 4,
    ProfilePipelineFrozen = 5,
    ProfileBranchInstructions = 6,
    ProfileTotalNonissues = 7,
    ProfileDcacheMisses = 8,
    ProfileIcacheMisses = 9,
    ProfileCacheMisses = 10,
    ProfileBranchMispredictions = 11,
    ProfileStoreInstructions = 12,
    ProfileFpInstructions = 13,
    ProfileIntegerInstructions = 14,
    Profile2Issue = 15,
    Profile3Issue = 16,
    Profile4Issue = 17,
    ProfileSpecialInstructions = 18,
    ProfileTotalCycles = 19,
    ProfileIcacheIssues = 20,
    ProfileDcacheAccesses = 21,
    ProfileMemoryBarrierCycles = 22,
    ProfileLoadLinkedIssues = 23,
    ProfileMaximum = 24,
}
pub use self::_KPROFILE_SOURCE as KPROFILE_SOURCE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _M128A {
    pub Low: ULONGLONG,
    pub High: LONGLONG,
}
impl Clone for _M128A {
    fn clone(&self) -> Self { *self }
}
pub use self::_M128A as M128A;
pub type PM128A = *mut _M128A;
#[repr(C)]
pub struct _XSAVE_FORMAT {
    pub ControlWord: USHORT,
    pub StatusWord: USHORT,
    pub TagWord: UCHAR,
    pub Reserved1: UCHAR,
    pub ErrorOpcode: USHORT,
    pub ErrorOffset: ULONG,
    pub ErrorSelector: USHORT,
    pub Reserved2: USHORT,
    pub DataOffset: ULONG,
    pub DataSelector: USHORT,
    pub Reserved3: USHORT,
    pub MxCsr: ULONG,
    pub MxCsr_Mask: ULONG,
    pub FloatRegisters: [M128A; 8usize],
    pub XmmRegisters: [M128A; 16usize],
    pub Reserved4: [UCHAR; 96usize],
}
pub use self::_XSAVE_FORMAT as XSAVE_FORMAT;
pub type PXSAVE_FORMAT = *mut _XSAVE_FORMAT;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _XSAVE_AREA_HEADER {
    pub Mask: ULONG64,
    pub CompactionMask: ULONG64,
    pub Reserved2: [ULONG64; 6usize],
}
impl Clone for _XSAVE_AREA_HEADER {
    fn clone(&self) -> Self { *self }
}
pub use self::_XSAVE_AREA_HEADER as XSAVE_AREA_HEADER;
pub type PXSAVE_AREA_HEADER = *mut _XSAVE_AREA_HEADER;
#[repr(C)]
pub struct _XSAVE_AREA {
    pub LegacyState: XSAVE_FORMAT,
    pub Header: XSAVE_AREA_HEADER,
}
pub use self::_XSAVE_AREA as XSAVE_AREA;
pub type PXSAVE_AREA = *mut _XSAVE_AREA;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _XSTATE_CONTEXT {
    pub Mask: ULONG64,
    pub Length: ULONG,
    pub Reserved1: ULONG,
    pub Area: PXSAVE_AREA,
    pub Reserved2: ULONG,
    pub Buffer: PVOID,
    pub Reserved3: ULONG,
}
#[test]
fn bindgen_test_layout__XSTATE_CONTEXT() {
    assert_eq!(::core::mem::size_of::<_XSTATE_CONTEXT>() , 48usize);
    assert_eq!(::core::mem::align_of::<_XSTATE_CONTEXT>() , 8usize);
}
impl Clone for _XSTATE_CONTEXT {
    fn clone(&self) -> Self { *self }
}
pub use self::_XSTATE_CONTEXT as XSTATE_CONTEXT;
pub type PXSTATE_CONTEXT = *mut _XSTATE_CONTEXT;
pub type __C_ASSERT__ = [libc::c_char; 1usize];
pub type PACCESS_TOKEN = PVOID;
pub type PSECURITY_DESCRIPTOR = PVOID;
pub type PSID = PVOID;
pub type PCLAIMS_BLOB = PVOID;
pub type ACCESS_MASK = ULONG;
pub type PACCESS_MASK = *mut ACCESS_MASK;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GENERIC_MAPPING {
    pub GenericRead: ACCESS_MASK,
    pub GenericWrite: ACCESS_MASK,
    pub GenericExecute: ACCESS_MASK,
    pub GenericAll: ACCESS_MASK,
}
#[test]
fn bindgen_test_layout__GENERIC_MAPPING() {
    assert_eq!(::core::mem::size_of::<_GENERIC_MAPPING>() , 16usize);
    assert_eq!(::core::mem::align_of::<_GENERIC_MAPPING>() , 4usize);
}
impl Clone for _GENERIC_MAPPING {
    fn clone(&self) -> Self { *self }
}
pub use self::_GENERIC_MAPPING as GENERIC_MAPPING;
pub type PGENERIC_MAPPING = *mut GENERIC_MAPPING;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _LUID_AND_ATTRIBUTES {
    pub Luid: LUID,
    pub Attributes: ULONG,
}
impl Clone for _LUID_AND_ATTRIBUTES {
    fn clone(&self) -> Self { *self }
}
pub use self::_LUID_AND_ATTRIBUTES as LUID_AND_ATTRIBUTES;
pub type PLUID_AND_ATTRIBUTES = *mut _LUID_AND_ATTRIBUTES;
pub type LUID_AND_ATTRIBUTES_ARRAY = [LUID_AND_ATTRIBUTES; 1usize];
pub type PLUID_AND_ATTRIBUTES_ARRAY = *mut LUID_AND_ATTRIBUTES_ARRAY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _ACL {
    pub AclRevision: UCHAR,
    pub Sbz1: UCHAR,
    pub AclSize: USHORT,
    pub AceCount: USHORT,
    pub Sbz2: USHORT,
}
#[test]
fn bindgen_test_layout__ACL() {
    assert_eq!(::core::mem::size_of::<_ACL>() , 8usize);
    assert_eq!(::core::mem::align_of::<_ACL>() , 2usize);
}
impl Clone for _ACL {
    fn clone(&self) -> Self { *self }
}
pub use self::_ACL as ACL;
pub type PACL = *mut ACL;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PRIVILEGE_SET {
    pub PrivilegeCount: ULONG,
    pub Control: ULONG,
    pub Privilege: [LUID_AND_ATTRIBUTES; 1usize],
}
#[test]
fn bindgen_test_layout__PRIVILEGE_SET() {
    assert_eq!(::core::mem::size_of::<_PRIVILEGE_SET>() , 20usize);
    assert_eq!(::core::mem::align_of::<_PRIVILEGE_SET>() , 4usize);
}
impl Clone for _PRIVILEGE_SET {
    fn clone(&self) -> Self { *self }
}
pub use self::_PRIVILEGE_SET as PRIVILEGE_SET;
pub type PPRIVILEGE_SET = *mut _PRIVILEGE_SET;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _SECURITY_IMPERSONATION_LEVEL {
    SecurityAnonymous = 0,
    SecurityIdentification = 1,
    SecurityImpersonation = 2,
    SecurityDelegation = 3,
}
pub use self::_SECURITY_IMPERSONATION_LEVEL as SECURITY_IMPERSONATION_LEVEL;
pub type PSECURITY_IMPERSONATION_LEVEL = *mut _SECURITY_IMPERSONATION_LEVEL;
pub type SECURITY_CONTEXT_TRACKING_MODE = BOOLEAN;
pub type PSECURITY_CONTEXT_TRACKING_MODE = *mut BOOLEAN;
pub use self::_SECURITY_QUALITY_OF_SERVICE as SECURITY_QUALITY_OF_SERVICE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SE_IMPERSONATION_STATE {
    pub Token: PACCESS_TOKEN,
    pub CopyOnOpen: BOOLEAN,
    pub EffectiveOnly: BOOLEAN,
    pub Level: SECURITY_IMPERSONATION_LEVEL,
}
#[test]
fn bindgen_test_layout__SE_IMPERSONATION_STATE() {
    assert_eq!(::core::mem::size_of::<_SE_IMPERSONATION_STATE>() , 16usize);
    assert_eq!(::core::mem::align_of::<_SE_IMPERSONATION_STATE>() , 8usize);
}
impl Clone for _SE_IMPERSONATION_STATE {
    fn clone(&self) -> Self { *self }
}
pub use self::_SE_IMPERSONATION_STATE as SE_IMPERSONATION_STATE;
pub type PSE_IMPERSONATION_STATE = *mut _SE_IMPERSONATION_STATE;
pub type SECURITY_INFORMATION = ULONG;
pub type PSECURITY_INFORMATION = *mut ULONG;
#[repr(i32)]
/////////////////////////////////////////////////////////////////////////
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _SE_ADT_PARAMETER_TYPE {
    SeAdtParmTypeNone = 0,
    SeAdtParmTypeString = 1,
    SeAdtParmTypeFileSpec = 2,
    SeAdtParmTypeUlong = 3,
    SeAdtParmTypeSid = 4,
    SeAdtParmTypeLogonId = 5,
    SeAdtParmTypeNoLogonId = 6,
    SeAdtParmTypeAccessMask = 7,
    SeAdtParmTypePrivs = 8,
    SeAdtParmTypeObjectTypes = 9,
    SeAdtParmTypeHexUlong = 10,
    SeAdtParmTypePtr = 11,
    SeAdtParmTypeTime = 12,
    SeAdtParmTypeGuid = 13,
    SeAdtParmTypeLuid = 14,
    SeAdtParmTypeHexInt64 = 15,
    SeAdtParmTypeStringList = 16,
    SeAdtParmTypeSidList = 17,
    SeAdtParmTypeDuration = 18,
    SeAdtParmTypeUserAccountControl = 19,
    SeAdtParmTypeNoUac = 20,
    SeAdtParmTypeMessage = 21,
    SeAdtParmTypeDateTime = 22,
    SeAdtParmTypeSockAddr = 23,
    SeAdtParmTypeSD = 24,
    SeAdtParmTypeLogonHours = 25,
    SeAdtParmTypeLogonIdNoSid = 26,
    SeAdtParmTypeUlongNoConv = 27,
    SeAdtParmTypeSockAddrNoPort = 28,
    SeAdtParmTypeAccessReason = 29,
    SeAdtParmTypeStagingReason = 30,
    SeAdtParmTypeResourceAttribute = 31,
    SeAdtParmTypeClaims = 32,
    SeAdtParmTypeLogonIdAsSid = 33,
    SeAdtParmTypeMultiSzString = 34,
    SeAdtParmTypeLogonIdEx = 35,
}
pub use self::_SE_ADT_PARAMETER_TYPE as SE_ADT_PARAMETER_TYPE;
pub type PSE_ADT_PARAMETER_TYPE = *mut _SE_ADT_PARAMETER_TYPE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SE_ADT_OBJECT_TYPE {
    pub ObjectType: GUID,
    pub Flags: USHORT,
    pub Level: USHORT,
    pub AccessMask: ACCESS_MASK,
}
#[test]
fn bindgen_test_layout__SE_ADT_OBJECT_TYPE() {
    assert_eq!(::core::mem::size_of::<_SE_ADT_OBJECT_TYPE>() , 24usize);
    assert_eq!(::core::mem::align_of::<_SE_ADT_OBJECT_TYPE>() , 4usize);
}
impl Clone for _SE_ADT_OBJECT_TYPE {
    fn clone(&self) -> Self { *self }
}
pub use self::_SE_ADT_OBJECT_TYPE as SE_ADT_OBJECT_TYPE;
pub type PSE_ADT_OBJECT_TYPE = *mut _SE_ADT_OBJECT_TYPE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SE_ADT_PARAMETER_ARRAY_ENTRY {
    pub Type: SE_ADT_PARAMETER_TYPE,
    pub Length: ULONG,
    pub Data: [ULONG_PTR; 2usize],
    pub Address: PVOID,
}
#[test]
fn bindgen_test_layout__SE_ADT_PARAMETER_ARRAY_ENTRY() {
    assert_eq!(::core::mem::size_of::<_SE_ADT_PARAMETER_ARRAY_ENTRY>() ,
               32usize);
    assert_eq!(::core::mem::align_of::<_SE_ADT_PARAMETER_ARRAY_ENTRY>() ,
               8usize);
}
impl Clone for _SE_ADT_PARAMETER_ARRAY_ENTRY {
    fn clone(&self) -> Self { *self }
}
pub use self::_SE_ADT_PARAMETER_ARRAY_ENTRY as SE_ADT_PARAMETER_ARRAY_ENTRY;
pub type PSE_ADT_PARAMETER_ARRAY_ENTRY = *mut _SE_ADT_PARAMETER_ARRAY_ENTRY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SE_ADT_ACCESS_REASON {
    pub AccessMask: ACCESS_MASK,
    pub AccessReasons: [ULONG; 32usize],
    pub ObjectTypeIndex: ULONG,
    pub AccessGranted: ULONG,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
}
#[test]
fn bindgen_test_layout__SE_ADT_ACCESS_REASON() {
    assert_eq!(::core::mem::size_of::<_SE_ADT_ACCESS_REASON>() , 152usize);
    assert_eq!(::core::mem::align_of::<_SE_ADT_ACCESS_REASON>() , 8usize);
}
impl Clone for _SE_ADT_ACCESS_REASON {
    fn clone(&self) -> Self { *self }
}
pub use self::_SE_ADT_ACCESS_REASON as SE_ADT_ACCESS_REASON;
pub type PSE_ADT_ACCESS_REASON = *mut _SE_ADT_ACCESS_REASON;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SE_ADT_CLAIMS {
    pub Length: ULONG,
    pub Claims: PCLAIMS_BLOB,
}
#[test]
fn bindgen_test_layout__SE_ADT_CLAIMS() {
    assert_eq!(::core::mem::size_of::<_SE_ADT_CLAIMS>() , 16usize);
    assert_eq!(::core::mem::align_of::<_SE_ADT_CLAIMS>() , 8usize);
}
impl Clone for _SE_ADT_CLAIMS {
    fn clone(&self) -> Self { *self }
}
pub use self::_SE_ADT_CLAIMS as SE_ADT_CLAIMS;
pub type PSE_ADT_CLAIMS = *mut _SE_ADT_CLAIMS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SE_ADT_PARAMETER_ARRAY {
    pub CategoryId: ULONG,
    pub AuditId: ULONG,
    pub ParameterCount: ULONG,
    pub Length: ULONG,
    pub FlatSubCategoryId: USHORT,
    pub Type: USHORT,
    pub Flags: ULONG,
    pub Parameters: [SE_ADT_PARAMETER_ARRAY_ENTRY; 32usize],
}
#[test]
fn bindgen_test_layout__SE_ADT_PARAMETER_ARRAY() {
    assert_eq!(::core::mem::size_of::<_SE_ADT_PARAMETER_ARRAY>() , 1048usize);
    assert_eq!(::core::mem::align_of::<_SE_ADT_PARAMETER_ARRAY>() , 8usize);
}
impl Clone for _SE_ADT_PARAMETER_ARRAY {
    fn clone(&self) -> Self { *self }
}
pub use self::_SE_ADT_PARAMETER_ARRAY as SE_ADT_PARAMETER_ARRAY;
pub type PSE_ADT_PARAMETER_ARRAY = *mut _SE_ADT_PARAMETER_ARRAY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SE_ADT_PARAMETER_ARRAY_EX {
    pub CategoryId: ULONG,
    pub AuditId: ULONG,
    pub Version: ULONG,
    pub ParameterCount: ULONG,
    pub Length: ULONG,
    pub FlatSubCategoryId: USHORT,
    pub Type: USHORT,
    pub Flags: ULONG,
    pub Parameters: [SE_ADT_PARAMETER_ARRAY_ENTRY; 32usize],
}
#[test]
fn bindgen_test_layout__SE_ADT_PARAMETER_ARRAY_EX() {
    assert_eq!(::core::mem::size_of::<_SE_ADT_PARAMETER_ARRAY_EX>() ,
               1056usize);
    assert_eq!(::core::mem::align_of::<_SE_ADT_PARAMETER_ARRAY_EX>() ,
               8usize);
}
impl Clone for _SE_ADT_PARAMETER_ARRAY_EX {
    fn clone(&self) -> Self { *self }
}
pub use self::_SE_ADT_PARAMETER_ARRAY_EX as SE_ADT_PARAMETER_ARRAY_EX;
pub type PSE_ADT_PARAMETER_ARRAY_EX = *mut _SE_ADT_PARAMETER_ARRAY_EX;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STATUS_BLOCK {
    pub __bindgen_anon_1: _IO_STATUS_BLOCK__bindgen_ty_1,
    pub Information: ULONG_PTR,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STATUS_BLOCK__bindgen_ty_1 {
    pub Status: __BindgenUnionField<NTSTATUS>,
    pub Pointer: __BindgenUnionField<PVOID>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__IO_STATUS_BLOCK__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_IO_STATUS_BLOCK__bindgen_ty_1>() ,
               8usize);
    assert_eq!(::core::mem::align_of::<_IO_STATUS_BLOCK__bindgen_ty_1>() ,
               8usize);
}
impl Clone for _IO_STATUS_BLOCK__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__IO_STATUS_BLOCK() {
    assert_eq!(::core::mem::size_of::<_IO_STATUS_BLOCK>() , 16usize);
    assert_eq!(::core::mem::align_of::<_IO_STATUS_BLOCK>() , 8usize);
}
impl Clone for _IO_STATUS_BLOCK {
    fn clone(&self) -> Self { *self }
}
pub use self::_IO_STATUS_BLOCK as IO_STATUS_BLOCK;
pub type PIO_STATUS_BLOCK = *mut _IO_STATUS_BLOCK;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_STATUS_BLOCK32 {
    pub Status: NTSTATUS,
    pub Information: ULONG,
}
#[test]
fn bindgen_test_layout__IO_STATUS_BLOCK32() {
    assert_eq!(::core::mem::size_of::<_IO_STATUS_BLOCK32>() , 8usize);
    assert_eq!(::core::mem::align_of::<_IO_STATUS_BLOCK32>() , 4usize);
}
impl Clone for _IO_STATUS_BLOCK32 {
    fn clone(&self) -> Self { *self }
}
pub use self::_IO_STATUS_BLOCK32 as IO_STATUS_BLOCK32;
pub type PIO_STATUS_BLOCK32 = *mut _IO_STATUS_BLOCK32;
pub type PIO_APC_ROUTINE =
    ::core::option::Option<unsafe extern "C" fn(ApcContext: PVOID,
                                                IoStatusBlock:
                                                    PIO_STATUS_BLOCK,
                                                Reserved: ULONG)>;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _IO_SESSION_EVENT {
    IoSessionEventIgnore = 0,
    IoSessionEventCreated = 1,
    IoSessionEventTerminated = 2,
    IoSessionEventConnected = 3,
    IoSessionEventDisconnected = 4,
    IoSessionEventLogon = 5,
    IoSessionEventLogoff = 6,
    IoSessionEventMax = 7,
}
pub use self::_IO_SESSION_EVENT as IO_SESSION_EVENT;
pub type PIO_SESSION_EVENT = *mut _IO_SESSION_EVENT;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _IO_SESSION_STATE {
    IoSessionStateCreated = 1,
    IoSessionStateInitialized = 2,
    IoSessionStateConnected = 3,
    IoSessionStateDisconnected = 4,
    IoSessionStateDisconnectedLoggedOn = 5,
    IoSessionStateLoggedOn = 6,
    IoSessionStateLoggedOff = 7,
    IoSessionStateTerminated = 8,
    IoSessionStateMax = 9,
}
pub use self::_IO_SESSION_STATE as IO_SESSION_STATE;
pub type PIO_SESSION_STATE = *mut _IO_SESSION_STATE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_SESSION_CONNECT_INFO {
    pub SessionId: ULONG,
    pub LocalSession: BOOLEAN,
}
#[test]
fn bindgen_test_layout__IO_SESSION_CONNECT_INFO() {
    assert_eq!(::core::mem::size_of::<_IO_SESSION_CONNECT_INFO>() , 8usize);
    assert_eq!(::core::mem::align_of::<_IO_SESSION_CONNECT_INFO>() , 4usize);
}
impl Clone for _IO_SESSION_CONNECT_INFO {
    fn clone(&self) -> Self { *self }
}
pub use self::_IO_SESSION_CONNECT_INFO as IO_SESSION_CONNECT_INFO;
pub type PIO_SESSION_CONNECT_INFO = *mut _IO_SESSION_CONNECT_INFO;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _FILE_INFORMATION_CLASS {
    FileDirectoryInformation = 1,
    FileFullDirectoryInformation = 2,
    FileBothDirectoryInformation = 3,
    FileBasicInformation = 4,
    FileStandardInformation = 5,
    FileInternalInformation = 6,
    FileEaInformation = 7,
    FileAccessInformation = 8,
    FileNameInformation = 9,
    FileRenameInformation = 10,
    FileLinkInformation = 11,
    FileNamesInformation = 12,
    FileDispositionInformation = 13,
    FilePositionInformation = 14,
    FileFullEaInformation = 15,
    FileModeInformation = 16,
    FileAlignmentInformation = 17,
    FileAllInformation = 18,
    FileAllocationInformation = 19,
    FileEndOfFileInformation = 20,
    FileAlternateNameInformation = 21,
    FileStreamInformation = 22,
    FilePipeInformation = 23,
    FilePipeLocalInformation = 24,
    FilePipeRemoteInformation = 25,
    FileMailslotQueryInformation = 26,
    FileMailslotSetInformation = 27,
    FileCompressionInformation = 28,
    FileObjectIdInformation = 29,
    FileCompletionInformation = 30,
    FileMoveClusterInformation = 31,
    FileQuotaInformation = 32,
    FileReparsePointInformation = 33,
    FileNetworkOpenInformation = 34,
    FileAttributeTagInformation = 35,
    FileTrackingInformation = 36,
    FileIdBothDirectoryInformation = 37,
    FileIdFullDirectoryInformation = 38,
    FileValidDataLengthInformation = 39,
    FileShortNameInformation = 40,
    FileIoCompletionNotificationInformation = 41,
    FileIoStatusBlockRangeInformation = 42,
    FileIoPriorityHintInformation = 43,
    FileSfioReserveInformation = 44,
    FileSfioVolumeInformation = 45,
    FileHardLinkInformation = 46,
    FileProcessIdsUsingFileInformation = 47,
    FileNormalizedNameInformation = 48,
    FileNetworkPhysicalNameInformation = 49,
    FileIdGlobalTxDirectoryInformation = 50,
    FileIsRemoteDeviceInformation = 51,
    FileUnusedInformation = 52,
    FileNumaNodeInformation = 53,
    FileStandardLinkInformation = 54,
    FileRemoteProtocolInformation = 55,
    FileRenameInformationBypassAccessCheck = 56,
    FileLinkInformationBypassAccessCheck = 57,
    FileVolumeNameInformation = 58,
    FileIdInformation = 59,
    FileIdExtdDirectoryInformation = 60,
    FileReplaceCompletionInformation = 61,
    FileHardLinkFullIdInformation = 62,
    FileIdExtdBothDirectoryInformation = 63,
    FileDispositionInformationEx = 64,
    FileRenameInformationEx = 65,
    FileRenameInformationExBypassAccessCheck = 66,
    FileMaximumInformation = 67,
}
pub use self::_FILE_INFORMATION_CLASS as FILE_INFORMATION_CLASS;
pub type PFILE_INFORMATION_CLASS = *mut _FILE_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _FILE_BASIC_INFORMATION {
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub FileAttributes: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_BASIC_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_FILE_BASIC_INFORMATION>() , 40usize);
    assert_eq!(::core::mem::align_of::<_FILE_BASIC_INFORMATION>() , 8usize);
}
impl Clone for _FILE_BASIC_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_FILE_BASIC_INFORMATION as FILE_BASIC_INFORMATION;
pub type PFILE_BASIC_INFORMATION = *mut _FILE_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _FILE_STANDARD_INFORMATION {
    pub AllocationSize: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub NumberOfLinks: ULONG,
    pub DeletePending: BOOLEAN,
    pub Directory: BOOLEAN,
}
#[test]
fn bindgen_test_layout__FILE_STANDARD_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_FILE_STANDARD_INFORMATION>() ,
               24usize);
    assert_eq!(::core::mem::align_of::<_FILE_STANDARD_INFORMATION>() ,
               8usize);
}
impl Clone for _FILE_STANDARD_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_FILE_STANDARD_INFORMATION as FILE_STANDARD_INFORMATION;
pub type PFILE_STANDARD_INFORMATION = *mut _FILE_STANDARD_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _FILE_STANDARD_INFORMATION_EX {
    pub AllocationSize: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub NumberOfLinks: ULONG,
    pub DeletePending: BOOLEAN,
    pub Directory: BOOLEAN,
    pub AlternateStream: BOOLEAN,
    pub MetadataAttribute: BOOLEAN,
}
#[test]
fn bindgen_test_layout__FILE_STANDARD_INFORMATION_EX() {
    assert_eq!(::core::mem::size_of::<_FILE_STANDARD_INFORMATION_EX>() ,
               24usize);
    assert_eq!(::core::mem::align_of::<_FILE_STANDARD_INFORMATION_EX>() ,
               8usize);
}
impl Clone for _FILE_STANDARD_INFORMATION_EX {
    fn clone(&self) -> Self { *self }
}
pub use self::_FILE_STANDARD_INFORMATION_EX as FILE_STANDARD_INFORMATION_EX;
pub type PFILE_STANDARD_INFORMATION_EX = *mut _FILE_STANDARD_INFORMATION_EX;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _FILE_POSITION_INFORMATION {
    pub CurrentByteOffset: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__FILE_POSITION_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_FILE_POSITION_INFORMATION>() , 8usize);
    assert_eq!(::core::mem::align_of::<_FILE_POSITION_INFORMATION>() ,
               8usize);
}
impl Clone for _FILE_POSITION_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_FILE_POSITION_INFORMATION as FILE_POSITION_INFORMATION;
pub type PFILE_POSITION_INFORMATION = *mut _FILE_POSITION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _FILE_NETWORK_OPEN_INFORMATION {
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub FileAttributes: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_NETWORK_OPEN_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_FILE_NETWORK_OPEN_INFORMATION>() ,
               56usize);
    assert_eq!(::core::mem::align_of::<_FILE_NETWORK_OPEN_INFORMATION>() ,
               8usize);
}
impl Clone for _FILE_NETWORK_OPEN_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_FILE_NETWORK_OPEN_INFORMATION as FILE_NETWORK_OPEN_INFORMATION;
pub type PFILE_NETWORK_OPEN_INFORMATION = *mut _FILE_NETWORK_OPEN_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _FILE_FULL_EA_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub Flags: UCHAR,
    pub EaNameLength: UCHAR,
    pub EaValueLength: USHORT,
    pub EaName: [CHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_FULL_EA_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_FILE_FULL_EA_INFORMATION>() , 12usize);
    assert_eq!(::core::mem::align_of::<_FILE_FULL_EA_INFORMATION>() , 4usize);
}
impl Clone for _FILE_FULL_EA_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_FILE_FULL_EA_INFORMATION as FILE_FULL_EA_INFORMATION;
pub type PFILE_FULL_EA_INFORMATION = *mut _FILE_FULL_EA_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _FILE_SFIO_RESERVE_INFORMATION {
    pub RequestsPerPeriod: ULONG,
    pub Period: ULONG,
    pub RetryFailures: BOOLEAN,
    pub Discardable: BOOLEAN,
    pub RequestSize: ULONG,
    pub NumOutstandingRequests: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_SFIO_RESERVE_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_FILE_SFIO_RESERVE_INFORMATION>() ,
               20usize);
    assert_eq!(::core::mem::align_of::<_FILE_SFIO_RESERVE_INFORMATION>() ,
               4usize);
}
impl Clone for _FILE_SFIO_RESERVE_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_FILE_SFIO_RESERVE_INFORMATION as FILE_SFIO_RESERVE_INFORMATION;
pub type PFILE_SFIO_RESERVE_INFORMATION = *mut _FILE_SFIO_RESERVE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _FILE_SFIO_VOLUME_INFORMATION {
    pub MaximumRequestsPerPeriod: ULONG,
    pub MinimumPeriod: ULONG,
    pub MinimumTransferSize: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_SFIO_VOLUME_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_FILE_SFIO_VOLUME_INFORMATION>() ,
               12usize);
    assert_eq!(::core::mem::align_of::<_FILE_SFIO_VOLUME_INFORMATION>() ,
               4usize);
}
impl Clone for _FILE_SFIO_VOLUME_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_FILE_SFIO_VOLUME_INFORMATION as FILE_SFIO_VOLUME_INFORMATION;
pub type PFILE_SFIO_VOLUME_INFORMATION = *mut _FILE_SFIO_VOLUME_INFORMATION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _IO_PRIORITY_HINT {
    IoPriorityVeryLow = 0,
    IoPriorityLow = 1,
    IoPriorityNormal = 2,
    IoPriorityHigh = 3,
    IoPriorityCritical = 4,
    MaxIoPriorityTypes = 5,
}
pub use self::_IO_PRIORITY_HINT as IO_PRIORITY_HINT;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _FILE_IO_PRIORITY_HINT_INFORMATION {
    pub PriorityHint: IO_PRIORITY_HINT,
}
#[test]
fn bindgen_test_layout__FILE_IO_PRIORITY_HINT_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_FILE_IO_PRIORITY_HINT_INFORMATION>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_FILE_IO_PRIORITY_HINT_INFORMATION>() ,
               4usize);
}
impl Clone for _FILE_IO_PRIORITY_HINT_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_FILE_IO_PRIORITY_HINT_INFORMATION as
        FILE_IO_PRIORITY_HINT_INFORMATION;
pub type PFILE_IO_PRIORITY_HINT_INFORMATION =
    *mut _FILE_IO_PRIORITY_HINT_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _FILE_IO_PRIORITY_HINT_INFORMATION_EX {
    pub PriorityHint: IO_PRIORITY_HINT,
    pub BoostOutstanding: BOOLEAN,
}
#[test]
fn bindgen_test_layout__FILE_IO_PRIORITY_HINT_INFORMATION_EX() {
    assert_eq!(::core::mem::size_of::<_FILE_IO_PRIORITY_HINT_INFORMATION_EX>()
               , 8usize);
    assert_eq!(::core::mem::align_of::<_FILE_IO_PRIORITY_HINT_INFORMATION_EX>()
               , 4usize);
}
impl Clone for _FILE_IO_PRIORITY_HINT_INFORMATION_EX {
    fn clone(&self) -> Self { *self }
}
pub use self::_FILE_IO_PRIORITY_HINT_INFORMATION_EX as
        FILE_IO_PRIORITY_HINT_INFORMATION_EX;
pub type PFILE_IO_PRIORITY_HINT_INFORMATION_EX =
    *mut _FILE_IO_PRIORITY_HINT_INFORMATION_EX;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _FILE_IO_COMPLETION_NOTIFICATION_INFORMATION {
    pub Flags: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_IO_COMPLETION_NOTIFICATION_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_FILE_IO_COMPLETION_NOTIFICATION_INFORMATION>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_FILE_IO_COMPLETION_NOTIFICATION_INFORMATION>()
               , 4usize);
}
impl Clone for _FILE_IO_COMPLETION_NOTIFICATION_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_FILE_IO_COMPLETION_NOTIFICATION_INFORMATION as
        FILE_IO_COMPLETION_NOTIFICATION_INFORMATION;
pub type PFILE_IO_COMPLETION_NOTIFICATION_INFORMATION =
    *mut _FILE_IO_COMPLETION_NOTIFICATION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _FILE_PROCESS_IDS_USING_FILE_INFORMATION {
    pub NumberOfProcessIdsInList: ULONG,
    pub ProcessIdList: [ULONG_PTR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_PROCESS_IDS_USING_FILE_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_FILE_PROCESS_IDS_USING_FILE_INFORMATION>()
               , 16usize);
    assert_eq!(::core::mem::align_of::<_FILE_PROCESS_IDS_USING_FILE_INFORMATION>()
               , 8usize);
}
impl Clone for _FILE_PROCESS_IDS_USING_FILE_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_FILE_PROCESS_IDS_USING_FILE_INFORMATION as
        FILE_PROCESS_IDS_USING_FILE_INFORMATION;
pub type PFILE_PROCESS_IDS_USING_FILE_INFORMATION =
    *mut _FILE_PROCESS_IDS_USING_FILE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _FILE_IS_REMOTE_DEVICE_INFORMATION {
    pub IsRemote: BOOLEAN,
}
#[test]
fn bindgen_test_layout__FILE_IS_REMOTE_DEVICE_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_FILE_IS_REMOTE_DEVICE_INFORMATION>() ,
               1usize);
    assert_eq!(::core::mem::align_of::<_FILE_IS_REMOTE_DEVICE_INFORMATION>() ,
               1usize);
}
impl Clone for _FILE_IS_REMOTE_DEVICE_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_FILE_IS_REMOTE_DEVICE_INFORMATION as
        FILE_IS_REMOTE_DEVICE_INFORMATION;
pub type PFILE_IS_REMOTE_DEVICE_INFORMATION =
    *mut _FILE_IS_REMOTE_DEVICE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _FILE_NUMA_NODE_INFORMATION {
    pub NodeNumber: USHORT,
}
#[test]
fn bindgen_test_layout__FILE_NUMA_NODE_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_FILE_NUMA_NODE_INFORMATION>() ,
               2usize);
    assert_eq!(::core::mem::align_of::<_FILE_NUMA_NODE_INFORMATION>() ,
               2usize);
}
impl Clone for _FILE_NUMA_NODE_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_FILE_NUMA_NODE_INFORMATION as FILE_NUMA_NODE_INFORMATION;
pub type PFILE_NUMA_NODE_INFORMATION = *mut _FILE_NUMA_NODE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _FILE_IOSTATUSBLOCK_RANGE_INFORMATION {
    pub IoStatusBlockRange: PUCHAR,
    pub Length: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_IOSTATUSBLOCK_RANGE_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_FILE_IOSTATUSBLOCK_RANGE_INFORMATION>()
               , 16usize);
    assert_eq!(::core::mem::align_of::<_FILE_IOSTATUSBLOCK_RANGE_INFORMATION>()
               , 8usize);
}
impl Clone for _FILE_IOSTATUSBLOCK_RANGE_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_FILE_IOSTATUSBLOCK_RANGE_INFORMATION as
        FILE_IOSTATUSBLOCK_RANGE_INFORMATION;
pub type PFILE_IOSTATUSBLOCK_RANGE_INFORMATION =
    *mut _FILE_IOSTATUSBLOCK_RANGE_INFORMATION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _FSINFOCLASS {
    FileFsVolumeInformation = 1,
    FileFsLabelInformation = 2,
    FileFsSizeInformation = 3,
    FileFsDeviceInformation = 4,
    FileFsAttributeInformation = 5,
    FileFsControlInformation = 6,
    FileFsFullSizeInformation = 7,
    FileFsObjectIdInformation = 8,
    FileFsDriverPathInformation = 9,
    FileFsVolumeFlagsInformation = 10,
    FileFsSectorSizeInformation = 11,
    FileFsDataCopyInformation = 12,
    FileFsMetadataSizeInformation = 13,
    FileFsMaximumInformation = 14,
}
pub use self::_FSINFOCLASS as FS_INFORMATION_CLASS;
pub type PFS_INFORMATION_CLASS = *mut _FSINFOCLASS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _FILE_FS_DEVICE_INFORMATION {
    pub DeviceType: ULONG,
    pub Characteristics: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_FS_DEVICE_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_FILE_FS_DEVICE_INFORMATION>() ,
               8usize);
    assert_eq!(::core::mem::align_of::<_FILE_FS_DEVICE_INFORMATION>() ,
               4usize);
}
impl Clone for _FILE_FS_DEVICE_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_FILE_FS_DEVICE_INFORMATION as FILE_FS_DEVICE_INFORMATION;
pub type PFILE_FS_DEVICE_INFORMATION = *mut _FILE_FS_DEVICE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _FILE_SEGMENT_ELEMENT {
    pub Buffer: __BindgenUnionField<*mut libc::c_void>,
    pub Alignment: __BindgenUnionField<ULONGLONG>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__FILE_SEGMENT_ELEMENT() {
    assert_eq!(::core::mem::size_of::<_FILE_SEGMENT_ELEMENT>() , 8usize);
    assert_eq!(::core::mem::align_of::<_FILE_SEGMENT_ELEMENT>() , 8usize);
}
impl Clone for _FILE_SEGMENT_ELEMENT {
    fn clone(&self) -> Self { *self }
}
pub use self::_FILE_SEGMENT_ELEMENT as FILE_SEGMENT_ELEMENT;
pub type PFILE_SEGMENT_ELEMENT = *mut _FILE_SEGMENT_ELEMENT;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _INTERFACE_TYPE {
    InterfaceTypeUndefined = -1,
    Internal = 0,
    Isa = 1,
    Eisa = 2,
    MicroChannel = 3,
    TurboChannel = 4,
    PCIBus = 5,
    VMEBus = 6,
    NuBus = 7,
    PCMCIABus = 8,
    CBus = 9,
    MPIBus = 10,
    MPSABus = 11,
    ProcessorInternal = 12,
    InternalPowerBus = 13,
    PNPISABus = 14,
    PNPBus = 15,
    Vmcs = 16,
    ACPIBus = 17,
    MaximumInterfaceType = 18,
}
pub use self::_INTERFACE_TYPE as INTERFACE_TYPE;
pub type PINTERFACE_TYPE = *mut _INTERFACE_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _DMA_WIDTH {
    Width8Bits = 0,
    Width16Bits = 1,
    Width32Bits = 2,
    Width64Bits = 3,
    WidthNoWrap = 4,
    MaximumDmaWidth = 5,
}
pub use self::_DMA_WIDTH as DMA_WIDTH;
pub type PDMA_WIDTH = *mut _DMA_WIDTH;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _DMA_SPEED {
    Compatible = 0,
    TypeA = 1,
    TypeB = 2,
    TypeC = 3,
    TypeF = 4,
    MaximumDmaSpeed = 5,
}
pub use self::_DMA_SPEED as DMA_SPEED;
pub type PDMA_SPEED = *mut _DMA_SPEED;
pub type PINTERFACE_REFERENCE =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID)>;
pub type PINTERFACE_DEREFERENCE =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_ERROR_LOG_PACKET {
    pub MajorFunctionCode: UCHAR,
    pub RetryCount: UCHAR,
    pub DumpDataSize: USHORT,
    pub NumberOfStrings: USHORT,
    pub StringOffset: USHORT,
    pub EventCategory: USHORT,
    pub ErrorCode: NTSTATUS,
    pub UniqueErrorValue: ULONG,
    pub FinalStatus: NTSTATUS,
    pub SequenceNumber: ULONG,
    pub IoControlCode: ULONG,
    pub DeviceOffset: LARGE_INTEGER,
    pub DumpData: [ULONG; 1usize],
}
#[test]
fn bindgen_test_layout__IO_ERROR_LOG_PACKET() {
    assert_eq!(::core::mem::size_of::<_IO_ERROR_LOG_PACKET>() , 48usize);
    assert_eq!(::core::mem::align_of::<_IO_ERROR_LOG_PACKET>() , 8usize);
}
impl Clone for _IO_ERROR_LOG_PACKET {
    fn clone(&self) -> Self { *self }
}
pub use self::_IO_ERROR_LOG_PACKET as IO_ERROR_LOG_PACKET;
pub type PIO_ERROR_LOG_PACKET = *mut _IO_ERROR_LOG_PACKET;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_ERROR_LOG_MESSAGE {
    pub Type: USHORT,
    pub Size: USHORT,
    pub DriverNameLength: USHORT,
    pub TimeStamp: LARGE_INTEGER,
    pub DriverNameOffset: ULONG,
    pub EntryData: IO_ERROR_LOG_PACKET,
}
#[test]
fn bindgen_test_layout__IO_ERROR_LOG_MESSAGE() {
    assert_eq!(::core::mem::size_of::<_IO_ERROR_LOG_MESSAGE>() , 72usize);
    assert_eq!(::core::mem::align_of::<_IO_ERROR_LOG_MESSAGE>() , 8usize);
}
impl Clone for _IO_ERROR_LOG_MESSAGE {
    fn clone(&self) -> Self { *self }
}
pub use self::_IO_ERROR_LOG_MESSAGE as IO_ERROR_LOG_MESSAGE;
pub type PIO_ERROR_LOG_MESSAGE = *mut _IO_ERROR_LOG_MESSAGE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KEY_BASIC_INFORMATION {
    pub LastWriteTime: LARGE_INTEGER,
    pub TitleIndex: ULONG,
    pub NameLength: ULONG,
    pub Name: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__KEY_BASIC_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_KEY_BASIC_INFORMATION>() , 24usize);
    assert_eq!(::core::mem::align_of::<_KEY_BASIC_INFORMATION>() , 8usize);
}
impl Clone for _KEY_BASIC_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_KEY_BASIC_INFORMATION as KEY_BASIC_INFORMATION;
pub type PKEY_BASIC_INFORMATION = *mut _KEY_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KEY_NODE_INFORMATION {
    pub LastWriteTime: LARGE_INTEGER,
    pub TitleIndex: ULONG,
    pub ClassOffset: ULONG,
    pub ClassLength: ULONG,
    pub NameLength: ULONG,
    pub Name: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__KEY_NODE_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_KEY_NODE_INFORMATION>() , 32usize);
    assert_eq!(::core::mem::align_of::<_KEY_NODE_INFORMATION>() , 8usize);
}
impl Clone for _KEY_NODE_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_KEY_NODE_INFORMATION as KEY_NODE_INFORMATION;
pub type PKEY_NODE_INFORMATION = *mut _KEY_NODE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KEY_FULL_INFORMATION {
    pub LastWriteTime: LARGE_INTEGER,
    pub TitleIndex: ULONG,
    pub ClassOffset: ULONG,
    pub ClassLength: ULONG,
    pub SubKeys: ULONG,
    pub MaxNameLen: ULONG,
    pub MaxClassLen: ULONG,
    pub Values: ULONG,
    pub MaxValueNameLen: ULONG,
    pub MaxValueDataLen: ULONG,
    pub Class: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__KEY_FULL_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_KEY_FULL_INFORMATION>() , 48usize);
    assert_eq!(::core::mem::align_of::<_KEY_FULL_INFORMATION>() , 8usize);
}
impl Clone for _KEY_FULL_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_KEY_FULL_INFORMATION as KEY_FULL_INFORMATION;
pub type PKEY_FULL_INFORMATION = *mut _KEY_FULL_INFORMATION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _KEY_INFORMATION_CLASS {
    KeyBasicInformation = 0,
    KeyNodeInformation = 1,
    KeyFullInformation = 2,
    KeyNameInformation = 3,
    KeyCachedInformation = 4,
    KeyFlagsInformation = 5,
    KeyVirtualizationInformation = 6,
    KeyHandleTagsInformation = 7,
    KeyTrustInformation = 8,
    KeyLayerInformation = 9,
    MaxKeyInfoClass = 10,
}
pub use self::_KEY_INFORMATION_CLASS as KEY_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KEY_WRITE_TIME_INFORMATION {
    pub LastWriteTime: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__KEY_WRITE_TIME_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_KEY_WRITE_TIME_INFORMATION>() ,
               8usize);
    assert_eq!(::core::mem::align_of::<_KEY_WRITE_TIME_INFORMATION>() ,
               8usize);
}
impl Clone for _KEY_WRITE_TIME_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_KEY_WRITE_TIME_INFORMATION as KEY_WRITE_TIME_INFORMATION;
pub type PKEY_WRITE_TIME_INFORMATION = *mut _KEY_WRITE_TIME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KEY_WOW64_FLAGS_INFORMATION {
    pub UserFlags: ULONG,
}
#[test]
fn bindgen_test_layout__KEY_WOW64_FLAGS_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_KEY_WOW64_FLAGS_INFORMATION>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_KEY_WOW64_FLAGS_INFORMATION>() ,
               4usize);
}
impl Clone for _KEY_WOW64_FLAGS_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_KEY_WOW64_FLAGS_INFORMATION as KEY_WOW64_FLAGS_INFORMATION;
pub type PKEY_WOW64_FLAGS_INFORMATION = *mut _KEY_WOW64_FLAGS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KEY_CONTROL_FLAGS_INFORMATION {
    pub ControlFlags: ULONG,
}
#[test]
fn bindgen_test_layout__KEY_CONTROL_FLAGS_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_KEY_CONTROL_FLAGS_INFORMATION>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_KEY_CONTROL_FLAGS_INFORMATION>() ,
               4usize);
}
impl Clone for _KEY_CONTROL_FLAGS_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_KEY_CONTROL_FLAGS_INFORMATION as KEY_CONTROL_FLAGS_INFORMATION;
pub type PKEY_CONTROL_FLAGS_INFORMATION = *mut _KEY_CONTROL_FLAGS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KEY_SET_VIRTUALIZATION_INFORMATION {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__KEY_SET_VIRTUALIZATION_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_KEY_SET_VIRTUALIZATION_INFORMATION>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_KEY_SET_VIRTUALIZATION_INFORMATION>()
               , 4usize);
}
impl Clone for _KEY_SET_VIRTUALIZATION_INFORMATION {
    fn clone(&self) -> Self { *self }
}
impl _KEY_SET_VIRTUALIZATION_INFORMATION {
    #[inline]
    pub fn VirtualTarget(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_VirtualTarget(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn VirtualStore(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_VirtualStore(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn VirtualSource(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                        2u32) as u32)
        }
    }
    #[inline]
    pub fn set_VirtualSource(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967288usize as u32)) >> 3u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967288usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 3u32) & (4294967288usize as u32);
    }
}
pub use self::_KEY_SET_VIRTUALIZATION_INFORMATION as
        KEY_SET_VIRTUALIZATION_INFORMATION;
pub type PKEY_SET_VIRTUALIZATION_INFORMATION =
    *mut _KEY_SET_VIRTUALIZATION_INFORMATION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _KEY_SET_INFORMATION_CLASS {
    KeyWriteTimeInformation = 0,
    KeyWow64FlagsInformation = 1,
    KeyControlFlagsInformation = 2,
    KeySetVirtualizationInformation = 3,
    KeySetDebugInformation = 4,
    KeySetHandleTagsInformation = 5,
    MaxKeySetInfoClass = 6,
}
pub use self::_KEY_SET_INFORMATION_CLASS as KEY_SET_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KEY_VALUE_BASIC_INFORMATION {
    pub TitleIndex: ULONG,
    pub Type: ULONG,
    pub NameLength: ULONG,
    pub Name: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__KEY_VALUE_BASIC_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_KEY_VALUE_BASIC_INFORMATION>() ,
               16usize);
    assert_eq!(::core::mem::align_of::<_KEY_VALUE_BASIC_INFORMATION>() ,
               4usize);
}
impl Clone for _KEY_VALUE_BASIC_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_KEY_VALUE_BASIC_INFORMATION as KEY_VALUE_BASIC_INFORMATION;
pub type PKEY_VALUE_BASIC_INFORMATION = *mut _KEY_VALUE_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KEY_VALUE_FULL_INFORMATION {
    pub TitleIndex: ULONG,
    pub Type: ULONG,
    pub DataOffset: ULONG,
    pub DataLength: ULONG,
    pub NameLength: ULONG,
    pub Name: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__KEY_VALUE_FULL_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_KEY_VALUE_FULL_INFORMATION>() ,
               24usize);
    assert_eq!(::core::mem::align_of::<_KEY_VALUE_FULL_INFORMATION>() ,
               4usize);
}
impl Clone for _KEY_VALUE_FULL_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_KEY_VALUE_FULL_INFORMATION as KEY_VALUE_FULL_INFORMATION;
pub type PKEY_VALUE_FULL_INFORMATION = *mut _KEY_VALUE_FULL_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KEY_VALUE_PARTIAL_INFORMATION {
    pub TitleIndex: ULONG,
    pub Type: ULONG,
    pub DataLength: ULONG,
    pub Data: [UCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__KEY_VALUE_PARTIAL_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_KEY_VALUE_PARTIAL_INFORMATION>() ,
               16usize);
    assert_eq!(::core::mem::align_of::<_KEY_VALUE_PARTIAL_INFORMATION>() ,
               4usize);
}
impl Clone for _KEY_VALUE_PARTIAL_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_KEY_VALUE_PARTIAL_INFORMATION as KEY_VALUE_PARTIAL_INFORMATION;
pub type PKEY_VALUE_PARTIAL_INFORMATION = *mut _KEY_VALUE_PARTIAL_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 {
    pub Type: ULONG,
    pub DataLength: ULONG,
    pub Data: [UCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__KEY_VALUE_PARTIAL_INFORMATION_ALIGN64() {
    assert_eq!(::core::mem::size_of::<_KEY_VALUE_PARTIAL_INFORMATION_ALIGN64>()
               , 12usize);
    assert_eq!(::core::mem::align_of::<_KEY_VALUE_PARTIAL_INFORMATION_ALIGN64>()
               , 4usize);
}
impl Clone for _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 {
    fn clone(&self) -> Self { *self }
}
pub use self::_KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 as
        KEY_VALUE_PARTIAL_INFORMATION_ALIGN64;
pub type PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64 =
    *mut _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KEY_VALUE_LAYER_INFORMATION {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__KEY_VALUE_LAYER_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_KEY_VALUE_LAYER_INFORMATION>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_KEY_VALUE_LAYER_INFORMATION>() ,
               4usize);
}
impl Clone for _KEY_VALUE_LAYER_INFORMATION {
    fn clone(&self) -> Self { *self }
}
impl _KEY_VALUE_LAYER_INFORMATION {
    #[inline]
    pub fn IsTombstone(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_IsTombstone(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967294usize as u32)) >> 1u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967294usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 1u32) & (4294967294usize as u32);
    }
}
pub use self::_KEY_VALUE_LAYER_INFORMATION as KEY_VALUE_LAYER_INFORMATION;
pub type PKEY_VALUE_LAYER_INFORMATION = *mut _KEY_VALUE_LAYER_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KEY_VALUE_ENTRY {
    pub ValueName: PUNICODE_STRING,
    pub DataLength: ULONG,
    pub DataOffset: ULONG,
    pub Type: ULONG,
}
#[test]
fn bindgen_test_layout__KEY_VALUE_ENTRY() {
    assert_eq!(::core::mem::size_of::<_KEY_VALUE_ENTRY>() , 24usize);
    assert_eq!(::core::mem::align_of::<_KEY_VALUE_ENTRY>() , 8usize);
}
impl Clone for _KEY_VALUE_ENTRY {
    fn clone(&self) -> Self { *self }
}
pub use self::_KEY_VALUE_ENTRY as KEY_VALUE_ENTRY;
pub type PKEY_VALUE_ENTRY = *mut _KEY_VALUE_ENTRY;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _KEY_VALUE_INFORMATION_CLASS {
    KeyValueBasicInformation = 0,
    KeyValueFullInformation = 1,
    KeyValuePartialInformation = 2,
    KeyValueFullInformationAlign64 = 3,
    KeyValuePartialInformationAlign64 = 4,
    KeyValueLayerInformation = 5,
    MaxKeyValueInfoClass = 6,
}
pub use self::_KEY_VALUE_INFORMATION_CLASS as KEY_VALUE_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KEY_TRUST_INFORMATION {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__KEY_TRUST_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_KEY_TRUST_INFORMATION>() , 4usize);
    assert_eq!(::core::mem::align_of::<_KEY_TRUST_INFORMATION>() , 4usize);
}
impl Clone for _KEY_TRUST_INFORMATION {
    fn clone(&self) -> Self { *self }
}
impl _KEY_TRUST_INFORMATION {
    #[inline]
    pub fn TrustedKey(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_TrustedKey(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967294usize as u32)) >> 1u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967294usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 1u32) & (4294967294usize as u32);
    }
}
pub use self::_KEY_TRUST_INFORMATION as KEY_TRUST_INFORMATION;
pub type PKEY_TRUST_INFORMATION = *mut _KEY_TRUST_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _OBJECT_NAME_INFORMATION {
    pub Name: UNICODE_STRING,
}
#[test]
fn bindgen_test_layout__OBJECT_NAME_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_OBJECT_NAME_INFORMATION>() , 16usize);
    assert_eq!(::core::mem::align_of::<_OBJECT_NAME_INFORMATION>() , 8usize);
}
impl Clone for _OBJECT_NAME_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_OBJECT_NAME_INFORMATION as OBJECT_NAME_INFORMATION;
pub type POBJECT_NAME_INFORMATION = *mut _OBJECT_NAME_INFORMATION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _SECTION_INHERIT { ViewShare = 1, ViewUnmap = 2, }
pub use self::_SECTION_INHERIT as SECTION_INHERIT;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CLIENT_ID {
    pub UniqueProcess: HANDLE,
    pub UniqueThread: HANDLE,
}
#[test]
fn bindgen_test_layout__CLIENT_ID() {
    assert_eq!(::core::mem::size_of::<_CLIENT_ID>() , 16usize);
    assert_eq!(::core::mem::align_of::<_CLIENT_ID>() , 8usize);
}
impl Clone for _CLIENT_ID {
    fn clone(&self) -> Self { *self }
}
pub use self::_CLIENT_ID as CLIENT_ID;
pub type PCLIENT_ID = *mut CLIENT_ID;
extern "C" {
    #[link_name = "GUID_MAX_POWER_SAVINGS"]
    pub static GUID_MAX_POWER_SAVINGS: GUID;
}
extern "C" {
    #[link_name = "GUID_MIN_POWER_SAVINGS"]
    pub static GUID_MIN_POWER_SAVINGS: GUID;
}
extern "C" {
    #[link_name = "GUID_TYPICAL_POWER_SAVINGS"]
    pub static GUID_TYPICAL_POWER_SAVINGS: GUID;
}
extern "C" {
    #[link_name = "NO_SUBGROUP_GUID"]
    pub static NO_SUBGROUP_GUID: GUID;
}
extern "C" {
    #[link_name = "ALL_POWERSCHEMES_GUID"]
    pub static ALL_POWERSCHEMES_GUID: GUID;
}
extern "C" {
    #[link_name = "GUID_POWERSCHEME_PERSONALITY"]
    pub static GUID_POWERSCHEME_PERSONALITY: GUID;
}
extern "C" {
    #[link_name = "GUID_ACTIVE_POWERSCHEME"]
    pub static GUID_ACTIVE_POWERSCHEME: GUID;
}
extern "C" {
    #[link_name = "GUID_IDLE_RESILIENCY_SUBGROUP"]
    pub static GUID_IDLE_RESILIENCY_SUBGROUP: GUID;
}
extern "C" {
    #[link_name = "GUID_IDLE_RESILIENCY_PERIOD"]
    pub static GUID_IDLE_RESILIENCY_PERIOD: GUID;
}
extern "C" {
    #[link_name = "GUID_DEEP_SLEEP_ENABLED"]
    pub static GUID_DEEP_SLEEP_ENABLED: GUID;
}
extern "C" {
    #[link_name = "GUID_DEEP_SLEEP_PLATFORM_STATE"]
    pub static GUID_DEEP_SLEEP_PLATFORM_STATE: GUID;
}
extern "C" {
    #[link_name = "GUID_DISK_COALESCING_POWERDOWN_TIMEOUT"]
    pub static GUID_DISK_COALESCING_POWERDOWN_TIMEOUT: GUID;
}
extern "C" {
    #[link_name = "GUID_EXECUTION_REQUIRED_REQUEST_TIMEOUT"]
    pub static GUID_EXECUTION_REQUIRED_REQUEST_TIMEOUT: GUID;
}
extern "C" {
    #[link_name = "GUID_VIDEO_SUBGROUP"]
    pub static GUID_VIDEO_SUBGROUP: GUID;
}
extern "C" {
    #[link_name = "GUID_VIDEO_POWERDOWN_TIMEOUT"]
    pub static GUID_VIDEO_POWERDOWN_TIMEOUT: GUID;
}
extern "C" {
    #[link_name = "GUID_VIDEO_ANNOYANCE_TIMEOUT"]
    pub static GUID_VIDEO_ANNOYANCE_TIMEOUT: GUID;
}
extern "C" {
    #[link_name = "GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE"]
    pub static GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE: GUID;
}
extern "C" {
    #[link_name = "GUID_VIDEO_DIM_TIMEOUT"]
    pub static GUID_VIDEO_DIM_TIMEOUT: GUID;
}
extern "C" {
    #[link_name = "GUID_VIDEO_ADAPTIVE_POWERDOWN"]
    pub static GUID_VIDEO_ADAPTIVE_POWERDOWN: GUID;
}
extern "C" {
    #[link_name = "GUID_DISK_MAX_POWER"]
    pub static GUID_DISK_MAX_POWER: GUID;
}
extern "C" {
    #[link_name = "GUID_MONITOR_POWER_ON"]
    pub static GUID_MONITOR_POWER_ON: GUID;
}
extern "C" {
    #[link_name = "GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS"]
    pub static GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS: GUID;
}
extern "C" {
    #[link_name = "GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS"]
    pub static GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS: GUID;
}
extern "C" {
    #[link_name = "GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS"]
    pub static GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS: GUID;
}
extern "C" {
    #[link_name = "GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS"]
    pub static GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS: GUID;
}
extern "C" {
    #[link_name = "GUID_CONSOLE_DISPLAY_STATE"]
    pub static GUID_CONSOLE_DISPLAY_STATE: GUID;
}
extern "C" {
    #[link_name = "GUID_ALLOW_DISPLAY_REQUIRED"]
    pub static GUID_ALLOW_DISPLAY_REQUIRED: GUID;
}
extern "C" {
    #[link_name = "GUID_VIDEO_CONSOLE_LOCK_TIMEOUT"]
    pub static GUID_VIDEO_CONSOLE_LOCK_TIMEOUT: GUID;
}
extern "C" {
    #[link_name = "GUID_ADAPTIVE_POWER_BEHAVIOR_SUBGROUP"]
    pub static GUID_ADAPTIVE_POWER_BEHAVIOR_SUBGROUP: GUID;
}
extern "C" {
    #[link_name = "GUID_NON_ADAPTIVE_INPUT_TIMEOUT"]
    pub static GUID_NON_ADAPTIVE_INPUT_TIMEOUT: GUID;
}
extern "C" {
    #[link_name = "GUID_DISK_SUBGROUP"]
    pub static GUID_DISK_SUBGROUP: GUID;
}
extern "C" {
    #[link_name = "GUID_DISK_POWERDOWN_TIMEOUT"]
    pub static GUID_DISK_POWERDOWN_TIMEOUT: GUID;
}
extern "C" {
    #[link_name = "GUID_DISK_IDLE_TIMEOUT"]
    pub static GUID_DISK_IDLE_TIMEOUT: GUID;
}
extern "C" {
    #[link_name = "GUID_DISK_BURST_IGNORE_THRESHOLD"]
    pub static GUID_DISK_BURST_IGNORE_THRESHOLD: GUID;
}
extern "C" {
    #[link_name = "GUID_DISK_ADAPTIVE_POWERDOWN"]
    pub static GUID_DISK_ADAPTIVE_POWERDOWN: GUID;
}
extern "C" {
    #[link_name = "GUID_SLEEP_SUBGROUP"]
    pub static GUID_SLEEP_SUBGROUP: GUID;
}
extern "C" {
    #[link_name = "GUID_SLEEP_IDLE_THRESHOLD"]
    pub static GUID_SLEEP_IDLE_THRESHOLD: GUID;
}
extern "C" {
    #[link_name = "GUID_STANDBY_TIMEOUT"]
    pub static GUID_STANDBY_TIMEOUT: GUID;
}
extern "C" {
    #[link_name = "GUID_UNATTEND_SLEEP_TIMEOUT"]
    pub static GUID_UNATTEND_SLEEP_TIMEOUT: GUID;
}
extern "C" {
    #[link_name = "GUID_HIBERNATE_TIMEOUT"]
    pub static GUID_HIBERNATE_TIMEOUT: GUID;
}
extern "C" {
    #[link_name = "GUID_HIBERNATE_FASTS4_POLICY"]
    pub static GUID_HIBERNATE_FASTS4_POLICY: GUID;
}
extern "C" {
    #[link_name = "GUID_CRITICAL_POWER_TRANSITION"]
    pub static GUID_CRITICAL_POWER_TRANSITION: GUID;
}
extern "C" {
    #[link_name = "GUID_SYSTEM_AWAYMODE"]
    pub static GUID_SYSTEM_AWAYMODE: GUID;
}
extern "C" {
    #[link_name = "GUID_ALLOW_AWAYMODE"]
    pub static GUID_ALLOW_AWAYMODE: GUID;
}
extern "C" {
    #[link_name = "GUID_USER_PRESENCE_PREDICTION"]
    pub static GUID_USER_PRESENCE_PREDICTION: GUID;
}
extern "C" {
    #[link_name = "GUID_STANDBY_BUDGET_GRACE_PERIOD"]
    pub static GUID_STANDBY_BUDGET_GRACE_PERIOD: GUID;
}
extern "C" {
    #[link_name = "GUID_STANDBY_BUDGET_PERCENT"]
    pub static GUID_STANDBY_BUDGET_PERCENT: GUID;
}
extern "C" {
    #[link_name = "GUID_STANDBY_RESERVE_GRACE_PERIOD"]
    pub static GUID_STANDBY_RESERVE_GRACE_PERIOD: GUID;
}
extern "C" {
    #[link_name = "GUID_STANDBY_RESERVE_TIME"]
    pub static GUID_STANDBY_RESERVE_TIME: GUID;
}
extern "C" {
    #[link_name = "GUID_STANDBY_RESET_PERCENT"]
    pub static GUID_STANDBY_RESET_PERCENT: GUID;
}
extern "C" {
    #[link_name = "GUID_ALLOW_STANDBY_STATES"]
    pub static GUID_ALLOW_STANDBY_STATES: GUID;
}
extern "C" {
    #[link_name = "GUID_ALLOW_RTC_WAKE"]
    pub static GUID_ALLOW_RTC_WAKE: GUID;
}
extern "C" {
    #[link_name = "GUID_ALLOW_SYSTEM_REQUIRED"]
    pub static GUID_ALLOW_SYSTEM_REQUIRED: GUID;
}
extern "C" {
    #[link_name = "GUID_POWER_SAVING_STATUS"]
    pub static GUID_POWER_SAVING_STATUS: GUID;
}
extern "C" {
    #[link_name = "GUID_ENERGY_SAVER_SUBGROUP"]
    pub static GUID_ENERGY_SAVER_SUBGROUP: GUID;
}
extern "C" {
    #[link_name = "GUID_ENERGY_SAVER_BATTERY_THRESHOLD"]
    pub static GUID_ENERGY_SAVER_BATTERY_THRESHOLD: GUID;
}
extern "C" {
    #[link_name = "GUID_ENERGY_SAVER_BRIGHTNESS"]
    pub static GUID_ENERGY_SAVER_BRIGHTNESS: GUID;
}
extern "C" {
    #[link_name = "GUID_ENERGY_SAVER_POLICY"]
    pub static GUID_ENERGY_SAVER_POLICY: GUID;
}
extern "C" {
    #[link_name = "GUID_SYSTEM_BUTTON_SUBGROUP"]
    pub static GUID_SYSTEM_BUTTON_SUBGROUP: GUID;
}
extern "C" {
    #[link_name = "GUID_POWERBUTTON_ACTION"]
    pub static GUID_POWERBUTTON_ACTION: GUID;
}
extern "C" {
    #[link_name = "GUID_SLEEPBUTTON_ACTION"]
    pub static GUID_SLEEPBUTTON_ACTION: GUID;
}
extern "C" {
    #[link_name = "GUID_USERINTERFACEBUTTON_ACTION"]
    pub static GUID_USERINTERFACEBUTTON_ACTION: GUID;
}
extern "C" {
    #[link_name = "GUID_LIDCLOSE_ACTION"]
    pub static GUID_LIDCLOSE_ACTION: GUID;
}
extern "C" {
    #[link_name = "GUID_LIDOPEN_POWERSTATE"]
    pub static GUID_LIDOPEN_POWERSTATE: GUID;
}
extern "C" {
    #[link_name = "GUID_BATTERY_SUBGROUP"]
    pub static GUID_BATTERY_SUBGROUP: GUID;
}
extern "C" {
    #[link_name = "GUID_BATTERY_DISCHARGE_ACTION_0"]
    pub static GUID_BATTERY_DISCHARGE_ACTION_0: GUID;
}
extern "C" {
    #[link_name = "GUID_BATTERY_DISCHARGE_LEVEL_0"]
    pub static GUID_BATTERY_DISCHARGE_LEVEL_0: GUID;
}
extern "C" {
    #[link_name = "GUID_BATTERY_DISCHARGE_FLAGS_0"]
    pub static GUID_BATTERY_DISCHARGE_FLAGS_0: GUID;
}
extern "C" {
    #[link_name = "GUID_BATTERY_DISCHARGE_ACTION_1"]
    pub static GUID_BATTERY_DISCHARGE_ACTION_1: GUID;
}
extern "C" {
    #[link_name = "GUID_BATTERY_DISCHARGE_LEVEL_1"]
    pub static GUID_BATTERY_DISCHARGE_LEVEL_1: GUID;
}
extern "C" {
    #[link_name = "GUID_BATTERY_DISCHARGE_FLAGS_1"]
    pub static GUID_BATTERY_DISCHARGE_FLAGS_1: GUID;
}
extern "C" {
    #[link_name = "GUID_BATTERY_DISCHARGE_ACTION_2"]
    pub static GUID_BATTERY_DISCHARGE_ACTION_2: GUID;
}
extern "C" {
    #[link_name = "GUID_BATTERY_DISCHARGE_LEVEL_2"]
    pub static GUID_BATTERY_DISCHARGE_LEVEL_2: GUID;
}
extern "C" {
    #[link_name = "GUID_BATTERY_DISCHARGE_FLAGS_2"]
    pub static GUID_BATTERY_DISCHARGE_FLAGS_2: GUID;
}
extern "C" {
    #[link_name = "GUID_BATTERY_DISCHARGE_ACTION_3"]
    pub static GUID_BATTERY_DISCHARGE_ACTION_3: GUID;
}
extern "C" {
    #[link_name = "GUID_BATTERY_DISCHARGE_LEVEL_3"]
    pub static GUID_BATTERY_DISCHARGE_LEVEL_3: GUID;
}
extern "C" {
    #[link_name = "GUID_BATTERY_DISCHARGE_FLAGS_3"]
    pub static GUID_BATTERY_DISCHARGE_FLAGS_3: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_SETTINGS_SUBGROUP"]
    pub static GUID_PROCESSOR_SETTINGS_SUBGROUP: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_THROTTLE_POLICY"]
    pub static GUID_PROCESSOR_THROTTLE_POLICY: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_THROTTLE_MAXIMUM"]
    pub static GUID_PROCESSOR_THROTTLE_MAXIMUM: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_THROTTLE_MAXIMUM_1"]
    pub static GUID_PROCESSOR_THROTTLE_MAXIMUM_1: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_THROTTLE_MINIMUM"]
    pub static GUID_PROCESSOR_THROTTLE_MINIMUM: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_THROTTLE_MINIMUM_1"]
    pub static GUID_PROCESSOR_THROTTLE_MINIMUM_1: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_ALLOW_THROTTLING"]
    pub static GUID_PROCESSOR_ALLOW_THROTTLING: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_IDLESTATE_POLICY"]
    pub static GUID_PROCESSOR_IDLESTATE_POLICY: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_PERFSTATE_POLICY"]
    pub static GUID_PROCESSOR_PERFSTATE_POLICY: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_PERF_INCREASE_THRESHOLD"]
    pub static GUID_PROCESSOR_PERF_INCREASE_THRESHOLD: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_PERF_INCREASE_THRESHOLD_1"]
    pub static GUID_PROCESSOR_PERF_INCREASE_THRESHOLD_1: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_PERF_DECREASE_THRESHOLD"]
    pub static GUID_PROCESSOR_PERF_DECREASE_THRESHOLD: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_PERF_DECREASE_THRESHOLD_1"]
    pub static GUID_PROCESSOR_PERF_DECREASE_THRESHOLD_1: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_PERF_INCREASE_POLICY"]
    pub static GUID_PROCESSOR_PERF_INCREASE_POLICY: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_PERF_INCREASE_POLICY_1"]
    pub static GUID_PROCESSOR_PERF_INCREASE_POLICY_1: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_PERF_DECREASE_POLICY"]
    pub static GUID_PROCESSOR_PERF_DECREASE_POLICY: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_PERF_DECREASE_POLICY_1"]
    pub static GUID_PROCESSOR_PERF_DECREASE_POLICY_1: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_PERF_INCREASE_TIME"]
    pub static GUID_PROCESSOR_PERF_INCREASE_TIME: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_PERF_INCREASE_TIME_1"]
    pub static GUID_PROCESSOR_PERF_INCREASE_TIME_1: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_PERF_DECREASE_TIME"]
    pub static GUID_PROCESSOR_PERF_DECREASE_TIME: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_PERF_DECREASE_TIME_1"]
    pub static GUID_PROCESSOR_PERF_DECREASE_TIME_1: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_PERF_TIME_CHECK"]
    pub static GUID_PROCESSOR_PERF_TIME_CHECK: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_PERF_BOOST_POLICY"]
    pub static GUID_PROCESSOR_PERF_BOOST_POLICY: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_PERF_BOOST_MODE"]
    pub static GUID_PROCESSOR_PERF_BOOST_MODE: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_PERF_AUTONOMOUS_MODE"]
    pub static GUID_PROCESSOR_PERF_AUTONOMOUS_MODE: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_PERF_ENERGY_PERFORMANCE_PREFERENCE"]
    pub static GUID_PROCESSOR_PERF_ENERGY_PERFORMANCE_PREFERENCE: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_PERF_AUTONOMOUS_ACTIVITY_WINDOW"]
    pub static GUID_PROCESSOR_PERF_AUTONOMOUS_ACTIVITY_WINDOW: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_DUTY_CYCLING"]
    pub static GUID_PROCESSOR_DUTY_CYCLING: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_IDLE_ALLOW_SCALING"]
    pub static GUID_PROCESSOR_IDLE_ALLOW_SCALING: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_IDLE_DISABLE"]
    pub static GUID_PROCESSOR_IDLE_DISABLE: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_IDLE_STATE_MAXIMUM"]
    pub static GUID_PROCESSOR_IDLE_STATE_MAXIMUM: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_IDLE_TIME_CHECK"]
    pub static GUID_PROCESSOR_IDLE_TIME_CHECK: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_IDLE_DEMOTE_THRESHOLD"]
    pub static GUID_PROCESSOR_IDLE_DEMOTE_THRESHOLD: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_IDLE_PROMOTE_THRESHOLD"]
    pub static GUID_PROCESSOR_IDLE_PROMOTE_THRESHOLD: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_CORE_PARKING_INCREASE_THRESHOLD"]
    pub static GUID_PROCESSOR_CORE_PARKING_INCREASE_THRESHOLD: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_CORE_PARKING_DECREASE_THRESHOLD"]
    pub static GUID_PROCESSOR_CORE_PARKING_DECREASE_THRESHOLD: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_CORE_PARKING_INCREASE_POLICY"]
    pub static GUID_PROCESSOR_CORE_PARKING_INCREASE_POLICY: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_CORE_PARKING_DECREASE_POLICY"]
    pub static GUID_PROCESSOR_CORE_PARKING_DECREASE_POLICY: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_CORE_PARKING_MAX_CORES"]
    pub static GUID_PROCESSOR_CORE_PARKING_MAX_CORES: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_CORE_PARKING_MAX_CORES_1"]
    pub static GUID_PROCESSOR_CORE_PARKING_MAX_CORES_1: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_CORE_PARKING_MIN_CORES"]
    pub static GUID_PROCESSOR_CORE_PARKING_MIN_CORES: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_CORE_PARKING_MIN_CORES_1"]
    pub static GUID_PROCESSOR_CORE_PARKING_MIN_CORES_1: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_CORE_PARKING_INCREASE_TIME"]
    pub static GUID_PROCESSOR_CORE_PARKING_INCREASE_TIME: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_CORE_PARKING_DECREASE_TIME"]
    pub static GUID_PROCESSOR_CORE_PARKING_DECREASE_TIME: GUID;
}
extern "C" {
    #[link_name =
          "GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_DECREASE_FACTOR"]
    pub static GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_DECREASE_FACTOR:
               GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_THRESHOLD"]
    pub static GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_THRESHOLD: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_CORE_PARKING_AFFINITY_WEIGHTING"]
    pub static GUID_PROCESSOR_CORE_PARKING_AFFINITY_WEIGHTING: GUID;
}
extern "C" {
    #[link_name =
          "GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_DECREASE_FACTOR"]
    pub static GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_DECREASE_FACTOR:
               GUID;
}
extern "C" {
    #[link_name =
          "GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_THRESHOLD"]
    pub static GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_THRESHOLD:
               GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_WEIGHTING"]
    pub static GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_WEIGHTING: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_THRESHOLD"]
    pub static GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_THRESHOLD: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_PARKING_CORE_OVERRIDE"]
    pub static GUID_PROCESSOR_PARKING_CORE_OVERRIDE: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_PARKING_PERF_STATE"]
    pub static GUID_PROCESSOR_PARKING_PERF_STATE: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_PARKING_PERF_STATE_1"]
    pub static GUID_PROCESSOR_PARKING_PERF_STATE_1: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_PARKING_CONCURRENCY_THRESHOLD"]
    pub static GUID_PROCESSOR_PARKING_CONCURRENCY_THRESHOLD: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_PARKING_HEADROOM_THRESHOLD"]
    pub static GUID_PROCESSOR_PARKING_HEADROOM_THRESHOLD: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_PARKING_DISTRIBUTION_THRESHOLD"]
    pub static GUID_PROCESSOR_PARKING_DISTRIBUTION_THRESHOLD: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_PERF_HISTORY"]
    pub static GUID_PROCESSOR_PERF_HISTORY: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_PERF_HISTORY_1"]
    pub static GUID_PROCESSOR_PERF_HISTORY_1: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_PERF_INCREASE_HISTORY"]
    pub static GUID_PROCESSOR_PERF_INCREASE_HISTORY: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_PERF_DECREASE_HISTORY"]
    pub static GUID_PROCESSOR_PERF_DECREASE_HISTORY: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_PERF_CORE_PARKING_HISTORY"]
    pub static GUID_PROCESSOR_PERF_CORE_PARKING_HISTORY: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_PERF_LATENCY_HINT"]
    pub static GUID_PROCESSOR_PERF_LATENCY_HINT: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_PERF_LATENCY_HINT_PERF"]
    pub static GUID_PROCESSOR_PERF_LATENCY_HINT_PERF: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_PERF_LATENCY_HINT_PERF_1"]
    pub static GUID_PROCESSOR_PERF_LATENCY_HINT_PERF_1: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK"]
    pub static GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK_1"]
    pub static GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK_1: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_DISTRIBUTE_UTILITY"]
    pub static GUID_PROCESSOR_DISTRIBUTE_UTILITY: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_HETEROGENEOUS_POLICY"]
    pub static GUID_PROCESSOR_HETEROGENEOUS_POLICY: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_HETERO_DECREASE_TIME"]
    pub static GUID_PROCESSOR_HETERO_DECREASE_TIME: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_HETERO_INCREASE_TIME"]
    pub static GUID_PROCESSOR_HETERO_INCREASE_TIME: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_HETERO_DECREASE_THRESHOLD"]
    pub static GUID_PROCESSOR_HETERO_DECREASE_THRESHOLD: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_HETERO_INCREASE_THRESHOLD"]
    pub static GUID_PROCESSOR_HETERO_INCREASE_THRESHOLD: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_CLASS0_FLOOR_PERF"]
    pub static GUID_PROCESSOR_CLASS0_FLOOR_PERF: GUID;
}
extern "C" {
    #[link_name = "GUID_PROCESSOR_CLASS1_INITIAL_PERF"]
    pub static GUID_PROCESSOR_CLASS1_INITIAL_PERF: GUID;
}
extern "C" {
    #[link_name = "GUID_SYSTEM_COOLING_POLICY"]
    pub static GUID_SYSTEM_COOLING_POLICY: GUID;
}
extern "C" {
    #[link_name = "GUID_LOCK_CONSOLE_ON_WAKE"]
    pub static GUID_LOCK_CONSOLE_ON_WAKE: GUID;
}
extern "C" {
    #[link_name = "GUID_DEVICE_IDLE_POLICY"]
    pub static GUID_DEVICE_IDLE_POLICY: GUID;
}
extern "C" {
    #[link_name = "GUID_CONNECTIVITY_IN_STANDBY"]
    pub static GUID_CONNECTIVITY_IN_STANDBY: GUID;
}
extern "C" {
    #[link_name = "GUID_ACDC_POWER_SOURCE"]
    pub static GUID_ACDC_POWER_SOURCE: GUID;
}
extern "C" {
    #[link_name = "GUID_LIDSWITCH_STATE_CHANGE"]
    pub static GUID_LIDSWITCH_STATE_CHANGE: GUID;
}
extern "C" {
    #[link_name = "GUID_BATTERY_PERCENTAGE_REMAINING"]
    pub static GUID_BATTERY_PERCENTAGE_REMAINING: GUID;
}
extern "C" {
    #[link_name = "GUID_BATTERY_COUNT"]
    pub static GUID_BATTERY_COUNT: GUID;
}
extern "C" {
    #[link_name = "GUID_GLOBAL_USER_PRESENCE"]
    pub static GUID_GLOBAL_USER_PRESENCE: GUID;
}
extern "C" {
    #[link_name = "GUID_SESSION_DISPLAY_STATUS"]
    pub static GUID_SESSION_DISPLAY_STATUS: GUID;
}
extern "C" {
    #[link_name = "GUID_SESSION_USER_PRESENCE"]
    pub static GUID_SESSION_USER_PRESENCE: GUID;
}
extern "C" {
    #[link_name = "GUID_IDLE_BACKGROUND_TASK"]
    pub static GUID_IDLE_BACKGROUND_TASK: GUID;
}
extern "C" {
    #[link_name = "GUID_BACKGROUND_TASK_NOTIFICATION"]
    pub static GUID_BACKGROUND_TASK_NOTIFICATION: GUID;
}
extern "C" {
    #[link_name = "GUID_APPLAUNCH_BUTTON"]
    pub static GUID_APPLAUNCH_BUTTON: GUID;
}
extern "C" {
    #[link_name = "GUID_PCIEXPRESS_SETTINGS_SUBGROUP"]
    pub static GUID_PCIEXPRESS_SETTINGS_SUBGROUP: GUID;
}
extern "C" {
    #[link_name = "GUID_PCIEXPRESS_ASPM_POLICY"]
    pub static GUID_PCIEXPRESS_ASPM_POLICY: GUID;
}
extern "C" {
    #[link_name = "GUID_ENABLE_SWITCH_FORCED_SHUTDOWN"]
    pub static GUID_ENABLE_SWITCH_FORCED_SHUTDOWN: GUID;
}
extern "C" {
    #[link_name = "GUID_INTSTEER_SUBGROUP"]
    pub static GUID_INTSTEER_SUBGROUP: GUID;
}
extern "C" {
    #[link_name = "GUID_INTSTEER_MODE"]
    pub static GUID_INTSTEER_MODE: GUID;
}
extern "C" {
    #[link_name = "GUID_INTSTEER_LOAD_PER_PROC_TRIGGER"]
    pub static GUID_INTSTEER_LOAD_PER_PROC_TRIGGER: GUID;
}
extern "C" {
    #[link_name = "GUID_INTSTEER_TIME_UNPARK_TRIGGER"]
    pub static GUID_INTSTEER_TIME_UNPARK_TRIGGER: GUID;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _SYSTEM_POWER_STATE {
    PowerSystemUnspecified = 0,
    PowerSystemWorking = 1,
    PowerSystemSleeping1 = 2,
    PowerSystemSleeping2 = 3,
    PowerSystemSleeping3 = 4,
    PowerSystemHibernate = 5,
    PowerSystemShutdown = 6,
    PowerSystemMaximum = 7,
}
pub use self::_SYSTEM_POWER_STATE as SYSTEM_POWER_STATE;
pub type PSYSTEM_POWER_STATE = *mut _SYSTEM_POWER_STATE;
pub const PowerActionNone: _bindgen_ty_3 = _bindgen_ty_3::PowerActionNone;
pub const PowerActionReserved: _bindgen_ty_3 =
    _bindgen_ty_3::PowerActionReserved;
pub const PowerActionSleep: _bindgen_ty_3 = _bindgen_ty_3::PowerActionSleep;
pub const PowerActionHibernate: _bindgen_ty_3 =
    _bindgen_ty_3::PowerActionHibernate;
pub const PowerActionShutdown: _bindgen_ty_3 =
    _bindgen_ty_3::PowerActionShutdown;
pub const PowerActionShutdownReset: _bindgen_ty_3 =
    _bindgen_ty_3::PowerActionShutdownReset;
pub const PowerActionShutdownOff: _bindgen_ty_3 =
    _bindgen_ty_3::PowerActionShutdownOff;
pub const PowerActionWarmEject: _bindgen_ty_3 =
    _bindgen_ty_3::PowerActionWarmEject;
pub const PowerActionDisplayOff: _bindgen_ty_3 =
    _bindgen_ty_3::PowerActionDisplayOff;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_3 {
    PowerActionNone = 0,
    PowerActionReserved = 1,
    PowerActionSleep = 2,
    PowerActionHibernate = 3,
    PowerActionShutdown = 4,
    PowerActionShutdownReset = 5,
    PowerActionShutdownOff = 6,
    PowerActionWarmEject = 7,
    PowerActionDisplayOff = 8,
}
pub use self::_bindgen_ty_3 as POWER_ACTION;
pub type PPOWER_ACTION = *mut _bindgen_ty_3;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _DEVICE_POWER_STATE {
    PowerDeviceUnspecified = 0,
    PowerDeviceD0 = 1,
    PowerDeviceD1 = 2,
    PowerDeviceD2 = 3,
    PowerDeviceD3 = 4,
    PowerDeviceMaximum = 5,
}
pub use self::_DEVICE_POWER_STATE as DEVICE_POWER_STATE;
pub type PDEVICE_POWER_STATE = *mut _DEVICE_POWER_STATE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _MONITOR_DISPLAY_STATE {
    PowerMonitorOff = 0,
    PowerMonitorOn = 1,
    PowerMonitorDim = 2,
}
pub use self::_MONITOR_DISPLAY_STATE as MONITOR_DISPLAY_STATE;
pub type PMONITOR_DISPLAY_STATE = *mut _MONITOR_DISPLAY_STATE;
pub const _USER_ACTIVITY_PRESENCE_PowerUserInvalid: _USER_ACTIVITY_PRESENCE =
    _USER_ACTIVITY_PRESENCE::PowerUserMaximum;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _USER_ACTIVITY_PRESENCE {
    PowerUserPresent = 0,
    PowerUserNotPresent = 1,
    PowerUserInactive = 2,
    PowerUserMaximum = 3,
}
pub use self::_USER_ACTIVITY_PRESENCE as USER_ACTIVITY_PRESENCE;
pub type PUSER_ACTIVITY_PRESENCE = *mut _USER_ACTIVITY_PRESENCE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _POWER_STATE {
    pub SystemState: __BindgenUnionField<SYSTEM_POWER_STATE>,
    pub DeviceState: __BindgenUnionField<DEVICE_POWER_STATE>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout__POWER_STATE() {
    assert_eq!(::core::mem::size_of::<_POWER_STATE>() , 4usize);
    assert_eq!(::core::mem::align_of::<_POWER_STATE>() , 4usize);
}
impl Clone for _POWER_STATE {
    fn clone(&self) -> Self { *self }
}
pub use self::_POWER_STATE as POWER_STATE;
pub type PPOWER_STATE = *mut _POWER_STATE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _POWER_STATE_TYPE { SystemPowerState = 0, DevicePowerState = 1, }
pub use self::_POWER_STATE_TYPE as POWER_STATE_TYPE;
pub type PPOWER_STATE_TYPE = *mut _POWER_STATE_TYPE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SYSTEM_POWER_STATE_CONTEXT {
    pub __bindgen_anon_1: _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1 {
    pub __bindgen_anon_1: __BindgenUnionField<_SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1>,
    pub ContextAsUlong: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (255usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        self._bitfield_1 &= !(255usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (255usize as u32);
    }
    #[inline]
    pub fn TargetSystemState(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (3840usize as u32)) >>
                                        8u32) as u32)
        }
    }
    #[inline]
    pub fn set_TargetSystemState(&mut self, val: ULONG) {
        self._bitfield_1 &= !(3840usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 8u32) & (3840usize as u32);
    }
    #[inline]
    pub fn EffectiveSystemState(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (61440usize as u32))
                                        >> 12u32) as u32)
        }
    }
    #[inline]
    pub fn set_EffectiveSystemState(&mut self, val: ULONG) {
        self._bitfield_1 &= !(61440usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 12u32) & (61440usize as u32);
    }
    #[inline]
    pub fn CurrentSystemState(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (983040usize as u32))
                                        >> 16u32) as u32)
        }
    }
    #[inline]
    pub fn set_CurrentSystemState(&mut self, val: ULONG) {
        self._bitfield_1 &= !(983040usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (983040usize as u32);
    }
    #[inline]
    pub fn IgnoreHibernationPath(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1048576usize as u32))
                                        >> 20u32) as u32)
        }
    }
    #[inline]
    pub fn set_IgnoreHibernationPath(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1048576usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 20u32) & (1048576usize as u32);
    }
    #[inline]
    pub fn PseudoTransition(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2097152usize as u32))
                                        >> 21u32) as u32)
        }
    }
    #[inline]
    pub fn set_PseudoTransition(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2097152usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 21u32) & (2097152usize as u32);
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4290772992usize as u32)) >> 22u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4290772992usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 22u32) & (4290772992usize as u32);
    }
}
#[test]
fn bindgen_test_layout__SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__SYSTEM_POWER_STATE_CONTEXT() {
    assert_eq!(::core::mem::size_of::<_SYSTEM_POWER_STATE_CONTEXT>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_SYSTEM_POWER_STATE_CONTEXT>() ,
               4usize);
}
impl Clone for _SYSTEM_POWER_STATE_CONTEXT {
    fn clone(&self) -> Self { *self }
}
pub use self::_SYSTEM_POWER_STATE_CONTEXT as SYSTEM_POWER_STATE_CONTEXT;
pub type PSYSTEM_POWER_STATE_CONTEXT = *mut _SYSTEM_POWER_STATE_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _COUNTED_REASON_CONTEXT {
    pub Version: ULONG,
    pub Flags: ULONG,
    pub __bindgen_anon_1: _COUNTED_REASON_CONTEXT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _COUNTED_REASON_CONTEXT__bindgen_ty_1 {
    pub __bindgen_anon_1: __BindgenUnionField<_COUNTED_REASON_CONTEXT__bindgen_ty_1__bindgen_ty_1>,
    pub SimpleString: __BindgenUnionField<UNICODE_STRING>,
    pub bindgen_union_field: [u64; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _COUNTED_REASON_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    pub ResourceFileName: UNICODE_STRING,
    pub ResourceReasonId: USHORT,
    pub StringCount: ULONG,
    pub ReasonStrings: PUNICODE_STRING,
}
#[test]
fn bindgen_test_layout__COUNTED_REASON_CONTEXT__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_COUNTED_REASON_CONTEXT__bindgen_ty_1__bindgen_ty_1>()
               , 32usize);
    assert_eq!(::core::mem::align_of::<_COUNTED_REASON_CONTEXT__bindgen_ty_1__bindgen_ty_1>()
               , 8usize);
}
impl Clone for _COUNTED_REASON_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__COUNTED_REASON_CONTEXT__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_COUNTED_REASON_CONTEXT__bindgen_ty_1>()
               , 32usize);
    assert_eq!(::core::mem::align_of::<_COUNTED_REASON_CONTEXT__bindgen_ty_1>()
               , 8usize);
}
impl Clone for _COUNTED_REASON_CONTEXT__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__COUNTED_REASON_CONTEXT() {
    assert_eq!(::core::mem::size_of::<_COUNTED_REASON_CONTEXT>() , 40usize);
    assert_eq!(::core::mem::align_of::<_COUNTED_REASON_CONTEXT>() , 8usize);
}
impl Clone for _COUNTED_REASON_CONTEXT {
    fn clone(&self) -> Self { *self }
}
pub use self::_COUNTED_REASON_CONTEXT as COUNTED_REASON_CONTEXT;
pub type PCOUNTED_REASON_CONTEXT = *mut _COUNTED_REASON_CONTEXT;
pub type EXECUTION_STATE = ULONG;
pub type PEXECUTION_STATE = *mut ULONG;
pub const LT_DONT_CARE: _bindgen_ty_4 = _bindgen_ty_4::LT_DONT_CARE;
pub const LT_LOWEST_LATENCY: _bindgen_ty_4 = _bindgen_ty_4::LT_LOWEST_LATENCY;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_4 { LT_DONT_CARE = 0, LT_LOWEST_LATENCY = 1, }
pub use self::_bindgen_ty_4 as LATENCY_TIME;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _POWER_REQUEST_TYPE {
    PowerRequestDisplayRequired = 0,
    PowerRequestSystemRequired = 1,
    PowerRequestAwayModeRequired = 2,
    PowerRequestExecutionRequired = 3,
}
pub use self::_POWER_REQUEST_TYPE as POWER_REQUEST_TYPE;
pub type PPOWER_REQUEST_TYPE = *mut _POWER_REQUEST_TYPE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CM_Power_Data_s {
    pub PD_Size: ULONG,
    pub PD_MostRecentPowerState: DEVICE_POWER_STATE,
    pub PD_Capabilities: ULONG,
    pub PD_D1Latency: ULONG,
    pub PD_D2Latency: ULONG,
    pub PD_D3Latency: ULONG,
    pub PD_PowerStateMapping: [DEVICE_POWER_STATE; 7usize],
    pub PD_DeepestSystemWake: SYSTEM_POWER_STATE,
}
#[test]
fn bindgen_test_layout_CM_Power_Data_s() {
    assert_eq!(::core::mem::size_of::<CM_Power_Data_s>() , 56usize);
    assert_eq!(::core::mem::align_of::<CM_Power_Data_s>() , 4usize);
}
impl Clone for CM_Power_Data_s {
    fn clone(&self) -> Self { *self }
}
pub use self::CM_Power_Data_s as CM_POWER_DATA;
pub type PCM_POWER_DATA = *mut CM_Power_Data_s;
pub const SystemPowerPolicyAc: _bindgen_ty_5 =
    _bindgen_ty_5::SystemPowerPolicyAc;
pub const SystemPowerPolicyDc: _bindgen_ty_5 =
    _bindgen_ty_5::SystemPowerPolicyDc;
pub const VerifySystemPolicyAc: _bindgen_ty_5 =
    _bindgen_ty_5::VerifySystemPolicyAc;
pub const VerifySystemPolicyDc: _bindgen_ty_5 =
    _bindgen_ty_5::VerifySystemPolicyDc;
pub const SystemPowerCapabilities: _bindgen_ty_5 =
    _bindgen_ty_5::SystemPowerCapabilities;
pub const SystemBatteryState: _bindgen_ty_5 =
    _bindgen_ty_5::SystemBatteryState;
pub const SystemPowerStateHandler: _bindgen_ty_5 =
    _bindgen_ty_5::SystemPowerStateHandler;
pub const ProcessorStateHandler: _bindgen_ty_5 =
    _bindgen_ty_5::ProcessorStateHandler;
pub const SystemPowerPolicyCurrent: _bindgen_ty_5 =
    _bindgen_ty_5::SystemPowerPolicyCurrent;
pub const AdministratorPowerPolicy: _bindgen_ty_5 =
    _bindgen_ty_5::AdministratorPowerPolicy;
pub const SystemReserveHiberFile: _bindgen_ty_5 =
    _bindgen_ty_5::SystemReserveHiberFile;
pub const ProcessorInformation: _bindgen_ty_5 =
    _bindgen_ty_5::ProcessorInformation;
pub const SystemPowerInformation: _bindgen_ty_5 =
    _bindgen_ty_5::SystemPowerInformation;
pub const ProcessorStateHandler2: _bindgen_ty_5 =
    _bindgen_ty_5::ProcessorStateHandler2;
pub const LastWakeTime: _bindgen_ty_5 = _bindgen_ty_5::LastWakeTime;
pub const LastSleepTime: _bindgen_ty_5 = _bindgen_ty_5::LastSleepTime;
pub const SystemExecutionState: _bindgen_ty_5 =
    _bindgen_ty_5::SystemExecutionState;
pub const SystemPowerStateNotifyHandler: _bindgen_ty_5 =
    _bindgen_ty_5::SystemPowerStateNotifyHandler;
pub const ProcessorPowerPolicyAc: _bindgen_ty_5 =
    _bindgen_ty_5::ProcessorPowerPolicyAc;
pub const ProcessorPowerPolicyDc: _bindgen_ty_5 =
    _bindgen_ty_5::ProcessorPowerPolicyDc;
pub const VerifyProcessorPowerPolicyAc: _bindgen_ty_5 =
    _bindgen_ty_5::VerifyProcessorPowerPolicyAc;
pub const VerifyProcessorPowerPolicyDc: _bindgen_ty_5 =
    _bindgen_ty_5::VerifyProcessorPowerPolicyDc;
pub const ProcessorPowerPolicyCurrent: _bindgen_ty_5 =
    _bindgen_ty_5::ProcessorPowerPolicyCurrent;
pub const SystemPowerStateLogging: _bindgen_ty_5 =
    _bindgen_ty_5::SystemPowerStateLogging;
pub const SystemPowerLoggingEntry: _bindgen_ty_5 =
    _bindgen_ty_5::SystemPowerLoggingEntry;
pub const SetPowerSettingValue: _bindgen_ty_5 =
    _bindgen_ty_5::SetPowerSettingValue;
pub const NotifyUserPowerSetting: _bindgen_ty_5 =
    _bindgen_ty_5::NotifyUserPowerSetting;
pub const PowerInformationLevelUnused0: _bindgen_ty_5 =
    _bindgen_ty_5::PowerInformationLevelUnused0;
pub const SystemMonitorHiberBootPowerOff: _bindgen_ty_5 =
    _bindgen_ty_5::SystemMonitorHiberBootPowerOff;
pub const SystemVideoState: _bindgen_ty_5 = _bindgen_ty_5::SystemVideoState;
pub const TraceApplicationPowerMessage: _bindgen_ty_5 =
    _bindgen_ty_5::TraceApplicationPowerMessage;
pub const TraceApplicationPowerMessageEnd: _bindgen_ty_5 =
    _bindgen_ty_5::TraceApplicationPowerMessageEnd;
pub const ProcessorPerfStates: _bindgen_ty_5 =
    _bindgen_ty_5::ProcessorPerfStates;
pub const ProcessorIdleStates: _bindgen_ty_5 =
    _bindgen_ty_5::ProcessorIdleStates;
pub const ProcessorCap: _bindgen_ty_5 = _bindgen_ty_5::ProcessorCap;
pub const SystemWakeSource: _bindgen_ty_5 = _bindgen_ty_5::SystemWakeSource;
pub const SystemHiberFileInformation: _bindgen_ty_5 =
    _bindgen_ty_5::SystemHiberFileInformation;
pub const TraceServicePowerMessage: _bindgen_ty_5 =
    _bindgen_ty_5::TraceServicePowerMessage;
pub const ProcessorLoad: _bindgen_ty_5 = _bindgen_ty_5::ProcessorLoad;
pub const PowerShutdownNotification: _bindgen_ty_5 =
    _bindgen_ty_5::PowerShutdownNotification;
pub const MonitorCapabilities: _bindgen_ty_5 =
    _bindgen_ty_5::MonitorCapabilities;
pub const SessionPowerInit: _bindgen_ty_5 = _bindgen_ty_5::SessionPowerInit;
pub const SessionDisplayState: _bindgen_ty_5 =
    _bindgen_ty_5::SessionDisplayState;
pub const PowerRequestCreate: _bindgen_ty_5 =
    _bindgen_ty_5::PowerRequestCreate;
pub const PowerRequestAction: _bindgen_ty_5 =
    _bindgen_ty_5::PowerRequestAction;
pub const GetPowerRequestList: _bindgen_ty_5 =
    _bindgen_ty_5::GetPowerRequestList;
pub const ProcessorInformationEx: _bindgen_ty_5 =
    _bindgen_ty_5::ProcessorInformationEx;
pub const NotifyUserModeLegacyPowerEvent: _bindgen_ty_5 =
    _bindgen_ty_5::NotifyUserModeLegacyPowerEvent;
pub const GroupPark: _bindgen_ty_5 = _bindgen_ty_5::GroupPark;
pub const ProcessorIdleDomains: _bindgen_ty_5 =
    _bindgen_ty_5::ProcessorIdleDomains;
pub const WakeTimerList: _bindgen_ty_5 = _bindgen_ty_5::WakeTimerList;
pub const SystemHiberFileSize: _bindgen_ty_5 =
    _bindgen_ty_5::SystemHiberFileSize;
pub const ProcessorIdleStatesHv: _bindgen_ty_5 =
    _bindgen_ty_5::ProcessorIdleStatesHv;
pub const ProcessorPerfStatesHv: _bindgen_ty_5 =
    _bindgen_ty_5::ProcessorPerfStatesHv;
pub const ProcessorPerfCapHv: _bindgen_ty_5 =
    _bindgen_ty_5::ProcessorPerfCapHv;
pub const ProcessorSetIdle: _bindgen_ty_5 = _bindgen_ty_5::ProcessorSetIdle;
pub const LogicalProcessorIdling: _bindgen_ty_5 =
    _bindgen_ty_5::LogicalProcessorIdling;
pub const UserPresence: _bindgen_ty_5 = _bindgen_ty_5::UserPresence;
pub const PowerSettingNotificationName: _bindgen_ty_5 =
    _bindgen_ty_5::PowerSettingNotificationName;
pub const GetPowerSettingValue: _bindgen_ty_5 =
    _bindgen_ty_5::GetPowerSettingValue;
pub const IdleResiliency: _bindgen_ty_5 = _bindgen_ty_5::IdleResiliency;
pub const SessionRITState: _bindgen_ty_5 = _bindgen_ty_5::SessionRITState;
pub const SessionConnectNotification: _bindgen_ty_5 =
    _bindgen_ty_5::SessionConnectNotification;
pub const SessionPowerCleanup: _bindgen_ty_5 =
    _bindgen_ty_5::SessionPowerCleanup;
pub const SessionLockState: _bindgen_ty_5 = _bindgen_ty_5::SessionLockState;
pub const SystemHiberbootState: _bindgen_ty_5 =
    _bindgen_ty_5::SystemHiberbootState;
pub const PlatformInformation: _bindgen_ty_5 =
    _bindgen_ty_5::PlatformInformation;
pub const PdcInvocation: _bindgen_ty_5 = _bindgen_ty_5::PdcInvocation;
pub const MonitorInvocation: _bindgen_ty_5 = _bindgen_ty_5::MonitorInvocation;
pub const FirmwareTableInformationRegistered: _bindgen_ty_5 =
    _bindgen_ty_5::FirmwareTableInformationRegistered;
pub const SetShutdownSelectedTime: _bindgen_ty_5 =
    _bindgen_ty_5::SetShutdownSelectedTime;
pub const SuspendResumeInvocation: _bindgen_ty_5 =
    _bindgen_ty_5::SuspendResumeInvocation;
pub const PlmPowerRequestCreate: _bindgen_ty_5 =
    _bindgen_ty_5::PlmPowerRequestCreate;
pub const ScreenOff: _bindgen_ty_5 = _bindgen_ty_5::ScreenOff;
pub const CsDeviceNotification: _bindgen_ty_5 =
    _bindgen_ty_5::CsDeviceNotification;
pub const PlatformRole: _bindgen_ty_5 = _bindgen_ty_5::PlatformRole;
pub const LastResumePerformance: _bindgen_ty_5 =
    _bindgen_ty_5::LastResumePerformance;
pub const DisplayBurst: _bindgen_ty_5 = _bindgen_ty_5::DisplayBurst;
pub const ExitLatencySamplingPercentage: _bindgen_ty_5 =
    _bindgen_ty_5::ExitLatencySamplingPercentage;
pub const RegisterSpmPowerSettings: _bindgen_ty_5 =
    _bindgen_ty_5::RegisterSpmPowerSettings;
pub const PlatformIdleStates: _bindgen_ty_5 =
    _bindgen_ty_5::PlatformIdleStates;
pub const ProcessorIdleVeto: _bindgen_ty_5 = _bindgen_ty_5::ProcessorIdleVeto;
pub const PlatformIdleVeto: _bindgen_ty_5 = _bindgen_ty_5::PlatformIdleVeto;
pub const SystemBatteryStatePrecise: _bindgen_ty_5 =
    _bindgen_ty_5::SystemBatteryStatePrecise;
pub const ThermalEvent: _bindgen_ty_5 = _bindgen_ty_5::ThermalEvent;
pub const PowerRequestActionInternal: _bindgen_ty_5 =
    _bindgen_ty_5::PowerRequestActionInternal;
pub const BatteryDeviceState: _bindgen_ty_5 =
    _bindgen_ty_5::BatteryDeviceState;
pub const PowerInformationInternal: _bindgen_ty_5 =
    _bindgen_ty_5::PowerInformationInternal;
pub const ThermalStandby: _bindgen_ty_5 = _bindgen_ty_5::ThermalStandby;
pub const SystemHiberFileType: _bindgen_ty_5 =
    _bindgen_ty_5::SystemHiberFileType;
pub const PhysicalPowerButtonPress: _bindgen_ty_5 =
    _bindgen_ty_5::PhysicalPowerButtonPress;
pub const PowerInformationLevelMaximum: _bindgen_ty_5 =
    _bindgen_ty_5::PowerInformationLevelMaximum;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_5 {
    SystemPowerPolicyAc = 0,
    SystemPowerPolicyDc = 1,
    VerifySystemPolicyAc = 2,
    VerifySystemPolicyDc = 3,
    SystemPowerCapabilities = 4,
    SystemBatteryState = 5,
    SystemPowerStateHandler = 6,
    ProcessorStateHandler = 7,
    SystemPowerPolicyCurrent = 8,
    AdministratorPowerPolicy = 9,
    SystemReserveHiberFile = 10,
    ProcessorInformation = 11,
    SystemPowerInformation = 12,
    ProcessorStateHandler2 = 13,
    LastWakeTime = 14,
    LastSleepTime = 15,
    SystemExecutionState = 16,
    SystemPowerStateNotifyHandler = 17,
    ProcessorPowerPolicyAc = 18,
    ProcessorPowerPolicyDc = 19,
    VerifyProcessorPowerPolicyAc = 20,
    VerifyProcessorPowerPolicyDc = 21,
    ProcessorPowerPolicyCurrent = 22,
    SystemPowerStateLogging = 23,
    SystemPowerLoggingEntry = 24,
    SetPowerSettingValue = 25,
    NotifyUserPowerSetting = 26,
    PowerInformationLevelUnused0 = 27,
    SystemMonitorHiberBootPowerOff = 28,
    SystemVideoState = 29,
    TraceApplicationPowerMessage = 30,
    TraceApplicationPowerMessageEnd = 31,
    ProcessorPerfStates = 32,
    ProcessorIdleStates = 33,
    ProcessorCap = 34,
    SystemWakeSource = 35,
    SystemHiberFileInformation = 36,
    TraceServicePowerMessage = 37,
    ProcessorLoad = 38,
    PowerShutdownNotification = 39,
    MonitorCapabilities = 40,
    SessionPowerInit = 41,
    SessionDisplayState = 42,
    PowerRequestCreate = 43,
    PowerRequestAction = 44,
    GetPowerRequestList = 45,
    ProcessorInformationEx = 46,
    NotifyUserModeLegacyPowerEvent = 47,
    GroupPark = 48,
    ProcessorIdleDomains = 49,
    WakeTimerList = 50,
    SystemHiberFileSize = 51,
    ProcessorIdleStatesHv = 52,
    ProcessorPerfStatesHv = 53,
    ProcessorPerfCapHv = 54,
    ProcessorSetIdle = 55,
    LogicalProcessorIdling = 56,
    UserPresence = 57,
    PowerSettingNotificationName = 58,
    GetPowerSettingValue = 59,
    IdleResiliency = 60,
    SessionRITState = 61,
    SessionConnectNotification = 62,
    SessionPowerCleanup = 63,
    SessionLockState = 64,
    SystemHiberbootState = 65,
    PlatformInformation = 66,
    PdcInvocation = 67,
    MonitorInvocation = 68,
    FirmwareTableInformationRegistered = 69,
    SetShutdownSelectedTime = 70,
    SuspendResumeInvocation = 71,
    PlmPowerRequestCreate = 72,
    ScreenOff = 73,
    CsDeviceNotification = 74,
    PlatformRole = 75,
    LastResumePerformance = 76,
    DisplayBurst = 77,
    ExitLatencySamplingPercentage = 78,
    RegisterSpmPowerSettings = 79,
    PlatformIdleStates = 80,
    ProcessorIdleVeto = 81,
    PlatformIdleVeto = 82,
    SystemBatteryStatePrecise = 83,
    ThermalEvent = 84,
    PowerRequestActionInternal = 85,
    BatteryDeviceState = 86,
    PowerInformationInternal = 87,
    ThermalStandby = 88,
    SystemHiberFileType = 89,
    PhysicalPowerButtonPress = 90,
    PowerInformationLevelMaximum = 91,
}
pub use self::_bindgen_ty_5 as POWER_INFORMATION_LEVEL;
pub const UserNotPresent: _bindgen_ty_6 = _bindgen_ty_6::UserNotPresent;
pub const UserPresent: _bindgen_ty_6 = _bindgen_ty_6::UserPresent;
pub const UserUnknown: _bindgen_ty_6 = _bindgen_ty_6::UserUnknown;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_6 {
    UserNotPresent = 0,
    UserPresent = 1,
    UserUnknown = 255,
}
pub use self::_bindgen_ty_6 as POWER_USER_PRESENCE_TYPE;
pub type PPOWER_USER_PRESENCE_TYPE = *mut _bindgen_ty_6;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _POWER_USER_PRESENCE {
    pub UserPresence: POWER_USER_PRESENCE_TYPE,
}
#[test]
fn bindgen_test_layout__POWER_USER_PRESENCE() {
    assert_eq!(::core::mem::size_of::<_POWER_USER_PRESENCE>() , 4usize);
    assert_eq!(::core::mem::align_of::<_POWER_USER_PRESENCE>() , 4usize);
}
impl Clone for _POWER_USER_PRESENCE {
    fn clone(&self) -> Self { *self }
}
pub use self::_POWER_USER_PRESENCE as POWER_USER_PRESENCE;
pub type PPOWER_USER_PRESENCE = *mut _POWER_USER_PRESENCE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _POWER_SESSION_CONNECT {
    pub Connected: BOOLEAN,
    pub Console: BOOLEAN,
}
#[test]
fn bindgen_test_layout__POWER_SESSION_CONNECT() {
    assert_eq!(::core::mem::size_of::<_POWER_SESSION_CONNECT>() , 2usize);
    assert_eq!(::core::mem::align_of::<_POWER_SESSION_CONNECT>() , 1usize);
}
impl Clone for _POWER_SESSION_CONNECT {
    fn clone(&self) -> Self { *self }
}
pub use self::_POWER_SESSION_CONNECT as POWER_SESSION_CONNECT;
pub type PPOWER_SESSION_CONNECT = *mut _POWER_SESSION_CONNECT;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _POWER_SESSION_TIMEOUTS {
    pub InputTimeout: ULONG,
    pub DisplayTimeout: ULONG,
}
#[test]
fn bindgen_test_layout__POWER_SESSION_TIMEOUTS() {
    assert_eq!(::core::mem::size_of::<_POWER_SESSION_TIMEOUTS>() , 8usize);
    assert_eq!(::core::mem::align_of::<_POWER_SESSION_TIMEOUTS>() , 4usize);
}
impl Clone for _POWER_SESSION_TIMEOUTS {
    fn clone(&self) -> Self { *self }
}
pub use self::_POWER_SESSION_TIMEOUTS as POWER_SESSION_TIMEOUTS;
pub type PPOWER_SESSION_TIMEOUTS = *mut _POWER_SESSION_TIMEOUTS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _POWER_SESSION_RIT_STATE {
    pub Active: BOOLEAN,
    pub LastInputTime: ULONG,
}
#[test]
fn bindgen_test_layout__POWER_SESSION_RIT_STATE() {
    assert_eq!(::core::mem::size_of::<_POWER_SESSION_RIT_STATE>() , 8usize);
    assert_eq!(::core::mem::align_of::<_POWER_SESSION_RIT_STATE>() , 4usize);
}
impl Clone for _POWER_SESSION_RIT_STATE {
    fn clone(&self) -> Self { *self }
}
pub use self::_POWER_SESSION_RIT_STATE as POWER_SESSION_RIT_STATE;
pub type PPOWER_SESSION_RIT_STATE = *mut _POWER_SESSION_RIT_STATE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _POWER_SESSION_WINLOGON {
    pub SessionId: ULONG,
    pub Console: BOOLEAN,
    pub Locked: BOOLEAN,
}
#[test]
fn bindgen_test_layout__POWER_SESSION_WINLOGON() {
    assert_eq!(::core::mem::size_of::<_POWER_SESSION_WINLOGON>() , 8usize);
    assert_eq!(::core::mem::align_of::<_POWER_SESSION_WINLOGON>() , 4usize);
}
impl Clone for _POWER_SESSION_WINLOGON {
    fn clone(&self) -> Self { *self }
}
pub use self::_POWER_SESSION_WINLOGON as POWER_SESSION_WINLOGON;
pub type PPOWER_SESSION_WINLOGON = *mut _POWER_SESSION_WINLOGON;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _POWER_IDLE_RESILIENCY {
    pub CoalescingTimeout: ULONG,
    pub IdleResiliencyPeriod: ULONG,
}
#[test]
fn bindgen_test_layout__POWER_IDLE_RESILIENCY() {
    assert_eq!(::core::mem::size_of::<_POWER_IDLE_RESILIENCY>() , 8usize);
    assert_eq!(::core::mem::align_of::<_POWER_IDLE_RESILIENCY>() , 4usize);
}
impl Clone for _POWER_IDLE_RESILIENCY {
    fn clone(&self) -> Self { *self }
}
pub use self::_POWER_IDLE_RESILIENCY as POWER_IDLE_RESILIENCY;
pub type PPOWER_IDLE_RESILIENCY = *mut _POWER_IDLE_RESILIENCY;
pub const MonitorRequestReasonUnknown: _bindgen_ty_7 =
    _bindgen_ty_7::MonitorRequestReasonUnknown;
pub const MonitorRequestReasonPowerButton: _bindgen_ty_7 =
    _bindgen_ty_7::MonitorRequestReasonPowerButton;
pub const MonitorRequestReasonRemoteConnection: _bindgen_ty_7 =
    _bindgen_ty_7::MonitorRequestReasonRemoteConnection;
pub const MonitorRequestReasonScMonitorpower: _bindgen_ty_7 =
    _bindgen_ty_7::MonitorRequestReasonScMonitorpower;
pub const MonitorRequestReasonUserInput: _bindgen_ty_7 =
    _bindgen_ty_7::MonitorRequestReasonUserInput;
pub const MonitorRequestReasonAcDcDisplayBurst: _bindgen_ty_7 =
    _bindgen_ty_7::MonitorRequestReasonAcDcDisplayBurst;
pub const MonitorRequestReasonUserDisplayBurst: _bindgen_ty_7 =
    _bindgen_ty_7::MonitorRequestReasonUserDisplayBurst;
pub const MonitorRequestReasonPoSetSystemState: _bindgen_ty_7 =
    _bindgen_ty_7::MonitorRequestReasonPoSetSystemState;
pub const MonitorRequestReasonSetThreadExecutionState: _bindgen_ty_7 =
    _bindgen_ty_7::MonitorRequestReasonSetThreadExecutionState;
pub const MonitorRequestReasonFullWake: _bindgen_ty_7 =
    _bindgen_ty_7::MonitorRequestReasonFullWake;
pub const MonitorRequestReasonSessionUnlock: _bindgen_ty_7 =
    _bindgen_ty_7::MonitorRequestReasonSessionUnlock;
pub const MonitorRequestReasonScreenOffRequest: _bindgen_ty_7 =
    _bindgen_ty_7::MonitorRequestReasonScreenOffRequest;
pub const MonitorRequestReasonIdleTimeout: _bindgen_ty_7 =
    _bindgen_ty_7::MonitorRequestReasonIdleTimeout;
pub const MonitorRequestReasonPolicyChange: _bindgen_ty_7 =
    _bindgen_ty_7::MonitorRequestReasonPolicyChange;
pub const MonitorRequestReasonSleepButton: _bindgen_ty_7 =
    _bindgen_ty_7::MonitorRequestReasonSleepButton;
pub const MonitorRequestReasonLid: _bindgen_ty_7 =
    _bindgen_ty_7::MonitorRequestReasonLid;
pub const MonitorRequestReasonBatteryCountChange: _bindgen_ty_7 =
    _bindgen_ty_7::MonitorRequestReasonBatteryCountChange;
pub const MonitorRequestReasonGracePeriod: _bindgen_ty_7 =
    _bindgen_ty_7::MonitorRequestReasonGracePeriod;
pub const MonitorRequestReasonPnP: _bindgen_ty_7 =
    _bindgen_ty_7::MonitorRequestReasonPnP;
pub const MonitorRequestReasonDP: _bindgen_ty_7 =
    _bindgen_ty_7::MonitorRequestReasonDP;
pub const MonitorRequestReasonSxTransition: _bindgen_ty_7 =
    _bindgen_ty_7::MonitorRequestReasonSxTransition;
pub const MonitorRequestReasonSystemIdle: _bindgen_ty_7 =
    _bindgen_ty_7::MonitorRequestReasonSystemIdle;
pub const MonitorRequestReasonNearProximity: _bindgen_ty_7 =
    _bindgen_ty_7::MonitorRequestReasonNearProximity;
pub const MonitorRequestReasonThermalStandby: _bindgen_ty_7 =
    _bindgen_ty_7::MonitorRequestReasonThermalStandby;
pub const MonitorRequestReasonResumePdc: _bindgen_ty_7 =
    _bindgen_ty_7::MonitorRequestReasonResumePdc;
pub const MonitorRequestReasonResumeS4: _bindgen_ty_7 =
    _bindgen_ty_7::MonitorRequestReasonResumeS4;
pub const MonitorRequestReasonTerminal: _bindgen_ty_7 =
    _bindgen_ty_7::MonitorRequestReasonTerminal;
pub const MonitorRequestReasonPdcSignal: _bindgen_ty_7 =
    _bindgen_ty_7::MonitorRequestReasonPdcSignal;
pub const MonitorRequestReasonMax: _bindgen_ty_7 =
    _bindgen_ty_7::MonitorRequestReasonMax;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_7 {
    MonitorRequestReasonUnknown = 0,
    MonitorRequestReasonPowerButton = 1,
    MonitorRequestReasonRemoteConnection = 2,
    MonitorRequestReasonScMonitorpower = 3,
    MonitorRequestReasonUserInput = 4,
    MonitorRequestReasonAcDcDisplayBurst = 5,
    MonitorRequestReasonUserDisplayBurst = 6,
    MonitorRequestReasonPoSetSystemState = 7,
    MonitorRequestReasonSetThreadExecutionState = 8,
    MonitorRequestReasonFullWake = 9,
    MonitorRequestReasonSessionUnlock = 10,
    MonitorRequestReasonScreenOffRequest = 11,
    MonitorRequestReasonIdleTimeout = 12,
    MonitorRequestReasonPolicyChange = 13,
    MonitorRequestReasonSleepButton = 14,
    MonitorRequestReasonLid = 15,
    MonitorRequestReasonBatteryCountChange = 16,
    MonitorRequestReasonGracePeriod = 17,
    MonitorRequestReasonPnP = 18,
    MonitorRequestReasonDP = 19,
    MonitorRequestReasonSxTransition = 20,
    MonitorRequestReasonSystemIdle = 21,
    MonitorRequestReasonNearProximity = 22,
    MonitorRequestReasonThermalStandby = 23,
    MonitorRequestReasonResumePdc = 24,
    MonitorRequestReasonResumeS4 = 25,
    MonitorRequestReasonTerminal = 26,
    MonitorRequestReasonPdcSignal = 27,
    MonitorRequestReasonMax = 28,
}
pub use self::_bindgen_ty_7 as POWER_MONITOR_REQUEST_REASON;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _POWER_MONITOR_REQUEST_TYPE {
    MonitorRequestTypeOff = 0,
    MonitorRequestTypeOnAndPresent = 1,
    MonitorRequestTypeToggleOn = 2,
}
pub use self::_POWER_MONITOR_REQUEST_TYPE as POWER_MONITOR_REQUEST_TYPE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _POWER_MONITOR_INVOCATION {
    pub Console: BOOLEAN,
    pub RequestReason: POWER_MONITOR_REQUEST_REASON,
}
#[test]
fn bindgen_test_layout__POWER_MONITOR_INVOCATION() {
    assert_eq!(::core::mem::size_of::<_POWER_MONITOR_INVOCATION>() , 8usize);
    assert_eq!(::core::mem::align_of::<_POWER_MONITOR_INVOCATION>() , 4usize);
}
impl Clone for _POWER_MONITOR_INVOCATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_POWER_MONITOR_INVOCATION as POWER_MONITOR_INVOCATION;
pub type PPOWER_MONITOR_INVOCATION = *mut _POWER_MONITOR_INVOCATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _RESUME_PERFORMANCE {
    pub PostTimeMs: ULONG,
    pub TotalResumeTimeMs: ULONGLONG,
    pub ResumeCompleteTimestamp: ULONGLONG,
}
#[test]
fn bindgen_test_layout__RESUME_PERFORMANCE() {
    assert_eq!(::core::mem::size_of::<_RESUME_PERFORMANCE>() , 24usize);
    assert_eq!(::core::mem::align_of::<_RESUME_PERFORMANCE>() , 8usize);
}
impl Clone for _RESUME_PERFORMANCE {
    fn clone(&self) -> Self { *self }
}
pub use self::_RESUME_PERFORMANCE as RESUME_PERFORMANCE;
pub type PRESUME_PERFORMANCE = *mut _RESUME_PERFORMANCE;
pub const PoAc: _bindgen_ty_8 = _bindgen_ty_8::PoAc;
pub const PoDc: _bindgen_ty_8 = _bindgen_ty_8::PoDc;
pub const PoHot: _bindgen_ty_8 = _bindgen_ty_8::PoHot;
pub const PoConditionMaximum: _bindgen_ty_8 =
    _bindgen_ty_8::PoConditionMaximum;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_8 {
    PoAc = 0,
    PoDc = 1,
    PoHot = 2,
    PoConditionMaximum = 3,
}
pub use self::_bindgen_ty_8 as SYSTEM_POWER_CONDITION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_9 {
    pub Version: ULONG,
    pub Guid: GUID,
    pub PowerCondition: SYSTEM_POWER_CONDITION,
    pub DataLength: ULONG,
    pub Data: [UCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_9() {
    assert_eq!(::core::mem::size_of::<_bindgen_ty_9>() , 32usize);
    assert_eq!(::core::mem::align_of::<_bindgen_ty_9>() , 4usize);
}
impl Clone for _bindgen_ty_9 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_9 as SET_POWER_SETTING_VALUE;
pub type PSET_POWER_SETTING_VALUE = *mut _bindgen_ty_9;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_10 {
    pub Guid: GUID,
}
#[test]
fn bindgen_test_layout__bindgen_ty_10() {
    assert_eq!(::core::mem::size_of::<_bindgen_ty_10>() , 16usize);
    assert_eq!(::core::mem::align_of::<_bindgen_ty_10>() , 4usize);
}
impl Clone for _bindgen_ty_10 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_10 as NOTIFY_USER_POWER_SETTING;
pub type PNOTIFY_USER_POWER_SETTING = *mut _bindgen_ty_10;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _APPLICATIONLAUNCH_SETTING_VALUE {
    pub ActivationTime: LARGE_INTEGER,
    pub Flags: ULONG,
    pub ButtonInstanceID: ULONG,
}
#[test]
fn bindgen_test_layout__APPLICATIONLAUNCH_SETTING_VALUE() {
    assert_eq!(::core::mem::size_of::<_APPLICATIONLAUNCH_SETTING_VALUE>() ,
               16usize);
    assert_eq!(::core::mem::align_of::<_APPLICATIONLAUNCH_SETTING_VALUE>() ,
               8usize);
}
impl Clone for _APPLICATIONLAUNCH_SETTING_VALUE {
    fn clone(&self) -> Self { *self }
}
pub use self::_APPLICATIONLAUNCH_SETTING_VALUE as
        APPLICATIONLAUNCH_SETTING_VALUE;
pub type PAPPLICATIONLAUNCH_SETTING_VALUE =
    *mut _APPLICATIONLAUNCH_SETTING_VALUE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _POWER_PLATFORM_ROLE {
    PlatformRoleUnspecified = 0,
    PlatformRoleDesktop = 1,
    PlatformRoleMobile = 2,
    PlatformRoleWorkstation = 3,
    PlatformRoleEnterpriseServer = 4,
    PlatformRoleSOHOServer = 5,
    PlatformRoleAppliancePC = 6,
    PlatformRolePerformanceServer = 7,
    PlatformRoleSlate = 8,
    PlatformRoleMaximum = 9,
}
pub use self::_POWER_PLATFORM_ROLE as POWER_PLATFORM_ROLE;
pub type PPOWER_PLATFORM_ROLE = *mut _POWER_PLATFORM_ROLE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _POWER_PLATFORM_INFORMATION {
    pub AoAc: BOOLEAN,
}
#[test]
fn bindgen_test_layout__POWER_PLATFORM_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_POWER_PLATFORM_INFORMATION>() ,
               1usize);
    assert_eq!(::core::mem::align_of::<_POWER_PLATFORM_INFORMATION>() ,
               1usize);
}
impl Clone for _POWER_PLATFORM_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_POWER_PLATFORM_INFORMATION as POWER_PLATFORM_INFORMATION;
pub type PPOWER_PLATFORM_INFORMATION = *mut _POWER_PLATFORM_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_11 {
    pub Granularity: ULONG,
    pub Capacity: ULONG,
}
#[test]
fn bindgen_test_layout__bindgen_ty_11() {
    assert_eq!(::core::mem::size_of::<_bindgen_ty_11>() , 8usize);
    assert_eq!(::core::mem::align_of::<_bindgen_ty_11>() , 4usize);
}
impl Clone for _bindgen_ty_11 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_11 as BATTERY_REPORTING_SCALE;
pub type PBATTERY_REPORTING_SCALE = *mut _bindgen_ty_11;
extern "C" {
    pub fn NtPowerInformation(InformationLevel: POWER_INFORMATION_LEVEL,
                              InputBuffer: PVOID, InputBufferLength: ULONG,
                              OutputBuffer: PVOID, OutputBufferLength: ULONG)
     -> NTSTATUS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _CM_SERVICE_NODE_TYPE {
    DriverType = 1,
    FileSystemType = 2,
    Win32ServiceOwnProcess = 16,
    Win32ServiceShareProcess = 32,
    AdapterType = 4,
    RecognizerType = 8,
}
pub use self::_CM_SERVICE_NODE_TYPE as SERVICE_NODE_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _CM_SERVICE_LOAD_TYPE {
    BootLoad = 0,
    SystemLoad = 1,
    AutoLoad = 2,
    DemandLoad = 3,
    DisableLoad = 4,
}
pub use self::_CM_SERVICE_LOAD_TYPE as SERVICE_LOAD_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _CM_ERROR_CONTROL_TYPE {
    IgnoreError = 0,
    NormalError = 1,
    SevereError = 2,
    CriticalError = 3,
}
pub use self::_CM_ERROR_CONTROL_TYPE as SERVICE_ERROR_TYPE;
pub type CM_RESOURCE_TYPE = libc::c_int;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _CM_SHARE_DISPOSITION {
    CmResourceShareUndetermined = 0,
    CmResourceShareDeviceExclusive = 1,
    CmResourceShareDriverExclusive = 2,
    CmResourceShareShared = 3,
}
pub use self::_CM_SHARE_DISPOSITION as CM_SHARE_DISPOSITION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR {
    pub Type: UCHAR,
    pub ShareDisposition: UCHAR,
    pub Flags: USHORT,
    pub u: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1 {
    pub Generic: __BindgenUnionField<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>,
    pub Port: __BindgenUnionField<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2>,
    pub Interrupt: __BindgenUnionField<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3>,
    pub MessageInterrupt: __BindgenUnionField<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4>,
    pub Memory: __BindgenUnionField<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5>,
    pub Dma: __BindgenUnionField<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6>,
    pub DmaV3: __BindgenUnionField<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7>,
    pub DevicePrivate: __BindgenUnionField<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8>,
    pub BusNumber: __BindgenUnionField<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9>,
    pub DeviceSpecificData: __BindgenUnionField<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10>,
    pub Memory40: __BindgenUnionField<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11>,
    pub Memory48: __BindgenUnionField<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12>,
    pub Memory64: __BindgenUnionField<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13>,
    pub Connection: __BindgenUnionField<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14>,
    pub bindgen_union_field: [u32; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    pub Start: PHYSICAL_ADDRESS,
    pub Length: ULONG,
}
impl Clone for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 {
    pub Start: PHYSICAL_ADDRESS,
    pub Length: ULONG,
}
impl Clone for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3 {
    pub Level: ULONG,
    pub Vector: ULONG,
    pub Affinity: KAFFINITY,
}
impl Clone for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4 {
    pub __bindgen_anon_1: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    pub Raw: __BindgenUnionField<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1>,
    pub Translated: __BindgenUnionField<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: [u32; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    pub Reserved: USHORT,
    pub MessageCount: USHORT,
    pub Vector: ULONG,
    pub Affinity: KAFFINITY,
}
impl Clone for
 _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1
 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2 {
    pub Level: ULONG,
    pub Vector: ULONG,
    pub Affinity: KAFFINITY,
}
impl Clone for
 _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2
 {
    fn clone(&self) -> Self { *self }
}
impl Clone for
 _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Clone for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5 {
    pub Start: PHYSICAL_ADDRESS,
    pub Length: ULONG,
}
impl Clone for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6 {
    pub Channel: ULONG,
    pub Port: ULONG,
    pub Reserved1: ULONG,
}
impl Clone for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7 {
    pub Channel: ULONG,
    pub RequestLine: ULONG,
    pub TransferWidth: UCHAR,
    pub Reserved1: UCHAR,
    pub Reserved2: UCHAR,
    pub Reserved3: UCHAR,
}
impl Clone for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8 {
    pub Data: [ULONG; 3usize],
}
impl Clone for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9 {
    pub Start: ULONG,
    pub Length: ULONG,
    pub Reserved: ULONG,
}
impl Clone for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10 {
    pub DataSize: ULONG,
    pub Reserved1: ULONG,
    pub Reserved2: ULONG,
}
impl Clone for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11 {
    pub Start: PHYSICAL_ADDRESS,
    pub Length40: ULONG,
}
impl Clone for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12 {
    pub Start: PHYSICAL_ADDRESS,
    pub Length48: ULONG,
}
impl Clone for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13 {
    pub Start: PHYSICAL_ADDRESS,
    pub Length64: ULONG,
}
impl Clone for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14 {
    pub Class: UCHAR,
    pub Type: UCHAR,
    pub Reserved1: UCHAR,
    pub Reserved2: UCHAR,
    pub IdLowPart: ULONG,
    pub IdHighPart: ULONG,
}
impl Clone for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14 {
    fn clone(&self) -> Self { *self }
}
impl Clone for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Clone for _CM_PARTIAL_RESOURCE_DESCRIPTOR {
    fn clone(&self) -> Self { *self }
}
pub use self::_CM_PARTIAL_RESOURCE_DESCRIPTOR as
        CM_PARTIAL_RESOURCE_DESCRIPTOR;
pub type PCM_PARTIAL_RESOURCE_DESCRIPTOR =
    *mut _CM_PARTIAL_RESOURCE_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_PARTIAL_RESOURCE_LIST {
    pub Version: USHORT,
    pub Revision: USHORT,
    pub Count: ULONG,
    pub PartialDescriptors: [CM_PARTIAL_RESOURCE_DESCRIPTOR; 1usize],
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_LIST() {
    assert_eq!(::core::mem::size_of::<_CM_PARTIAL_RESOURCE_LIST>() , 28usize);
    assert_eq!(::core::mem::align_of::<_CM_PARTIAL_RESOURCE_LIST>() , 4usize);
}
impl Clone for _CM_PARTIAL_RESOURCE_LIST {
    fn clone(&self) -> Self { *self }
}
pub use self::_CM_PARTIAL_RESOURCE_LIST as CM_PARTIAL_RESOURCE_LIST;
pub type PCM_PARTIAL_RESOURCE_LIST = *mut _CM_PARTIAL_RESOURCE_LIST;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_FULL_RESOURCE_DESCRIPTOR {
    pub InterfaceType: INTERFACE_TYPE,
    pub BusNumber: ULONG,
    pub PartialResourceList: CM_PARTIAL_RESOURCE_LIST,
}
#[test]
fn bindgen_test_layout__CM_FULL_RESOURCE_DESCRIPTOR() {
    assert_eq!(::core::mem::size_of::<_CM_FULL_RESOURCE_DESCRIPTOR>() ,
               36usize);
    assert_eq!(::core::mem::align_of::<_CM_FULL_RESOURCE_DESCRIPTOR>() ,
               4usize);
}
impl Clone for _CM_FULL_RESOURCE_DESCRIPTOR {
    fn clone(&self) -> Self { *self }
}
pub use self::_CM_FULL_RESOURCE_DESCRIPTOR as CM_FULL_RESOURCE_DESCRIPTOR;
pub type PCM_FULL_RESOURCE_DESCRIPTOR = *mut _CM_FULL_RESOURCE_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_RESOURCE_LIST {
    pub Count: ULONG,
    pub List: [CM_FULL_RESOURCE_DESCRIPTOR; 1usize],
}
#[test]
fn bindgen_test_layout__CM_RESOURCE_LIST() {
    assert_eq!(::core::mem::size_of::<_CM_RESOURCE_LIST>() , 40usize);
    assert_eq!(::core::mem::align_of::<_CM_RESOURCE_LIST>() , 4usize);
}
impl Clone for _CM_RESOURCE_LIST {
    fn clone(&self) -> Self { *self }
}
pub use self::_CM_RESOURCE_LIST as CM_RESOURCE_LIST;
pub type PCM_RESOURCE_LIST = *mut _CM_RESOURCE_LIST;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DEVICE_FLAGS {
    pub _bitfield_1: u8,
}
#[test]
fn bindgen_test_layout__DEVICE_FLAGS() {
    assert_eq!(::core::mem::size_of::<_DEVICE_FLAGS>() , 4usize);
    assert_eq!(::core::mem::align_of::<_DEVICE_FLAGS>() , 4usize);
}
impl Clone for _DEVICE_FLAGS {
    fn clone(&self) -> Self { *self }
}
impl _DEVICE_FLAGS {
    #[inline]
    pub fn Failed(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_Failed(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 0u32) & (1usize as u8);
    }
    #[inline]
    pub fn ReadOnly(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u8)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_ReadOnly(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 1u32) & (2usize as u8);
    }
    #[inline]
    pub fn Removable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u8)) >>
                                        2u32) as u32)
        }
    }
    #[inline]
    pub fn set_Removable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 2u32) & (4usize as u8);
    }
    #[inline]
    pub fn ConsoleIn(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u8)) >>
                                        3u32) as u32)
        }
    }
    #[inline]
    pub fn set_ConsoleIn(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 3u32) & (8usize as u8);
    }
    #[inline]
    pub fn ConsoleOut(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u8)) >>
                                        4u32) as u32)
        }
    }
    #[inline]
    pub fn set_ConsoleOut(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 4u32) & (16usize as u8);
    }
    #[inline]
    pub fn Input(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u8)) >>
                                        5u32) as u32)
        }
    }
    #[inline]
    pub fn set_Input(&mut self, val: ULONG) {
        self._bitfield_1 &= !(32usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 5u32) & (32usize as u8);
    }
    #[inline]
    pub fn Output(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u8)) >>
                                        6u32) as u32)
        }
    }
    #[inline]
    pub fn set_Output(&mut self, val: ULONG) {
        self._bitfield_1 &= !(64usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 6u32) & (64usize as u8);
    }
}
pub use self::_DEVICE_FLAGS as DEVICE_FLAGS;
pub type PDEVICE_FLAGS = *mut _DEVICE_FLAGS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_COMPONENT_INFORMATION {
    pub Flags: DEVICE_FLAGS,
    pub Version: ULONG,
    pub Key: ULONG,
    pub AffinityMask: KAFFINITY,
}
#[test]
fn bindgen_test_layout__CM_COMPONENT_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_CM_COMPONENT_INFORMATION>() , 24usize);
    assert_eq!(::core::mem::align_of::<_CM_COMPONENT_INFORMATION>() , 8usize);
}
impl Clone for _CM_COMPONENT_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_CM_COMPONENT_INFORMATION as CM_COMPONENT_INFORMATION;
pub type PCM_COMPONENT_INFORMATION = *mut _CM_COMPONENT_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_ROM_BLOCK {
    pub Address: ULONG,
    pub Size: ULONG,
}
#[test]
fn bindgen_test_layout__CM_ROM_BLOCK() {
    assert_eq!(::core::mem::size_of::<_CM_ROM_BLOCK>() , 8usize);
    assert_eq!(::core::mem::align_of::<_CM_ROM_BLOCK>() , 4usize);
}
impl Clone for _CM_ROM_BLOCK {
    fn clone(&self) -> Self { *self }
}
pub use self::_CM_ROM_BLOCK as CM_ROM_BLOCK;
pub type PCM_ROM_BLOCK = *mut _CM_ROM_BLOCK;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_INT13_DRIVE_PARAMETER {
    pub DriveSelect: USHORT,
    pub MaxCylinders: ULONG,
    pub SectorsPerTrack: USHORT,
    pub MaxHeads: USHORT,
    pub NumberDrives: USHORT,
}
impl Clone for _CM_INT13_DRIVE_PARAMETER {
    fn clone(&self) -> Self { *self }
}
pub use self::_CM_INT13_DRIVE_PARAMETER as CM_INT13_DRIVE_PARAMETER;
pub type PCM_INT13_DRIVE_PARAMETER = *mut _CM_INT13_DRIVE_PARAMETER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_MCA_POS_DATA {
    pub AdapterId: USHORT,
    pub PosData1: UCHAR,
    pub PosData2: UCHAR,
    pub PosData3: UCHAR,
    pub PosData4: UCHAR,
}
impl Clone for _CM_MCA_POS_DATA {
    fn clone(&self) -> Self { *self }
}
pub use self::_CM_MCA_POS_DATA as CM_MCA_POS_DATA;
pub type PCM_MCA_POS_DATA = *mut _CM_MCA_POS_DATA;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _EISA_MEMORY_TYPE {
    pub _bitfield_1: u8,
}
impl Clone for _EISA_MEMORY_TYPE {
    fn clone(&self) -> Self { *self }
}
impl _EISA_MEMORY_TYPE {
    #[inline]
    pub fn ReadWrite(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                        0u32) as u8)
        }
    }
    #[inline]
    pub fn set_ReadWrite(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 0u32) & (1usize as u8);
    }
    #[inline]
    pub fn Cached(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u8)) >>
                                        1u32) as u8)
        }
    }
    #[inline]
    pub fn set_Cached(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(2usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 1u32) & (2usize as u8);
    }
    #[inline]
    pub fn Reserved0(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u8)) >>
                                        2u32) as u8)
        }
    }
    #[inline]
    pub fn set_Reserved0(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(4usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 2u32) & (4usize as u8);
    }
    #[inline]
    pub fn Type(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (24usize as u8)) >>
                                        3u32) as u8)
        }
    }
    #[inline]
    pub fn set_Type(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(24usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 3u32) & (24usize as u8);
    }
    #[inline]
    pub fn Shared(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u8)) >>
                                        5u32) as u8)
        }
    }
    #[inline]
    pub fn set_Shared(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(32usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 5u32) & (32usize as u8);
    }
    #[inline]
    pub fn Reserved1(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u8)) >>
                                        6u32) as u8)
        }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(64usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 6u32) & (64usize as u8);
    }
    #[inline]
    pub fn MoreEntries(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (128usize as u8)) >>
                                        7u32) as u8)
        }
    }
    #[inline]
    pub fn set_MoreEntries(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(128usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 7u32) & (128usize as u8);
    }
}
pub use self::_EISA_MEMORY_TYPE as EISA_MEMORY_TYPE;
pub type PEISA_MEMORY_TYPE = *mut _EISA_MEMORY_TYPE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _EISA_MEMORY_CONFIGURATION {
    pub ConfigurationByte: EISA_MEMORY_TYPE,
    pub DataSize: UCHAR,
    pub AddressLowWord: USHORT,
    pub AddressHighByte: UCHAR,
    pub MemorySize: USHORT,
}
impl Clone for _EISA_MEMORY_CONFIGURATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_EISA_MEMORY_CONFIGURATION as EISA_MEMORY_CONFIGURATION;
pub type PEISA_MEMORY_CONFIGURATION = *mut _EISA_MEMORY_CONFIGURATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _EISA_IRQ_DESCRIPTOR {
    pub _bitfield_1: u8,
}
impl Clone for _EISA_IRQ_DESCRIPTOR {
    fn clone(&self) -> Self { *self }
}
impl _EISA_IRQ_DESCRIPTOR {
    #[inline]
    pub fn Interrupt(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (15usize as u8)) >>
                                        0u32) as u8)
        }
    }
    #[inline]
    pub fn set_Interrupt(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(15usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 0u32) & (15usize as u8);
    }
    #[inline]
    pub fn Reserved(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u8)) >>
                                        4u32) as u8)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(16usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 4u32) & (16usize as u8);
    }
    #[inline]
    pub fn LevelTriggered(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u8)) >>
                                        5u32) as u8)
        }
    }
    #[inline]
    pub fn set_LevelTriggered(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(32usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 5u32) & (32usize as u8);
    }
    #[inline]
    pub fn Shared(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u8)) >>
                                        6u32) as u8)
        }
    }
    #[inline]
    pub fn set_Shared(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(64usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 6u32) & (64usize as u8);
    }
    #[inline]
    pub fn MoreEntries(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (128usize as u8)) >>
                                        7u32) as u8)
        }
    }
    #[inline]
    pub fn set_MoreEntries(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(128usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 7u32) & (128usize as u8);
    }
}
pub use self::_EISA_IRQ_DESCRIPTOR as EISA_IRQ_DESCRIPTOR;
pub type PEISA_IRQ_DESCRIPTOR = *mut _EISA_IRQ_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _EISA_IRQ_CONFIGURATION {
    pub ConfigurationByte: EISA_IRQ_DESCRIPTOR,
    pub Reserved: UCHAR,
}
impl Clone for _EISA_IRQ_CONFIGURATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_EISA_IRQ_CONFIGURATION as EISA_IRQ_CONFIGURATION;
pub type PEISA_IRQ_CONFIGURATION = *mut _EISA_IRQ_CONFIGURATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DMA_CONFIGURATION_BYTE0 {
    pub _bitfield_1: u8,
}
impl Clone for _DMA_CONFIGURATION_BYTE0 {
    fn clone(&self) -> Self { *self }
}
impl _DMA_CONFIGURATION_BYTE0 {
    #[inline]
    pub fn Channel(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (7usize as u8)) >>
                                        0u32) as u8)
        }
    }
    #[inline]
    pub fn set_Channel(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(7usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 0u32) & (7usize as u8);
    }
    #[inline]
    pub fn Reserved(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (56usize as u8)) >>
                                        3u32) as u8)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(56usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 3u32) & (56usize as u8);
    }
    #[inline]
    pub fn Shared(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u8)) >>
                                        6u32) as u8)
        }
    }
    #[inline]
    pub fn set_Shared(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(64usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 6u32) & (64usize as u8);
    }
    #[inline]
    pub fn MoreEntries(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (128usize as u8)) >>
                                        7u32) as u8)
        }
    }
    #[inline]
    pub fn set_MoreEntries(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(128usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 7u32) & (128usize as u8);
    }
}
pub use self::_DMA_CONFIGURATION_BYTE0 as DMA_CONFIGURATION_BYTE0;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DMA_CONFIGURATION_BYTE1 {
    pub _bitfield_1: u8,
}
impl Clone for _DMA_CONFIGURATION_BYTE1 {
    fn clone(&self) -> Self { *self }
}
impl _DMA_CONFIGURATION_BYTE1 {
    #[inline]
    pub fn Reserved0(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (3usize as u8)) >>
                                        0u32) as u8)
        }
    }
    #[inline]
    pub fn set_Reserved0(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(3usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 0u32) & (3usize as u8);
    }
    #[inline]
    pub fn TransferSize(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (12usize as u8)) >>
                                        2u32) as u8)
        }
    }
    #[inline]
    pub fn set_TransferSize(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(12usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 2u32) & (12usize as u8);
    }
    #[inline]
    pub fn Timing(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (48usize as u8)) >>
                                        4u32) as u8)
        }
    }
    #[inline]
    pub fn set_Timing(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(48usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 4u32) & (48usize as u8);
    }
    #[inline]
    pub fn Reserved1(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (192usize as u8)) >>
                                        6u32) as u8)
        }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(192usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 6u32) & (192usize as u8);
    }
}
pub use self::_DMA_CONFIGURATION_BYTE1 as DMA_CONFIGURATION_BYTE1;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _EISA_DMA_CONFIGURATION {
    pub ConfigurationByte0: DMA_CONFIGURATION_BYTE0,
    pub ConfigurationByte1: DMA_CONFIGURATION_BYTE1,
}
impl Clone for _EISA_DMA_CONFIGURATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_EISA_DMA_CONFIGURATION as EISA_DMA_CONFIGURATION;
pub type PEISA_DMA_CONFIGURATION = *mut _EISA_DMA_CONFIGURATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _EISA_PORT_DESCRIPTOR {
    pub _bitfield_1: u8,
}
impl Clone for _EISA_PORT_DESCRIPTOR {
    fn clone(&self) -> Self { *self }
}
impl _EISA_PORT_DESCRIPTOR {
    #[inline]
    pub fn NumberPorts(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (31usize as u8)) >>
                                        0u32) as u8)
        }
    }
    #[inline]
    pub fn set_NumberPorts(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(31usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 0u32) & (31usize as u8);
    }
    #[inline]
    pub fn Reserved(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u8)) >>
                                        5u32) as u8)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(32usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 5u32) & (32usize as u8);
    }
    #[inline]
    pub fn Shared(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u8)) >>
                                        6u32) as u8)
        }
    }
    #[inline]
    pub fn set_Shared(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(64usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 6u32) & (64usize as u8);
    }
    #[inline]
    pub fn MoreEntries(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (128usize as u8)) >>
                                        7u32) as u8)
        }
    }
    #[inline]
    pub fn set_MoreEntries(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(128usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 7u32) & (128usize as u8);
    }
}
pub use self::_EISA_PORT_DESCRIPTOR as EISA_PORT_DESCRIPTOR;
pub type PEISA_PORT_DESCRIPTOR = *mut _EISA_PORT_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _EISA_PORT_CONFIGURATION {
    pub Configuration: EISA_PORT_DESCRIPTOR,
    pub PortAddress: USHORT,
}
impl Clone for _EISA_PORT_CONFIGURATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_EISA_PORT_CONFIGURATION as EISA_PORT_CONFIGURATION;
pub type PEISA_PORT_CONFIGURATION = *mut _EISA_PORT_CONFIGURATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_EISA_SLOT_INFORMATION {
    pub ReturnCode: UCHAR,
    pub ReturnFlags: UCHAR,
    pub MajorRevision: UCHAR,
    pub MinorRevision: UCHAR,
    pub Checksum: USHORT,
    pub NumberFunctions: UCHAR,
    pub FunctionInformation: UCHAR,
    pub CompressedId: ULONG,
}
impl Clone for _CM_EISA_SLOT_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_CM_EISA_SLOT_INFORMATION as CM_EISA_SLOT_INFORMATION;
pub type PCM_EISA_SLOT_INFORMATION = *mut _CM_EISA_SLOT_INFORMATION;
#[repr(C)]
pub struct _CM_EISA_FUNCTION_INFORMATION {
    pub CompressedId: ULONG,
    pub IdSlotFlags1: UCHAR,
    pub IdSlotFlags2: UCHAR,
    pub MinorRevision: UCHAR,
    pub MajorRevision: UCHAR,
    pub Selections: [UCHAR; 26usize],
    pub FunctionFlags: UCHAR,
    pub TypeString: [UCHAR; 80usize],
    pub EisaMemory: [EISA_MEMORY_CONFIGURATION; 9usize],
    pub EisaIrq: [EISA_IRQ_CONFIGURATION; 7usize],
    pub EisaDma: [EISA_DMA_CONFIGURATION; 4usize],
    pub EisaPort: [EISA_PORT_CONFIGURATION; 20usize],
    pub InitializationData: [UCHAR; 60usize],
}
pub use self::_CM_EISA_FUNCTION_INFORMATION as CM_EISA_FUNCTION_INFORMATION;
pub type PCM_EISA_FUNCTION_INFORMATION = *mut _CM_EISA_FUNCTION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_PNP_BIOS_DEVICE_NODE {
    pub Size: USHORT,
    pub Node: UCHAR,
    pub ProductId: ULONG,
    pub DeviceType: [UCHAR; 3usize],
    pub DeviceAttributes: USHORT,
}
impl Clone for _CM_PNP_BIOS_DEVICE_NODE {
    fn clone(&self) -> Self { *self }
}
pub use self::_CM_PNP_BIOS_DEVICE_NODE as CM_PNP_BIOS_DEVICE_NODE;
pub type PCM_PNP_BIOS_DEVICE_NODE = *mut _CM_PNP_BIOS_DEVICE_NODE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_PNP_BIOS_INSTALLATION_CHECK {
    pub Signature: [UCHAR; 4usize],
    pub Revision: UCHAR,
    pub Length: UCHAR,
    pub ControlField: USHORT,
    pub Checksum: UCHAR,
    pub EventFlagAddress: ULONG,
    pub RealModeEntryOffset: USHORT,
    pub RealModeEntrySegment: USHORT,
    pub ProtectedModeEntryOffset: USHORT,
    pub ProtectedModeCodeBaseAddress: ULONG,
    pub OemDeviceId: ULONG,
    pub RealModeDataBaseAddress: USHORT,
    pub ProtectedModeDataBaseAddress: ULONG,
}
impl Clone for _CM_PNP_BIOS_INSTALLATION_CHECK {
    fn clone(&self) -> Self { *self }
}
pub use self::_CM_PNP_BIOS_INSTALLATION_CHECK as
        CM_PNP_BIOS_INSTALLATION_CHECK;
pub type PCM_PNP_BIOS_INSTALLATION_CHECK =
    *mut _CM_PNP_BIOS_INSTALLATION_CHECK;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_SCSI_DEVICE_DATA {
    pub Version: USHORT,
    pub Revision: USHORT,
    pub HostIdentifier: UCHAR,
}
#[test]
fn bindgen_test_layout__CM_SCSI_DEVICE_DATA() {
    assert_eq!(::core::mem::size_of::<_CM_SCSI_DEVICE_DATA>() , 6usize);
    assert_eq!(::core::mem::align_of::<_CM_SCSI_DEVICE_DATA>() , 2usize);
}
impl Clone for _CM_SCSI_DEVICE_DATA {
    fn clone(&self) -> Self { *self }
}
pub use self::_CM_SCSI_DEVICE_DATA as CM_SCSI_DEVICE_DATA;
pub type PCM_SCSI_DEVICE_DATA = *mut _CM_SCSI_DEVICE_DATA;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_VIDEO_DEVICE_DATA {
    pub Version: USHORT,
    pub Revision: USHORT,
    pub VideoClock: ULONG,
}
#[test]
fn bindgen_test_layout__CM_VIDEO_DEVICE_DATA() {
    assert_eq!(::core::mem::size_of::<_CM_VIDEO_DEVICE_DATA>() , 8usize);
    assert_eq!(::core::mem::align_of::<_CM_VIDEO_DEVICE_DATA>() , 4usize);
}
impl Clone for _CM_VIDEO_DEVICE_DATA {
    fn clone(&self) -> Self { *self }
}
pub use self::_CM_VIDEO_DEVICE_DATA as CM_VIDEO_DEVICE_DATA;
pub type PCM_VIDEO_DEVICE_DATA = *mut _CM_VIDEO_DEVICE_DATA;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_SONIC_DEVICE_DATA {
    pub Version: USHORT,
    pub Revision: USHORT,
    pub DataConfigurationRegister: USHORT,
    pub EthernetAddress: [UCHAR; 8usize],
}
#[test]
fn bindgen_test_layout__CM_SONIC_DEVICE_DATA() {
    assert_eq!(::core::mem::size_of::<_CM_SONIC_DEVICE_DATA>() , 14usize);
    assert_eq!(::core::mem::align_of::<_CM_SONIC_DEVICE_DATA>() , 2usize);
}
impl Clone for _CM_SONIC_DEVICE_DATA {
    fn clone(&self) -> Self { *self }
}
pub use self::_CM_SONIC_DEVICE_DATA as CM_SONIC_DEVICE_DATA;
pub type PCM_SONIC_DEVICE_DATA = *mut _CM_SONIC_DEVICE_DATA;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_SERIAL_DEVICE_DATA {
    pub Version: USHORT,
    pub Revision: USHORT,
    pub BaudClock: ULONG,
}
#[test]
fn bindgen_test_layout__CM_SERIAL_DEVICE_DATA() {
    assert_eq!(::core::mem::size_of::<_CM_SERIAL_DEVICE_DATA>() , 8usize);
    assert_eq!(::core::mem::align_of::<_CM_SERIAL_DEVICE_DATA>() , 4usize);
}
impl Clone for _CM_SERIAL_DEVICE_DATA {
    fn clone(&self) -> Self { *self }
}
pub use self::_CM_SERIAL_DEVICE_DATA as CM_SERIAL_DEVICE_DATA;
pub type PCM_SERIAL_DEVICE_DATA = *mut _CM_SERIAL_DEVICE_DATA;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_MONITOR_DEVICE_DATA {
    pub Version: USHORT,
    pub Revision: USHORT,
    pub HorizontalScreenSize: USHORT,
    pub VerticalScreenSize: USHORT,
    pub HorizontalResolution: USHORT,
    pub VerticalResolution: USHORT,
    pub HorizontalDisplayTimeLow: USHORT,
    pub HorizontalDisplayTime: USHORT,
    pub HorizontalDisplayTimeHigh: USHORT,
    pub HorizontalBackPorchLow: USHORT,
    pub HorizontalBackPorch: USHORT,
    pub HorizontalBackPorchHigh: USHORT,
    pub HorizontalFrontPorchLow: USHORT,
    pub HorizontalFrontPorch: USHORT,
    pub HorizontalFrontPorchHigh: USHORT,
    pub HorizontalSyncLow: USHORT,
    pub HorizontalSync: USHORT,
    pub HorizontalSyncHigh: USHORT,
    pub VerticalBackPorchLow: USHORT,
    pub VerticalBackPorch: USHORT,
    pub VerticalBackPorchHigh: USHORT,
    pub VerticalFrontPorchLow: USHORT,
    pub VerticalFrontPorch: USHORT,
    pub VerticalFrontPorchHigh: USHORT,
    pub VerticalSyncLow: USHORT,
    pub VerticalSync: USHORT,
    pub VerticalSyncHigh: USHORT,
}
#[test]
fn bindgen_test_layout__CM_MONITOR_DEVICE_DATA() {
    assert_eq!(::core::mem::size_of::<_CM_MONITOR_DEVICE_DATA>() , 54usize);
    assert_eq!(::core::mem::align_of::<_CM_MONITOR_DEVICE_DATA>() , 2usize);
}
impl Clone for _CM_MONITOR_DEVICE_DATA {
    fn clone(&self) -> Self { *self }
}
pub use self::_CM_MONITOR_DEVICE_DATA as CM_MONITOR_DEVICE_DATA;
pub type PCM_MONITOR_DEVICE_DATA = *mut _CM_MONITOR_DEVICE_DATA;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_FLOPPY_DEVICE_DATA {
    pub Version: USHORT,
    pub Revision: USHORT,
    pub Size: [CHAR; 8usize],
    pub MaxDensity: ULONG,
    pub MountDensity: ULONG,
    pub StepRateHeadUnloadTime: UCHAR,
    pub HeadLoadTime: UCHAR,
    pub MotorOffTime: UCHAR,
    pub SectorLengthCode: UCHAR,
    pub SectorPerTrack: UCHAR,
    pub ReadWriteGapLength: UCHAR,
    pub DataTransferLength: UCHAR,
    pub FormatGapLength: UCHAR,
    pub FormatFillCharacter: UCHAR,
    pub HeadSettleTime: UCHAR,
    pub MotorSettleTime: UCHAR,
    pub MaximumTrackValue: UCHAR,
    pub DataTransferRate: UCHAR,
}
#[test]
fn bindgen_test_layout__CM_FLOPPY_DEVICE_DATA() {
    assert_eq!(::core::mem::size_of::<_CM_FLOPPY_DEVICE_DATA>() , 36usize);
    assert_eq!(::core::mem::align_of::<_CM_FLOPPY_DEVICE_DATA>() , 4usize);
}
impl Clone for _CM_FLOPPY_DEVICE_DATA {
    fn clone(&self) -> Self { *self }
}
pub use self::_CM_FLOPPY_DEVICE_DATA as CM_FLOPPY_DEVICE_DATA;
pub type PCM_FLOPPY_DEVICE_DATA = *mut _CM_FLOPPY_DEVICE_DATA;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_KEYBOARD_DEVICE_DATA {
    pub Version: USHORT,
    pub Revision: USHORT,
    pub Type: UCHAR,
    pub Subtype: UCHAR,
    pub KeyboardFlags: USHORT,
}
#[test]
fn bindgen_test_layout__CM_KEYBOARD_DEVICE_DATA() {
    assert_eq!(::core::mem::size_of::<_CM_KEYBOARD_DEVICE_DATA>() , 8usize);
    assert_eq!(::core::mem::align_of::<_CM_KEYBOARD_DEVICE_DATA>() , 2usize);
}
impl Clone for _CM_KEYBOARD_DEVICE_DATA {
    fn clone(&self) -> Self { *self }
}
pub use self::_CM_KEYBOARD_DEVICE_DATA as CM_KEYBOARD_DEVICE_DATA;
pub type PCM_KEYBOARD_DEVICE_DATA = *mut _CM_KEYBOARD_DEVICE_DATA;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_DISK_GEOMETRY_DEVICE_DATA {
    pub BytesPerSector: ULONG,
    pub NumberOfCylinders: ULONG,
    pub SectorsPerTrack: ULONG,
    pub NumberOfHeads: ULONG,
}
#[test]
fn bindgen_test_layout__CM_DISK_GEOMETRY_DEVICE_DATA() {
    assert_eq!(::core::mem::size_of::<_CM_DISK_GEOMETRY_DEVICE_DATA>() ,
               16usize);
    assert_eq!(::core::mem::align_of::<_CM_DISK_GEOMETRY_DEVICE_DATA>() ,
               4usize);
}
impl Clone for _CM_DISK_GEOMETRY_DEVICE_DATA {
    fn clone(&self) -> Self { *self }
}
pub use self::_CM_DISK_GEOMETRY_DEVICE_DATA as CM_DISK_GEOMETRY_DEVICE_DATA;
pub type PCM_DISK_GEOMETRY_DEVICE_DATA = *mut _CM_DISK_GEOMETRY_DEVICE_DATA;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _IRQ_DEVICE_POLICY {
    IrqPolicyMachineDefault = 0,
    IrqPolicyAllCloseProcessors = 1,
    IrqPolicyOneCloseProcessor = 2,
    IrqPolicyAllProcessorsInMachine = 3,
    IrqPolicySpecifiedProcessors = 4,
    IrqPolicySpreadMessagesAcrossAllProcessors = 5,
    IrqPolicyAllProcessorsInMachineWhenSteered = 6,
}
pub use self::_IRQ_DEVICE_POLICY as IRQ_DEVICE_POLICY;
pub type PIRQ_DEVICE_POLICY = *mut _IRQ_DEVICE_POLICY;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _IRQ_PRIORITY {
    IrqPriorityUndefined = 0,
    IrqPriorityLow = 1,
    IrqPriorityNormal = 2,
    IrqPriorityHigh = 3,
}
pub use self::_IRQ_PRIORITY as IRQ_PRIORITY;
pub type PIRQ_PRIORITY = *mut _IRQ_PRIORITY;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _IRQ_GROUP_POLICY {
    GroupAffinityAllGroupZero = 0,
    GroupAffinityDontCare = 1,
}
pub use self::_IRQ_GROUP_POLICY as IRQ_GROUP_POLICY;
pub type PIRQ_GROUP_POLICY = *mut _IRQ_GROUP_POLICY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_RESOURCE_DESCRIPTOR {
    pub Option: UCHAR,
    pub Type: UCHAR,
    pub ShareDisposition: UCHAR,
    pub Spare1: UCHAR,
    pub Flags: USHORT,
    pub Spare2: USHORT,
    pub u: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1 {
    pub Port: __BindgenUnionField<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>,
    pub Memory: __BindgenUnionField<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2>,
    pub Interrupt: __BindgenUnionField<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3>,
    pub Dma: __BindgenUnionField<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4>,
    pub DmaV3: __BindgenUnionField<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5>,
    pub Generic: __BindgenUnionField<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6>,
    pub DevicePrivate: __BindgenUnionField<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7>,
    pub BusNumber: __BindgenUnionField<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8>,
    pub ConfigData: __BindgenUnionField<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9>,
    pub Memory40: __BindgenUnionField<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10>,
    pub Memory48: __BindgenUnionField<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11>,
    pub Memory64: __BindgenUnionField<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12>,
    pub Connection: __BindgenUnionField<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13>,
    pub bindgen_union_field: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    pub Length: ULONG,
    pub Alignment: ULONG,
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>()
               , 24usize);
    assert_eq!(::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>()
               , 8usize);
}
impl Clone for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 {
    pub Length: ULONG,
    pub Alignment: ULONG,
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2>()
               , 24usize);
    assert_eq!(::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2>()
               , 8usize);
}
impl Clone for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3 {
    pub MinimumVector: ULONG,
    pub MaximumVector: ULONG,
    pub AffinityPolicy: IRQ_DEVICE_POLICY,
    pub PriorityPolicy: IRQ_PRIORITY,
    pub TargetedProcessors: KAFFINITY,
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3>()
               , 24usize);
    assert_eq!(::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3>()
               , 8usize);
}
impl Clone for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4 {
    pub MinimumChannel: ULONG,
    pub MaximumChannel: ULONG,
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4>()
               , 8usize);
    assert_eq!(::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4>()
               , 4usize);
}
impl Clone for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5 {
    pub RequestLine: ULONG,
    pub Reserved: ULONG,
    pub Channel: ULONG,
    pub TransferWidth: ULONG,
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5>()
               , 16usize);
    assert_eq!(::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5>()
               , 4usize);
}
impl Clone for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6 {
    pub Length: ULONG,
    pub Alignment: ULONG,
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6>()
               , 24usize);
    assert_eq!(::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6>()
               , 8usize);
}
impl Clone for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7 {
    pub Data: [ULONG; 3usize],
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7() {
    assert_eq!(::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7>()
               , 12usize);
    assert_eq!(::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7>()
               , 4usize);
}
impl Clone for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8 {
    pub Length: ULONG,
    pub MinBusNumber: ULONG,
    pub MaxBusNumber: ULONG,
    pub Reserved: ULONG,
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8() {
    assert_eq!(::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8>()
               , 16usize);
    assert_eq!(::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8>()
               , 4usize);
}
impl Clone for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9 {
    pub Priority: ULONG,
    pub Reserved1: ULONG,
    pub Reserved2: ULONG,
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9() {
    assert_eq!(::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9>()
               , 12usize);
    assert_eq!(::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9>()
               , 4usize);
}
impl Clone for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10 {
    pub Length40: ULONG,
    pub Alignment40: ULONG,
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10() {
    assert_eq!(::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10>()
               , 24usize);
    assert_eq!(::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10>()
               , 8usize);
}
impl Clone for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11 {
    pub Length48: ULONG,
    pub Alignment48: ULONG,
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11() {
    assert_eq!(::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11>()
               , 24usize);
    assert_eq!(::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11>()
               , 8usize);
}
impl Clone for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12 {
    pub Length64: ULONG,
    pub Alignment64: ULONG,
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12() {
    assert_eq!(::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12>()
               , 24usize);
    assert_eq!(::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12>()
               , 8usize);
}
impl Clone for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13 {
    pub Class: UCHAR,
    pub Type: UCHAR,
    pub Reserved1: UCHAR,
    pub Reserved2: UCHAR,
    pub IdLowPart: ULONG,
    pub IdHighPart: ULONG,
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13() {
    assert_eq!(::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13>()
               , 12usize);
    assert_eq!(::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13>()
               , 4usize);
}
impl Clone for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1>()
               , 24usize);
    assert_eq!(::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1>()
               , 8usize);
}
impl Clone for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR() {
    assert_eq!(::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR>() , 32usize);
    assert_eq!(::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR>() , 8usize);
}
impl Clone for _IO_RESOURCE_DESCRIPTOR {
    fn clone(&self) -> Self { *self }
}
pub use self::_IO_RESOURCE_DESCRIPTOR as IO_RESOURCE_DESCRIPTOR;
pub type PIO_RESOURCE_DESCRIPTOR = *mut _IO_RESOURCE_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_RESOURCE_LIST {
    pub Version: USHORT,
    pub Revision: USHORT,
    pub Count: ULONG,
    pub Descriptors: [IO_RESOURCE_DESCRIPTOR; 1usize],
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_LIST() {
    assert_eq!(::core::mem::size_of::<_IO_RESOURCE_LIST>() , 40usize);
    assert_eq!(::core::mem::align_of::<_IO_RESOURCE_LIST>() , 8usize);
}
impl Clone for _IO_RESOURCE_LIST {
    fn clone(&self) -> Self { *self }
}
pub use self::_IO_RESOURCE_LIST as IO_RESOURCE_LIST;
pub type PIO_RESOURCE_LIST = *mut _IO_RESOURCE_LIST;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_RESOURCE_REQUIREMENTS_LIST {
    pub ListSize: ULONG,
    pub InterfaceType: INTERFACE_TYPE,
    pub BusNumber: ULONG,
    pub SlotNumber: ULONG,
    pub Reserved: [ULONG; 3usize],
    pub AlternativeLists: ULONG,
    pub List: [IO_RESOURCE_LIST; 1usize],
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_REQUIREMENTS_LIST() {
    assert_eq!(::core::mem::size_of::<_IO_RESOURCE_REQUIREMENTS_LIST>() ,
               72usize);
    assert_eq!(::core::mem::align_of::<_IO_RESOURCE_REQUIREMENTS_LIST>() ,
               8usize);
}
impl Clone for _IO_RESOURCE_REQUIREMENTS_LIST {
    fn clone(&self) -> Self { *self }
}
pub use self::_IO_RESOURCE_REQUIREMENTS_LIST as IO_RESOURCE_REQUIREMENTS_LIST;
pub type PIO_RESOURCE_REQUIREMENTS_LIST = *mut _IO_RESOURCE_REQUIREMENTS_LIST;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SLIST_ENTRY {
    pub Next: *mut _SLIST_ENTRY,
}
impl Clone for _SLIST_ENTRY {
    fn clone(&self) -> Self { *self }
}
pub use self::_SLIST_ENTRY as SLIST_ENTRY;
pub type PSLIST_ENTRY = *mut _SLIST_ENTRY;
#[repr(C)]
#[derive(Copy)]
pub struct _SLIST_HEADER {
    pub Alignment: __BindgenUnionField<ULONGLONG>,
    pub __bindgen_anon_1: __BindgenUnionField<_SLIST_HEADER__bindgen_ty_1>,
    pub bindgen_union_field: [u8; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SLIST_HEADER__bindgen_ty_1 {
    pub Next: SLIST_ENTRY,
    pub Depth: USHORT,
    pub CpuId: USHORT,
}
#[test]
fn bindgen_test_layout__SLIST_HEADER__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_SLIST_HEADER__bindgen_ty_1>() ,
               32usize);
    assert_eq!(::core::mem::align_of::<_SLIST_HEADER__bindgen_ty_1>() ,
               16usize);
}
impl Clone for _SLIST_HEADER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__SLIST_HEADER() {
    assert_eq!(::core::mem::size_of::<_SLIST_HEADER>() , 32usize);
    assert_eq!(::core::mem::align_of::<_SLIST_HEADER>() , 16usize);
}
impl Clone for _SLIST_HEADER {
    fn clone(&self) -> Self { *self }
}
pub use self::_SLIST_HEADER as SLIST_HEADER;
pub type PSLIST_HEADER = *mut _SLIST_HEADER;
extern "C" {
    pub fn RtlAssert(VoidFailedAssertion: PVOID, VoidFileName: PVOID,
                     LineNumber: ULONG, MutableMessage: PSTR);
}
extern "C" {
    pub fn __fastfail(Code: libc::c_uint);
}
extern "C" {
    pub fn RtlIntegerToUnicodeString(Value: ULONG, Base: ULONG,
                                     String: PUNICODE_STRING) -> NTSTATUS;
}
extern "C" {
    pub fn RtlInt64ToUnicodeString(Value: ULONGLONG, Base: ULONG,
                                   String: PUNICODE_STRING) -> NTSTATUS;
}
extern "C" {
    pub fn RtlUnicodeStringToInteger(String: PCUNICODE_STRING, Base: ULONG,
                                     Value: PULONG) -> NTSTATUS;
}
extern "C" {
    pub fn RtlUnicodeStringToInt64(String: PCUNICODE_STRING, Base: ULONG,
                                   Number: PLONG64, EndPointer: *mut PWSTR)
     -> NTSTATUS;
}
extern "C" {
    #[link_name = "NlsMbCodePageTag"]
    pub static mut NlsMbCodePageTag: *mut libc::c_uchar;
}
extern "C" {
    #[link_name = "NlsMbOemCodePageTag"]
    pub static mut NlsMbOemCodePageTag: *mut libc::c_uchar;
}
extern "C" {
    pub fn RtlInitString(DestinationString: PSTRING, SourceString: PCSZ);
}
extern "C" {
    pub fn RtlInitAnsiString(DestinationString: PANSI_STRING,
                             SourceString: PCSZ);
}
extern "C" {
    pub fn RtlInitUnicodeString(DestinationString: PUNICODE_STRING,
                                SourceString: PCWSTR);
}
pub type PRTL_QUERY_REGISTRY_ROUTINE =
    ::core::option::Option<unsafe extern "C" fn() -> NTSTATUS>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _RTL_QUERY_REGISTRY_TABLE {
    pub QueryRoutine: PRTL_QUERY_REGISTRY_ROUTINE,
    pub Flags: ULONG,
    pub Name: PWSTR,
    pub EntryContext: PVOID,
    pub DefaultType: ULONG,
    pub DefaultData: PVOID,
    pub DefaultLength: ULONG,
}
#[test]
fn bindgen_test_layout__RTL_QUERY_REGISTRY_TABLE() {
    assert_eq!(::core::mem::size_of::<_RTL_QUERY_REGISTRY_TABLE>() , 56usize);
    assert_eq!(::core::mem::align_of::<_RTL_QUERY_REGISTRY_TABLE>() , 8usize);
}
impl Clone for _RTL_QUERY_REGISTRY_TABLE {
    fn clone(&self) -> Self { *self }
}
pub use self::_RTL_QUERY_REGISTRY_TABLE as RTL_QUERY_REGISTRY_TABLE;
pub type PRTL_QUERY_REGISTRY_TABLE = *mut _RTL_QUERY_REGISTRY_TABLE;
extern "C" {
    pub fn RtlQueryRegistryValues(RelativeTo: ULONG, Path: PCWSTR,
                                  QueryTable: PRTL_QUERY_REGISTRY_TABLE,
                                  Context: PVOID, Environment: PVOID)
     -> NTSTATUS;
}
extern "C" {
    pub fn MmGetSystemRoutineAddress(SystemRoutineName: PUNICODE_STRING)
     -> PVOID;
}
extern "C" {
    pub fn RtlWriteRegistryValue(RelativeTo: ULONG, Path: PCWSTR,
                                 ValueName: PCWSTR, ValueType: ULONG,
                                 ValueData: PVOID, ValueLength: ULONG)
     -> NTSTATUS;
}
extern "C" {
    pub fn RtlDeleteRegistryValue(RelativeTo: ULONG, Path: PCWSTR,
                                  ValueName: PCWSTR) -> NTSTATUS;
}
extern "C" {
    pub fn RtlCreateRegistryKey(RelativeTo: ULONG, Path: PWSTR) -> NTSTATUS;
}
extern "C" {
    pub fn RtlCheckRegistryKey(RelativeTo: ULONG, Path: PWSTR) -> NTSTATUS;
}
extern "C" {
    pub fn RtlInitAnsiStringEx(DestinationString: PANSI_STRING,
                               SourceString: PCSZ) -> NTSTATUS;
}
extern "C" {
    pub fn RtlInitStringEx(DestinationString: PSTRING, SourceString: PCSZ)
     -> NTSTATUS;
}
extern "C" {
    pub fn RtlAnsiStringToUnicodeString(DestinationString: PUNICODE_STRING,
                                        SourceString: PCANSI_STRING,
                                        AllocateDestinationString: BOOLEAN)
     -> NTSTATUS;
}
extern "C" {
    pub fn RtlUnicodeStringToAnsiString(DestinationString: PANSI_STRING,
                                        SourceString: PCUNICODE_STRING,
                                        AllocateDestinationString: BOOLEAN)
     -> NTSTATUS;
}
extern "C" {
    pub fn RtlCompareUnicodeStrings(String1: PCWCH, String1Length: SIZE_T,
                                    String2: PCWCH, String2Length: SIZE_T,
                                    CaseInSensitive: BOOLEAN) -> LONG;
}
extern "C" {
    pub fn RtlCompareUnicodeString(String1: PCUNICODE_STRING,
                                   String2: PCUNICODE_STRING,
                                   CaseInSensitive: BOOLEAN) -> LONG;
}
extern "C" {
    pub fn RtlEqualUnicodeString(String1: PCUNICODE_STRING,
                                 String2: PCUNICODE_STRING,
                                 CaseInSensitive: BOOLEAN) -> BOOLEAN;
}
extern "C" {
    pub fn RtlHashUnicodeString(String: PCUNICODE_STRING,
                                CaseInSensitive: BOOLEAN,
                                HashAlgorithm: ULONG, HashValue: PULONG)
     -> NTSTATUS;
}
extern "C" {
    pub fn RtlCopyUnicodeString(DestinationString: PUNICODE_STRING,
                                SourceString: PCUNICODE_STRING);
}
extern "C" {
    pub fn RtlAppendUnicodeStringToString(Destination: PUNICODE_STRING,
                                          Source: PCUNICODE_STRING)
     -> NTSTATUS;
}
extern "C" {
    pub fn RtlAppendUnicodeToString(Destination: PUNICODE_STRING,
                                    Source: PCWSTR) -> NTSTATUS;
}
extern "C" {
    pub fn RtlUpcaseUnicodeChar(SourceCharacter: WCHAR) -> WCHAR;
}
extern "C" {
    pub fn RtlDowncaseUnicodeChar(SourceCharacter: WCHAR) -> WCHAR;
}
extern "C" {
    pub fn RtlFreeUnicodeString(UnicodeString: PUNICODE_STRING);
}
extern "C" {
    pub fn RtlFreeAnsiString(AnsiString: PANSI_STRING);
}
extern "C" {
    pub fn RtlxUnicodeStringToAnsiSize(UnicodeString: PCUNICODE_STRING)
     -> ULONG;
}
extern "C" {
    pub fn RtlxAnsiStringToUnicodeSize(AnsiString: PCANSI_STRING) -> ULONG;
}
extern "C" {
    pub fn RtlUnicodeToUTF8N(UTF8StringDestination: PCHAR,
                             UTF8StringMaxByteCount: ULONG,
                             UTF8StringActualByteCount: PULONG,
                             UnicodeStringSource: PCWCH,
                             UnicodeStringByteCount: ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn RtlUTF8ToUnicodeN(UnicodeStringDestination: PWSTR,
                             UnicodeStringMaxByteCount: ULONG,
                             UnicodeStringActualByteCount: PULONG,
                             UTF8StringSource: PCCH,
                             UTF8StringByteCount: ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn RtlStringFromGUID(Guid: *const GUID, GuidString: PUNICODE_STRING)
     -> NTSTATUS;
}
extern "C" {
    pub fn RtlGUIDFromString(GuidString: PCUNICODE_STRING, Guid: *mut GUID)
     -> NTSTATUS;
}
extern "C" {
    pub fn RtlGenerateClass5Guid(NamespaceGuid: *const GUID, Buffer: PVOID,
                                 BufferSize: ULONG, Guid: *mut GUID)
     -> NTSTATUS;
}
extern "C" {
    pub fn RtlCopyMemoryNonTemporal(Destination: *mut libc::c_void,
                                    Source: *const libc::c_void,
                                    Length: SIZE_T);
}
extern "C" {
    pub fn RtlPrefetchMemoryNonTemporal(Source: PVOID, Length: SIZE_T);
}
extern "C" {
    pub fn DbgBreakPointWithStatus(Status: ULONG);
}
extern "C" {
    pub fn DbgPrint(Format: PCSTR, ...) -> ULONG;
}
extern "C" {
    pub fn DbgPrintEx(ComponentId: ULONG, Level: ULONG, Format: PCSTR, ...)
     -> ULONG;
}
extern "C" {
    pub fn vDbgPrintEx(ComponentId: ULONG, Level: ULONG, Format: PCCH,
                       arglist: va_list) -> ULONG;
}
extern "C" {
    pub fn vDbgPrintExWithPrefix(Prefix: PCCH, ComponentId: ULONG,
                                 Level: ULONG, Format: PCCH, arglist: va_list)
     -> ULONG;
}
extern "C" {
    pub fn DbgPrintReturnControlC(Format: PCCH, ...) -> ULONG;
}
extern "C" {
    pub fn DbgQueryDebugFilterState(ComponentId: ULONG, Level: ULONG)
     -> NTSTATUS;
}
extern "C" {
    pub fn DbgSetDebugFilterState(ComponentId: ULONG, Level: ULONG,
                                  State: BOOLEAN) -> NTSTATUS;
}
pub type PDEBUG_PRINT_CALLBACK =
    ::core::option::Option<unsafe extern "C" fn(Output: PSTRING,
                                                ComponentId: ULONG,
                                                Level: ULONG)>;
extern "C" {
    pub fn DbgSetDebugPrintCallback(DebugPrintCallback: PDEBUG_PRINT_CALLBACK,
                                    Enable: BOOLEAN) -> NTSTATUS;
}
extern "C" {
    pub fn RtlExtendedMagicDivide(Dividend: LARGE_INTEGER,
                                  MagicDivisor: LARGE_INTEGER,
                                  ShiftCount: CCHAR) -> LARGE_INTEGER;
}
extern "C" {
    pub fn RtlExtendedLargeIntegerDivide(Dividend: LARGE_INTEGER,
                                         Divisor: ULONG, Remainder: PULONG)
     -> LARGE_INTEGER;
}
extern "C" {
    pub fn RtlExtendedIntegerMultiply(Multiplicand: LARGE_INTEGER,
                                      Multiplier: LONG) -> LARGE_INTEGER;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _TIME_FIELDS {
    pub Year: CSHORT,
    pub Month: CSHORT,
    pub Day: CSHORT,
    pub Hour: CSHORT,
    pub Minute: CSHORT,
    pub Second: CSHORT,
    pub Milliseconds: CSHORT,
    pub Weekday: CSHORT,
}
#[test]
fn bindgen_test_layout__TIME_FIELDS() {
    assert_eq!(::core::mem::size_of::<_TIME_FIELDS>() , 16usize);
    assert_eq!(::core::mem::align_of::<_TIME_FIELDS>() , 2usize);
}
impl Clone for _TIME_FIELDS {
    fn clone(&self) -> Self { *self }
}
pub use self::_TIME_FIELDS as TIME_FIELDS;
pub type PTIME_FIELDS = *mut TIME_FIELDS;
extern "C" {
    pub fn RtlTimeToTimeFields(Time: PLARGE_INTEGER,
                               TimeFields: PTIME_FIELDS);
}
extern "C" {
    pub fn RtlTimeFieldsToTime(TimeFields: PTIME_FIELDS, Time: PLARGE_INTEGER)
     -> BOOLEAN;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _RTL_BITMAP {
    pub SizeOfBitMap: ULONG,
    pub Buffer: PULONG,
}
#[test]
fn bindgen_test_layout__RTL_BITMAP() {
    assert_eq!(::core::mem::size_of::<_RTL_BITMAP>() , 16usize);
    assert_eq!(::core::mem::align_of::<_RTL_BITMAP>() , 8usize);
}
impl Clone for _RTL_BITMAP {
    fn clone(&self) -> Self { *self }
}
pub use self::_RTL_BITMAP as RTL_BITMAP;
pub type PRTL_BITMAP = *mut RTL_BITMAP;
extern "C" {
    pub fn RtlInitializeBitMap(BitMapHeader: PRTL_BITMAP,
                               BitMapBuffer: PULONG, SizeOfBitMap: ULONG);
}
extern "C" {
    pub fn RtlClearBit(BitMapHeader: PRTL_BITMAP, BitNumber: ULONG);
}
extern "C" {
    pub fn RtlSetBit(BitMapHeader: PRTL_BITMAP, BitNumber: ULONG);
}
extern "C" {
    pub fn RtlTestBit(BitMapHeader: PRTL_BITMAP, BitNumber: ULONG) -> BOOLEAN;
}
extern "C" {
    pub fn RtlClearAllBits(BitMapHeader: PRTL_BITMAP);
}
extern "C" {
    pub fn RtlSetAllBits(BitMapHeader: PRTL_BITMAP);
}
extern "C" {
    pub fn RtlFindClearBits(BitMapHeader: PRTL_BITMAP, NumberToFind: ULONG,
                            HintIndex: ULONG) -> ULONG;
}
extern "C" {
    pub fn RtlFindSetBits(BitMapHeader: PRTL_BITMAP, NumberToFind: ULONG,
                          HintIndex: ULONG) -> ULONG;
}
extern "C" {
    pub fn RtlFindClearBitsAndSet(BitMapHeader: PRTL_BITMAP,
                                  NumberToFind: ULONG, HintIndex: ULONG)
     -> ULONG;
}
extern "C" {
    pub fn RtlFindSetBitsAndClear(BitMapHeader: PRTL_BITMAP,
                                  NumberToFind: ULONG, HintIndex: ULONG)
     -> ULONG;
}
extern "C" {
    pub fn RtlClearBits(BitMapHeader: PRTL_BITMAP, StartingIndex: ULONG,
                        NumberToClear: ULONG);
}
extern "C" {
    pub fn RtlSetBits(BitMapHeader: PRTL_BITMAP, StartingIndex: ULONG,
                      NumberToSet: ULONG);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _RTL_BITMAP_RUN {
    pub StartingIndex: ULONG,
    pub NumberOfBits: ULONG,
}
#[test]
fn bindgen_test_layout__RTL_BITMAP_RUN() {
    assert_eq!(::core::mem::size_of::<_RTL_BITMAP_RUN>() , 8usize);
    assert_eq!(::core::mem::align_of::<_RTL_BITMAP_RUN>() , 4usize);
}
impl Clone for _RTL_BITMAP_RUN {
    fn clone(&self) -> Self { *self }
}
pub use self::_RTL_BITMAP_RUN as RTL_BITMAP_RUN;
pub type PRTL_BITMAP_RUN = *mut RTL_BITMAP_RUN;
extern "C" {
    pub fn RtlFindClearRuns(BitMapHeader: PRTL_BITMAP,
                            RunArray: PRTL_BITMAP_RUN, SizeOfRunArray: ULONG,
                            LocateLongestRuns: BOOLEAN) -> ULONG;
}
extern "C" {
    pub fn RtlFindLongestRunClear(BitMapHeader: PRTL_BITMAP,
                                  StartingIndex: PULONG) -> ULONG;
}
extern "C" {
    pub fn RtlFindFirstRunClear(BitMapHeader: PRTL_BITMAP,
                                StartingIndex: PULONG) -> ULONG;
}
extern "C" {
    pub fn RtlNumberOfClearBitsInRange(BitMapHeader: PRTL_BITMAP,
                                       StartingIndex: ULONG, Length: ULONG)
     -> ULONG;
}
extern "C" {
    pub fn RtlNumberOfSetBitsInRange(BitMapHeader: PRTL_BITMAP,
                                     StartingIndex: ULONG, Length: ULONG)
     -> ULONG;
}
extern "C" {
    pub fn RtlNumberOfClearBits(BitMapHeader: PRTL_BITMAP) -> ULONG;
}
extern "C" {
    pub fn RtlNumberOfSetBits(BitMapHeader: PRTL_BITMAP) -> ULONG;
}
extern "C" {
    pub fn RtlAreBitsClear(BitMapHeader: PRTL_BITMAP, StartingIndex: ULONG,
                           Length: ULONG) -> BOOLEAN;
}
extern "C" {
    pub fn RtlAreBitsSet(BitMapHeader: PRTL_BITMAP, StartingIndex: ULONG,
                         Length: ULONG) -> BOOLEAN;
}
extern "C" {
    pub fn RtlFindNextForwardRunClear(BitMapHeader: PRTL_BITMAP,
                                      FromIndex: ULONG,
                                      StartingRunIndex: PULONG) -> ULONG;
}
extern "C" {
    pub fn RtlFindLastBackwardRunClear(BitMapHeader: PRTL_BITMAP,
                                       FromIndex: ULONG,
                                       StartingRunIndex: PULONG) -> ULONG;
}
extern "C" {
    pub fn RtlFindLeastSignificantBit(Set: ULONGLONG) -> CCHAR;
}
extern "C" {
    pub fn RtlFindMostSignificantBit(Set: ULONGLONG) -> CCHAR;
}
extern "C" {
    pub fn RtlNumberOfSetBitsUlongPtr(Target: ULONG_PTR) -> ULONG;
}
extern "C" {
    pub fn RtlCopyBitMap(Source: PRTL_BITMAP, Destination: PRTL_BITMAP,
                         TargetBit: ULONG);
}
extern "C" {
    pub fn RtlExtractBitMap(Source: PRTL_BITMAP, Destination: PRTL_BITMAP,
                            TargetBit: ULONG, NumberOfBits: ULONG);
}
extern "C" {
    pub fn RtlCreateSecurityDescriptor(SecurityDescriptor:
                                           PSECURITY_DESCRIPTOR,
                                       Revision: ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn RtlValidSecurityDescriptor(SecurityDescriptor:
                                          PSECURITY_DESCRIPTOR) -> BOOLEAN;
}
extern "C" {
    pub fn RtlLengthSecurityDescriptor(SecurityDescriptor:
                                           PSECURITY_DESCRIPTOR) -> ULONG;
}
extern "C" {
    pub fn RtlValidRelativeSecurityDescriptor(SecurityDescriptorInput:
                                                  PSECURITY_DESCRIPTOR,
                                              SecurityDescriptorLength: ULONG,
                                              RequiredInformation:
                                                  SECURITY_INFORMATION)
     -> BOOLEAN;
}
extern "C" {
    pub fn RtlSetDaclSecurityDescriptor(SecurityDescriptor:
                                            PSECURITY_DESCRIPTOR,
                                        DaclPresent: BOOLEAN, Dacl: PACL,
                                        DaclDefaulted: BOOLEAN) -> NTSTATUS;
}
extern "C" {
    pub fn _byteswap_ushort(arg1: libc::c_ushort) -> libc::c_ushort;
}
extern "C" {
    pub fn _byteswap_ulong(arg1: libc::c_ulong) -> libc::c_ulong;
}
extern "C" {
    pub fn _byteswap_uint64(arg1: libc::c_ulonglong) -> libc::c_ulonglong;
}
#[repr(C)]
pub struct _OSVERSIONINFOA {
    pub dwOSVersionInfoSize: ULONG,
    pub dwMajorVersion: ULONG,
    pub dwMinorVersion: ULONG,
    pub dwBuildNumber: ULONG,
    pub dwPlatformId: ULONG,
    pub szCSDVersion: [CHAR; 128usize],
}
#[test]
fn bindgen_test_layout__OSVERSIONINFOA() {
    assert_eq!(::core::mem::size_of::<_OSVERSIONINFOA>() , 148usize);
    assert_eq!(::core::mem::align_of::<_OSVERSIONINFOA>() , 4usize);
}
pub use self::_OSVERSIONINFOA as OSVERSIONINFOA;
pub type POSVERSIONINFOA = *mut _OSVERSIONINFOA;
pub type LPOSVERSIONINFOA = *mut _OSVERSIONINFOA;
#[repr(C)]
pub struct _OSVERSIONINFOW {
    pub dwOSVersionInfoSize: ULONG,
    pub dwMajorVersion: ULONG,
    pub dwMinorVersion: ULONG,
    pub dwBuildNumber: ULONG,
    pub dwPlatformId: ULONG,
    pub szCSDVersion: [WCHAR; 128usize],
}
#[test]
fn bindgen_test_layout__OSVERSIONINFOW() {
    assert_eq!(::core::mem::size_of::<_OSVERSIONINFOW>() , 276usize);
    assert_eq!(::core::mem::align_of::<_OSVERSIONINFOW>() , 4usize);
}
pub use self::_OSVERSIONINFOW as OSVERSIONINFOW;
pub type POSVERSIONINFOW = *mut _OSVERSIONINFOW;
pub type LPOSVERSIONINFOW = *mut _OSVERSIONINFOW;
pub use self::_OSVERSIONINFOW as RTL_OSVERSIONINFOW;
pub type PRTL_OSVERSIONINFOW = *mut _OSVERSIONINFOW;
pub use self::OSVERSIONINFOA as OSVERSIONINFO;
pub type POSVERSIONINFO = POSVERSIONINFOA;
pub type LPOSVERSIONINFO = LPOSVERSIONINFOA;
#[repr(C)]
pub struct _OSVERSIONINFOEXA {
    pub dwOSVersionInfoSize: ULONG,
    pub dwMajorVersion: ULONG,
    pub dwMinorVersion: ULONG,
    pub dwBuildNumber: ULONG,
    pub dwPlatformId: ULONG,
    pub szCSDVersion: [CHAR; 128usize],
    pub wServicePackMajor: USHORT,
    pub wServicePackMinor: USHORT,
    pub wSuiteMask: USHORT,
    pub wProductType: UCHAR,
    pub wReserved: UCHAR,
}
#[test]
fn bindgen_test_layout__OSVERSIONINFOEXA() {
    assert_eq!(::core::mem::size_of::<_OSVERSIONINFOEXA>() , 156usize);
    assert_eq!(::core::mem::align_of::<_OSVERSIONINFOEXA>() , 4usize);
}
pub use self::_OSVERSIONINFOEXA as OSVERSIONINFOEXA;
pub type POSVERSIONINFOEXA = *mut _OSVERSIONINFOEXA;
pub type LPOSVERSIONINFOEXA = *mut _OSVERSIONINFOEXA;
#[repr(C)]
pub struct _OSVERSIONINFOEXW {
    pub dwOSVersionInfoSize: ULONG,
    pub dwMajorVersion: ULONG,
    pub dwMinorVersion: ULONG,
    pub dwBuildNumber: ULONG,
    pub dwPlatformId: ULONG,
    pub szCSDVersion: [WCHAR; 128usize],
    pub wServicePackMajor: USHORT,
    pub wServicePackMinor: USHORT,
    pub wSuiteMask: USHORT,
    pub wProductType: UCHAR,
    pub wReserved: UCHAR,
}
#[test]
fn bindgen_test_layout__OSVERSIONINFOEXW() {
    assert_eq!(::core::mem::size_of::<_OSVERSIONINFOEXW>() , 284usize);
    assert_eq!(::core::mem::align_of::<_OSVERSIONINFOEXW>() , 4usize);
}
pub use self::_OSVERSIONINFOEXW as OSVERSIONINFOEXW;
pub type POSVERSIONINFOEXW = *mut _OSVERSIONINFOEXW;
pub type LPOSVERSIONINFOEXW = *mut _OSVERSIONINFOEXW;
pub use self::_OSVERSIONINFOEXW as RTL_OSVERSIONINFOEXW;
pub type PRTL_OSVERSIONINFOEXW = *mut _OSVERSIONINFOEXW;
pub use self::OSVERSIONINFOEXA as OSVERSIONINFOEX;
pub type POSVERSIONINFOEX = POSVERSIONINFOEXA;
pub type LPOSVERSIONINFOEX = LPOSVERSIONINFOEXA;
extern "C" {
    pub fn VerSetConditionMask(ConditionMask: ULONGLONG, TypeMask: ULONG,
                               Condition: UCHAR) -> ULONGLONG;
}
extern "C" {
    pub fn RtlGetVersion(lpVersionInformation: PRTL_OSVERSIONINFOW)
     -> NTSTATUS;
}
extern "C" {
    pub fn RtlVerifyVersionInfo(VersionInfo: PRTL_OSVERSIONINFOEXW,
                                TypeMask: ULONG, ConditionMask: ULONGLONG)
     -> NTSTATUS;
}
pub type PFN_RTL_IS_NTDDI_VERSION_AVAILABLE =
    ::core::option::Option<unsafe extern "C" fn(Version: ULONG)
                               -> libc::c_uchar>;
pub type PFN_RTL_IS_SERVICE_PACK_VERSION_INSTALLED =
    ::core::option::Option<unsafe extern "C" fn(Version: ULONG)
                               -> libc::c_uchar>;
extern "C" {
    pub fn RtlIsNtDdiVersionAvailable(Version: ULONG) -> BOOLEAN;
}
extern "C" {
    pub fn RtlIsServicePackVersionInstalled(Version: ULONG) -> BOOLEAN;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _DPFLTR_TYPE {
    DPFLTR_SYSTEM_ID = 0,
    DPFLTR_SMSS_ID = 1,
    DPFLTR_SETUP_ID = 2,
    DPFLTR_NTFS_ID = 3,
    DPFLTR_FSTUB_ID = 4,
    DPFLTR_CRASHDUMP_ID = 5,
    DPFLTR_CDAUDIO_ID = 6,
    DPFLTR_CDROM_ID = 7,
    DPFLTR_CLASSPNP_ID = 8,
    DPFLTR_DISK_ID = 9,
    DPFLTR_REDBOOK_ID = 10,
    DPFLTR_STORPROP_ID = 11,
    DPFLTR_SCSIPORT_ID = 12,
    DPFLTR_SCSIMINIPORT_ID = 13,
    DPFLTR_CONFIG_ID = 14,
    DPFLTR_I8042PRT_ID = 15,
    DPFLTR_SERMOUSE_ID = 16,
    DPFLTR_LSERMOUS_ID = 17,
    DPFLTR_KBDHID_ID = 18,
    DPFLTR_MOUHID_ID = 19,
    DPFLTR_KBDCLASS_ID = 20,
    DPFLTR_MOUCLASS_ID = 21,
    DPFLTR_TWOTRACK_ID = 22,
    DPFLTR_WMILIB_ID = 23,
    DPFLTR_ACPI_ID = 24,
    DPFLTR_AMLI_ID = 25,
    DPFLTR_HALIA64_ID = 26,
    DPFLTR_VIDEO_ID = 27,
    DPFLTR_SVCHOST_ID = 28,
    DPFLTR_VIDEOPRT_ID = 29,
    DPFLTR_TCPIP_ID = 30,
    DPFLTR_DMSYNTH_ID = 31,
    DPFLTR_NTOSPNP_ID = 32,
    DPFLTR_FASTFAT_ID = 33,
    DPFLTR_SAMSS_ID = 34,
    DPFLTR_PNPMGR_ID = 35,
    DPFLTR_NETAPI_ID = 36,
    DPFLTR_SCSERVER_ID = 37,
    DPFLTR_SCCLIENT_ID = 38,
    DPFLTR_SERIAL_ID = 39,
    DPFLTR_SERENUM_ID = 40,
    DPFLTR_UHCD_ID = 41,
    DPFLTR_RPCPROXY_ID = 42,
    DPFLTR_AUTOCHK_ID = 43,
    DPFLTR_DCOMSS_ID = 44,
    DPFLTR_UNIMODEM_ID = 45,
    DPFLTR_SIS_ID = 46,
    DPFLTR_FLTMGR_ID = 47,
    DPFLTR_WMICORE_ID = 48,
    DPFLTR_BURNENG_ID = 49,
    DPFLTR_IMAPI_ID = 50,
    DPFLTR_SXS_ID = 51,
    DPFLTR_FUSION_ID = 52,
    DPFLTR_IDLETASK_ID = 53,
    DPFLTR_SOFTPCI_ID = 54,
    DPFLTR_TAPE_ID = 55,
    DPFLTR_MCHGR_ID = 56,
    DPFLTR_IDEP_ID = 57,
    DPFLTR_PCIIDE_ID = 58,
    DPFLTR_FLOPPY_ID = 59,
    DPFLTR_FDC_ID = 60,
    DPFLTR_TERMSRV_ID = 61,
    DPFLTR_W32TIME_ID = 62,
    DPFLTR_PREFETCHER_ID = 63,
    DPFLTR_RSFILTER_ID = 64,
    DPFLTR_FCPORT_ID = 65,
    DPFLTR_PCI_ID = 66,
    DPFLTR_DMIO_ID = 67,
    DPFLTR_DMCONFIG_ID = 68,
    DPFLTR_DMADMIN_ID = 69,
    DPFLTR_WSOCKTRANSPORT_ID = 70,
    DPFLTR_VSS_ID = 71,
    DPFLTR_PNPMEM_ID = 72,
    DPFLTR_PROCESSOR_ID = 73,
    DPFLTR_DMSERVER_ID = 74,
    DPFLTR_SR_ID = 75,
    DPFLTR_INFINIBAND_ID = 76,
    DPFLTR_IHVDRIVER_ID = 77,
    DPFLTR_IHVVIDEO_ID = 78,
    DPFLTR_IHVAUDIO_ID = 79,
    DPFLTR_IHVNETWORK_ID = 80,
    DPFLTR_IHVSTREAMING_ID = 81,
    DPFLTR_IHVBUS_ID = 82,
    DPFLTR_HPS_ID = 83,
    DPFLTR_RTLTHREADPOOL_ID = 84,
    DPFLTR_LDR_ID = 85,
    DPFLTR_TCPIP6_ID = 86,
    DPFLTR_ISAPNP_ID = 87,
    DPFLTR_SHPC_ID = 88,
    DPFLTR_STORPORT_ID = 89,
    DPFLTR_STORMINIPORT_ID = 90,
    DPFLTR_PRINTSPOOLER_ID = 91,
    DPFLTR_VSSDYNDISK_ID = 92,
    DPFLTR_VERIFIER_ID = 93,
    DPFLTR_VDS_ID = 94,
    DPFLTR_VDSBAS_ID = 95,
    DPFLTR_VDSDYN_ID = 96,
    DPFLTR_VDSDYNDR_ID = 97,
    DPFLTR_VDSLDR_ID = 98,
    DPFLTR_VDSUTIL_ID = 99,
    DPFLTR_DFRGIFC_ID = 100,
    DPFLTR_DEFAULT_ID = 101,
    DPFLTR_MM_ID = 102,
    DPFLTR_DFSC_ID = 103,
    DPFLTR_WOW64_ID = 104,
    DPFLTR_ALPC_ID = 105,
    DPFLTR_WDI_ID = 106,
    DPFLTR_PERFLIB_ID = 107,
    DPFLTR_KTM_ID = 108,
    DPFLTR_IOSTRESS_ID = 109,
    DPFLTR_HEAP_ID = 110,
    DPFLTR_WHEA_ID = 111,
    DPFLTR_USERGDI_ID = 112,
    DPFLTR_MMCSS_ID = 113,
    DPFLTR_TPM_ID = 114,
    DPFLTR_THREADORDER_ID = 115,
    DPFLTR_ENVIRON_ID = 116,
    DPFLTR_EMS_ID = 117,
    DPFLTR_WDT_ID = 118,
    DPFLTR_FVEVOL_ID = 119,
    DPFLTR_NDIS_ID = 120,
    DPFLTR_NVCTRACE_ID = 121,
    DPFLTR_LUAFV_ID = 122,
    DPFLTR_APPCOMPAT_ID = 123,
    DPFLTR_USBSTOR_ID = 124,
    DPFLTR_SBP2PORT_ID = 125,
    DPFLTR_COVERAGE_ID = 126,
    DPFLTR_CACHEMGR_ID = 127,
    DPFLTR_MOUNTMGR_ID = 128,
    DPFLTR_CFR_ID = 129,
    DPFLTR_TXF_ID = 130,
    DPFLTR_KSECDD_ID = 131,
    DPFLTR_FLTREGRESS_ID = 132,
    DPFLTR_MPIO_ID = 133,
    DPFLTR_MSDSM_ID = 134,
    DPFLTR_UDFS_ID = 135,
    DPFLTR_PSHED_ID = 136,
    DPFLTR_STORVSP_ID = 137,
    DPFLTR_LSASS_ID = 138,
    DPFLTR_SSPICLI_ID = 139,
    DPFLTR_CNG_ID = 140,
    DPFLTR_EXFAT_ID = 141,
    DPFLTR_FILETRACE_ID = 142,
    DPFLTR_XSAVE_ID = 143,
    DPFLTR_SE_ID = 144,
    DPFLTR_DRIVEEXTENDER_ID = 145,
    DPFLTR_POWER_ID = 146,
    DPFLTR_CRASHDUMPXHCI_ID = 147,
    DPFLTR_GPIO_ID = 148,
    DPFLTR_REFS_ID = 149,
    DPFLTR_WER_ID = 150,
    DPFLTR_CAPIMG_ID = 151,
    DPFLTR_VPCI_ID = 152,
    DPFLTR_STORAGECLASSMEMORY_ID = 153,
    DPFLTR_FSLIB_ID = 154,
    DPFLTR_ENDOFTABLE_ID = 155,
}
pub use self::_DPFLTR_TYPE as DPFLTR_TYPE;
extern "C" {
    pub fn RtlIoEncodeMemIoResource(Descriptor: PIO_RESOURCE_DESCRIPTOR,
                                    Type: UCHAR, Length: ULONGLONG,
                                    Alignment: ULONGLONG,
                                    MinimumAddress: ULONGLONG,
                                    MaximumAddress: ULONGLONG) -> NTSTATUS;
}
extern "C" {
    pub fn RtlCmEncodeMemIoResource(Descriptor:
                                        PCM_PARTIAL_RESOURCE_DESCRIPTOR,
                                    Type: UCHAR, Length: ULONGLONG,
                                    Start: ULONGLONG) -> NTSTATUS;
}
extern "C" {
    pub fn RtlIoDecodeMemIoResource(Descriptor: PIO_RESOURCE_DESCRIPTOR,
                                    Alignment: PULONGLONG,
                                    MinimumAddress: PULONGLONG,
                                    MaximumAddress: PULONGLONG) -> ULONGLONG;
}
extern "C" {
    pub fn RtlCmDecodeMemIoResource(Descriptor:
                                        PCM_PARTIAL_RESOURCE_DESCRIPTOR,
                                    Start: PULONGLONG) -> ULONGLONG;
}
extern "C" {
    pub fn RtlFindClosestEncodableLength(SourceLength: ULONGLONG,
                                         TargetLength: PULONGLONG)
     -> NTSTATUS;
}
extern "C" {
    pub fn RtlIsUntrustedObject(Handle: HANDLE, Object: PVOID,
                                UntrustedObject: PBOOLEAN) -> NTSTATUS;
}
extern "C" {
    pub fn RtlQueryValidationRunlevel(ComponentName: PCUNICODE_STRING)
     -> ULONG;
}
extern "C" {
    pub fn RtlCrc32(Buffer: *const libc::c_void, Size: usize,
                    InitialCrc: ULONG) -> ULONG;
}
extern "C" {
    pub fn RtlCrc64(Buffer: *const libc::c_void, Size: usize,
                    InitialCrc: ULONGLONG) -> ULONGLONG;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _OS_DEPLOYEMENT_STATE_VALUES {
    OS_DEPLOYMENT_STANDARD = 1,
    OS_DEPLOYMENT_COMPACT = 2,
}
pub use self::_OS_DEPLOYEMENT_STATE_VALUES as OS_DEPLOYEMENT_STATE_VALUES;
extern "C" {
    pub fn RtlOsDeploymentState(Flags: ULONG) -> OS_DEPLOYEMENT_STATE_VALUES;
}
extern "C" {
    pub fn RtlCompareMemory(Source1: *const libc::c_void,
                            Source2: *const libc::c_void, Length: SIZE_T)
     -> SIZE_T;
}
pub use self::GUID as UOW;
pub type PUOW = *mut GUID;
pub use self::GUID as CRM_PROTOCOL_ID;
pub type PCRM_PROTOCOL_ID = *mut GUID;
pub type NOTIFICATION_MASK = ULONG;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _TRANSACTION_NOTIFICATION {
    pub TransactionKey: PVOID,
    pub TransactionNotification: ULONG,
    pub TmVirtualClock: LARGE_INTEGER,
    pub ArgumentLength: ULONG,
}
#[test]
fn bindgen_test_layout__TRANSACTION_NOTIFICATION() {
    assert_eq!(::core::mem::size_of::<_TRANSACTION_NOTIFICATION>() , 32usize);
    assert_eq!(::core::mem::align_of::<_TRANSACTION_NOTIFICATION>() , 8usize);
}
impl Clone for _TRANSACTION_NOTIFICATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_TRANSACTION_NOTIFICATION as TRANSACTION_NOTIFICATION;
pub type PTRANSACTION_NOTIFICATION = *mut _TRANSACTION_NOTIFICATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT {
    pub EnlistmentId: GUID,
    pub UOW: UOW,
}
#[test]
fn bindgen_test_layout__TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT() {
    assert_eq!(::core::mem::size_of::<_TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT>()
               , 32usize);
    assert_eq!(::core::mem::align_of::<_TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT>()
               , 4usize);
}
impl Clone for _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT {
    fn clone(&self) -> Self { *self }
}
pub use self::_TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT as
        TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT =
    *mut _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT {
    pub TmIdentity: GUID,
    pub Flags: ULONG,
}
#[test]
fn bindgen_test_layout__TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT() {
    assert_eq!(::core::mem::size_of::<_TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT>()
               , 20usize);
    assert_eq!(::core::mem::align_of::<_TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT>()
               , 4usize);
}
impl Clone for _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT {
    fn clone(&self) -> Self { *self }
}
pub use self::_TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT as
        TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT =
    *mut _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT;
pub type SAVEPOINT_ID = ULONG;
pub type PSAVEPOINT_ID = *mut ULONG;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT {
    pub SavepointId: SAVEPOINT_ID,
}
#[test]
fn bindgen_test_layout__TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT() {
    assert_eq!(::core::mem::size_of::<_TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT>()
               , 4usize);
}
impl Clone for _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT {
    fn clone(&self) -> Self { *self }
}
pub use self::_TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT as
        TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT =
    *mut _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT {
    pub PropagationCookie: ULONG,
    pub UOW: GUID,
    pub TmIdentity: GUID,
    pub BufferLength: ULONG,
}
#[test]
fn bindgen_test_layout__TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT() {
    assert_eq!(::core::mem::size_of::<_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT>()
               , 40usize);
    assert_eq!(::core::mem::align_of::<_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT>()
               , 4usize);
}
impl Clone for _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT {
    fn clone(&self) -> Self { *self }
}
pub use self::_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT as
        TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT =
    *mut _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT {
    pub MarshalCookie: ULONG,
    pub UOW: GUID,
}
#[test]
fn bindgen_test_layout__TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT() {
    assert_eq!(::core::mem::size_of::<_TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT>()
               , 20usize);
    assert_eq!(::core::mem::align_of::<_TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT>()
               , 4usize);
}
impl Clone for _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT {
    fn clone(&self) -> Self { *self }
}
pub use self::_TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT as
        TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT =
    *mut _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT;
pub use self::TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT as
        TRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT =
    *mut TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KCRM_MARSHAL_HEADER {
    pub VersionMajor: ULONG,
    pub VersionMinor: ULONG,
    pub NumProtocols: ULONG,
    pub Unused: ULONG,
}
#[test]
fn bindgen_test_layout__KCRM_MARSHAL_HEADER() {
    assert_eq!(::core::mem::size_of::<_KCRM_MARSHAL_HEADER>() , 16usize);
    assert_eq!(::core::mem::align_of::<_KCRM_MARSHAL_HEADER>() , 4usize);
}
impl Clone for _KCRM_MARSHAL_HEADER {
    fn clone(&self) -> Self { *self }
}
pub use self::_KCRM_MARSHAL_HEADER as KCRM_MARSHAL_HEADER;
pub type PKCRM_MARSHAL_HEADER = *mut _KCRM_MARSHAL_HEADER;
pub type PRKCRM_MARSHAL_HEADER = *mut _KCRM_MARSHAL_HEADER;
#[repr(C)]
pub struct _KCRM_TRANSACTION_BLOB {
    pub UOW: UOW,
    pub TmIdentity: GUID,
    pub IsolationLevel: ULONG,
    pub IsolationFlags: ULONG,
    pub Timeout: ULONG,
    pub Description: [WCHAR; 64usize],
}
#[test]
fn bindgen_test_layout__KCRM_TRANSACTION_BLOB() {
    assert_eq!(::core::mem::size_of::<_KCRM_TRANSACTION_BLOB>() , 172usize);
    assert_eq!(::core::mem::align_of::<_KCRM_TRANSACTION_BLOB>() , 4usize);
}
pub use self::_KCRM_TRANSACTION_BLOB as KCRM_TRANSACTION_BLOB;
pub type PKCRM_TRANSACTION_BLOB = *mut _KCRM_TRANSACTION_BLOB;
pub type PRKCRM_TRANSACTION_BLOB = *mut _KCRM_TRANSACTION_BLOB;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KCRM_PROTOCOL_BLOB {
    pub ProtocolId: CRM_PROTOCOL_ID,
    pub StaticInfoLength: ULONG,
    pub TransactionIdInfoLength: ULONG,
    pub Unused1: ULONG,
    pub Unused2: ULONG,
}
#[test]
fn bindgen_test_layout__KCRM_PROTOCOL_BLOB() {
    assert_eq!(::core::mem::size_of::<_KCRM_PROTOCOL_BLOB>() , 32usize);
    assert_eq!(::core::mem::align_of::<_KCRM_PROTOCOL_BLOB>() , 4usize);
}
impl Clone for _KCRM_PROTOCOL_BLOB {
    fn clone(&self) -> Self { *self }
}
pub use self::_KCRM_PROTOCOL_BLOB as KCRM_PROTOCOL_BLOB;
pub type PKCRM_PROTOCOL_BLOB = *mut _KCRM_PROTOCOL_BLOB;
pub type PRKCRM_PROTOCOL_BLOB = *mut _KCRM_PROTOCOL_BLOB;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _TRANSACTION_OUTCOME {
    TransactionOutcomeUndetermined = 1,
    TransactionOutcomeCommitted = 2,
    TransactionOutcomeAborted = 3,
}
pub use self::_TRANSACTION_OUTCOME as TRANSACTION_OUTCOME;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _TRANSACTION_STATE {
    TransactionStateNormal = 1,
    TransactionStateIndoubt = 2,
    TransactionStateCommittedNotify = 3,
}
pub use self::_TRANSACTION_STATE as TRANSACTION_STATE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _TRANSACTION_BASIC_INFORMATION {
    pub TransactionId: GUID,
    pub State: ULONG,
    pub Outcome: ULONG,
}
#[test]
fn bindgen_test_layout__TRANSACTION_BASIC_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_TRANSACTION_BASIC_INFORMATION>() ,
               24usize);
    assert_eq!(::core::mem::align_of::<_TRANSACTION_BASIC_INFORMATION>() ,
               4usize);
}
impl Clone for _TRANSACTION_BASIC_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_TRANSACTION_BASIC_INFORMATION as TRANSACTION_BASIC_INFORMATION;
pub type PTRANSACTION_BASIC_INFORMATION = *mut _TRANSACTION_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _TRANSACTIONMANAGER_BASIC_INFORMATION {
    pub TmIdentity: GUID,
    pub VirtualClock: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__TRANSACTIONMANAGER_BASIC_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_TRANSACTIONMANAGER_BASIC_INFORMATION>()
               , 24usize);
    assert_eq!(::core::mem::align_of::<_TRANSACTIONMANAGER_BASIC_INFORMATION>()
               , 8usize);
}
impl Clone for _TRANSACTIONMANAGER_BASIC_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_TRANSACTIONMANAGER_BASIC_INFORMATION as
        TRANSACTIONMANAGER_BASIC_INFORMATION;
pub type PTRANSACTIONMANAGER_BASIC_INFORMATION =
    *mut _TRANSACTIONMANAGER_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _TRANSACTIONMANAGER_LOG_INFORMATION {
    pub LogIdentity: GUID,
}
#[test]
fn bindgen_test_layout__TRANSACTIONMANAGER_LOG_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_TRANSACTIONMANAGER_LOG_INFORMATION>() ,
               16usize);
    assert_eq!(::core::mem::align_of::<_TRANSACTIONMANAGER_LOG_INFORMATION>()
               , 4usize);
}
impl Clone for _TRANSACTIONMANAGER_LOG_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_TRANSACTIONMANAGER_LOG_INFORMATION as
        TRANSACTIONMANAGER_LOG_INFORMATION;
pub type PTRANSACTIONMANAGER_LOG_INFORMATION =
    *mut _TRANSACTIONMANAGER_LOG_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _TRANSACTIONMANAGER_LOGPATH_INFORMATION {
    pub LogPathLength: ULONG,
    pub LogPath: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__TRANSACTIONMANAGER_LOGPATH_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_TRANSACTIONMANAGER_LOGPATH_INFORMATION>()
               , 8usize);
    assert_eq!(::core::mem::align_of::<_TRANSACTIONMANAGER_LOGPATH_INFORMATION>()
               , 4usize);
}
impl Clone for _TRANSACTIONMANAGER_LOGPATH_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_TRANSACTIONMANAGER_LOGPATH_INFORMATION as
        TRANSACTIONMANAGER_LOGPATH_INFORMATION;
pub type PTRANSACTIONMANAGER_LOGPATH_INFORMATION =
    *mut _TRANSACTIONMANAGER_LOGPATH_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _TRANSACTIONMANAGER_RECOVERY_INFORMATION {
    pub LastRecoveredLsn: ULONGLONG,
}
#[test]
fn bindgen_test_layout__TRANSACTIONMANAGER_RECOVERY_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_TRANSACTIONMANAGER_RECOVERY_INFORMATION>()
               , 8usize);
    assert_eq!(::core::mem::align_of::<_TRANSACTIONMANAGER_RECOVERY_INFORMATION>()
               , 8usize);
}
impl Clone for _TRANSACTIONMANAGER_RECOVERY_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_TRANSACTIONMANAGER_RECOVERY_INFORMATION as
        TRANSACTIONMANAGER_RECOVERY_INFORMATION;
pub type PTRANSACTIONMANAGER_RECOVERY_INFORMATION =
    *mut _TRANSACTIONMANAGER_RECOVERY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _TRANSACTION_PROPERTIES_INFORMATION {
    pub IsolationLevel: ULONG,
    pub IsolationFlags: ULONG,
    pub Timeout: LARGE_INTEGER,
    pub Outcome: ULONG,
    pub DescriptionLength: ULONG,
    pub Description: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__TRANSACTION_PROPERTIES_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_TRANSACTION_PROPERTIES_INFORMATION>() ,
               32usize);
    assert_eq!(::core::mem::align_of::<_TRANSACTION_PROPERTIES_INFORMATION>()
               , 8usize);
}
impl Clone for _TRANSACTION_PROPERTIES_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_TRANSACTION_PROPERTIES_INFORMATION as
        TRANSACTION_PROPERTIES_INFORMATION;
pub type PTRANSACTION_PROPERTIES_INFORMATION =
    *mut _TRANSACTION_PROPERTIES_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _TRANSACTION_BIND_INFORMATION {
    pub TmHandle: HANDLE,
}
#[test]
fn bindgen_test_layout__TRANSACTION_BIND_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_TRANSACTION_BIND_INFORMATION>() ,
               8usize);
    assert_eq!(::core::mem::align_of::<_TRANSACTION_BIND_INFORMATION>() ,
               8usize);
}
impl Clone for _TRANSACTION_BIND_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_TRANSACTION_BIND_INFORMATION as TRANSACTION_BIND_INFORMATION;
pub type PTRANSACTION_BIND_INFORMATION = *mut _TRANSACTION_BIND_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _TRANSACTION_ENLISTMENT_PAIR {
    pub EnlistmentId: GUID,
    pub ResourceManagerId: GUID,
}
#[test]
fn bindgen_test_layout__TRANSACTION_ENLISTMENT_PAIR() {
    assert_eq!(::core::mem::size_of::<_TRANSACTION_ENLISTMENT_PAIR>() ,
               32usize);
    assert_eq!(::core::mem::align_of::<_TRANSACTION_ENLISTMENT_PAIR>() ,
               4usize);
}
impl Clone for _TRANSACTION_ENLISTMENT_PAIR {
    fn clone(&self) -> Self { *self }
}
pub use self::_TRANSACTION_ENLISTMENT_PAIR as TRANSACTION_ENLISTMENT_PAIR;
pub type PTRANSACTION_ENLISTMENT_PAIR = *mut _TRANSACTION_ENLISTMENT_PAIR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _TRANSACTION_ENLISTMENTS_INFORMATION {
    pub NumberOfEnlistments: ULONG,
    pub EnlistmentPair: [TRANSACTION_ENLISTMENT_PAIR; 1usize],
}
#[test]
fn bindgen_test_layout__TRANSACTION_ENLISTMENTS_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_TRANSACTION_ENLISTMENTS_INFORMATION>()
               , 36usize);
    assert_eq!(::core::mem::align_of::<_TRANSACTION_ENLISTMENTS_INFORMATION>()
               , 4usize);
}
impl Clone for _TRANSACTION_ENLISTMENTS_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_TRANSACTION_ENLISTMENTS_INFORMATION as
        TRANSACTION_ENLISTMENTS_INFORMATION;
pub type PTRANSACTION_ENLISTMENTS_INFORMATION =
    *mut _TRANSACTION_ENLISTMENTS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION {
    pub SuperiorEnlistmentPair: TRANSACTION_ENLISTMENT_PAIR,
}
#[test]
fn bindgen_test_layout__TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION>()
               , 32usize);
    assert_eq!(::core::mem::align_of::<_TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION>()
               , 4usize);
}
impl Clone for _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION as
        TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION;
pub type PTRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION =
    *mut _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _RESOURCEMANAGER_BASIC_INFORMATION {
    pub ResourceManagerId: GUID,
    pub DescriptionLength: ULONG,
    pub Description: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__RESOURCEMANAGER_BASIC_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_RESOURCEMANAGER_BASIC_INFORMATION>() ,
               24usize);
    assert_eq!(::core::mem::align_of::<_RESOURCEMANAGER_BASIC_INFORMATION>() ,
               4usize);
}
impl Clone for _RESOURCEMANAGER_BASIC_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_RESOURCEMANAGER_BASIC_INFORMATION as
        RESOURCEMANAGER_BASIC_INFORMATION;
pub type PRESOURCEMANAGER_BASIC_INFORMATION =
    *mut _RESOURCEMANAGER_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _RESOURCEMANAGER_COMPLETION_INFORMATION {
    pub IoCompletionPortHandle: HANDLE,
    pub CompletionKey: ULONG_PTR,
}
#[test]
fn bindgen_test_layout__RESOURCEMANAGER_COMPLETION_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_RESOURCEMANAGER_COMPLETION_INFORMATION>()
               , 16usize);
    assert_eq!(::core::mem::align_of::<_RESOURCEMANAGER_COMPLETION_INFORMATION>()
               , 8usize);
}
impl Clone for _RESOURCEMANAGER_COMPLETION_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_RESOURCEMANAGER_COMPLETION_INFORMATION as
        RESOURCEMANAGER_COMPLETION_INFORMATION;
pub type PRESOURCEMANAGER_COMPLETION_INFORMATION =
    *mut _RESOURCEMANAGER_COMPLETION_INFORMATION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _TRANSACTION_INFORMATION_CLASS {
    TransactionBasicInformation = 0,
    TransactionPropertiesInformation = 1,
    TransactionEnlistmentInformation = 2,
    TransactionSuperiorEnlistmentInformation = 3,
}
pub use self::_TRANSACTION_INFORMATION_CLASS as TRANSACTION_INFORMATION_CLASS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _TRANSACTIONMANAGER_INFORMATION_CLASS {
    TransactionManagerBasicInformation = 0,
    TransactionManagerLogInformation = 1,
    TransactionManagerLogPathInformation = 2,
    TransactionManagerRecoveryInformation = 4,
}
pub use self::_TRANSACTIONMANAGER_INFORMATION_CLASS as
        TRANSACTIONMANAGER_INFORMATION_CLASS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _RESOURCEMANAGER_INFORMATION_CLASS {
    ResourceManagerBasicInformation = 0,
    ResourceManagerCompletionInformation = 1,
}
pub use self::_RESOURCEMANAGER_INFORMATION_CLASS as
        RESOURCEMANAGER_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _ENLISTMENT_BASIC_INFORMATION {
    pub EnlistmentId: GUID,
    pub TransactionId: GUID,
    pub ResourceManagerId: GUID,
}
#[test]
fn bindgen_test_layout__ENLISTMENT_BASIC_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_ENLISTMENT_BASIC_INFORMATION>() ,
               48usize);
    assert_eq!(::core::mem::align_of::<_ENLISTMENT_BASIC_INFORMATION>() ,
               4usize);
}
impl Clone for _ENLISTMENT_BASIC_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_ENLISTMENT_BASIC_INFORMATION as ENLISTMENT_BASIC_INFORMATION;
pub type PENLISTMENT_BASIC_INFORMATION = *mut _ENLISTMENT_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _ENLISTMENT_CRM_INFORMATION {
    pub CrmTransactionManagerId: GUID,
    pub CrmResourceManagerId: GUID,
    pub CrmEnlistmentId: GUID,
}
#[test]
fn bindgen_test_layout__ENLISTMENT_CRM_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_ENLISTMENT_CRM_INFORMATION>() ,
               48usize);
    assert_eq!(::core::mem::align_of::<_ENLISTMENT_CRM_INFORMATION>() ,
               4usize);
}
impl Clone for _ENLISTMENT_CRM_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_ENLISTMENT_CRM_INFORMATION as ENLISTMENT_CRM_INFORMATION;
pub type PENLISTMENT_CRM_INFORMATION = *mut _ENLISTMENT_CRM_INFORMATION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ENLISTMENT_INFORMATION_CLASS {
    EnlistmentBasicInformation = 0,
    EnlistmentRecoveryInformation = 1,
    EnlistmentCrmInformation = 2,
}
pub use self::_ENLISTMENT_INFORMATION_CLASS as ENLISTMENT_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _TRANSACTION_LIST_ENTRY {
    pub UOW: UOW,
}
#[test]
fn bindgen_test_layout__TRANSACTION_LIST_ENTRY() {
    assert_eq!(::core::mem::size_of::<_TRANSACTION_LIST_ENTRY>() , 16usize);
    assert_eq!(::core::mem::align_of::<_TRANSACTION_LIST_ENTRY>() , 4usize);
}
impl Clone for _TRANSACTION_LIST_ENTRY {
    fn clone(&self) -> Self { *self }
}
pub use self::_TRANSACTION_LIST_ENTRY as TRANSACTION_LIST_ENTRY;
pub type PTRANSACTION_LIST_ENTRY = *mut _TRANSACTION_LIST_ENTRY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _TRANSACTION_LIST_INFORMATION {
    pub NumberOfTransactions: ULONG,
    pub TransactionInformation: [TRANSACTION_LIST_ENTRY; 1usize],
}
#[test]
fn bindgen_test_layout__TRANSACTION_LIST_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_TRANSACTION_LIST_INFORMATION>() ,
               20usize);
    assert_eq!(::core::mem::align_of::<_TRANSACTION_LIST_INFORMATION>() ,
               4usize);
}
impl Clone for _TRANSACTION_LIST_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_TRANSACTION_LIST_INFORMATION as TRANSACTION_LIST_INFORMATION;
pub type PTRANSACTION_LIST_INFORMATION = *mut _TRANSACTION_LIST_INFORMATION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _KTMOBJECT_TYPE {
    KTMOBJECT_TRANSACTION = 0,
    KTMOBJECT_TRANSACTION_MANAGER = 1,
    KTMOBJECT_RESOURCE_MANAGER = 2,
    KTMOBJECT_ENLISTMENT = 3,
    KTMOBJECT_INVALID = 4,
}
pub use self::_KTMOBJECT_TYPE as KTMOBJECT_TYPE;
pub type PKTMOBJECT_TYPE = *mut _KTMOBJECT_TYPE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KTMOBJECT_CURSOR {
    pub LastQuery: GUID,
    pub ObjectIdCount: ULONG,
    pub ObjectIds: [GUID; 1usize],
}
#[test]
fn bindgen_test_layout__KTMOBJECT_CURSOR() {
    assert_eq!(::core::mem::size_of::<_KTMOBJECT_CURSOR>() , 36usize);
    assert_eq!(::core::mem::align_of::<_KTMOBJECT_CURSOR>() , 4usize);
}
impl Clone for _KTMOBJECT_CURSOR {
    fn clone(&self) -> Self { *self }
}
pub use self::_KTMOBJECT_CURSOR as KTMOBJECT_CURSOR;
pub type PKTMOBJECT_CURSOR = *mut _KTMOBJECT_CURSOR;
extern "C" {
    pub fn NtCreateTransactionManager(TmHandle: PHANDLE,
                                      DesiredAccess: ACCESS_MASK,
                                      ObjectAttributes: POBJECT_ATTRIBUTES,
                                      LogFileName: PUNICODE_STRING,
                                      CreateOptions: ULONG,
                                      CommitStrength: ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn NtOpenTransactionManager(TmHandle: PHANDLE,
                                    DesiredAccess: ACCESS_MASK,
                                    ObjectAttributes: POBJECT_ATTRIBUTES,
                                    LogFileName: PUNICODE_STRING,
                                    TmIdentity: LPGUID, OpenOptions: ULONG)
     -> NTSTATUS;
}
extern "C" {
    pub fn NtRenameTransactionManager(LogFileName: PUNICODE_STRING,
                                      ExistingTransactionManagerGuid: LPGUID)
     -> NTSTATUS;
}
extern "C" {
    pub fn NtRollforwardTransactionManager(TransactionManagerHandle: HANDLE,
                                           TmVirtualClock: PLARGE_INTEGER)
     -> NTSTATUS;
}
extern "C" {
    pub fn NtRecoverTransactionManager(TransactionManagerHandle: HANDLE)
     -> NTSTATUS;
}
extern "C" {
    pub fn NtQueryInformationTransactionManager(TransactionManagerHandle:
                                                    HANDLE,
                                                TransactionManagerInformationClass:
                                                    TRANSACTIONMANAGER_INFORMATION_CLASS,
                                                TransactionManagerInformation:
                                                    PVOID,
                                                TransactionManagerInformationLength:
                                                    ULONG,
                                                ReturnLength: PULONG)
     -> NTSTATUS;
}
extern "C" {
    pub fn NtSetInformationTransactionManager(TmHandle: HANDLE,
                                              TransactionManagerInformationClass:
                                                  TRANSACTIONMANAGER_INFORMATION_CLASS,
                                              TransactionManagerInformation:
                                                  PVOID,
                                              TransactionManagerInformationLength:
                                                  ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn NtEnumerateTransactionObject(RootObjectHandle: HANDLE,
                                        QueryType: KTMOBJECT_TYPE,
                                        ObjectCursor: PKTMOBJECT_CURSOR,
                                        ObjectCursorLength: ULONG,
                                        ReturnLength: PULONG) -> NTSTATUS;
}
pub type PFN_NT_CREATE_TRANSACTION =
    ::core::option::Option<unsafe extern "C" fn(TransactionHandle: PHANDLE,
                                                DesiredAccess: ACCESS_MASK,
                                                ObjectAttributes:
                                                    POBJECT_ATTRIBUTES,
                                                Uow: LPGUID, TmHandle: HANDLE,
                                                CreateOptions: ULONG,
                                                IsolationLevel: ULONG,
                                                IsolationFlags: ULONG,
                                                Timeout: PLARGE_INTEGER,
                                                Description: PUNICODE_STRING)
                               -> libc::c_long>;
extern "C" {
    pub fn NtCreateTransaction(TransactionHandle: PHANDLE,
                               DesiredAccess: ACCESS_MASK,
                               ObjectAttributes: POBJECT_ATTRIBUTES,
                               Uow: LPGUID, TmHandle: HANDLE,
                               CreateOptions: ULONG, IsolationLevel: ULONG,
                               IsolationFlags: ULONG, Timeout: PLARGE_INTEGER,
                               Description: PUNICODE_STRING) -> NTSTATUS;
}
pub type PFN_NT_OPEN_TRANSACTION =
    ::core::option::Option<unsafe extern "C" fn(TransactionHandle: PHANDLE,
                                                DesiredAccess: ACCESS_MASK,
                                                ObjectAttributes:
                                                    POBJECT_ATTRIBUTES,
                                                Uow: LPGUID, TmHandle: HANDLE)
                               -> libc::c_long>;
extern "C" {
    pub fn NtOpenTransaction(TransactionHandle: PHANDLE,
                             DesiredAccess: ACCESS_MASK,
                             ObjectAttributes: POBJECT_ATTRIBUTES,
                             Uow: LPGUID, TmHandle: HANDLE) -> NTSTATUS;
}
pub type PFN_NT_QUERY_INFORMATION_TRANSACTION =
    ::core::option::Option<unsafe extern "C" fn(TransactionHandle: HANDLE,
                                                TransactionInformationClass:
                                                    TRANSACTION_INFORMATION_CLASS,
                                                TransactionInformation: PVOID,
                                                TransactionInformationLength:
                                                    ULONG,
                                                ReturnLength: PULONG)
                               -> libc::c_long>;
extern "C" {
    pub fn NtQueryInformationTransaction(TransactionHandle: HANDLE,
                                         TransactionInformationClass:
                                             TRANSACTION_INFORMATION_CLASS,
                                         TransactionInformation: PVOID,
                                         TransactionInformationLength: ULONG,
                                         ReturnLength: PULONG) -> NTSTATUS;
}
pub type PFN_NT_SET_INFORMATION_TRANSACTION =
    ::core::option::Option<unsafe extern "C" fn(TransactionHandle: HANDLE,
                                                TransactionInformationClass:
                                                    TRANSACTION_INFORMATION_CLASS,
                                                TransactionInformation: PVOID,
                                                TransactionInformationLength:
                                                    ULONG) -> libc::c_long>;
extern "C" {
    pub fn NtSetInformationTransaction(TransactionHandle: HANDLE,
                                       TransactionInformationClass:
                                           TRANSACTION_INFORMATION_CLASS,
                                       TransactionInformation: PVOID,
                                       TransactionInformationLength: ULONG)
     -> NTSTATUS;
}
pub type PFN_NT_COMMIT_TRANSACTION =
    ::core::option::Option<unsafe extern "C" fn(TransactionHandle: HANDLE,
                                                Wait: BOOLEAN)
                               -> libc::c_long>;
extern "C" {
    pub fn NtCommitTransaction(TransactionHandle: HANDLE, Wait: BOOLEAN)
     -> NTSTATUS;
}
pub type PFN_NT_ROLLBACK_TRANSACTION =
    ::core::option::Option<unsafe extern "C" fn(TransactionHandle: HANDLE,
                                                Wait: BOOLEAN)
                               -> libc::c_long>;
extern "C" {
    pub fn NtRollbackTransaction(TransactionHandle: HANDLE, Wait: BOOLEAN)
     -> NTSTATUS;
}
extern "C" {
    pub fn NtCreateEnlistment(EnlistmentHandle: PHANDLE,
                              DesiredAccess: ACCESS_MASK,
                              ResourceManagerHandle: HANDLE,
                              TransactionHandle: HANDLE,
                              ObjectAttributes: POBJECT_ATTRIBUTES,
                              CreateOptions: ULONG,
                              NotificationMask: NOTIFICATION_MASK,
                              EnlistmentKey: PVOID) -> NTSTATUS;
}
extern "C" {
    pub fn NtOpenEnlistment(EnlistmentHandle: PHANDLE,
                            DesiredAccess: ACCESS_MASK,
                            ResourceManagerHandle: HANDLE,
                            EnlistmentGuid: LPGUID,
                            ObjectAttributes: POBJECT_ATTRIBUTES) -> NTSTATUS;
}
extern "C" {
    pub fn NtQueryInformationEnlistment(EnlistmentHandle: HANDLE,
                                        EnlistmentInformationClass:
                                            ENLISTMENT_INFORMATION_CLASS,
                                        EnlistmentInformation: PVOID,
                                        EnlistmentInformationLength: ULONG,
                                        ReturnLength: PULONG) -> NTSTATUS;
}
extern "C" {
    pub fn NtSetInformationEnlistment(EnlistmentHandle: HANDLE,
                                      EnlistmentInformationClass:
                                          ENLISTMENT_INFORMATION_CLASS,
                                      EnlistmentInformation: PVOID,
                                      EnlistmentInformationLength: ULONG)
     -> NTSTATUS;
}
extern "C" {
    pub fn NtRecoverEnlistment(EnlistmentHandle: HANDLE, EnlistmentKey: PVOID)
     -> NTSTATUS;
}
extern "C" {
    pub fn NtPrePrepareEnlistment(EnlistmentHandle: HANDLE,
                                  TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
extern "C" {
    pub fn NtPrepareEnlistment(EnlistmentHandle: HANDLE,
                               TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
extern "C" {
    pub fn NtCommitEnlistment(EnlistmentHandle: HANDLE,
                              TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
extern "C" {
    pub fn NtRollbackEnlistment(EnlistmentHandle: HANDLE,
                                TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
extern "C" {
    pub fn NtPrePrepareComplete(EnlistmentHandle: HANDLE,
                                TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
extern "C" {
    pub fn NtPrepareComplete(EnlistmentHandle: HANDLE,
                             TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
extern "C" {
    pub fn NtCommitComplete(EnlistmentHandle: HANDLE,
                            TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
extern "C" {
    pub fn NtReadOnlyEnlistment(EnlistmentHandle: HANDLE,
                                TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
extern "C" {
    pub fn NtRollbackComplete(EnlistmentHandle: HANDLE,
                              TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
extern "C" {
    pub fn NtSinglePhaseReject(EnlistmentHandle: HANDLE,
                               TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
extern "C" {
    pub fn NtCreateResourceManager(ResourceManagerHandle: PHANDLE,
                                   DesiredAccess: ACCESS_MASK,
                                   TmHandle: HANDLE, RmGuid: LPGUID,
                                   ObjectAttributes: POBJECT_ATTRIBUTES,
                                   CreateOptions: ULONG,
                                   Description: PUNICODE_STRING) -> NTSTATUS;
}
extern "C" {
    pub fn NtOpenResourceManager(ResourceManagerHandle: PHANDLE,
                                 DesiredAccess: ACCESS_MASK, TmHandle: HANDLE,
                                 ResourceManagerGuid: LPGUID,
                                 ObjectAttributes: POBJECT_ATTRIBUTES)
     -> NTSTATUS;
}
extern "C" {
    pub fn NtRecoverResourceManager(ResourceManagerHandle: HANDLE)
     -> NTSTATUS;
}
extern "C" {
    pub fn NtGetNotificationResourceManager(ResourceManagerHandle: HANDLE,
                                            TransactionNotification:
                                                PTRANSACTION_NOTIFICATION,
                                            NotificationLength: ULONG,
                                            Timeout: PLARGE_INTEGER,
                                            ReturnLength: PULONG,
                                            Asynchronous: ULONG,
                                            AsynchronousContext: ULONG_PTR)
     -> NTSTATUS;
}
extern "C" {
    pub fn NtQueryInformationResourceManager(ResourceManagerHandle: HANDLE,
                                             ResourceManagerInformationClass:
                                                 RESOURCEMANAGER_INFORMATION_CLASS,
                                             ResourceManagerInformation:
                                                 PVOID,
                                             ResourceManagerInformationLength:
                                                 ULONG, ReturnLength: PULONG)
     -> NTSTATUS;
}
extern "C" {
    pub fn NtSetInformationResourceManager(ResourceManagerHandle: HANDLE,
                                           ResourceManagerInformationClass:
                                               RESOURCEMANAGER_INFORMATION_CLASS,
                                           ResourceManagerInformation: PVOID,
                                           ResourceManagerInformationLength:
                                               ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn NtRegisterProtocolAddressInformation(ResourceManager: HANDLE,
                                                ProtocolId: PCRM_PROTOCOL_ID,
                                                ProtocolInformationSize:
                                                    ULONG,
                                                ProtocolInformation: PVOID,
                                                CreateOptions: ULONG)
     -> NTSTATUS;
}
extern "C" {
    pub fn NtPropagationComplete(ResourceManagerHandle: HANDLE,
                                 RequestCookie: ULONG, BufferLength: ULONG,
                                 Buffer: PVOID) -> NTSTATUS;
}
extern "C" {
    pub fn NtPropagationFailed(ResourceManagerHandle: HANDLE,
                               RequestCookie: ULONG, PropStatus: NTSTATUS)
     -> NTSTATUS;
}
pub use self::_POOL_TYPE as POOL_TYPE;
pub type ALLOCATE_FUNCTION =
    ::core::option::Option<unsafe extern "C" fn(PoolType: POOL_TYPE,
                                                NumberOfBytes: SIZE_T,
                                                Tag: ULONG) -> PVOID>;
pub type PALLOCATE_FUNCTION = ALLOCATE_FUNCTION;
pub type FREE_FUNCTION =
    ::core::option::Option<unsafe extern "C" fn(Buffer: PVOID)>;
pub type PFREE_FUNCTION = FREE_FUNCTION;
#[repr(C)]
#[derive(Copy)]
pub struct _LOOKASIDE_LIST_EX {
    pub L: GENERAL_LOOKASIDE_POOL,
}
#[test]
fn bindgen_test_layout__LOOKASIDE_LIST_EX() {
    assert_eq!(::core::mem::size_of::<_LOOKASIDE_LIST_EX>() , 112usize);
    assert_eq!(::core::mem::align_of::<_LOOKASIDE_LIST_EX>() , 16usize);
}
impl Clone for _LOOKASIDE_LIST_EX {
    fn clone(&self) -> Self { *self }
}
pub type PLOOKASIDE_LIST_EX = *mut _LOOKASIDE_LIST_EX;
pub type ALLOCATE_FUNCTION_EX =
    ::core::option::Option<unsafe extern "C" fn(PoolType: POOL_TYPE,
                                                NumberOfBytes: SIZE_T,
                                                Tag: ULONG,
                                                Lookaside: PLOOKASIDE_LIST_EX)
                               -> PVOID>;
pub type PALLOCATE_FUNCTION_EX = ALLOCATE_FUNCTION_EX;
pub type FREE_FUNCTION_EX =
    ::core::option::Option<unsafe extern "C" fn(Buffer: PVOID,
                                                Lookaside:
                                                    PLOOKASIDE_LIST_EX)>;
pub type PFREE_FUNCTION_EX = FREE_FUNCTION_EX;
#[repr(C)]
#[derive(Copy)]
pub struct _GENERAL_LOOKASIDE {
    pub __bindgen_anon_1: _GENERAL_LOOKASIDE__bindgen_ty_1,
    pub Depth: USHORT,
    pub MaximumDepth: USHORT,
    pub TotalAllocates: ULONG,
    pub __bindgen_anon_2: _GENERAL_LOOKASIDE__bindgen_ty_2,
    pub TotalFrees: ULONG,
    pub __bindgen_anon_3: _GENERAL_LOOKASIDE__bindgen_ty_3,
    pub Type: POOL_TYPE,
    pub Tag: ULONG,
    pub Size: ULONG,
    pub __bindgen_anon_4: _GENERAL_LOOKASIDE__bindgen_ty_4,
    pub __bindgen_anon_5: _GENERAL_LOOKASIDE__bindgen_ty_5,
    pub ListEntry: LIST_ENTRY,
    pub LastTotalAllocates: ULONG,
    pub __bindgen_anon_6: _GENERAL_LOOKASIDE__bindgen_ty_6,
    pub Future: [ULONG; 2usize],
}
#[repr(C)]
#[derive(Copy)]
pub struct _GENERAL_LOOKASIDE__bindgen_ty_1 {
    pub ListHead: __BindgenUnionField<SLIST_HEADER>,
    pub SingleListHead: __BindgenUnionField<SINGLE_LIST_ENTRY>,
    pub bindgen_union_field: [u8; 32usize],
}
#[test]
fn bindgen_test_layout__GENERAL_LOOKASIDE__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_GENERAL_LOOKASIDE__bindgen_ty_1>() ,
               32usize);
    assert_eq!(::core::mem::align_of::<_GENERAL_LOOKASIDE__bindgen_ty_1>() ,
               16usize);
}
impl Clone for _GENERAL_LOOKASIDE__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GENERAL_LOOKASIDE__bindgen_ty_2 {
    pub AllocateMisses: __BindgenUnionField<ULONG>,
    pub AllocateHits: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout__GENERAL_LOOKASIDE__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<_GENERAL_LOOKASIDE__bindgen_ty_2>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_GENERAL_LOOKASIDE__bindgen_ty_2>() ,
               4usize);
}
impl Clone for _GENERAL_LOOKASIDE__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GENERAL_LOOKASIDE__bindgen_ty_3 {
    pub FreeMisses: __BindgenUnionField<ULONG>,
    pub FreeHits: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout__GENERAL_LOOKASIDE__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<_GENERAL_LOOKASIDE__bindgen_ty_3>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_GENERAL_LOOKASIDE__bindgen_ty_3>() ,
               4usize);
}
impl Clone for _GENERAL_LOOKASIDE__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GENERAL_LOOKASIDE__bindgen_ty_4 {
    pub AllocateEx: __BindgenUnionField<PALLOCATE_FUNCTION_EX>,
    pub Allocate: __BindgenUnionField<PALLOCATE_FUNCTION>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__GENERAL_LOOKASIDE__bindgen_ty_4() {
    assert_eq!(::core::mem::size_of::<_GENERAL_LOOKASIDE__bindgen_ty_4>() ,
               8usize);
    assert_eq!(::core::mem::align_of::<_GENERAL_LOOKASIDE__bindgen_ty_4>() ,
               8usize);
}
impl Clone for _GENERAL_LOOKASIDE__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GENERAL_LOOKASIDE__bindgen_ty_5 {
    pub FreeEx: __BindgenUnionField<PFREE_FUNCTION_EX>,
    pub Free: __BindgenUnionField<PFREE_FUNCTION>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__GENERAL_LOOKASIDE__bindgen_ty_5() {
    assert_eq!(::core::mem::size_of::<_GENERAL_LOOKASIDE__bindgen_ty_5>() ,
               8usize);
    assert_eq!(::core::mem::align_of::<_GENERAL_LOOKASIDE__bindgen_ty_5>() ,
               8usize);
}
impl Clone for _GENERAL_LOOKASIDE__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GENERAL_LOOKASIDE__bindgen_ty_6 {
    pub LastAllocateMisses: __BindgenUnionField<ULONG>,
    pub LastAllocateHits: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout__GENERAL_LOOKASIDE__bindgen_ty_6() {
    assert_eq!(::core::mem::size_of::<_GENERAL_LOOKASIDE__bindgen_ty_6>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_GENERAL_LOOKASIDE__bindgen_ty_6>() ,
               4usize);
}
impl Clone for _GENERAL_LOOKASIDE__bindgen_ty_6 {
    fn clone(&self) -> Self { *self }
}
impl Clone for _GENERAL_LOOKASIDE {
    fn clone(&self) -> Self { *self }
}
pub use self::_GENERAL_LOOKASIDE as GENERAL_LOOKASIDE;
pub type PGENERAL_LOOKASIDE = *mut GENERAL_LOOKASIDE;
#[repr(C)]
#[derive(Copy)]
pub struct _GENERAL_LOOKASIDE_POOL {
    pub __bindgen_anon_1: _GENERAL_LOOKASIDE_POOL__bindgen_ty_1,
    pub Depth: USHORT,
    pub MaximumDepth: USHORT,
    pub TotalAllocates: ULONG,
    pub __bindgen_anon_2: _GENERAL_LOOKASIDE_POOL__bindgen_ty_2,
    pub TotalFrees: ULONG,
    pub __bindgen_anon_3: _GENERAL_LOOKASIDE_POOL__bindgen_ty_3,
    pub Type: POOL_TYPE,
    pub Tag: ULONG,
    pub Size: ULONG,
    pub __bindgen_anon_4: _GENERAL_LOOKASIDE_POOL__bindgen_ty_4,
    pub __bindgen_anon_5: _GENERAL_LOOKASIDE_POOL__bindgen_ty_5,
    pub ListEntry: LIST_ENTRY,
    pub LastTotalAllocates: ULONG,
    pub __bindgen_anon_6: _GENERAL_LOOKASIDE_POOL__bindgen_ty_6,
    pub Future: [ULONG; 2usize],
}
#[repr(C)]
#[derive(Copy)]
pub struct _GENERAL_LOOKASIDE_POOL__bindgen_ty_1 {
    pub ListHead: __BindgenUnionField<SLIST_HEADER>,
    pub SingleListHead: __BindgenUnionField<SINGLE_LIST_ENTRY>,
    pub bindgen_union_field: [u8; 32usize],
}
#[test]
fn bindgen_test_layout__GENERAL_LOOKASIDE_POOL__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_GENERAL_LOOKASIDE_POOL__bindgen_ty_1>()
               , 32usize);
    assert_eq!(::core::mem::align_of::<_GENERAL_LOOKASIDE_POOL__bindgen_ty_1>()
               , 16usize);
}
impl Clone for _GENERAL_LOOKASIDE_POOL__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GENERAL_LOOKASIDE_POOL__bindgen_ty_2 {
    pub AllocateMisses: __BindgenUnionField<ULONG>,
    pub AllocateHits: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout__GENERAL_LOOKASIDE_POOL__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<_GENERAL_LOOKASIDE_POOL__bindgen_ty_2>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_GENERAL_LOOKASIDE_POOL__bindgen_ty_2>()
               , 4usize);
}
impl Clone for _GENERAL_LOOKASIDE_POOL__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GENERAL_LOOKASIDE_POOL__bindgen_ty_3 {
    pub FreeMisses: __BindgenUnionField<ULONG>,
    pub FreeHits: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout__GENERAL_LOOKASIDE_POOL__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<_GENERAL_LOOKASIDE_POOL__bindgen_ty_3>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_GENERAL_LOOKASIDE_POOL__bindgen_ty_3>()
               , 4usize);
}
impl Clone for _GENERAL_LOOKASIDE_POOL__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GENERAL_LOOKASIDE_POOL__bindgen_ty_4 {
    pub AllocateEx: __BindgenUnionField<PALLOCATE_FUNCTION_EX>,
    pub Allocate: __BindgenUnionField<PALLOCATE_FUNCTION>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__GENERAL_LOOKASIDE_POOL__bindgen_ty_4() {
    assert_eq!(::core::mem::size_of::<_GENERAL_LOOKASIDE_POOL__bindgen_ty_4>()
               , 8usize);
    assert_eq!(::core::mem::align_of::<_GENERAL_LOOKASIDE_POOL__bindgen_ty_4>()
               , 8usize);
}
impl Clone for _GENERAL_LOOKASIDE_POOL__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GENERAL_LOOKASIDE_POOL__bindgen_ty_5 {
    pub FreeEx: __BindgenUnionField<PFREE_FUNCTION_EX>,
    pub Free: __BindgenUnionField<PFREE_FUNCTION>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__GENERAL_LOOKASIDE_POOL__bindgen_ty_5() {
    assert_eq!(::core::mem::size_of::<_GENERAL_LOOKASIDE_POOL__bindgen_ty_5>()
               , 8usize);
    assert_eq!(::core::mem::align_of::<_GENERAL_LOOKASIDE_POOL__bindgen_ty_5>()
               , 8usize);
}
impl Clone for _GENERAL_LOOKASIDE_POOL__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GENERAL_LOOKASIDE_POOL__bindgen_ty_6 {
    pub LastAllocateMisses: __BindgenUnionField<ULONG>,
    pub LastAllocateHits: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout__GENERAL_LOOKASIDE_POOL__bindgen_ty_6() {
    assert_eq!(::core::mem::size_of::<_GENERAL_LOOKASIDE_POOL__bindgen_ty_6>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_GENERAL_LOOKASIDE_POOL__bindgen_ty_6>()
               , 4usize);
}
impl Clone for _GENERAL_LOOKASIDE_POOL__bindgen_ty_6 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__GENERAL_LOOKASIDE_POOL() {
    assert_eq!(::core::mem::size_of::<_GENERAL_LOOKASIDE_POOL>() , 112usize);
    assert_eq!(::core::mem::align_of::<_GENERAL_LOOKASIDE_POOL>() , 16usize);
}
impl Clone for _GENERAL_LOOKASIDE_POOL {
    fn clone(&self) -> Self { *self }
}
pub use self::_GENERAL_LOOKASIDE_POOL as GENERAL_LOOKASIDE_POOL;
pub type PGENERAL_LOOKASIDE_POOL = *mut _GENERAL_LOOKASIDE_POOL;
pub type KPROCESSOR_MODE = CCHAR;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _MODE { KernelMode = 0, UserMode = 1, MaximumMode = 2, }
pub use self::_MODE as MODE;
pub type KSYNCHRONIZE_ROUTINE =
    ::core::option::Option<unsafe extern "C" fn(SynchronizeContext: PVOID)
                               -> BOOLEAN>;
pub type PKSYNCHRONIZE_ROUTINE = KSYNCHRONIZE_ROUTINE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KAPC {
    pub Type: UCHAR,
    pub SpareByte0: UCHAR,
    pub Size: UCHAR,
    pub SpareByte1: UCHAR,
    pub SpareLong0: ULONG,
    pub Thread: *mut _KTHREAD,
    pub ApcListEntry: LIST_ENTRY,
    pub Reserved: [PVOID; 3usize],
    pub NormalContext: PVOID,
    pub SystemArgument1: PVOID,
    pub SystemArgument2: PVOID,
    pub ApcStateIndex: CCHAR,
    pub ApcMode: KPROCESSOR_MODE,
    pub Inserted: BOOLEAN,
}
#[test]
fn bindgen_test_layout__KAPC() {
    assert_eq!(::core::mem::size_of::<_KAPC>() , 88usize);
    assert_eq!(::core::mem::align_of::<_KAPC>() , 8usize);
}
impl Clone for _KAPC {
    fn clone(&self) -> Self { *self }
}
pub use self::_KAPC as KAPC;
pub type PKAPC = *mut _KAPC;
pub type PRKAPC = *mut _KAPC;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KDPC {
    pub __bindgen_anon_1: _KDPC__bindgen_ty_1,
    pub DpcListEntry: SINGLE_LIST_ENTRY,
    pub ProcessorHistory: KAFFINITY,
    pub DeferredRoutine: PKDEFERRED_ROUTINE,
    pub DeferredContext: PVOID,
    pub SystemArgument1: PVOID,
    pub SystemArgument2: PVOID,
    pub DpcData: PVOID,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KDPC__bindgen_ty_1 {
    pub TargetInfoAsUlong: __BindgenUnionField<ULONG>,
    pub __bindgen_anon_1: __BindgenUnionField<_KDPC__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KDPC__bindgen_ty_1__bindgen_ty_1 {
    pub Type: UCHAR,
    pub Importance: UCHAR,
    pub Number: USHORT,
}
#[test]
fn bindgen_test_layout__KDPC__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_KDPC__bindgen_ty_1__bindgen_ty_1>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_KDPC__bindgen_ty_1__bindgen_ty_1>() ,
               2usize);
}
impl Clone for _KDPC__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__KDPC__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_KDPC__bindgen_ty_1>() , 4usize);
    assert_eq!(::core::mem::align_of::<_KDPC__bindgen_ty_1>() , 4usize);
}
impl Clone for _KDPC__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__KDPC() {
    assert_eq!(::core::mem::size_of::<_KDPC>() , 64usize);
    assert_eq!(::core::mem::align_of::<_KDPC>() , 8usize);
}
impl Clone for _KDPC {
    fn clone(&self) -> Self { *self }
}
pub type KDEFERRED_ROUTINE =
    ::core::option::Option<unsafe extern "C" fn(Dpc: *mut _KDPC,
                                                DeferredContext: PVOID,
                                                SystemArgument1: PVOID,
                                                SystemArgument2: PVOID)>;
pub type PKDEFERRED_ROUTINE = KDEFERRED_ROUTINE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _KDPC_IMPORTANCE {
    LowImportance = 0,
    MediumImportance = 1,
    HighImportance = 2,
    MediumHighImportance = 3,
}
pub use self::_KDPC_IMPORTANCE as KDPC_IMPORTANCE;
pub use self::_KDPC as KDPC;
pub type PKDPC = *mut _KDPC;
pub type PRKDPC = *mut _KDPC;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _MDL {
    pub Next: *mut _MDL,
    pub Size: CSHORT,
    pub MdlFlags: CSHORT,
    pub Process: *mut _EPROCESS,
    pub MappedSystemVa: PVOID,
    pub StartVa: PVOID,
    pub ByteCount: ULONG,
    pub ByteOffset: ULONG,
}
#[test]
fn bindgen_test_layout__MDL() {
    assert_eq!(::core::mem::size_of::<_MDL>() , 48usize);
    assert_eq!(::core::mem::align_of::<_MDL>() , 8usize);
}
impl Clone for _MDL {
    fn clone(&self) -> Self { *self }
}
pub use self::_MDL as MDL;
pub type PMDL = *mut _MDL;
pub type PMDLX = *mut MDL;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DISPATCHER_HEADER {
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1,
    pub SignalState: LONG,
    pub WaitListHead: LIST_ENTRY,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1 {
    pub __bindgen_anon_1: __BindgenUnionField<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1>,
    pub __bindgen_anon_2: __BindgenUnionField<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2>,
    pub __bindgen_anon_3: __BindgenUnionField<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3>,
    pub __bindgen_anon_4: __BindgenUnionField<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4>,
    pub __bindgen_anon_5: __BindgenUnionField<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5>,
    pub __bindgen_anon_6: __BindgenUnionField<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6>,
    pub __bindgen_anon_7: __BindgenUnionField<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1 {
    pub Lock: __BindgenUnionField<LONG>,
    pub LockNV: __BindgenUnionField<LONG>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2 {
    pub Type: UCHAR,
    pub Signalling: UCHAR,
    pub Size: UCHAR,
    pub Reserved1: UCHAR,
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2>()
               , 1usize);
}
impl Clone for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3 {
    pub TimerType: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1,
    pub Hand: UCHAR,
    pub __bindgen_anon_2: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    pub TimerControlFlags: __BindgenUnionField<UCHAR>,
    pub __bindgen_anon_1: __BindgenUnionField<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u8,
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>()
               , 1usize);
    assert_eq!(::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>()
               , 1usize);
}
impl Clone for
 _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1
 {
    #[inline]
    pub fn Absolute(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                        0u32) as u8)
        }
    }
    #[inline]
    pub fn set_Absolute(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 0u32) & (1usize as u8);
    }
    #[inline]
    pub fn Wake(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u8)) >>
                                        1u32) as u8)
        }
    }
    #[inline]
    pub fn set_Wake(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(2usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 1u32) & (2usize as u8);
    }
    #[inline]
    pub fn EncodedTolerableDelay(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (252usize as u8)) >>
                                        2u32) as u8)
        }
    }
    #[inline]
    pub fn set_EncodedTolerableDelay(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(252usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 2u32) & (252usize as u8);
    }
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1>()
               , 1usize);
    assert_eq!(::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1>()
               , 1usize);
}
impl Clone for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2 {
    pub TimerMiscFlags: __BindgenUnionField<UCHAR>,
    pub __bindgen_anon_1: __BindgenUnionField<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1>,
    pub bindgen_union_field: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: u8,
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1>()
               , 1usize);
    assert_eq!(::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1>()
               , 1usize);
}
impl Clone for
 _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1
 {
    #[inline]
    pub fn Index(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                        0u32) as u8)
        }
    }
    #[inline]
    pub fn set_Index(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 0u32) & (1usize as u8);
    }
    #[inline]
    pub fn Processor(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (62usize as u8)) >>
                                        1u32) as u8)
        }
    }
    #[inline]
    pub fn set_Processor(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(62usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 1u32) & (62usize as u8);
    }
    #[inline]
    pub fn Inserted(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u8)) >>
                                        6u32) as u8)
        }
    }
    #[inline]
    pub fn set_Inserted(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(64usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 6u32) & (64usize as u8);
    }
    #[inline]
    pub fn Expired(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (128usize as u8)) >>
                                        7u32) as u8)
        }
    }
    #[inline]
    pub fn set_Expired(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(128usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 7u32) & (128usize as u8);
    }
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2>()
               , 1usize);
    assert_eq!(::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2>()
               , 1usize);
}
impl Clone for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3>()
               , 1usize);
}
impl Clone for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4 {
    pub Timer2Type: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
    pub Timer2Reserved1: UCHAR,
    pub Timer2Reserved2: UCHAR,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    pub Timer2Flags: __BindgenUnionField<UCHAR>,
    pub __bindgen_anon_1: __BindgenUnionField<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u8,
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1>()
               , 1usize);
    assert_eq!(::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1>()
               , 1usize);
}
impl Clone for
 _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1
 {
    #[inline]
    pub fn Timer2Inserted(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                        0u32) as u8)
        }
    }
    #[inline]
    pub fn set_Timer2Inserted(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 0u32) & (1usize as u8);
    }
    #[inline]
    pub fn Timer2Expiring(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u8)) >>
                                        1u32) as u8)
        }
    }
    #[inline]
    pub fn set_Timer2Expiring(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(2usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 1u32) & (2usize as u8);
    }
    #[inline]
    pub fn Timer2CancelPending(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u8)) >>
                                        2u32) as u8)
        }
    }
    #[inline]
    pub fn set_Timer2CancelPending(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(4usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 2u32) & (4usize as u8);
    }
    #[inline]
    pub fn Timer2SetPending(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u8)) >>
                                        3u32) as u8)
        }
    }
    #[inline]
    pub fn set_Timer2SetPending(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(8usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 3u32) & (8usize as u8);
    }
    #[inline]
    pub fn Timer2Running(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u8)) >>
                                        4u32) as u8)
        }
    }
    #[inline]
    pub fn set_Timer2Running(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(16usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 4u32) & (16usize as u8);
    }
    #[inline]
    pub fn Timer2Disabled(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u8)) >>
                                        5u32) as u8)
        }
    }
    #[inline]
    pub fn set_Timer2Disabled(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(32usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 5u32) & (32usize as u8);
    }
    #[inline]
    pub fn Timer2ReservedFlags(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (192usize as u8)) >>
                                        6u32) as u8)
        }
    }
    #[inline]
    pub fn set_Timer2ReservedFlags(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(192usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 6u32) & (192usize as u8);
    }
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1>()
               , 1usize);
    assert_eq!(::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1>()
               , 1usize);
}
impl Clone for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4>()
               , 1usize);
}
impl Clone for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5 {
    pub QueueType: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
    pub QueueSize: UCHAR,
    pub QueueReserved: UCHAR,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub QueueControlFlags: __BindgenUnionField<UCHAR>,
    pub __bindgen_anon_1: __BindgenUnionField<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u8,
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>()
               , 1usize);
    assert_eq!(::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>()
               , 1usize);
}
impl Clone for
 _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1
 {
    #[inline]
    pub fn Abandoned(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                        0u32) as u8)
        }
    }
    #[inline]
    pub fn set_Abandoned(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 0u32) & (1usize as u8);
    }
    #[inline]
    pub fn DisableIncrement(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u8)) >>
                                        1u32) as u8)
        }
    }
    #[inline]
    pub fn set_DisableIncrement(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(2usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 1u32) & (2usize as u8);
    }
    #[inline]
    pub fn QueueReservedControlFlags(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (252usize as u8)) >>
                                        2u32) as u8)
        }
    }
    #[inline]
    pub fn set_QueueReservedControlFlags(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(252usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 2u32) & (252usize as u8);
    }
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>()
               , 1usize);
    assert_eq!(::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>()
               , 1usize);
}
impl Clone for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5>()
               , 1usize);
}
impl Clone for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6 {
    pub ThreadType: UCHAR,
    pub ThreadReserved: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1,
    pub __bindgen_anon_2: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1 {
    pub ThreadControlFlags: __BindgenUnionField<UCHAR>,
    pub __bindgen_anon_1: __BindgenUnionField<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u8,
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1__bindgen_ty_1>()
               , 1usize);
    assert_eq!(::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1__bindgen_ty_1>()
               , 1usize);
}
impl Clone for
 _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1__bindgen_ty_1
 {
    #[inline]
    pub fn CycleProfiling(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                        0u32) as u8)
        }
    }
    #[inline]
    pub fn set_CycleProfiling(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 0u32) & (1usize as u8);
    }
    #[inline]
    pub fn CounterProfiling(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u8)) >>
                                        1u32) as u8)
        }
    }
    #[inline]
    pub fn set_CounterProfiling(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(2usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 1u32) & (2usize as u8);
    }
    #[inline]
    pub fn GroupScheduling(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u8)) >>
                                        2u32) as u8)
        }
    }
    #[inline]
    pub fn set_GroupScheduling(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(4usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 2u32) & (4usize as u8);
    }
    #[inline]
    pub fn AffinitySet(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u8)) >>
                                        3u32) as u8)
        }
    }
    #[inline]
    pub fn set_AffinitySet(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(8usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 3u32) & (8usize as u8);
    }
    #[inline]
    pub fn Tagged(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u8)) >>
                                        4u32) as u8)
        }
    }
    #[inline]
    pub fn set_Tagged(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(16usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 4u32) & (16usize as u8);
    }
    #[inline]
    pub fn EnergyProfiling(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u8)) >>
                                        5u32) as u8)
        }
    }
    #[inline]
    pub fn set_EnergyProfiling(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(32usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 5u32) & (32usize as u8);
    }
    #[inline]
    pub fn Instrumented(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u8)) >>
                                        6u32) as u8)
        }
    }
    #[inline]
    pub fn set_Instrumented(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(64usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 6u32) & (64usize as u8);
    }
    #[inline]
    pub fn ThreadReservedControlFlags(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (128usize as u8)) >>
                                        7u32) as u8)
        }
    }
    #[inline]
    pub fn set_ThreadReservedControlFlags(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(128usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 7u32) & (128usize as u8);
    }
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1>()
               , 1usize);
    assert_eq!(::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1>()
               , 1usize);
}
impl Clone for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2 {
    pub DebugActive: __BindgenUnionField<UCHAR>,
    pub bindgen_union_field: u8,
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2>()
               , 1usize);
    assert_eq!(::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2>()
               , 1usize);
}
impl Clone for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6>()
               , 1usize);
}
impl Clone for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7 {
    pub MutantType: UCHAR,
    pub MutantSize: UCHAR,
    pub DpcActive: BOOLEAN,
    pub MutantReserved: UCHAR,
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7() {
    assert_eq!(::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7>()
               , 1usize);
}
impl Clone for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1>() ,
               4usize);
}
impl Clone for _DISPATCHER_HEADER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER() {
    assert_eq!(::core::mem::size_of::<_DISPATCHER_HEADER>() , 24usize);
    assert_eq!(::core::mem::align_of::<_DISPATCHER_HEADER>() , 8usize);
}
impl Clone for _DISPATCHER_HEADER {
    fn clone(&self) -> Self { *self }
}
pub use self::_DISPATCHER_HEADER as DISPATCHER_HEADER;
pub type PDISPATCHER_HEADER = *mut _DISPATCHER_HEADER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KEVENT {
    pub Header: DISPATCHER_HEADER,
}
#[test]
fn bindgen_test_layout__KEVENT() {
    assert_eq!(::core::mem::size_of::<_KEVENT>() , 24usize);
    assert_eq!(::core::mem::align_of::<_KEVENT>() , 8usize);
}
impl Clone for _KEVENT {
    fn clone(&self) -> Self { *self }
}
pub use self::_KEVENT as KEVENT;
pub type PKEVENT = *mut _KEVENT;
pub type PRKEVENT = *mut _KEVENT;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KGATE {
    pub Header: DISPATCHER_HEADER,
}
#[test]
fn bindgen_test_layout__KGATE() {
    assert_eq!(::core::mem::size_of::<_KGATE>() , 24usize);
    assert_eq!(::core::mem::align_of::<_KGATE>() , 8usize);
}
impl Clone for _KGATE {
    fn clone(&self) -> Self { *self }
}
pub use self::_KGATE as KGATE;
pub type PKGATE = *mut _KGATE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KTIMER {
    pub Header: DISPATCHER_HEADER,
    pub DueTime: ULARGE_INTEGER,
    pub TimerListEntry: LIST_ENTRY,
    pub Dpc: *mut _KDPC,
    pub Period: ULONG,
}
#[test]
fn bindgen_test_layout__KTIMER() {
    assert_eq!(::core::mem::size_of::<_KTIMER>() , 64usize);
    assert_eq!(::core::mem::align_of::<_KTIMER>() , 8usize);
}
impl Clone for _KTIMER {
    fn clone(&self) -> Self { *self }
}
pub use self::_KTIMER as KTIMER;
pub type PKTIMER = *mut _KTIMER;
pub type PRKTIMER = *mut _KTIMER;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _LOCK_OPERATION {
    IoReadAccess = 0,
    IoWriteAccess = 1,
    IoModifyAccess = 2,
}
pub use self::_LOCK_OPERATION as LOCK_OPERATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _FAST_MUTEX {
    pub Count: LONG,
    pub Owner: PVOID,
    pub Contention: ULONG,
    pub Event: KEVENT,
    pub OldIrql: ULONG,
}
#[test]
fn bindgen_test_layout__FAST_MUTEX() {
    assert_eq!(::core::mem::size_of::<_FAST_MUTEX>() , 56usize);
    assert_eq!(::core::mem::align_of::<_FAST_MUTEX>() , 8usize);
}
impl Clone for _FAST_MUTEX {
    fn clone(&self) -> Self { *self }
}
pub use self::_FAST_MUTEX as FAST_MUTEX;
pub type PFAST_MUTEX = *mut _FAST_MUTEX;
pub use self::_FAST_MUTEX as KGUARDED_MUTEX;
pub type PKGUARDED_MUTEX = *mut _FAST_MUTEX;
pub type PFN_COUNT = ULONG;
pub type SPFN_NUMBER = LONG;
pub type PSPFN_NUMBER = *mut LONG;
pub type PFN_NUMBER = ULONG;
pub type PPFN_NUMBER = *mut ULONG;
extern "C" {
    pub fn KfLowerIrql(NewIrql: KIRQL);
}
extern "C" {
    pub fn KfRaiseIrql(NewIrql: KIRQL) -> KIRQL;
}
extern "C" {
    pub fn KeRaiseIrqlToDpcLevel() -> KIRQL;
}
extern "C" {
    pub fn READ_REGISTER_UCHAR(Register: *mut UCHAR) -> UCHAR;
}
extern "C" {
    pub fn READ_REGISTER_USHORT(Register: *mut USHORT) -> USHORT;
}
extern "C" {
    pub fn READ_REGISTER_ULONG(Register: *mut ULONG) -> ULONG;
}
extern "C" {
    pub fn READ_REGISTER_BUFFER_UCHAR(Register: *mut UCHAR, Buffer: PUCHAR,
                                      Count: ULONG);
}
extern "C" {
    pub fn READ_REGISTER_BUFFER_USHORT(Register: *mut USHORT, Buffer: PUSHORT,
                                       Count: ULONG);
}
extern "C" {
    pub fn READ_REGISTER_BUFFER_ULONG(Register: *mut ULONG, Buffer: PULONG,
                                      Count: ULONG);
}
extern "C" {
    pub fn WRITE_REGISTER_UCHAR(Register: *mut UCHAR, Value: UCHAR);
}
extern "C" {
    pub fn WRITE_REGISTER_USHORT(Register: *mut USHORT, Value: USHORT);
}
extern "C" {
    pub fn WRITE_REGISTER_ULONG(Register: *mut ULONG, Value: ULONG);
}
extern "C" {
    pub fn WRITE_REGISTER_BUFFER_UCHAR(Register: *mut UCHAR, Buffer: PUCHAR,
                                       Count: ULONG);
}
extern "C" {
    pub fn WRITE_REGISTER_BUFFER_USHORT(Register: *mut USHORT,
                                        Buffer: PUSHORT, Count: ULONG);
}
extern "C" {
    pub fn WRITE_REGISTER_BUFFER_ULONG(Register: *mut ULONG, Buffer: PULONG,
                                       Count: ULONG);
}
extern "C" {
    pub fn READ_PORT_UCHAR(Port: PUCHAR) -> UCHAR;
}
extern "C" {
    pub fn READ_PORT_USHORT(Port: PUSHORT) -> USHORT;
}
extern "C" {
    pub fn READ_PORT_ULONG(Port: PULONG) -> ULONG;
}
extern "C" {
    pub fn READ_PORT_BUFFER_UCHAR(Port: PUCHAR, Buffer: PUCHAR, Count: ULONG);
}
extern "C" {
    pub fn READ_PORT_BUFFER_USHORT(Port: PUSHORT, Buffer: PUSHORT,
                                   Count: ULONG);
}
extern "C" {
    pub fn READ_PORT_BUFFER_ULONG(Port: PULONG, Buffer: PULONG, Count: ULONG);
}
extern "C" {
    pub fn WRITE_PORT_UCHAR(Port: PUCHAR, Value: UCHAR);
}
extern "C" {
    pub fn WRITE_PORT_USHORT(Port: PUSHORT, Value: USHORT);
}
extern "C" {
    pub fn WRITE_PORT_ULONG(Port: PULONG, Value: ULONG);
}
extern "C" {
    pub fn WRITE_PORT_BUFFER_UCHAR(Port: PUCHAR, Buffer: PUCHAR,
                                   Count: ULONG);
}
extern "C" {
    pub fn WRITE_PORT_BUFFER_USHORT(Port: PUSHORT, Buffer: PUSHORT,
                                    Count: ULONG);
}
extern "C" {
    pub fn WRITE_PORT_BUFFER_ULONG(Port: PULONG, Buffer: PULONG,
                                   Count: ULONG);
}
extern "C" {
    pub fn KeFlushIoBuffers(Mdl: PMDL, ReadOperation: BOOLEAN,
                            DmaOperation: BOOLEAN);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KFLOATING_SAVE {
    pub ControlWord: ULONG,
    pub StatusWord: ULONG,
    pub ErrorOffset: ULONG,
    pub ErrorSelector: ULONG,
    pub DataOffset: ULONG,
    pub DataSelector: ULONG,
    pub Spare0: ULONG,
    pub Spare1: ULONG,
}
#[test]
fn bindgen_test_layout__KFLOATING_SAVE() {
    assert_eq!(::core::mem::size_of::<_KFLOATING_SAVE>() , 32usize);
    assert_eq!(::core::mem::align_of::<_KFLOATING_SAVE>() , 4usize);
}
impl Clone for _KFLOATING_SAVE {
    fn clone(&self) -> Self { *self }
}
pub use self::_KFLOATING_SAVE as KFLOATING_SAVE;
pub type PKFLOATING_SAVE = *mut _KFLOATING_SAVE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _AMD_L1_CACHE_INFO {
    pub Ulong: __BindgenUnionField<ULONG>,
    pub __bindgen_anon_1: __BindgenUnionField<_AMD_L1_CACHE_INFO__bindgen_ty_1>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _AMD_L1_CACHE_INFO__bindgen_ty_1 {
    pub LineSize: UCHAR,
    pub LinesPerTag: UCHAR,
    pub Associativity: UCHAR,
    pub Size: UCHAR,
}
#[test]
fn bindgen_test_layout__AMD_L1_CACHE_INFO__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_AMD_L1_CACHE_INFO__bindgen_ty_1>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_AMD_L1_CACHE_INFO__bindgen_ty_1>() ,
               1usize);
}
impl Clone for _AMD_L1_CACHE_INFO__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__AMD_L1_CACHE_INFO() {
    assert_eq!(::core::mem::size_of::<_AMD_L1_CACHE_INFO>() , 4usize);
    assert_eq!(::core::mem::align_of::<_AMD_L1_CACHE_INFO>() , 4usize);
}
impl Clone for _AMD_L1_CACHE_INFO {
    fn clone(&self) -> Self { *self }
}
pub use self::_AMD_L1_CACHE_INFO as AMD_L1_CACHE_INFO;
pub type PAMD_L1_CACHE_INFO = *mut _AMD_L1_CACHE_INFO;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _AMD_L2_CACHE_INFO {
    pub Ulong: __BindgenUnionField<ULONG>,
    pub __bindgen_anon_1: __BindgenUnionField<_AMD_L2_CACHE_INFO__bindgen_ty_1>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _AMD_L2_CACHE_INFO__bindgen_ty_1 {
    pub LineSize: UCHAR,
    pub _bitfield_1: u8,
    pub Size: USHORT,
}
#[test]
fn bindgen_test_layout__AMD_L2_CACHE_INFO__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_AMD_L2_CACHE_INFO__bindgen_ty_1>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_AMD_L2_CACHE_INFO__bindgen_ty_1>() ,
               2usize);
}
impl Clone for _AMD_L2_CACHE_INFO__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _AMD_L2_CACHE_INFO__bindgen_ty_1 {
    #[inline]
    pub fn LinesPerTag(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (15usize as u8)) >>
                                        0u32) as u8)
        }
    }
    #[inline]
    pub fn set_LinesPerTag(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(15usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 0u32) & (15usize as u8);
    }
    #[inline]
    pub fn Associativity(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (240usize as u8)) >>
                                        4u32) as u8)
        }
    }
    #[inline]
    pub fn set_Associativity(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(240usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 4u32) & (240usize as u8);
    }
}
#[test]
fn bindgen_test_layout__AMD_L2_CACHE_INFO() {
    assert_eq!(::core::mem::size_of::<_AMD_L2_CACHE_INFO>() , 4usize);
    assert_eq!(::core::mem::align_of::<_AMD_L2_CACHE_INFO>() , 4usize);
}
impl Clone for _AMD_L2_CACHE_INFO {
    fn clone(&self) -> Self { *self }
}
pub use self::_AMD_L2_CACHE_INFO as AMD_L2_CACHE_INFO;
pub type PAMD_L2_CACHE_INFO = *mut _AMD_L2_CACHE_INFO;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _AMD_L3_CACHE_INFO {
    pub Ulong: __BindgenUnionField<ULONG>,
    pub __bindgen_anon_1: __BindgenUnionField<_AMD_L3_CACHE_INFO__bindgen_ty_1>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _AMD_L3_CACHE_INFO__bindgen_ty_1 {
    pub LineSize: UCHAR,
    pub _bitfield_1: u16,
    pub _bitfield_2: u16,
}
#[test]
fn bindgen_test_layout__AMD_L3_CACHE_INFO__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_AMD_L3_CACHE_INFO__bindgen_ty_1>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_AMD_L3_CACHE_INFO__bindgen_ty_1>() ,
               2usize);
}
impl Clone for _AMD_L3_CACHE_INFO__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _AMD_L3_CACHE_INFO__bindgen_ty_1 {
    #[inline]
    pub fn LinesPerTag(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (15usize as u16)) >>
                                        0u32) as u8)
        }
    }
    #[inline]
    pub fn set_LinesPerTag(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(15usize as u16);
        self._bitfield_1 |= ((val as u8 as u16) << 0u32) & (15usize as u16);
    }
    #[inline]
    pub fn Associativity(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (240usize as u16)) >>
                                        4u32) as u8)
        }
    }
    #[inline]
    pub fn set_Associativity(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(240usize as u16);
        self._bitfield_1 |= ((val as u8 as u16) << 4u32) & (240usize as u16);
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (768usize as u16)) >>
                                        8u32) as u16)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        self._bitfield_1 &= !(768usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 8u32) & (768usize as u16);
    }
    #[inline]
    pub fn Size(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_2 & (16383usize as u16))
                                        >> 0u32) as u16)
        }
    }
    #[inline]
    pub fn set_Size(&mut self, val: USHORT) {
        self._bitfield_2 &= !(16383usize as u16);
        self._bitfield_2 |=
            ((val as u16 as u16) << 0u32) & (16383usize as u16);
    }
}
#[test]
fn bindgen_test_layout__AMD_L3_CACHE_INFO() {
    assert_eq!(::core::mem::size_of::<_AMD_L3_CACHE_INFO>() , 4usize);
    assert_eq!(::core::mem::align_of::<_AMD_L3_CACHE_INFO>() , 4usize);
}
impl Clone for _AMD_L3_CACHE_INFO {
    fn clone(&self) -> Self { *self }
}
pub use self::_AMD_L3_CACHE_INFO as AMD_L3_CACHE_INFO;
pub type PAMD_L3_CACHE_INFO = *mut _AMD_L3_CACHE_INFO;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _INTEL_CACHE_TYPE {
    IntelCacheNull = 0,
    IntelCacheData = 1,
    IntelCacheInstruction = 2,
    IntelCacheUnified = 3,
    IntelCacheRam = 4,
    IntelCacheTrace = 5,
}
pub use self::_INTEL_CACHE_TYPE as INTEL_CACHE_TYPE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct INTEL_CACHE_INFO_EAX {
    pub Ulong: __BindgenUnionField<ULONG>,
    pub __bindgen_anon_1: __BindgenUnionField<INTEL_CACHE_INFO_EAX__bindgen_ty_1>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct INTEL_CACHE_INFO_EAX__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout_INTEL_CACHE_INFO_EAX__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<INTEL_CACHE_INFO_EAX__bindgen_ty_1>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<INTEL_CACHE_INFO_EAX__bindgen_ty_1>() ,
               4usize);
}
impl Clone for INTEL_CACHE_INFO_EAX__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl INTEL_CACHE_INFO_EAX__bindgen_ty_1 {
    #[inline]
    pub fn Type(&self) -> INTEL_CACHE_TYPE {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (31usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_Type(&mut self, val: INTEL_CACHE_TYPE) {
        self._bitfield_1 &= !(31usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (31usize as u32);
    }
    #[inline]
    pub fn Level(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (224usize as u32)) >>
                                        5u32) as u32)
        }
    }
    #[inline]
    pub fn set_Level(&mut self, val: ULONG) {
        self._bitfield_1 &= !(224usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (224usize as u32);
    }
    #[inline]
    pub fn SelfInitializing(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (256usize as u32)) >>
                                        8u32) as u32)
        }
    }
    #[inline]
    pub fn set_SelfInitializing(&mut self, val: ULONG) {
        self._bitfield_1 &= !(256usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 8u32) & (256usize as u32);
    }
    #[inline]
    pub fn FullyAssociative(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (512usize as u32)) >>
                                        9u32) as u32)
        }
    }
    #[inline]
    pub fn set_FullyAssociative(&mut self, val: ULONG) {
        self._bitfield_1 &= !(512usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 9u32) & (512usize as u32);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (15360usize as u32))
                                        >> 10u32) as u32)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        self._bitfield_1 &= !(15360usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 10u32) & (15360usize as u32);
    }
    #[inline]
    pub fn ThreadsSharing(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (67092480usize as u32)) >> 14u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_ThreadsSharing(&mut self, val: ULONG) {
        self._bitfield_1 &= !(67092480usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 14u32) & (67092480usize as u32);
    }
    #[inline]
    pub fn ProcessorCores(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4227858432usize as u32)) >> 26u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_ProcessorCores(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4227858432usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 26u32) & (4227858432usize as u32);
    }
}
#[test]
fn bindgen_test_layout_INTEL_CACHE_INFO_EAX() {
    assert_eq!(::core::mem::size_of::<INTEL_CACHE_INFO_EAX>() , 4usize);
    assert_eq!(::core::mem::align_of::<INTEL_CACHE_INFO_EAX>() , 4usize);
}
impl Clone for INTEL_CACHE_INFO_EAX {
    fn clone(&self) -> Self { *self }
}
pub type PINTEL_CACHE_INFO_EAX = *mut INTEL_CACHE_INFO_EAX;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct INTEL_CACHE_INFO_EBX {
    pub Ulong: __BindgenUnionField<ULONG>,
    pub __bindgen_anon_1: __BindgenUnionField<INTEL_CACHE_INFO_EBX__bindgen_ty_1>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct INTEL_CACHE_INFO_EBX__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout_INTEL_CACHE_INFO_EBX__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<INTEL_CACHE_INFO_EBX__bindgen_ty_1>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<INTEL_CACHE_INFO_EBX__bindgen_ty_1>() ,
               4usize);
}
impl Clone for INTEL_CACHE_INFO_EBX__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl INTEL_CACHE_INFO_EBX__bindgen_ty_1 {
    #[inline]
    pub fn LineSize(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4095usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_LineSize(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4095usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 0u32) & (4095usize as u32);
    }
    #[inline]
    pub fn Partitions(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4190208usize as u32))
                                        >> 12u32) as u32)
        }
    }
    #[inline]
    pub fn set_Partitions(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4190208usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 12u32) & (4190208usize as u32);
    }
    #[inline]
    pub fn Associativity(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4290772992usize as u32)) >> 22u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_Associativity(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4290772992usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 22u32) & (4290772992usize as u32);
    }
}
#[test]
fn bindgen_test_layout_INTEL_CACHE_INFO_EBX() {
    assert_eq!(::core::mem::size_of::<INTEL_CACHE_INFO_EBX>() , 4usize);
    assert_eq!(::core::mem::align_of::<INTEL_CACHE_INFO_EBX>() , 4usize);
}
impl Clone for INTEL_CACHE_INFO_EBX {
    fn clone(&self) -> Self { *self }
}
pub type PINTEL_CACHE_INFO_EBX = *mut INTEL_CACHE_INFO_EBX;
extern "C" {
    pub fn _mm_clflush(Address: *const libc::c_void);
}
extern "C" {
    pub fn __invlpg(Page: PVOID);
}
extern "C" {
    pub fn __wbinvd();
}
extern "C" {
    pub fn __readcr3() -> ULONG;
}
extern "C" {
    pub fn __writecr3(Data: UINT32);
}
extern "C" {
    pub fn __readeflags() -> UINT32;
}
extern "C" {
    pub fn _ReadWriteBarrier();
}
extern "C" {
    pub fn KeSaveFloatingPointState(FloatSave: PKFLOATING_SAVE) -> NTSTATUS;
}
extern "C" {
    pub fn KeRestoreFloatingPointState(FloatSave: PKFLOATING_SAVE)
     -> NTSTATUS;
}
extern "C" {
    pub fn __inbyte(Port: USHORT) -> UCHAR;
}
extern "C" {
    pub fn __inword(Port: USHORT) -> USHORT;
}
extern "C" {
    pub fn __indword(Port: USHORT) -> ULONG;
}
extern "C" {
    pub fn __outbyte(Port: USHORT, Data: UCHAR);
}
extern "C" {
    pub fn __outword(Port: USHORT, Data: USHORT);
}
extern "C" {
    pub fn __outdword(Port: USHORT, Data: ULONG);
}
extern "C" {
    pub fn __inbytestring(Port: USHORT, Buffer: PUCHAR, Count: ULONG);
}
extern "C" {
    pub fn __inwordstring(Port: USHORT, Buffer: PUSHORT, Count: ULONG);
}
extern "C" {
    pub fn __indwordstring(Port: USHORT, Buffer: PULONG, Count: ULONG);
}
extern "C" {
    pub fn __outbytestring(Port: USHORT, Buffer: PUCHAR, Count: ULONG);
}
extern "C" {
    pub fn __outwordstring(Port: USHORT, Buffer: PUSHORT, Count: ULONG);
}
extern "C" {
    pub fn __outdwordstring(Port: USHORT, Buffer: PULONG, Count: ULONG);
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _LOGICAL_PROCESSOR_RELATIONSHIP {
    RelationProcessorCore = 0,
    RelationNumaNode = 1,
    RelationCache = 2,
    RelationProcessorPackage = 3,
    RelationGroup = 4,
    RelationAll = 65535,
}
pub use self::_LOGICAL_PROCESSOR_RELATIONSHIP as
        LOGICAL_PROCESSOR_RELATIONSHIP;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _PROCESSOR_CACHE_TYPE {
    CacheUnified = 0,
    CacheInstruction = 1,
    CacheData = 2,
    CacheTrace = 3,
}
pub use self::_PROCESSOR_CACHE_TYPE as PROCESSOR_CACHE_TYPE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CACHE_DESCRIPTOR {
    pub Level: UCHAR,
    pub Associativity: UCHAR,
    pub LineSize: USHORT,
    pub Size: ULONG,
    pub Type: PROCESSOR_CACHE_TYPE,
}
#[test]
fn bindgen_test_layout__CACHE_DESCRIPTOR() {
    assert_eq!(::core::mem::size_of::<_CACHE_DESCRIPTOR>() , 12usize);
    assert_eq!(::core::mem::align_of::<_CACHE_DESCRIPTOR>() , 4usize);
}
impl Clone for _CACHE_DESCRIPTOR {
    fn clone(&self) -> Self { *self }
}
pub use self::_CACHE_DESCRIPTOR as CACHE_DESCRIPTOR;
pub type PCACHE_DESCRIPTOR = *mut _CACHE_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION {
    pub ProcessorMask: ULONG_PTR,
    pub Relationship: LOGICAL_PROCESSOR_RELATIONSHIP,
    pub __bindgen_anon_1: _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1 {
    pub ProcessorCore: __BindgenUnionField<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1>,
    pub NumaNode: __BindgenUnionField<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2>,
    pub Cache: __BindgenUnionField<CACHE_DESCRIPTOR>,
    pub Reserved: __BindgenUnionField<[ULONGLONG; 2usize]>,
    pub bindgen_union_field: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    pub Flags: UCHAR,
}
#[test]
fn bindgen_test_layout__SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1>()
               , 1usize);
    assert_eq!(::core::mem::align_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1>()
               , 1usize);
}
impl Clone for
 _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2 {
    pub NodeNumber: ULONG,
}
#[test]
fn bindgen_test_layout__SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2>()
               , 4usize);
}
impl Clone for
 _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1>()
               , 16usize);
    assert_eq!(::core::mem::align_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1>()
               , 8usize);
}
impl Clone for _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__SYSTEM_LOGICAL_PROCESSOR_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION>()
               , 32usize);
    assert_eq!(::core::mem::align_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION>()
               , 8usize);
}
impl Clone for _SYSTEM_LOGICAL_PROCESSOR_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_SYSTEM_LOGICAL_PROCESSOR_INFORMATION as
        SYSTEM_LOGICAL_PROCESSOR_INFORMATION;
pub type PSYSTEM_LOGICAL_PROCESSOR_INFORMATION =
    *mut _SYSTEM_LOGICAL_PROCESSOR_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESSOR_RELATIONSHIP {
    pub Flags: UCHAR,
    pub EfficiencyClass: UCHAR,
    pub Reserved: [UCHAR; 20usize],
    pub GroupCount: USHORT,
    pub GroupMask: [GROUP_AFFINITY; 1usize],
}
#[test]
fn bindgen_test_layout__PROCESSOR_RELATIONSHIP() {
    assert_eq!(::core::mem::size_of::<_PROCESSOR_RELATIONSHIP>() , 40usize);
    assert_eq!(::core::mem::align_of::<_PROCESSOR_RELATIONSHIP>() , 8usize);
}
impl Clone for _PROCESSOR_RELATIONSHIP {
    fn clone(&self) -> Self { *self }
}
pub use self::_PROCESSOR_RELATIONSHIP as PROCESSOR_RELATIONSHIP;
pub type PPROCESSOR_RELATIONSHIP = *mut _PROCESSOR_RELATIONSHIP;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _NUMA_NODE_RELATIONSHIP {
    pub NodeNumber: ULONG,
    pub Reserved: [UCHAR; 20usize],
    pub GroupMask: GROUP_AFFINITY,
}
#[test]
fn bindgen_test_layout__NUMA_NODE_RELATIONSHIP() {
    assert_eq!(::core::mem::size_of::<_NUMA_NODE_RELATIONSHIP>() , 40usize);
    assert_eq!(::core::mem::align_of::<_NUMA_NODE_RELATIONSHIP>() , 8usize);
}
impl Clone for _NUMA_NODE_RELATIONSHIP {
    fn clone(&self) -> Self { *self }
}
pub use self::_NUMA_NODE_RELATIONSHIP as NUMA_NODE_RELATIONSHIP;
pub type PNUMA_NODE_RELATIONSHIP = *mut _NUMA_NODE_RELATIONSHIP;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CACHE_RELATIONSHIP {
    pub Level: UCHAR,
    pub Associativity: UCHAR,
    pub LineSize: USHORT,
    pub CacheSize: ULONG,
    pub Type: PROCESSOR_CACHE_TYPE,
    pub Reserved: [UCHAR; 20usize],
    pub GroupMask: GROUP_AFFINITY,
}
#[test]
fn bindgen_test_layout__CACHE_RELATIONSHIP() {
    assert_eq!(::core::mem::size_of::<_CACHE_RELATIONSHIP>() , 48usize);
    assert_eq!(::core::mem::align_of::<_CACHE_RELATIONSHIP>() , 8usize);
}
impl Clone for _CACHE_RELATIONSHIP {
    fn clone(&self) -> Self { *self }
}
pub use self::_CACHE_RELATIONSHIP as CACHE_RELATIONSHIP;
pub type PCACHE_RELATIONSHIP = *mut _CACHE_RELATIONSHIP;
#[repr(C)]
pub struct _PROCESSOR_GROUP_INFO {
    pub MaximumProcessorCount: UCHAR,
    pub ActiveProcessorCount: UCHAR,
    pub Reserved: [UCHAR; 38usize],
    pub ActiveProcessorMask: KAFFINITY,
}
#[test]
fn bindgen_test_layout__PROCESSOR_GROUP_INFO() {
    assert_eq!(::core::mem::size_of::<_PROCESSOR_GROUP_INFO>() , 48usize);
    assert_eq!(::core::mem::align_of::<_PROCESSOR_GROUP_INFO>() , 8usize);
}
pub use self::_PROCESSOR_GROUP_INFO as PROCESSOR_GROUP_INFO;
pub type PPROCESSOR_GROUP_INFO = *mut _PROCESSOR_GROUP_INFO;
#[repr(C)]
pub struct _GROUP_RELATIONSHIP {
    pub MaximumGroupCount: USHORT,
    pub ActiveGroupCount: USHORT,
    pub Reserved: [UCHAR; 20usize],
    pub GroupInfo: [PROCESSOR_GROUP_INFO; 1usize],
}
#[test]
fn bindgen_test_layout__GROUP_RELATIONSHIP() {
    assert_eq!(::core::mem::size_of::<_GROUP_RELATIONSHIP>() , 72usize);
    assert_eq!(::core::mem::align_of::<_GROUP_RELATIONSHIP>() , 8usize);
}
pub use self::_GROUP_RELATIONSHIP as GROUP_RELATIONSHIP;
pub type PGROUP_RELATIONSHIP = *mut _GROUP_RELATIONSHIP;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {
    pub Relationship: LOGICAL_PROCESSOR_RELATIONSHIP,
    pub Size: ULONG,
    pub __bindgen_anon_1: _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1 {
    pub Processor: __BindgenUnionField<PROCESSOR_RELATIONSHIP>,
    pub NumaNode: __BindgenUnionField<NUMA_NODE_RELATIONSHIP>,
    pub Cache: __BindgenUnionField<CACHE_RELATIONSHIP>,
    pub Group: __BindgenUnionField<GROUP_RELATIONSHIP>,
    pub bindgen_union_field: [u64; 9usize],
}
#[test]
fn bindgen_test_layout__SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1>()
               , 72usize);
    assert_eq!(::core::mem::align_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1>()
               , 8usize);
}
impl Clone for _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX() {
    assert_eq!(::core::mem::size_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX>()
               , 80usize);
    assert_eq!(::core::mem::align_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX>()
               , 8usize);
}
impl Clone for _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {
    fn clone(&self) -> Self { *self }
}
pub use self::_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX as
        SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;
pub type PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX =
    *mut _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _CPU_SET_INFORMATION_TYPE { CpuSetInformation = 0, }
pub use self::_CPU_SET_INFORMATION_TYPE as CPU_SET_INFORMATION_TYPE;
pub type PCPU_SET_INFORMATION_TYPE = *mut _CPU_SET_INFORMATION_TYPE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SYSTEM_CPU_SET_INFORMATION {
    pub Size: ULONG,
    pub Type: CPU_SET_INFORMATION_TYPE,
    pub __bindgen_anon_1: _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1 {
    pub CpuSet: __BindgenUnionField<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    pub Id: ULONG,
    pub Group: USHORT,
    pub LogicalProcessorIndex: UCHAR,
    pub CoreIndex: UCHAR,
    pub LastLevelCacheIndex: UCHAR,
    pub NumaNodeIndex: UCHAR,
    pub EfficiencyClass: UCHAR,
    pub __bindgen_anon_1: _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub Reserved: ULONG,
    pub AllocationTag: ULONG64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub AllFlags: __BindgenUnionField<UCHAR>,
    pub __bindgen_anon_1: __BindgenUnionField<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u8,
}
#[test]
fn bindgen_test_layout__SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()
               , 1usize);
    assert_eq!(::core::mem::align_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()
               , 1usize);
}
impl Clone for
 _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
 {
    fn clone(&self) -> Self { *self }
}
impl _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
 {
    #[inline]
    pub fn Parked(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                        0u32) as u8)
        }
    }
    #[inline]
    pub fn set_Parked(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 0u32) & (1usize as u8);
    }
    #[inline]
    pub fn Allocated(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u8)) >>
                                        1u32) as u8)
        }
    }
    #[inline]
    pub fn set_Allocated(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(2usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 1u32) & (2usize as u8);
    }
    #[inline]
    pub fn AllocatedToTargetProcess(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u8)) >>
                                        2u32) as u8)
        }
    }
    #[inline]
    pub fn set_AllocatedToTargetProcess(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(4usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 2u32) & (4usize as u8);
    }
    #[inline]
    pub fn RealTime(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u8)) >>
                                        3u32) as u8)
        }
    }
    #[inline]
    pub fn set_RealTime(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(8usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 3u32) & (8usize as u8);
    }
    #[inline]
    pub fn ReservedFlags(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (240usize as u8)) >>
                                        4u32) as u8)
        }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(240usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 4u32) & (240usize as u8);
    }
}
#[test]
fn bindgen_test_layout__SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()
               , 1usize);
    assert_eq!(::core::mem::align_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()
               , 1usize);
}
impl Clone for
 _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>()
               , 24usize);
    assert_eq!(::core::mem::align_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>()
               , 8usize);
}
impl Clone for _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1>()
               , 24usize);
    assert_eq!(::core::mem::align_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1>()
               , 8usize);
}
impl Clone for _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__SYSTEM_CPU_SET_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_SYSTEM_CPU_SET_INFORMATION>() ,
               32usize);
    assert_eq!(::core::mem::align_of::<_SYSTEM_CPU_SET_INFORMATION>() ,
               8usize);
}
impl Clone for _SYSTEM_CPU_SET_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_SYSTEM_CPU_SET_INFORMATION as SYSTEM_CPU_SET_INFORMATION;
pub type PSYSTEM_CPU_SET_INFORMATION = *mut _SYSTEM_CPU_SET_INFORMATION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ALTERNATIVE_ARCHITECTURE_TYPE {
    StandardDesign = 0,
    NEC98x86 = 1,
    EndAlternatives = 2,
}
pub use self::_ALTERNATIVE_ARCHITECTURE_TYPE as ALTERNATIVE_ARCHITECTURE_TYPE;
pub use self::_EXCEPTION_RECORD as EXCEPTION_RECORD;
pub type PEXCEPTION_RECORD = *mut EXCEPTION_RECORD;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _EXCEPTION_RECORD32 {
    pub ExceptionCode: NTSTATUS,
    pub ExceptionFlags: ULONG,
    pub ExceptionRecord: ULONG,
    pub ExceptionAddress: ULONG,
    pub NumberParameters: ULONG,
    pub ExceptionInformation: [ULONG; 15usize],
}
#[test]
fn bindgen_test_layout__EXCEPTION_RECORD32() {
    assert_eq!(::core::mem::size_of::<_EXCEPTION_RECORD32>() , 80usize);
    assert_eq!(::core::mem::align_of::<_EXCEPTION_RECORD32>() , 4usize);
}
impl Clone for _EXCEPTION_RECORD32 {
    fn clone(&self) -> Self { *self }
}
pub use self::_EXCEPTION_RECORD32 as EXCEPTION_RECORD32;
pub type PEXCEPTION_RECORD32 = *mut _EXCEPTION_RECORD32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _EXCEPTION_RECORD64 {
    pub ExceptionCode: NTSTATUS,
    pub ExceptionFlags: ULONG,
    pub ExceptionRecord: ULONG64,
    pub ExceptionAddress: ULONG64,
    pub NumberParameters: ULONG,
    pub __unusedAlignment: ULONG,
    pub ExceptionInformation: [ULONG64; 15usize],
}
#[test]
fn bindgen_test_layout__EXCEPTION_RECORD64() {
    assert_eq!(::core::mem::size_of::<_EXCEPTION_RECORD64>() , 152usize);
    assert_eq!(::core::mem::align_of::<_EXCEPTION_RECORD64>() , 8usize);
}
impl Clone for _EXCEPTION_RECORD64 {
    fn clone(&self) -> Self { *self }
}
pub use self::_EXCEPTION_RECORD64 as EXCEPTION_RECORD64;
pub type PEXCEPTION_RECORD64 = *mut _EXCEPTION_RECORD64;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _EXCEPTION_POINTERS {
    pub ExceptionRecord: PEXCEPTION_RECORD,
    pub ContextRecord: PCONTEXT,
}
#[test]
fn bindgen_test_layout__EXCEPTION_POINTERS() {
    assert_eq!(::core::mem::size_of::<_EXCEPTION_POINTERS>() , 16usize);
    assert_eq!(::core::mem::align_of::<_EXCEPTION_POINTERS>() , 8usize);
}
impl Clone for _EXCEPTION_POINTERS {
    fn clone(&self) -> Self { *self }
}
pub use self::_EXCEPTION_POINTERS as EXCEPTION_POINTERS;
pub type PEXCEPTION_POINTERS = *mut _EXCEPTION_POINTERS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _KINTERRUPT_MODE { LevelSensitive = 0, Latched = 1, }
pub use self::_KINTERRUPT_MODE as KINTERRUPT_MODE;
pub const _KINTERRUPT_POLARITY_InterruptRisingEdge: _KINTERRUPT_POLARITY =
    _KINTERRUPT_POLARITY::InterruptActiveHigh;
pub const _KINTERRUPT_POLARITY_InterruptFallingEdge: _KINTERRUPT_POLARITY =
    _KINTERRUPT_POLARITY::InterruptActiveLow;
pub const _KINTERRUPT_POLARITY_InterruptActiveBothTriggerLow:
          _KINTERRUPT_POLARITY =
    _KINTERRUPT_POLARITY::InterruptActiveBoth;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _KINTERRUPT_POLARITY {
    InterruptPolarityUnknown = 0,
    InterruptActiveHigh = 1,
    InterruptActiveLow = 2,
    InterruptActiveBoth = 3,
    InterruptActiveBothTriggerHigh = 4,
}
pub use self::_KINTERRUPT_POLARITY as KINTERRUPT_POLARITY;
pub type PKINTERRUPT_POLARITY = *mut _KINTERRUPT_POLARITY;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _KWAIT_REASON {
    Executive = 0,
    FreePage = 1,
    PageIn = 2,
    PoolAllocation = 3,
    DelayExecution = 4,
    Suspended = 5,
    UserRequest = 6,
    WrExecutive = 7,
    WrFreePage = 8,
    WrPageIn = 9,
    WrPoolAllocation = 10,
    WrDelayExecution = 11,
    WrSuspended = 12,
    WrUserRequest = 13,
    WrSpare0 = 14,
    WrQueue = 15,
    WrLpcReceive = 16,
    WrLpcReply = 17,
    WrVirtualMemory = 18,
    WrPageOut = 19,
    WrRendezvous = 20,
    WrKeyedEvent = 21,
    WrTerminated = 22,
    WrProcessInSwap = 23,
    WrCpuRateControl = 24,
    WrCalloutStack = 25,
    WrKernel = 26,
    WrResource = 27,
    WrPushLock = 28,
    WrMutex = 29,
    WrQuantumEnd = 30,
    WrDispatchInt = 31,
    WrPreempted = 32,
    WrYieldExecution = 33,
    WrFastMutex = 34,
    WrGuardedMutex = 35,
    WrRundown = 36,
    WrAlertByThreadId = 37,
    WrDeferredPreempt = 38,
    MaximumWaitReason = 39,
}
pub use self::_KWAIT_REASON as KWAIT_REASON;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KWAIT_BLOCK {
    pub WaitListEntry: LIST_ENTRY,
    pub WaitType: UCHAR,
    pub BlockState: UCHAR,
    pub WaitKey: USHORT,
    pub SpareLong: LONG,
    pub __bindgen_anon_1: _KWAIT_BLOCK__bindgen_ty_1,
    pub Object: PVOID,
    pub SparePtr: PVOID,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KWAIT_BLOCK__bindgen_ty_1 {
    pub Thread: __BindgenUnionField<*mut _KTHREAD>,
    pub NotificationQueue: __BindgenUnionField<*mut _KWAIT_BLOCK__bindgen_ty_1__KQUEUE>,
    pub bindgen_union_field: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KWAIT_BLOCK__bindgen_ty_1__KQUEUE {
    pub _address: u8,
}
impl Clone for _KWAIT_BLOCK__bindgen_ty_1__KQUEUE {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__KWAIT_BLOCK__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_KWAIT_BLOCK__bindgen_ty_1>() , 8usize);
    assert_eq!(::core::mem::align_of::<_KWAIT_BLOCK__bindgen_ty_1>() ,
               8usize);
}
impl Clone for _KWAIT_BLOCK__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__KWAIT_BLOCK() {
    assert_eq!(::core::mem::size_of::<_KWAIT_BLOCK>() , 48usize);
    assert_eq!(::core::mem::align_of::<_KWAIT_BLOCK>() , 8usize);
}
impl Clone for _KWAIT_BLOCK {
    fn clone(&self) -> Self { *self }
}
pub use self::_KWAIT_BLOCK as KWAIT_BLOCK;
pub type PKWAIT_BLOCK = *mut _KWAIT_BLOCK;
pub type PRKWAIT_BLOCK = *mut _KWAIT_BLOCK;
pub type KSTART_ROUTINE =
    ::core::option::Option<unsafe extern "C" fn(StartContext: PVOID)>;
pub type PKSTART_ROUTINE = KSTART_ROUTINE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KDEVICE_QUEUE {
    pub Type: CSHORT,
    pub Size: CSHORT,
    pub DeviceListHead: LIST_ENTRY,
    pub Lock: KSPIN_LOCK,
    pub Busy: BOOLEAN,
}
#[test]
fn bindgen_test_layout__KDEVICE_QUEUE() {
    assert_eq!(::core::mem::size_of::<_KDEVICE_QUEUE>() , 40usize);
    assert_eq!(::core::mem::align_of::<_KDEVICE_QUEUE>() , 8usize);
}
impl Clone for _KDEVICE_QUEUE {
    fn clone(&self) -> Self { *self }
}
pub use self::_KDEVICE_QUEUE as KDEVICE_QUEUE;
pub type PKDEVICE_QUEUE = *mut _KDEVICE_QUEUE;
pub type PRKDEVICE_QUEUE = *mut _KDEVICE_QUEUE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KDEVICE_QUEUE_ENTRY {
    pub DeviceListEntry: LIST_ENTRY,
    pub SortKey: ULONG,
    pub Inserted: BOOLEAN,
}
#[test]
fn bindgen_test_layout__KDEVICE_QUEUE_ENTRY() {
    assert_eq!(::core::mem::size_of::<_KDEVICE_QUEUE_ENTRY>() , 24usize);
    assert_eq!(::core::mem::align_of::<_KDEVICE_QUEUE_ENTRY>() , 8usize);
}
impl Clone for _KDEVICE_QUEUE_ENTRY {
    fn clone(&self) -> Self { *self }
}
pub use self::_KDEVICE_QUEUE_ENTRY as KDEVICE_QUEUE_ENTRY;
pub type PKDEVICE_QUEUE_ENTRY = *mut _KDEVICE_QUEUE_ENTRY;
pub type PRKDEVICE_QUEUE_ENTRY = *mut _KDEVICE_QUEUE_ENTRY;
pub type KSERVICE_ROUTINE =
    ::core::option::Option<unsafe extern "C" fn(Interrupt: *mut _KINTERRUPT,
                                                ServiceContext: PVOID)
                               -> BOOLEAN>;
pub type PKSERVICE_ROUTINE = KSERVICE_ROUTINE;
pub type KMESSAGE_SERVICE_ROUTINE =
    ::core::option::Option<unsafe extern "C" fn(Interrupt: *mut _KINTERRUPT,
                                                ServiceContext: PVOID,
                                                MessageID: ULONG) -> BOOLEAN>;
pub type PKMESSAGE_SERVICE_ROUTINE = KMESSAGE_SERVICE_ROUTINE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KMUTANT {
    pub Header: DISPATCHER_HEADER,
    pub MutantListEntry: LIST_ENTRY,
    pub OwnerThread: *mut _KTHREAD,
    pub Abandoned: BOOLEAN,
    pub ApcDisable: UCHAR,
}
#[test]
fn bindgen_test_layout__KMUTANT() {
    assert_eq!(::core::mem::size_of::<_KMUTANT>() , 56usize);
    assert_eq!(::core::mem::align_of::<_KMUTANT>() , 8usize);
}
impl Clone for _KMUTANT {
    fn clone(&self) -> Self { *self }
}
pub use self::_KMUTANT as KMUTANT;
pub type PKMUTANT = *mut _KMUTANT;
pub type PRKMUTANT = *mut _KMUTANT;
pub use self::_KMUTANT as KMUTEX;
pub type PKMUTEX = *mut _KMUTANT;
pub type PRKMUTEX = *mut _KMUTANT;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KSEMAPHORE {
    pub Header: DISPATCHER_HEADER,
    pub Limit: LONG,
}
#[test]
fn bindgen_test_layout__KSEMAPHORE() {
    assert_eq!(::core::mem::size_of::<_KSEMAPHORE>() , 32usize);
    assert_eq!(::core::mem::align_of::<_KSEMAPHORE>() , 8usize);
}
impl Clone for _KSEMAPHORE {
    fn clone(&self) -> Self { *self }
}
pub use self::_KSEMAPHORE as KSEMAPHORE;
pub type PKSEMAPHORE = *mut _KSEMAPHORE;
pub type PRKSEMAPHORE = *mut _KSEMAPHORE;
extern "C" {
    pub fn KeInitializeDpc(Dpc: PRKDPC, DeferredRoutine: PKDEFERRED_ROUTINE,
                           DeferredContext: PVOID);
}
extern "C" {
    pub fn KeInitializeThreadedDpc(Dpc: PRKDPC,
                                   DeferredRoutine: PKDEFERRED_ROUTINE,
                                   DeferredContext: PVOID);
}
extern "C" {
    pub fn KeInsertQueueDpc(Dpc: PRKDPC, SystemArgument1: PVOID,
                            SystemArgument2: PVOID) -> BOOLEAN;
}
extern "C" {
    pub fn KeRemoveQueueDpc(Dpc: PRKDPC) -> BOOLEAN;
}
extern "C" {
    pub fn KeRemoveQueueDpcEx(Dpc: PRKDPC, WaitIfActive: BOOLEAN) -> BOOLEAN;
}
extern "C" {
    pub fn KeInitializeCrashDumpHeader(DumpType: ULONG, Flags: ULONG,
                                       Buffer: PVOID, BufferSize: ULONG,
                                       BufferNeeded: PULONG) -> NTSTATUS;
}
extern "C" {
    pub fn KeSetImportanceDpc(Dpc: PRKDPC, Importance: KDPC_IMPORTANCE);
}
extern "C" {
    pub fn KeSetTargetProcessorDpc(Dpc: PRKDPC, Number: CCHAR);
}
extern "C" {
    pub fn KeFlushQueuedDpcs();
}
extern "C" {
    pub fn KeInitializeDeviceQueue(DeviceQueue: PKDEVICE_QUEUE);
}
extern "C" {
    pub fn KeInsertDeviceQueue(DeviceQueue: PKDEVICE_QUEUE,
                               DeviceQueueEntry: PKDEVICE_QUEUE_ENTRY)
     -> BOOLEAN;
}
extern "C" {
    pub fn KeInsertByKeyDeviceQueue(DeviceQueue: PKDEVICE_QUEUE,
                                    DeviceQueueEntry: PKDEVICE_QUEUE_ENTRY,
                                    SortKey: ULONG) -> BOOLEAN;
}
extern "C" {
    pub fn KeRemoveDeviceQueue(DeviceQueue: PKDEVICE_QUEUE)
     -> PKDEVICE_QUEUE_ENTRY;
}
extern "C" {
    pub fn KeRemoveByKeyDeviceQueue(DeviceQueue: PKDEVICE_QUEUE,
                                    SortKey: ULONG) -> PKDEVICE_QUEUE_ENTRY;
}
extern "C" {
    pub fn KeRemoveByKeyDeviceQueueIfBusy(DeviceQueue: PKDEVICE_QUEUE,
                                          SortKey: ULONG)
     -> PKDEVICE_QUEUE_ENTRY;
}
extern "C" {
    pub fn KeRemoveEntryDeviceQueue(DeviceQueue: PKDEVICE_QUEUE,
                                    DeviceQueueEntry: PKDEVICE_QUEUE_ENTRY)
     -> BOOLEAN;
}
extern "C" {
    pub fn KeSynchronizeExecution(Interrupt: PKINTERRUPT,
                                  SynchronizeRoutine: PKSYNCHRONIZE_ROUTINE,
                                  SynchronizeContext: PVOID) -> BOOLEAN;
}
extern "C" {
    pub fn KeAcquireInterruptSpinLock(Interrupt: PKINTERRUPT) -> KIRQL;
}
extern "C" {
    pub fn KeReleaseInterruptSpinLock(Interrupt: PKINTERRUPT, OldIrql: KIRQL);
}
extern "C" {
    pub fn KeInitializeEvent(Event: PRKEVENT, Type: EVENT_TYPE,
                             State: BOOLEAN);
}
extern "C" {
    pub fn KeClearEvent(Event: PRKEVENT);
}
extern "C" {
    pub fn KeReadStateEvent(Event: PRKEVENT) -> LONG;
}
extern "C" {
    pub fn KeResetEvent(Event: PRKEVENT) -> LONG;
}
extern "C" {
    pub fn KeSetEvent(Event: PRKEVENT, Increment: KPRIORITY, Wait: BOOLEAN)
     -> LONG;
}
extern "C" {
    pub fn KeInitializeMutex(Mutex: PRKMUTEX, Level: ULONG);
}
extern "C" {
    pub fn KeReadStateMutex(Mutex: PRKMUTEX) -> LONG;
}
extern "C" {
    pub fn KeReleaseMutex(Mutex: PRKMUTEX, Wait: BOOLEAN) -> LONG;
}
extern "C" {
    pub fn KeInitializeSemaphore(Semaphore: PRKSEMAPHORE, Count: LONG,
                                 Limit: LONG);
}
extern "C" {
    pub fn KeReadStateSemaphore(Semaphore: PRKSEMAPHORE) -> LONG;
}
extern "C" {
    pub fn KeReleaseSemaphore(Semaphore: PRKSEMAPHORE, Increment: KPRIORITY,
                              Adjustment: LONG, Wait: BOOLEAN) -> LONG;
}
extern "C" {
    pub fn KeDelayExecutionThread(WaitMode: KPROCESSOR_MODE,
                                  Alertable: BOOLEAN,
                                  Interval: PLARGE_INTEGER) -> NTSTATUS;
}
extern "C" {
    pub fn KeQueryPriorityThread(Thread: PKTHREAD) -> KPRIORITY;
}
extern "C" {
    pub fn KeQueryRuntimeThread(Thread: PKTHREAD, UserTime: PULONG) -> ULONG;
}
extern "C" {
    pub fn KeQueryTotalCycleTimeThread(Thread: PKTHREAD,
                                       CycleTimeStamp: PULONG64) -> ULONG64;
}
extern "C" {
    pub fn KeSetTargetProcessorDpcEx(Dpc: PKDPC,
                                     ProcNumber: PPROCESSOR_NUMBER)
     -> NTSTATUS;
}
extern "C" {
    pub fn KeRevertToUserAffinityThread();
}
extern "C" {
    pub fn KeSetSystemAffinityThread(Affinity: KAFFINITY);
}
extern "C" {
    pub fn KeRevertToUserAffinityThreadEx(Affinity: KAFFINITY);
}
extern "C" {
    pub fn KeSetSystemGroupAffinityThread(Affinity: PGROUP_AFFINITY,
                                          PreviousAffinity: PGROUP_AFFINITY);
}
extern "C" {
    pub fn KeRevertToUserGroupAffinityThread(PreviousAffinity:
                                                 PGROUP_AFFINITY);
}
extern "C" {
    pub fn KeSetSystemAffinityThreadEx(Affinity: KAFFINITY) -> KAFFINITY;
}
extern "C" {
    pub fn KeSetPriorityThread(Thread: PKTHREAD, Priority: KPRIORITY)
     -> KPRIORITY;
}
extern "C" {
    pub fn KeEnterCriticalRegion();
}
extern "C" {
    pub fn KeLeaveCriticalRegion();
}
extern "C" {
    pub fn KeEnterGuardedRegion();
}
extern "C" {
    pub fn KeLeaveGuardedRegion();
}
extern "C" {
    pub fn KeAreApcsDisabled() -> BOOLEAN;
}
extern "C" {
    pub fn KeInitializeTimer(Timer: PKTIMER);
}
extern "C" {
    pub fn KeInitializeTimerEx(Timer: PKTIMER, Type: TIMER_TYPE);
}
extern "C" {
    pub fn KeCancelTimer(arg1: PKTIMER) -> BOOLEAN;
}
extern "C" {
    pub fn KeReadStateTimer(Timer: PKTIMER) -> BOOLEAN;
}
extern "C" {
    pub fn KeSetTimer(Timer: PKTIMER, DueTime: LARGE_INTEGER, Dpc: PKDPC)
     -> BOOLEAN;
}
extern "C" {
    pub fn KeSetTimerEx(Timer: PKTIMER, DueTime: LARGE_INTEGER, Period: LONG,
                        Dpc: PKDPC) -> BOOLEAN;
}
extern "C" {
    pub fn KeSetCoalescableTimer(Timer: PKTIMER, DueTime: LARGE_INTEGER,
                                 Period: ULONG, TolerableDelay: ULONG,
                                 Dpc: PKDPC) -> BOOLEAN;
}
extern "C" {
    pub fn KeWaitForMultipleObjects(Count: ULONG, Object: *mut PVOID,
                                    WaitType: WAIT_TYPE,
                                    WaitReason: KWAIT_REASON,
                                    WaitMode: KPROCESSOR_MODE,
                                    Alertable: BOOLEAN,
                                    Timeout: PLARGE_INTEGER,
                                    WaitBlockArray: PKWAIT_BLOCK) -> NTSTATUS;
}
extern "C" {
    pub fn KeWaitForSingleObject(Object: PVOID, WaitReason: KWAIT_REASON,
                                 WaitMode: KPROCESSOR_MODE,
                                 Alertable: BOOLEAN, Timeout: PLARGE_INTEGER)
     -> NTSTATUS;
}
pub type KIPI_BROADCAST_WORKER =
    ::core::option::Option<unsafe extern "C" fn(Argument: ULONG_PTR)
                               -> ULONG_PTR>;
pub type PKIPI_BROADCAST_WORKER = KIPI_BROADCAST_WORKER;
extern "C" {
    pub fn KeIpiGenericCall(BroadcastFunction: PKIPI_BROADCAST_WORKER,
                            Context: ULONG_PTR) -> ULONG_PTR;
}
extern "C" {
    pub fn KeInitializeSpinLock(SpinLock: PKSPIN_LOCK);
}
extern "C" {
    pub fn KeTestSpinLock(SpinLock: PKSPIN_LOCK) -> BOOLEAN;
}
extern "C" {
    pub fn KeTryToAcquireSpinLockAtDpcLevel(SpinLock: PKSPIN_LOCK) -> BOOLEAN;
}
extern "C" {
    pub fn KefAcquireSpinLockAtDpcLevel(SpinLock: PKSPIN_LOCK);
}
extern "C" {
    pub fn KefReleaseSpinLockFromDpcLevel(SpinLock: PKSPIN_LOCK);
}
extern "C" {
    pub fn KfAcquireSpinLock(SpinLock: PKSPIN_LOCK) -> KIRQL;
}
extern "C" {
    pub fn KfReleaseSpinLock(SpinLock: PKSPIN_LOCK, NewIrql: KIRQL);
}
extern "C" {
    pub fn KeAcquireSpinLockForDpc(SpinLock: PKSPIN_LOCK) -> KIRQL;
}
extern "C" {
    pub fn KeReleaseSpinLockForDpc(SpinLock: PKSPIN_LOCK, OldIrql: KIRQL);
}
extern "C" {
    pub fn KeAcquireInStackQueuedSpinLock(SpinLock: PKSPIN_LOCK,
                                          LockHandle: PKLOCK_QUEUE_HANDLE);
}
extern "C" {
    pub fn KeReleaseInStackQueuedSpinLock(LockHandle: PKLOCK_QUEUE_HANDLE);
}
extern "C" {
    pub fn KeAcquireInStackQueuedSpinLockAtDpcLevel(SpinLock: PKSPIN_LOCK,
                                                    LockHandle:
                                                        PKLOCK_QUEUE_HANDLE);
}
extern "C" {
    pub fn KeReleaseInStackQueuedSpinLockFromDpcLevel(LockHandle:
                                                          PKLOCK_QUEUE_HANDLE);
}
extern "C" {
    pub fn KeAcquireInStackQueuedSpinLockForDpc(SpinLock: PKSPIN_LOCK,
                                                LockHandle:
                                                    PKLOCK_QUEUE_HANDLE);
}
extern "C" {
    pub fn KeReleaseInStackQueuedSpinLockForDpc(LockHandle:
                                                    PKLOCK_QUEUE_HANDLE);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KDPC_WATCHDOG_INFORMATION {
    pub DpcTimeLimit: ULONG,
    pub DpcTimeCount: ULONG,
    pub DpcWatchdogLimit: ULONG,
    pub DpcWatchdogCount: ULONG,
    pub Reserved: ULONG,
}
#[test]
fn bindgen_test_layout__KDPC_WATCHDOG_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_KDPC_WATCHDOG_INFORMATION>() ,
               20usize);
    assert_eq!(::core::mem::align_of::<_KDPC_WATCHDOG_INFORMATION>() ,
               4usize);
}
impl Clone for _KDPC_WATCHDOG_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_KDPC_WATCHDOG_INFORMATION as KDPC_WATCHDOG_INFORMATION;
pub type PKDPC_WATCHDOG_INFORMATION = *mut _KDPC_WATCHDOG_INFORMATION;
extern "C" {
    pub fn KeQueryDpcWatchdogInformation(WatchdogInformation:
                                             PKDPC_WATCHDOG_INFORMATION)
     -> NTSTATUS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _KBUGCHECK_BUFFER_DUMP_STATE {
    BufferEmpty = 0,
    BufferInserted = 1,
    BufferStarted = 2,
    BufferFinished = 3,
    BufferIncomplete = 4,
}
pub use self::_KBUGCHECK_BUFFER_DUMP_STATE as KBUGCHECK_BUFFER_DUMP_STATE;
pub type KBUGCHECK_CALLBACK_ROUTINE =
    ::core::option::Option<unsafe extern "C" fn(Buffer: PVOID,
                                                Length: ULONG)>;
pub type PKBUGCHECK_CALLBACK_ROUTINE = KBUGCHECK_CALLBACK_ROUTINE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KBUGCHECK_CALLBACK_RECORD {
    pub Entry: LIST_ENTRY,
    pub CallbackRoutine: PKBUGCHECK_CALLBACK_ROUTINE,
    pub Buffer: PVOID,
    pub Length: ULONG,
    pub Component: PUCHAR,
    pub Checksum: ULONG_PTR,
    pub State: UCHAR,
}
#[test]
fn bindgen_test_layout__KBUGCHECK_CALLBACK_RECORD() {
    assert_eq!(::core::mem::size_of::<_KBUGCHECK_CALLBACK_RECORD>() ,
               64usize);
    assert_eq!(::core::mem::align_of::<_KBUGCHECK_CALLBACK_RECORD>() ,
               8usize);
}
impl Clone for _KBUGCHECK_CALLBACK_RECORD {
    fn clone(&self) -> Self { *self }
}
pub use self::_KBUGCHECK_CALLBACK_RECORD as KBUGCHECK_CALLBACK_RECORD;
pub type PKBUGCHECK_CALLBACK_RECORD = *mut _KBUGCHECK_CALLBACK_RECORD;
extern "C" {
    pub fn KeDeregisterBugCheckCallback(CallbackRecord:
                                            PKBUGCHECK_CALLBACK_RECORD)
     -> BOOLEAN;
}
extern "C" {
    pub fn KeRegisterBugCheckCallback(CallbackRecord:
                                          PKBUGCHECK_CALLBACK_RECORD,
                                      CallbackRoutine:
                                          PKBUGCHECK_CALLBACK_ROUTINE,
                                      Buffer: PVOID, Length: ULONG,
                                      Component: PUCHAR) -> BOOLEAN;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _KBUGCHECK_CALLBACK_REASON {
    KbCallbackInvalid = 0,
    KbCallbackReserved1 = 1,
    KbCallbackSecondaryDumpData = 2,
    KbCallbackDumpIo = 3,
    KbCallbackAddPages = 4,
    KbCallbackSecondaryMultiPartDumpData = 5,
    KbCallbackRemovePages = 6,
}
pub use self::_KBUGCHECK_CALLBACK_REASON as KBUGCHECK_CALLBACK_REASON;
pub type KBUGCHECK_REASON_CALLBACK_ROUTINE =
    ::core::option::Option<unsafe extern "C" fn(Reason:
                                                    KBUGCHECK_CALLBACK_REASON,
                                                Record:
                                                    *mut _KBUGCHECK_REASON_CALLBACK_RECORD,
                                                ReasonSpecificData: PVOID,
                                                ReasonSpecificDataLength:
                                                    ULONG)>;
pub type PKBUGCHECK_REASON_CALLBACK_ROUTINE =
    KBUGCHECK_REASON_CALLBACK_ROUTINE;
extern "C" {
    pub fn BugCheckSecondaryMultiPartDumpDataCallback(Reason:
                                                          KBUGCHECK_CALLBACK_REASON,
                                                      Record:
                                                          *mut _KBUGCHECK_REASON_CALLBACK_RECORD,
                                                      ReasonSpecificData:
                                                          PVOID,
                                                      ReasonSpecificDataLength:
                                                          ULONG);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KBUGCHECK_REASON_CALLBACK_RECORD {
    pub Entry: LIST_ENTRY,
    pub CallbackRoutine: PKBUGCHECK_REASON_CALLBACK_ROUTINE,
    pub Component: PUCHAR,
    pub Checksum: ULONG_PTR,
    pub Reason: KBUGCHECK_CALLBACK_REASON,
    pub State: UCHAR,
}
#[test]
fn bindgen_test_layout__KBUGCHECK_REASON_CALLBACK_RECORD() {
    assert_eq!(::core::mem::size_of::<_KBUGCHECK_REASON_CALLBACK_RECORD>() ,
               48usize);
    assert_eq!(::core::mem::align_of::<_KBUGCHECK_REASON_CALLBACK_RECORD>() ,
               8usize);
}
impl Clone for _KBUGCHECK_REASON_CALLBACK_RECORD {
    fn clone(&self) -> Self { *self }
}
pub use self::_KBUGCHECK_REASON_CALLBACK_RECORD as
        KBUGCHECK_REASON_CALLBACK_RECORD;
pub type PKBUGCHECK_REASON_CALLBACK_RECORD =
    *mut _KBUGCHECK_REASON_CALLBACK_RECORD;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KBUGCHECK_SECONDARY_DUMP_DATA {
    pub InBuffer: PVOID,
    pub InBufferLength: ULONG,
    pub MaximumAllowed: ULONG,
    pub Guid: GUID,
    pub OutBuffer: PVOID,
    pub OutBufferLength: ULONG,
}
#[test]
fn bindgen_test_layout__KBUGCHECK_SECONDARY_DUMP_DATA() {
    assert_eq!(::core::mem::size_of::<_KBUGCHECK_SECONDARY_DUMP_DATA>() ,
               48usize);
    assert_eq!(::core::mem::align_of::<_KBUGCHECK_SECONDARY_DUMP_DATA>() ,
               8usize);
}
impl Clone for _KBUGCHECK_SECONDARY_DUMP_DATA {
    fn clone(&self) -> Self { *self }
}
pub use self::_KBUGCHECK_SECONDARY_DUMP_DATA as KBUGCHECK_SECONDARY_DUMP_DATA;
pub type PKBUGCHECK_SECONDARY_DUMP_DATA = *mut _KBUGCHECK_SECONDARY_DUMP_DATA;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KBUGCHECK_SECONDARY_DUMP_DATA_EX {
    pub InBuffer: PVOID,
    pub InBufferLength: ULONG,
    pub MaximumAllowed: ULONG,
    pub Guid: GUID,
    pub OutBuffer: PVOID,
    pub OutBufferLength: ULONG,
    pub Context: PVOID,
    pub Flags: ULONG,
    pub DumpType: ULONG,
    pub BugCheckCode: ULONG,
    pub BugCheckParameter1: ULONG_PTR,
    pub BugCheckParameter2: ULONG_PTR,
    pub BugCheckParameter3: ULONG_PTR,
    pub BugCheckParameter4: ULONG_PTR,
}
#[test]
fn bindgen_test_layout__KBUGCHECK_SECONDARY_DUMP_DATA_EX() {
    assert_eq!(::core::mem::size_of::<_KBUGCHECK_SECONDARY_DUMP_DATA_EX>() ,
               104usize);
    assert_eq!(::core::mem::align_of::<_KBUGCHECK_SECONDARY_DUMP_DATA_EX>() ,
               8usize);
}
impl Clone for _KBUGCHECK_SECONDARY_DUMP_DATA_EX {
    fn clone(&self) -> Self { *self }
}
pub use self::_KBUGCHECK_SECONDARY_DUMP_DATA_EX as
        KBUGCHECK_SECONDARY_DUMP_DATA_EX;
pub type PKBUGCHECK_SECONDARY_DUMP_DATA_EX =
    *mut _KBUGCHECK_SECONDARY_DUMP_DATA_EX;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _KBUGCHECK_DUMP_IO_TYPE {
    KbDumpIoInvalid = 0,
    KbDumpIoHeader = 1,
    KbDumpIoBody = 2,
    KbDumpIoSecondaryData = 3,
    KbDumpIoComplete = 4,
}
pub use self::_KBUGCHECK_DUMP_IO_TYPE as KBUGCHECK_DUMP_IO_TYPE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KBUGCHECK_DUMP_IO {
    pub Offset: ULONG64,
    pub Buffer: PVOID,
    pub BufferLength: ULONG,
    pub Type: KBUGCHECK_DUMP_IO_TYPE,
}
#[test]
fn bindgen_test_layout__KBUGCHECK_DUMP_IO() {
    assert_eq!(::core::mem::size_of::<_KBUGCHECK_DUMP_IO>() , 24usize);
    assert_eq!(::core::mem::align_of::<_KBUGCHECK_DUMP_IO>() , 8usize);
}
impl Clone for _KBUGCHECK_DUMP_IO {
    fn clone(&self) -> Self { *self }
}
pub use self::_KBUGCHECK_DUMP_IO as KBUGCHECK_DUMP_IO;
pub type PKBUGCHECK_DUMP_IO = *mut _KBUGCHECK_DUMP_IO;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KBUGCHECK_ADD_PAGES {
    pub Context: PVOID,
    pub Flags: ULONG,
    pub BugCheckCode: ULONG,
    pub Address: ULONG_PTR,
    pub Count: ULONG_PTR,
}
#[test]
fn bindgen_test_layout__KBUGCHECK_ADD_PAGES() {
    assert_eq!(::core::mem::size_of::<_KBUGCHECK_ADD_PAGES>() , 32usize);
    assert_eq!(::core::mem::align_of::<_KBUGCHECK_ADD_PAGES>() , 8usize);
}
impl Clone for _KBUGCHECK_ADD_PAGES {
    fn clone(&self) -> Self { *self }
}
pub use self::_KBUGCHECK_ADD_PAGES as KBUGCHECK_ADD_PAGES;
pub type PKBUGCHECK_ADD_PAGES = *mut _KBUGCHECK_ADD_PAGES;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KBUGCHECK_REMOVE_PAGES {
    pub Context: PVOID,
    pub Flags: ULONG,
    pub BugCheckCode: ULONG,
    pub Address: ULONG_PTR,
    pub Count: ULONG_PTR,
}
#[test]
fn bindgen_test_layout__KBUGCHECK_REMOVE_PAGES() {
    assert_eq!(::core::mem::size_of::<_KBUGCHECK_REMOVE_PAGES>() , 32usize);
    assert_eq!(::core::mem::align_of::<_KBUGCHECK_REMOVE_PAGES>() , 8usize);
}
impl Clone for _KBUGCHECK_REMOVE_PAGES {
    fn clone(&self) -> Self { *self }
}
pub use self::_KBUGCHECK_REMOVE_PAGES as KBUGCHECK_REMOVE_PAGES;
pub type PKBUGCHECK_REMOVE_PAGES = *mut _KBUGCHECK_REMOVE_PAGES;
extern "C" {
    pub fn KeDeregisterBugCheckReasonCallback(CallbackRecord:
                                                  PKBUGCHECK_REASON_CALLBACK_RECORD)
     -> BOOLEAN;
}
extern "C" {
    pub fn KeRegisterBugCheckReasonCallback(CallbackRecord:
                                                PKBUGCHECK_REASON_CALLBACK_RECORD,
                                            CallbackRoutine:
                                                PKBUGCHECK_REASON_CALLBACK_ROUTINE,
                                            Reason: KBUGCHECK_CALLBACK_REASON,
                                            Component: PUCHAR) -> BOOLEAN;
}
pub type NMI_CALLBACK =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                Handled: BOOLEAN) -> BOOLEAN>;
pub type PNMI_CALLBACK = NMI_CALLBACK;
extern "C" {
    pub fn KeRegisterNmiCallback(CallbackRoutine: PNMI_CALLBACK,
                                 Context: PVOID) -> PVOID;
}
extern "C" {
    pub fn KeDeregisterNmiCallback(Handle: PVOID) -> NTSTATUS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _BOUND_CALLBACK_STATUS {
    BoundExceptionContinueSearch = 0,
    BoundExceptionHandled = 1,
    BoundExceptionError = 2,
    BoundExceptionMaximum = 3,
}
pub use self::_BOUND_CALLBACK_STATUS as BOUND_CALLBACK_STATUS;
pub type PBOUND_CALLBACK_STATUS = *mut _BOUND_CALLBACK_STATUS;
pub type BOUND_CALLBACK =
    ::core::option::Option<unsafe extern "C" fn() -> BOUND_CALLBACK_STATUS>;
pub type PBOUND_CALLBACK = BOUND_CALLBACK;
extern "C" {
    pub fn KeRegisterBoundCallback(CallbackRoutine: PBOUND_CALLBACK) -> PVOID;
}
extern "C" {
    pub fn KeDeregisterBoundCallback(Handle: PVOID) -> NTSTATUS;
}
extern "C" {
    pub fn KeBugCheckEx(BugCheckCode: ULONG, BugCheckParameter1: ULONG_PTR,
                        BugCheckParameter2: ULONG_PTR,
                        BugCheckParameter3: ULONG_PTR,
                        BugCheckParameter4: ULONG_PTR);
}
extern "C" {
    pub fn KeQueryInterruptTime() -> ULONGLONG;
}
extern "C" {
    pub fn KeQuerySystemTime(CurrentTime: PLARGE_INTEGER);
}
extern "C" {
    pub fn KeQuerySystemTimePrecise(CurrentTime: PLARGE_INTEGER);
}
extern "C" {
    pub fn KeQueryInterruptTimePrecise(QpcTimeStamp: PULONG64) -> ULONG64;
}
extern "C" {
    pub fn KeQueryUnbiasedInterruptTimePrecise(QpcTimeStamp: PULONG64)
     -> ULONG64;
}
extern "C" {
    pub fn KeQueryTimeIncrement() -> ULONG;
}
extern "C" {
    pub fn KeQueryUnbiasedInterruptTime() -> ULONGLONG;
}
extern "C" {
    pub fn KeGetRecommendedSharedDataAlignment() -> ULONG;
}
extern "C" {
    pub fn KeQueryActiveProcessors() -> KAFFINITY;
}
extern "C" {
    pub fn KeQueryActiveProcessorCount(ActiveProcessors: PKAFFINITY) -> ULONG;
}
extern "C" {
    pub fn KeQueryActiveProcessorCountEx(GroupNumber: USHORT) -> ULONG;
}
extern "C" {
    pub fn KeQueryMaximumProcessorCount() -> ULONG;
}
extern "C" {
    pub fn KeQueryMaximumProcessorCountEx(GroupNumber: USHORT) -> ULONG;
}
extern "C" {
    pub fn KeQueryActiveGroupCount() -> USHORT;
}
extern "C" {
    pub fn KeQueryMaximumGroupCount() -> USHORT;
}
extern "C" {
    pub fn KeQueryGroupAffinity(GroupNumber: USHORT) -> KAFFINITY;
}
extern "C" {
    pub fn KeGetCurrentProcessorNumberEx(ProcNumber: PPROCESSOR_NUMBER)
     -> ULONG;
}
extern "C" {
    pub fn KeQueryNodeActiveAffinity(NodeNumber: USHORT,
                                     Affinity: PGROUP_AFFINITY,
                                     Count: PUSHORT);
}
extern "C" {
    pub fn KeQueryNodeMaximumProcessorCount(NodeNumber: USHORT) -> USHORT;
}
extern "C" {
    pub fn KeQueryHighestNodeNumber() -> USHORT;
}
extern "C" {
    pub fn KeGetCurrentNodeNumber() -> USHORT;
}
extern "C" {
    pub fn KeQueryLogicalProcessorRelationship(ProcessorNumber:
                                                   PPROCESSOR_NUMBER,
                                               RelationshipType:
                                                   LOGICAL_PROCESSOR_RELATIONSHIP,
                                               Information:
                                                   PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX,
                                               Length: PULONG) -> NTSTATUS;
}
extern "C" {
    pub fn KeShouldYieldProcessor() -> LOGICAL;
}
extern "C" {
    #[link_name = "KeTickCount"]
    pub static mut KeTickCount: KSYSTEM_TIME;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _MEMORY_CACHING_TYPE_ORIG { MmFrameBufferCached = 2, }
pub use self::_MEMORY_CACHING_TYPE_ORIG as MEMORY_CACHING_TYPE_ORIG;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _MEMORY_CACHING_TYPE {
    MmNonCached = 0,
    MmCached = 1,
    MmWriteCombined = 2,
    MmHardwareCoherentCached = 3,
    MmNonCachedUnordered = 4,
    MmUSWCCached = 5,
    MmMaximumCacheType = 6,
    MmNotMapped = -1,
}
pub use self::_MEMORY_CACHING_TYPE as MEMORY_CACHING_TYPE;
extern "C" {
    pub fn KeAreAllApcsDisabled() -> BOOLEAN;
}
extern "C" {
    pub fn KeInitializeGuardedMutex(Mutex: PKGUARDED_MUTEX);
}
extern "C" {
    pub fn KeAcquireGuardedMutex(Mutex: PKGUARDED_MUTEX);
}
extern "C" {
    pub fn KeReleaseGuardedMutex(Mutex: PKGUARDED_MUTEX);
}
extern "C" {
    pub fn KeTryToAcquireGuardedMutex(Mutex: PKGUARDED_MUTEX) -> BOOLEAN;
}
extern "C" {
    pub fn KeAcquireGuardedMutexUnsafe(FastMutex: PKGUARDED_MUTEX);
}
extern "C" {
    pub fn KeReleaseGuardedMutexUnsafe(FastMutex: PKGUARDED_MUTEX);
}
pub const KeProcessorAddStartNotify: _bindgen_ty_12 =
    _bindgen_ty_12::KeProcessorAddStartNotify;
pub const KeProcessorAddCompleteNotify: _bindgen_ty_12 =
    _bindgen_ty_12::KeProcessorAddCompleteNotify;
pub const KeProcessorAddFailureNotify: _bindgen_ty_12 =
    _bindgen_ty_12::KeProcessorAddFailureNotify;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_12 {
    KeProcessorAddStartNotify = 0,
    KeProcessorAddCompleteNotify = 1,
    KeProcessorAddFailureNotify = 2,
}
pub use self::_bindgen_ty_12 as KE_PROCESSOR_CHANGE_NOTIFY_STATE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KE_PROCESSOR_CHANGE_NOTIFY_CONTEXT {
    pub State: KE_PROCESSOR_CHANGE_NOTIFY_STATE,
    pub NtNumber: ULONG,
    pub Status: NTSTATUS,
    pub ProcNumber: PROCESSOR_NUMBER,
}
#[test]
fn bindgen_test_layout__KE_PROCESSOR_CHANGE_NOTIFY_CONTEXT() {
    assert_eq!(::core::mem::size_of::<_KE_PROCESSOR_CHANGE_NOTIFY_CONTEXT>() ,
               16usize);
    assert_eq!(::core::mem::align_of::<_KE_PROCESSOR_CHANGE_NOTIFY_CONTEXT>()
               , 4usize);
}
impl Clone for _KE_PROCESSOR_CHANGE_NOTIFY_CONTEXT {
    fn clone(&self) -> Self { *self }
}
pub use self::_KE_PROCESSOR_CHANGE_NOTIFY_CONTEXT as
        KE_PROCESSOR_CHANGE_NOTIFY_CONTEXT;
pub type PKE_PROCESSOR_CHANGE_NOTIFY_CONTEXT =
    *mut _KE_PROCESSOR_CHANGE_NOTIFY_CONTEXT;
pub type PROCESSOR_CALLBACK_FUNCTION =
    ::core::option::Option<unsafe extern "C" fn(CallbackContext: PVOID,
                                                ChangeContext:
                                                    PKE_PROCESSOR_CHANGE_NOTIFY_CONTEXT,
                                                OperationStatus: PNTSTATUS)>;
pub type PPROCESSOR_CALLBACK_FUNCTION = PROCESSOR_CALLBACK_FUNCTION;
extern "C" {
    pub fn KeRegisterProcessorChangeCallback(CallbackFunction:
                                                 PPROCESSOR_CALLBACK_FUNCTION,
                                             CallbackContext: PVOID,
                                             Flags: ULONG) -> PVOID;
}
extern "C" {
    pub fn KeDeregisterProcessorChangeCallback(CallbackHandle: PVOID);
}
extern "C" {
    pub fn KeGetProcessorNumberFromIndex(ProcIndex: ULONG,
                                         ProcNumber: PPROCESSOR_NUMBER)
     -> NTSTATUS;
}
extern "C" {
    pub fn KeGetProcessorIndexFromNumber(ProcNumber: PPROCESSOR_NUMBER)
     -> ULONG;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _XSTATE_SAVE {
    pub __bindgen_anon_1: _XSTATE_SAVE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _XSTATE_SAVE__bindgen_ty_1 {
    pub __bindgen_anon_1: __BindgenUnionField<_XSTATE_SAVE__bindgen_ty_1__bindgen_ty_1>,
    pub XStateContext: __BindgenUnionField<XSTATE_CONTEXT>,
    pub bindgen_union_field: [u64; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _XSTATE_SAVE__bindgen_ty_1__bindgen_ty_1 {
    pub Reserved1: LONG64,
    pub Reserved2: ULONG,
    pub Prev: *mut _XSTATE_SAVE,
    pub Reserved3: PXSAVE_AREA,
    pub Thread: *mut _KTHREAD,
    pub Reserved4: PVOID,
    pub Level: UCHAR,
}
#[test]
fn bindgen_test_layout__XSTATE_SAVE__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_XSTATE_SAVE__bindgen_ty_1__bindgen_ty_1>()
               , 56usize);
    assert_eq!(::core::mem::align_of::<_XSTATE_SAVE__bindgen_ty_1__bindgen_ty_1>()
               , 8usize);
}
impl Clone for _XSTATE_SAVE__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__XSTATE_SAVE__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_XSTATE_SAVE__bindgen_ty_1>() ,
               56usize);
    assert_eq!(::core::mem::align_of::<_XSTATE_SAVE__bindgen_ty_1>() ,
               8usize);
}
impl Clone for _XSTATE_SAVE__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__XSTATE_SAVE() {
    assert_eq!(::core::mem::size_of::<_XSTATE_SAVE>() , 56usize);
    assert_eq!(::core::mem::align_of::<_XSTATE_SAVE>() , 8usize);
}
impl Clone for _XSTATE_SAVE {
    fn clone(&self) -> Self { *self }
}
pub use self::_XSTATE_SAVE as XSTATE_SAVE;
pub type PXSTATE_SAVE = *mut _XSTATE_SAVE;
extern "C" {
    pub fn KeSaveExtendedProcessorState(Mask: ULONG64,
                                        XStateSave: PXSTATE_SAVE) -> NTSTATUS;
}
extern "C" {
    pub fn KeRestoreExtendedProcessorState(XStateSave: PXSTATE_SAVE);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _EXT_SET_PARAMETERS_V0 {
    pub Version: ULONG,
    pub Reserved: ULONG,
    pub NoWakeTolerance: LONGLONG,
}
#[test]
fn bindgen_test_layout__EXT_SET_PARAMETERS_V0() {
    assert_eq!(::core::mem::size_of::<_EXT_SET_PARAMETERS_V0>() , 16usize);
    assert_eq!(::core::mem::align_of::<_EXT_SET_PARAMETERS_V0>() , 8usize);
}
impl Clone for _EXT_SET_PARAMETERS_V0 {
    fn clone(&self) -> Self { *self }
}
pub use self::_EXT_SET_PARAMETERS_V0 as EXT_SET_PARAMETERS;
pub type PEXT_SET_PARAMETERS = *mut _EXT_SET_PARAMETERS_V0;
pub use self::EXT_SET_PARAMETERS as KT2_SET_PARAMETERS;
pub type PKT2_SET_PARAMETERS = *mut EXT_SET_PARAMETERS;
extern "C" {
    pub fn KeConvertAuxiliaryCounterToPerformanceCounter(AuxiliaryCounterValue:
                                                             ULONG64,
                                                         PerformanceCounterValue:
                                                             PULONG64,
                                                         ConversionError:
                                                             PULONG64)
     -> NTSTATUS;
}
extern "C" {
    pub fn KeConvertPerformanceCounterToAuxiliaryCounter(PerformanceCounterValue:
                                                             ULONG64,
                                                         AuxiliaryCounterValue:
                                                             PULONG64,
                                                         ConversionError:
                                                             PULONG64)
     -> NTSTATUS;
}
extern "C" {
    pub fn KeQueryAuxiliaryCounterFrequency(AuxiliaryCounterFrequency:
                                                PULONG64) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KWAIT_CHAIN {
    pub Head: SINGLE_LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__KWAIT_CHAIN() {
    assert_eq!(::core::mem::size_of::<_KWAIT_CHAIN>() , 8usize);
    assert_eq!(::core::mem::align_of::<_KWAIT_CHAIN>() , 8usize);
}
impl Clone for _KWAIT_CHAIN {
    fn clone(&self) -> Self { *self }
}
pub use self::_KWAIT_CHAIN as KWAIT_CHAIN;
pub type PKWAIT_CHAIN = *mut _KWAIT_CHAIN;
extern "C" {
    #[link_name = "KdDebuggerNotPresent"]
    pub static mut KdDebuggerNotPresent: PBOOLEAN;
}
extern "C" {
    #[link_name = "KdDebuggerEnabled"]
    pub static mut KdDebuggerEnabled: PBOOLEAN;
}
extern "C" {
    pub fn KdDisableDebugger() -> NTSTATUS;
}
extern "C" {
    pub fn KdEnableDebugger() -> NTSTATUS;
}
extern "C" {
    pub fn KdRefreshDebuggerNotPresent() -> BOOLEAN;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _KD_OPTION { KD_OPTION_SET_BLOCK_ENABLE = 0, }
pub use self::_KD_OPTION as KD_OPTION;
extern "C" {
    pub fn KdChangeOption(Option: KD_OPTION, InBufferBytes: ULONG,
                          InBuffer: PVOID, OutBufferBytes: ULONG,
                          OutBuffer: PVOID, OutBufferNeeded: PULONG)
     -> NTSTATUS;
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _POOL_TYPE { }
extern "C" {
    pub fn ExAllocatePool(PoolType: POOL_TYPE, NumberOfBytes: SIZE_T)
     -> PVOID;
}
extern "C" {
    pub fn ExAllocatePoolWithQuota(PoolType: POOL_TYPE, NumberOfBytes: SIZE_T)
     -> PVOID;
}
extern "C" {
    pub fn ExAllocatePoolWithTag(PoolType: POOL_TYPE, NumberOfBytes: SIZE_T,
                                 Tag: ULONG) -> PVOID;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _EX_POOL_PRIORITY {
    LowPoolPriority = 0,
    LowPoolPrioritySpecialPoolOverrun = 8,
    LowPoolPrioritySpecialPoolUnderrun = 9,
    NormalPoolPriority = 16,
    NormalPoolPrioritySpecialPoolOverrun = 24,
    NormalPoolPrioritySpecialPoolUnderrun = 25,
    HighPoolPriority = 32,
    HighPoolPrioritySpecialPoolOverrun = 40,
    HighPoolPrioritySpecialPoolUnderrun = 41,
}
pub use self::_EX_POOL_PRIORITY as EX_POOL_PRIORITY;
extern "C" {
    pub fn ExAllocatePoolWithTagPriority(PoolType: POOL_TYPE,
                                         NumberOfBytes: SIZE_T, Tag: ULONG,
                                         Priority: EX_POOL_PRIORITY) -> PVOID;
}
extern "C" {
    pub fn ExAllocatePoolWithQuotaTag(PoolType: POOL_TYPE,
                                      NumberOfBytes: SIZE_T, Tag: ULONG)
     -> PVOID;
}
extern "C" {
    pub fn ExFreePool(P: PVOID);
}
extern "C" {
    pub fn ExFreePoolWithTag(P: PVOID, Tag: ULONG);
}
extern "C" {
    pub fn ExAcquireFastMutexUnsafe(FastMutex: PFAST_MUTEX);
}
extern "C" {
    pub fn ExReleaseFastMutexUnsafe(FastMutex: PFAST_MUTEX);
}
extern "C" {
    pub fn ExAcquireFastMutex(FastMutex: PFAST_MUTEX);
}
extern "C" {
    pub fn ExReleaseFastMutex(FastMutex: PFAST_MUTEX);
}
extern "C" {
    pub fn ExTryToAcquireFastMutex(FastMutex: PFAST_MUTEX) -> BOOLEAN;
}
extern "C" {
    pub fn _InterlockedAddLargeStatistic(Addend: *mut libc::c_longlong,
                                         Increment: libc::c_long)
     -> libc::c_long;
}
extern "C" {
    pub fn ExInterlockedAddLargeInteger(Addend: PLARGE_INTEGER,
                                        Increment: LARGE_INTEGER,
                                        Lock: PKSPIN_LOCK) -> LARGE_INTEGER;
}
extern "C" {
    pub fn ExfInterlockedAddUlong(Addend: PULONG, Increment: ULONG,
                                  Lock: PKSPIN_LOCK) -> ULONG;
}
extern "C" {
    pub fn ExfInterlockedCompareExchange64(Destination: *mut LONGLONG,
                                           ExChange: PLONGLONG,
                                           Comperand: PLONGLONG) -> LONGLONG;
}
extern "C" {
    pub fn ExfInterlockedInsertHeadList(ListHead: PLIST_ENTRY,
                                        ListEntry: PLIST_ENTRY,
                                        Lock: PKSPIN_LOCK) -> PLIST_ENTRY;
}
extern "C" {
    pub fn ExfInterlockedInsertTailList(ListHead: PLIST_ENTRY,
                                        ListEntry: PLIST_ENTRY,
                                        Lock: PKSPIN_LOCK) -> PLIST_ENTRY;
}
extern "C" {
    pub fn ExfInterlockedRemoveHeadList(ListHead: PLIST_ENTRY,
                                        Lock: PKSPIN_LOCK) -> PLIST_ENTRY;
}
extern "C" {
    pub fn ExfInterlockedPopEntryList(ListHead: PSINGLE_LIST_ENTRY,
                                      Lock: PKSPIN_LOCK)
     -> PSINGLE_LIST_ENTRY;
}
extern "C" {
    pub fn ExfInterlockedPushEntryList(ListHead: PSINGLE_LIST_ENTRY,
                                       ListEntry: PSINGLE_LIST_ENTRY,
                                       Lock: PKSPIN_LOCK)
     -> PSINGLE_LIST_ENTRY;
}
extern "C" {
    pub fn InitializeSListHead(SListHead: PSLIST_HEADER);
}
extern "C" {
    pub fn FirstEntrySList(SListHead: PSLIST_HEADER) -> PSLIST_ENTRY;
}
extern "C" {
    pub fn ExInterlockedFlushSList(ListHead: PSLIST_HEADER) -> PSLIST_ENTRY;
}
extern "C" {
    pub fn InterlockedPopEntrySList(ListHead: PSLIST_HEADER) -> PSLIST_ENTRY;
}
extern "C" {
    pub fn InterlockedPushEntrySList(ListHead: PSLIST_HEADER,
                                     ListEntry: PSLIST_ENTRY) -> PSLIST_ENTRY;
}
pub use self::_LOOKASIDE_LIST_EX as LOOKASIDE_LIST_EX;
extern "C" {
    pub fn ExInitializeLookasideListEx(Lookaside: PLOOKASIDE_LIST_EX,
                                       Allocate: PALLOCATE_FUNCTION_EX,
                                       Free: PFREE_FUNCTION_EX,
                                       PoolType: POOL_TYPE, Flags: ULONG,
                                       Size: SIZE_T, Tag: ULONG,
                                       Depth: USHORT) -> NTSTATUS;
}
extern "C" {
    pub fn ExDeleteLookasideListEx(Lookaside: PLOOKASIDE_LIST_EX);
}
extern "C" {
    pub fn ExFlushLookasideListEx(Lookaside: PLOOKASIDE_LIST_EX);
}
#[repr(C)]
#[derive(Copy)]
pub struct _NPAGED_LOOKASIDE_LIST {
    pub L: GENERAL_LOOKASIDE,
    pub Lock__ObsoleteButDoNotDelete: KSPIN_LOCK,
}
impl Clone for _NPAGED_LOOKASIDE_LIST {
    fn clone(&self) -> Self { *self }
}
pub use self::_NPAGED_LOOKASIDE_LIST as NPAGED_LOOKASIDE_LIST;
pub type PNPAGED_LOOKASIDE_LIST = *mut _NPAGED_LOOKASIDE_LIST;
extern "C" {
    pub fn ExInitializeNPagedLookasideList(Lookaside: PNPAGED_LOOKASIDE_LIST,
                                           Allocate: PALLOCATE_FUNCTION,
                                           Free: PFREE_FUNCTION, Flags: ULONG,
                                           Size: SIZE_T, Tag: ULONG,
                                           Depth: USHORT);
}
extern "C" {
    pub fn ExDeleteNPagedLookasideList(Lookaside: PNPAGED_LOOKASIDE_LIST);
}
#[repr(C)]
#[derive(Copy)]
pub struct _PAGED_LOOKASIDE_LIST {
    pub L: GENERAL_LOOKASIDE,
    pub Lock__ObsoleteButDoNotDelete: FAST_MUTEX,
}
impl Clone for _PAGED_LOOKASIDE_LIST {
    fn clone(&self) -> Self { *self }
}
pub use self::_PAGED_LOOKASIDE_LIST as PAGED_LOOKASIDE_LIST;
pub type PPAGED_LOOKASIDE_LIST = *mut _PAGED_LOOKASIDE_LIST;
extern "C" {
    pub fn ExInitializePagedLookasideList(Lookaside: PPAGED_LOOKASIDE_LIST,
                                          Allocate: PALLOCATE_FUNCTION,
                                          Free: PFREE_FUNCTION, Flags: ULONG,
                                          Size: SIZE_T, Tag: ULONG,
                                          Depth: USHORT);
}
extern "C" {
    pub fn ExDeletePagedLookasideList(Lookaside: PPAGED_LOOKASIDE_LIST);
}
extern "C" {
    pub fn ProbeForRead(Address: *mut libc::c_void, Length: SIZE_T,
                        Alignment: ULONG);
}
extern "C" {
    pub fn ExRaiseStatus(Status: NTSTATUS);
}
extern "C" {
    pub fn ProbeForWrite(Address: *mut libc::c_void, Length: SIZE_T,
                         Alignment: ULONG);
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _WORK_QUEUE_TYPE {
    CriticalWorkQueue = 0,
    DelayedWorkQueue = 1,
    HyperCriticalWorkQueue = 2,
    NormalWorkQueue = 3,
    BackgroundWorkQueue = 4,
    RealTimeWorkQueue = 5,
    SuperCriticalWorkQueue = 6,
    MaximumWorkQueue = 7,
    CustomPriorityWorkQueue = 32,
}
pub use self::_WORK_QUEUE_TYPE as WORK_QUEUE_TYPE;
pub type WORKER_THREAD_ROUTINE =
    ::core::option::Option<unsafe extern "C" fn(Parameter: PVOID)>;
pub type PWORKER_THREAD_ROUTINE = WORKER_THREAD_ROUTINE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WORK_QUEUE_ITEM {
    pub List: LIST_ENTRY,
    pub WorkerRoutine: PWORKER_THREAD_ROUTINE,
    pub Parameter: PVOID,
}
#[test]
fn bindgen_test_layout__WORK_QUEUE_ITEM() {
    assert_eq!(::core::mem::size_of::<_WORK_QUEUE_ITEM>() , 32usize);
    assert_eq!(::core::mem::align_of::<_WORK_QUEUE_ITEM>() , 8usize);
}
impl Clone for _WORK_QUEUE_ITEM {
    fn clone(&self) -> Self { *self }
}
pub use self::_WORK_QUEUE_ITEM as WORK_QUEUE_ITEM;
pub type PWORK_QUEUE_ITEM = *mut _WORK_QUEUE_ITEM;
extern "C" {
    pub fn ExQueueWorkItem(WorkItem: PWORK_QUEUE_ITEM,
                           QueueType: WORK_QUEUE_TYPE);
}
extern "C" {
    pub fn ExIsProcessorFeaturePresent(ProcessorFeature: ULONG) -> BOOLEAN;
}
pub type ERESOURCE_THREAD = ULONG_PTR;
pub type PERESOURCE_THREAD = *mut ERESOURCE_THREAD;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _OWNER_ENTRY {
    pub OwnerThread: ERESOURCE_THREAD,
    pub __bindgen_anon_1: _OWNER_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _OWNER_ENTRY__bindgen_ty_1 {
    pub __bindgen_anon_1: __BindgenUnionField<_OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1>,
    pub TableSize: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn IoPriorityBoosted(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_IoPriorityBoosted(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn OwnerReferenced(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_OwnerReferenced(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn IoQoSPriorityBoosted(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                        2u32) as u32)
        }
    }
    #[inline]
    pub fn set_IoQoSPriorityBoosted(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn OwnerCount(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967288usize as u32)) >> 3u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_OwnerCount(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967288usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 3u32) & (4294967288usize as u32);
    }
}
#[test]
fn bindgen_test_layout__OWNER_ENTRY__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_OWNER_ENTRY__bindgen_ty_1>() , 4usize);
    assert_eq!(::core::mem::align_of::<_OWNER_ENTRY__bindgen_ty_1>() ,
               4usize);
}
impl Clone for _OWNER_ENTRY__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__OWNER_ENTRY() {
    assert_eq!(::core::mem::size_of::<_OWNER_ENTRY>() , 16usize);
    assert_eq!(::core::mem::align_of::<_OWNER_ENTRY>() , 8usize);
}
impl Clone for _OWNER_ENTRY {
    fn clone(&self) -> Self { *self }
}
pub use self::_OWNER_ENTRY as OWNER_ENTRY;
pub type POWNER_ENTRY = *mut _OWNER_ENTRY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _ERESOURCE {
    pub SystemResourcesList: LIST_ENTRY,
    pub OwnerTable: POWNER_ENTRY,
    pub ActiveCount: SHORT,
    pub __bindgen_anon_1: _ERESOURCE__bindgen_ty_1,
    pub SharedWaiters: KWAIT_CHAIN,
    pub ExclusiveWaiters: PKEVENT,
    pub OwnerEntry: OWNER_ENTRY,
    pub ActiveEntries: ULONG,
    pub ContentionCount: ULONG,
    pub NumberOfSharedWaiters: ULONG,
    pub NumberOfExclusiveWaiters: ULONG,
    pub Reserved2: PVOID,
    pub __bindgen_anon_2: _ERESOURCE__bindgen_ty_2,
    pub SpinLock: KSPIN_LOCK,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _ERESOURCE__bindgen_ty_1 {
    pub Flag: __BindgenUnionField<USHORT>,
    pub __bindgen_anon_1: __BindgenUnionField<_ERESOURCE__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _ERESOURCE__bindgen_ty_1__bindgen_ty_1 {
    pub ReservedLowFlags: UCHAR,
    pub WaiterPriority: UCHAR,
}
#[test]
fn bindgen_test_layout__ERESOURCE__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_ERESOURCE__bindgen_ty_1__bindgen_ty_1>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_ERESOURCE__bindgen_ty_1__bindgen_ty_1>()
               , 1usize);
}
impl Clone for _ERESOURCE__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__ERESOURCE__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_ERESOURCE__bindgen_ty_1>() , 2usize);
    assert_eq!(::core::mem::align_of::<_ERESOURCE__bindgen_ty_1>() , 2usize);
}
impl Clone for _ERESOURCE__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _ERESOURCE__bindgen_ty_2 {
    pub Address: __BindgenUnionField<PVOID>,
    pub CreatorBackTraceIndex: __BindgenUnionField<ULONG_PTR>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__ERESOURCE__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<_ERESOURCE__bindgen_ty_2>() , 8usize);
    assert_eq!(::core::mem::align_of::<_ERESOURCE__bindgen_ty_2>() , 8usize);
}
impl Clone for _ERESOURCE__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__ERESOURCE() {
    assert_eq!(::core::mem::size_of::<_ERESOURCE>() , 104usize);
    assert_eq!(::core::mem::align_of::<_ERESOURCE>() , 8usize);
}
impl Clone for _ERESOURCE {
    fn clone(&self) -> Self { *self }
}
pub use self::_ERESOURCE as ERESOURCE;
pub type PERESOURCE = *mut _ERESOURCE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _RESOURCE_HASH_ENTRY {
    pub ListEntry: LIST_ENTRY,
    pub Address: PVOID,
    pub ContentionCount: ULONG,
    pub Number: ULONG,
}
#[test]
fn bindgen_test_layout__RESOURCE_HASH_ENTRY() {
    assert_eq!(::core::mem::size_of::<_RESOURCE_HASH_ENTRY>() , 32usize);
    assert_eq!(::core::mem::align_of::<_RESOURCE_HASH_ENTRY>() , 8usize);
}
impl Clone for _RESOURCE_HASH_ENTRY {
    fn clone(&self) -> Self { *self }
}
pub use self::_RESOURCE_HASH_ENTRY as RESOURCE_HASH_ENTRY;
pub type PRESOURCE_HASH_ENTRY = *mut _RESOURCE_HASH_ENTRY;
#[repr(C)]
pub struct _RESOURCE_PERFORMANCE_DATA {
    pub ActiveResourceCount: ULONG,
    pub TotalResourceCount: ULONG,
    pub ExclusiveAcquire: ULONG,
    pub SharedFirstLevel: ULONG,
    pub SharedSecondLevel: ULONG,
    pub StarveFirstLevel: ULONG,
    pub StarveSecondLevel: ULONG,
    pub WaitForExclusive: ULONG,
    pub OwnerTableExpands: ULONG,
    pub MaximumTableExpand: ULONG,
    pub HashTable: [LIST_ENTRY; 64usize],
}
#[test]
fn bindgen_test_layout__RESOURCE_PERFORMANCE_DATA() {
    assert_eq!(::core::mem::size_of::<_RESOURCE_PERFORMANCE_DATA>() ,
               1064usize);
    assert_eq!(::core::mem::align_of::<_RESOURCE_PERFORMANCE_DATA>() ,
               8usize);
}
pub use self::_RESOURCE_PERFORMANCE_DATA as RESOURCE_PERFORMANCE_DATA;
pub type PRESOURCE_PERFORMANCE_DATA = *mut _RESOURCE_PERFORMANCE_DATA;
extern "C" {
    pub fn ExInitializeResourceLite(Resource: PERESOURCE) -> NTSTATUS;
}
extern "C" {
    pub fn ExReinitializeResourceLite(Resource: PERESOURCE) -> NTSTATUS;
}
extern "C" {
    pub fn ExAcquireResourceSharedLite(Resource: PERESOURCE, Wait: BOOLEAN)
     -> BOOLEAN;
}
extern "C" {
    pub fn ExEnterCriticalRegionAndAcquireResourceShared(Resource: PERESOURCE)
     -> PVOID;
}
extern "C" {
    pub fn ExAcquireResourceExclusiveLite(Resource: PERESOURCE, Wait: BOOLEAN)
     -> BOOLEAN;
}
extern "C" {
    pub fn ExEnterCriticalRegionAndAcquireResourceExclusive(Resource:
                                                                PERESOURCE)
     -> PVOID;
}
extern "C" {
    pub fn ExAcquireSharedStarveExclusive(Resource: PERESOURCE, Wait: BOOLEAN)
     -> BOOLEAN;
}
extern "C" {
    pub fn ExAcquireSharedWaitForExclusive(Resource: PERESOURCE,
                                           Wait: BOOLEAN) -> BOOLEAN;
}
extern "C" {
    pub fn ExEnterCriticalRegionAndAcquireSharedWaitForExclusive(Resource:
                                                                     PERESOURCE)
     -> PVOID;
}
extern "C" {
    pub fn ExReleaseResourceLite(Resource: PERESOURCE);
}
extern "C" {
    pub fn ExReleaseResourceAndLeaveCriticalRegion(Resource: PERESOURCE);
}
extern "C" {
    pub fn ExReleaseResourceForThreadLite(Resource: PERESOURCE,
                                          ResourceThreadId: ERESOURCE_THREAD);
}
extern "C" {
    pub fn ExSetResourceOwnerPointer(Resource: PERESOURCE,
                                     OwnerPointer: PVOID);
}
extern "C" {
    pub fn ExSetResourceOwnerPointerEx(Resource: PERESOURCE,
                                       OwnerPointer: PVOID, Flags: ULONG);
}
extern "C" {
    pub fn ExConvertExclusiveToSharedLite(Resource: PERESOURCE);
}
extern "C" {
    pub fn ExDeleteResourceLite(Resource: PERESOURCE) -> NTSTATUS;
}
extern "C" {
    pub fn ExGetExclusiveWaiterCount(Resource: PERESOURCE) -> ULONG;
}
extern "C" {
    pub fn ExGetSharedWaiterCount(Resource: PERESOURCE) -> ULONG;
}
extern "C" {
    pub fn ExIsResourceAcquiredExclusiveLite(Resource: PERESOURCE) -> BOOLEAN;
}
extern "C" {
    pub fn ExIsResourceAcquiredSharedLite(Resource: PERESOURCE) -> ULONG;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _EX_RUNDOWN_REF {
    pub __bindgen_anon_1: _EX_RUNDOWN_REF__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _EX_RUNDOWN_REF__bindgen_ty_1 {
    pub Count: __BindgenUnionField<ULONG_PTR>,
    pub Ptr: __BindgenUnionField<PVOID>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__EX_RUNDOWN_REF__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_EX_RUNDOWN_REF__bindgen_ty_1>() ,
               8usize);
    assert_eq!(::core::mem::align_of::<_EX_RUNDOWN_REF__bindgen_ty_1>() ,
               8usize);
}
impl Clone for _EX_RUNDOWN_REF__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__EX_RUNDOWN_REF() {
    assert_eq!(::core::mem::size_of::<_EX_RUNDOWN_REF>() , 8usize);
    assert_eq!(::core::mem::align_of::<_EX_RUNDOWN_REF>() , 8usize);
}
impl Clone for _EX_RUNDOWN_REF {
    fn clone(&self) -> Self { *self }
}
pub use self::_EX_RUNDOWN_REF as EX_RUNDOWN_REF;
pub type PEX_RUNDOWN_REF = *mut _EX_RUNDOWN_REF;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _EX_RUNDOWN_REF_CACHE_AWARE {
    pub _address: u8,
}
impl Clone for _EX_RUNDOWN_REF_CACHE_AWARE {
    fn clone(&self) -> Self { *self }
}
pub type PEX_RUNDOWN_REF_CACHE_AWARE = *mut _EX_RUNDOWN_REF_CACHE_AWARE;
extern "C" {
    pub fn ExGetPreviousMode() -> KPROCESSOR_MODE;
}
extern "C" {
    pub fn ExSetTimerResolution(DesiredTime: ULONG, SetResolution: BOOLEAN)
     -> ULONG;
}
extern "C" {
    pub fn ExQueryTimerResolution(MaximumTime: PULONG, MinimumTime: PULONG,
                                  CurrentTime: PULONG);
}
extern "C" {
    pub fn ExSystemTimeToLocalTime(SystemTime: PLARGE_INTEGER,
                                   LocalTime: PLARGE_INTEGER);
}
extern "C" {
    pub fn ExLocalTimeToSystemTime(LocalTime: PLARGE_INTEGER,
                                   SystemTime: PLARGE_INTEGER);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _EX_TIMER {
    pub _address: u8,
}
impl Clone for _EX_TIMER {
    fn clone(&self) -> Self { *self }
}
pub type PEX_TIMER = *mut _EX_TIMER;
pub type EXT_CALLBACK =
    ::core::option::Option<unsafe extern "C" fn(Timer: PEX_TIMER,
                                                Context: PVOID)>;
pub type PEXT_CALLBACK = EXT_CALLBACK;
pub type EXT_DELETE_CALLBACK =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID)>;
pub type PEXT_DELETE_CALLBACK = EXT_DELETE_CALLBACK;
pub type PEXT_CANCEL_PARAMETERS = PVOID;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _EXT_DELETE_PARAMETERS {
    pub Version: ULONG,
    pub Reserved: ULONG,
    pub DeleteCallback: PEXT_DELETE_CALLBACK,
    pub DeleteContext: PVOID,
}
#[test]
fn bindgen_test_layout__EXT_DELETE_PARAMETERS() {
    assert_eq!(::core::mem::size_of::<_EXT_DELETE_PARAMETERS>() , 24usize);
    assert_eq!(::core::mem::align_of::<_EXT_DELETE_PARAMETERS>() , 8usize);
}
impl Clone for _EXT_DELETE_PARAMETERS {
    fn clone(&self) -> Self { *self }
}
pub use self::_EXT_DELETE_PARAMETERS as EXT_DELETE_PARAMETERS;
pub type PEXT_DELETE_PARAMETERS = *mut _EXT_DELETE_PARAMETERS;
extern "C" {
    pub fn ExAllocateTimer(Callback: PEXT_CALLBACK, CallbackContext: PVOID,
                           Attributes: ULONG) -> PEX_TIMER;
}
extern "C" {
    pub fn ExSetTimer(Timer: PEX_TIMER, DueTime: LONGLONG, Period: LONGLONG,
                      Parameters: PEXT_SET_PARAMETERS) -> BOOLEAN;
}
extern "C" {
    pub fn ExCancelTimer(Timer: PEX_TIMER, Parameters: PEXT_CANCEL_PARAMETERS)
     -> BOOLEAN;
}
extern "C" {
    pub fn ExDeleteTimer(Timer: PEX_TIMER, Cancel: BOOLEAN, Wait: BOOLEAN,
                         Parameters: PEXT_DELETE_PARAMETERS) -> BOOLEAN;
}
pub type CALLBACK_FUNCTION =
    ::core::option::Option<unsafe extern "C" fn(CallbackContext: PVOID,
                                                Argument1: PVOID,
                                                Argument2: PVOID)>;
pub type PCALLBACK_FUNCTION = CALLBACK_FUNCTION;
extern "C" {
    pub fn ExCreateCallback(CallbackObject: *mut PCALLBACK_OBJECT,
                            ObjectAttributes: POBJECT_ATTRIBUTES,
                            Create: BOOLEAN, AllowMultipleCallbacks: BOOLEAN)
     -> NTSTATUS;
}
extern "C" {
    pub fn ExRegisterCallback(CallbackObject: PCALLBACK_OBJECT,
                              CallbackFunction: PCALLBACK_FUNCTION,
                              CallbackContext: PVOID) -> PVOID;
}
extern "C" {
    pub fn ExUnregisterCallback(CallbackRegistration: PVOID);
}
extern "C" {
    pub fn ExNotifyCallback(CallbackObject: PVOID, Argument1: PVOID,
                            Argument2: PVOID);
}
extern "C" {
    pub fn ExVerifySuite(SuiteType: SUITE_TYPE) -> BOOLEAN;
}
extern "C" {
    pub fn ExInitializeRundownProtection(RunRef: PEX_RUNDOWN_REF);
}
extern "C" {
    pub fn ExReInitializeRundownProtection(RunRef: PEX_RUNDOWN_REF);
}
extern "C" {
    pub fn ExAcquireRundownProtection(RunRef: PEX_RUNDOWN_REF) -> BOOLEAN;
}
extern "C" {
    pub fn ExAcquireRundownProtectionEx(RunRef: PEX_RUNDOWN_REF, Count: ULONG)
     -> BOOLEAN;
}
extern "C" {
    pub fn ExReleaseRundownProtection(RunRef: PEX_RUNDOWN_REF);
}
extern "C" {
    pub fn ExReleaseRundownProtectionEx(RunRef: PEX_RUNDOWN_REF,
                                        Count: ULONG);
}
extern "C" {
    pub fn ExRundownCompleted(RunRef: PEX_RUNDOWN_REF);
}
extern "C" {
    pub fn ExWaitForRundownProtectionRelease(RunRef: PEX_RUNDOWN_REF);
}
extern "C" {
    pub fn ExAllocateCacheAwareRundownProtection(PoolType: POOL_TYPE,
                                                 PoolTag: ULONG)
     -> PEX_RUNDOWN_REF_CACHE_AWARE;
}
extern "C" {
    pub fn ExSizeOfRundownProtectionCacheAware() -> SIZE_T;
}
extern "C" {
    pub fn ExInitializeRundownProtectionCacheAware(RunRefCacheAware:
                                                       PEX_RUNDOWN_REF_CACHE_AWARE,
                                                   RunRefSize: SIZE_T);
}
extern "C" {
    pub fn ExFreeCacheAwareRundownProtection(RunRefCacheAware:
                                                 PEX_RUNDOWN_REF_CACHE_AWARE);
}
extern "C" {
    pub fn ExAcquireRundownProtectionCacheAware(RunRefCacheAware:
                                                    PEX_RUNDOWN_REF_CACHE_AWARE)
     -> BOOLEAN;
}
extern "C" {
    pub fn ExReleaseRundownProtectionCacheAware(RunRefCacheAware:
                                                    PEX_RUNDOWN_REF_CACHE_AWARE);
}
extern "C" {
    pub fn ExAcquireRundownProtectionCacheAwareEx(RunRefCacheAware:
                                                      PEX_RUNDOWN_REF_CACHE_AWARE,
                                                  Count: ULONG) -> BOOLEAN;
}
extern "C" {
    pub fn ExReleaseRundownProtectionCacheAwareEx(RunRef:
                                                      PEX_RUNDOWN_REF_CACHE_AWARE,
                                                  Count: ULONG);
}
extern "C" {
    pub fn ExWaitForRundownProtectionReleaseCacheAware(RunRef:
                                                           PEX_RUNDOWN_REF_CACHE_AWARE);
}
extern "C" {
    pub fn ExReInitializeRundownProtectionCacheAware(RunRefCacheAware:
                                                         PEX_RUNDOWN_REF_CACHE_AWARE);
}
extern "C" {
    pub fn ExRundownCompletedCacheAware(RunRefCacheAware:
                                            PEX_RUNDOWN_REF_CACHE_AWARE);
}
extern "C" {
    pub fn ExInitializeRundownProtectionCacheAwareEx(RunRefCacheAware:
                                                         PEX_RUNDOWN_REF_CACHE_AWARE,
                                                     Flags: ULONG);
}
extern "C" {
    pub fn ExCleanupRundownProtectionCacheAware(RunRefCacheAware:
                                                    PEX_RUNDOWN_REF_CACHE_AWARE);
}
pub type EX_SPIN_LOCK = LONG;
pub type PEX_SPIN_LOCK = *mut LONG;
extern "C" {
    pub fn ExAcquireSpinLockSharedAtDpcLevel(SpinLock: PEX_SPIN_LOCK);
}
extern "C" {
    pub fn ExAcquireSpinLockShared(SpinLock: PEX_SPIN_LOCK) -> KIRQL;
}
extern "C" {
    pub fn ExReleaseSpinLockSharedFromDpcLevel(SpinLock: PEX_SPIN_LOCK);
}
extern "C" {
    pub fn ExReleaseSpinLockShared(SpinLock: PEX_SPIN_LOCK, OldIrql: KIRQL);
}
extern "C" {
    pub fn ExTryConvertSharedSpinLockExclusive(SpinLock: PEX_SPIN_LOCK)
     -> LOGICAL;
}
extern "C" {
    pub fn ExAcquireSpinLockExclusiveAtDpcLevel(SpinLock: PEX_SPIN_LOCK);
}
extern "C" {
    pub fn ExAcquireSpinLockExclusive(SpinLock: PEX_SPIN_LOCK) -> KIRQL;
}
extern "C" {
    pub fn ExReleaseSpinLockExclusiveFromDpcLevel(SpinLock: PEX_SPIN_LOCK);
}
extern "C" {
    pub fn ExReleaseSpinLockExclusive(SpinLock: PEX_SPIN_LOCK,
                                      OldIrql: KIRQL);
}
pub type EX_CALLBACK_FUNCTION =
    ::core::option::Option<unsafe extern "C" fn(CallbackContext: PVOID,
                                                Argument1: PVOID,
                                                Argument2: PVOID)
                               -> NTSTATUS>;
pub type PEX_CALLBACK_FUNCTION = EX_CALLBACK_FUNCTION;
extern "C" {
    pub fn ExGetFirmwareEnvironmentVariable(VariableName: PUNICODE_STRING,
                                            VendorGuid: LPGUID, Value: PVOID,
                                            ValueLength: PULONG,
                                            Attributes: PULONG) -> NTSTATUS;
}
extern "C" {
    pub fn ExSetFirmwareEnvironmentVariable(VariableName: PUNICODE_STRING,
                                            VendorGuid: LPGUID, Value: PVOID,
                                            ValueLength: ULONG,
                                            Attributes: ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn ExIsManufacturingModeEnabled() -> BOOLEAN;
}
pub const _REG_NOTIFY_CLASS_RegNtPreDeleteKey: _REG_NOTIFY_CLASS =
    _REG_NOTIFY_CLASS::RegNtDeleteKey;
pub const _REG_NOTIFY_CLASS_RegNtPreSetValueKey: _REG_NOTIFY_CLASS =
    _REG_NOTIFY_CLASS::RegNtSetValueKey;
pub const _REG_NOTIFY_CLASS_RegNtPreDeleteValueKey: _REG_NOTIFY_CLASS =
    _REG_NOTIFY_CLASS::RegNtDeleteValueKey;
pub const _REG_NOTIFY_CLASS_RegNtPreSetInformationKey: _REG_NOTIFY_CLASS =
    _REG_NOTIFY_CLASS::RegNtSetInformationKey;
pub const _REG_NOTIFY_CLASS_RegNtPreRenameKey: _REG_NOTIFY_CLASS =
    _REG_NOTIFY_CLASS::RegNtRenameKey;
pub const _REG_NOTIFY_CLASS_RegNtPreEnumerateKey: _REG_NOTIFY_CLASS =
    _REG_NOTIFY_CLASS::RegNtEnumerateKey;
pub const _REG_NOTIFY_CLASS_RegNtPreEnumerateValueKey: _REG_NOTIFY_CLASS =
    _REG_NOTIFY_CLASS::RegNtEnumerateValueKey;
pub const _REG_NOTIFY_CLASS_RegNtPreQueryKey: _REG_NOTIFY_CLASS =
    _REG_NOTIFY_CLASS::RegNtQueryKey;
pub const _REG_NOTIFY_CLASS_RegNtPreQueryValueKey: _REG_NOTIFY_CLASS =
    _REG_NOTIFY_CLASS::RegNtQueryValueKey;
pub const _REG_NOTIFY_CLASS_RegNtPreQueryMultipleValueKey: _REG_NOTIFY_CLASS =
    _REG_NOTIFY_CLASS::RegNtQueryMultipleValueKey;
pub const _REG_NOTIFY_CLASS_RegNtPreKeyHandleClose: _REG_NOTIFY_CLASS =
    _REG_NOTIFY_CLASS::RegNtKeyHandleClose;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _REG_NOTIFY_CLASS {
    RegNtDeleteKey = 0,
    RegNtSetValueKey = 1,
    RegNtDeleteValueKey = 2,
    RegNtSetInformationKey = 3,
    RegNtRenameKey = 4,
    RegNtEnumerateKey = 5,
    RegNtEnumerateValueKey = 6,
    RegNtQueryKey = 7,
    RegNtQueryValueKey = 8,
    RegNtQueryMultipleValueKey = 9,
    RegNtPreCreateKey = 10,
    RegNtPostCreateKey = 11,
    RegNtPreOpenKey = 12,
    RegNtPostOpenKey = 13,
    RegNtKeyHandleClose = 14,
    RegNtPostDeleteKey = 15,
    RegNtPostSetValueKey = 16,
    RegNtPostDeleteValueKey = 17,
    RegNtPostSetInformationKey = 18,
    RegNtPostRenameKey = 19,
    RegNtPostEnumerateKey = 20,
    RegNtPostEnumerateValueKey = 21,
    RegNtPostQueryKey = 22,
    RegNtPostQueryValueKey = 23,
    RegNtPostQueryMultipleValueKey = 24,
    RegNtPostKeyHandleClose = 25,
    RegNtPreCreateKeyEx = 26,
    RegNtPostCreateKeyEx = 27,
    RegNtPreOpenKeyEx = 28,
    RegNtPostOpenKeyEx = 29,
    RegNtPreFlushKey = 30,
    RegNtPostFlushKey = 31,
    RegNtPreLoadKey = 32,
    RegNtPostLoadKey = 33,
    RegNtPreUnLoadKey = 34,
    RegNtPostUnLoadKey = 35,
    RegNtPreQueryKeySecurity = 36,
    RegNtPostQueryKeySecurity = 37,
    RegNtPreSetKeySecurity = 38,
    RegNtPostSetKeySecurity = 39,
    RegNtCallbackObjectContextCleanup = 40,
    RegNtPreRestoreKey = 41,
    RegNtPostRestoreKey = 42,
    RegNtPreSaveKey = 43,
    RegNtPostSaveKey = 44,
    RegNtPreReplaceKey = 45,
    RegNtPostReplaceKey = 46,
    RegNtPreQueryKeyName = 47,
    RegNtPostQueryKeyName = 48,
    MaxRegNtNotifyClass = 49,
}
pub use self::_REG_NOTIFY_CLASS as REG_NOTIFY_CLASS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _REG_DELETE_KEY_INFORMATION {
    pub Object: PVOID,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
#[test]
fn bindgen_test_layout__REG_DELETE_KEY_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_REG_DELETE_KEY_INFORMATION>() ,
               32usize);
    assert_eq!(::core::mem::align_of::<_REG_DELETE_KEY_INFORMATION>() ,
               8usize);
}
impl Clone for _REG_DELETE_KEY_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_REG_DELETE_KEY_INFORMATION as REG_DELETE_KEY_INFORMATION;
pub type PREG_DELETE_KEY_INFORMATION = *mut _REG_DELETE_KEY_INFORMATION;
pub use self::_REG_DELETE_KEY_INFORMATION as REG_FLUSH_KEY_INFORMATION;
pub type PREG_FLUSH_KEY_INFORMATION = *mut _REG_DELETE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _REG_SET_VALUE_KEY_INFORMATION {
    pub Object: PVOID,
    pub ValueName: PUNICODE_STRING,
    pub TitleIndex: ULONG,
    pub Type: ULONG,
    pub Data: PVOID,
    pub DataSize: ULONG,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
#[test]
fn bindgen_test_layout__REG_SET_VALUE_KEY_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_REG_SET_VALUE_KEY_INFORMATION>() ,
               64usize);
    assert_eq!(::core::mem::align_of::<_REG_SET_VALUE_KEY_INFORMATION>() ,
               8usize);
}
impl Clone for _REG_SET_VALUE_KEY_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_REG_SET_VALUE_KEY_INFORMATION as REG_SET_VALUE_KEY_INFORMATION;
pub type PREG_SET_VALUE_KEY_INFORMATION = *mut _REG_SET_VALUE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _REG_DELETE_VALUE_KEY_INFORMATION {
    pub Object: PVOID,
    pub ValueName: PUNICODE_STRING,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
#[test]
fn bindgen_test_layout__REG_DELETE_VALUE_KEY_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_REG_DELETE_VALUE_KEY_INFORMATION>() ,
               40usize);
    assert_eq!(::core::mem::align_of::<_REG_DELETE_VALUE_KEY_INFORMATION>() ,
               8usize);
}
impl Clone for _REG_DELETE_VALUE_KEY_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_REG_DELETE_VALUE_KEY_INFORMATION as
        REG_DELETE_VALUE_KEY_INFORMATION;
pub type PREG_DELETE_VALUE_KEY_INFORMATION =
    *mut _REG_DELETE_VALUE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _REG_SET_INFORMATION_KEY_INFORMATION {
    pub Object: PVOID,
    pub KeySetInformationClass: KEY_SET_INFORMATION_CLASS,
    pub KeySetInformation: PVOID,
    pub KeySetInformationLength: ULONG,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
#[test]
fn bindgen_test_layout__REG_SET_INFORMATION_KEY_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_REG_SET_INFORMATION_KEY_INFORMATION>()
               , 56usize);
    assert_eq!(::core::mem::align_of::<_REG_SET_INFORMATION_KEY_INFORMATION>()
               , 8usize);
}
impl Clone for _REG_SET_INFORMATION_KEY_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_REG_SET_INFORMATION_KEY_INFORMATION as
        REG_SET_INFORMATION_KEY_INFORMATION;
pub type PREG_SET_INFORMATION_KEY_INFORMATION =
    *mut _REG_SET_INFORMATION_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _REG_ENUMERATE_KEY_INFORMATION {
    pub Object: PVOID,
    pub Index: ULONG,
    pub KeyInformationClass: KEY_INFORMATION_CLASS,
    pub KeyInformation: PVOID,
    pub Length: ULONG,
    pub ResultLength: PULONG,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
#[test]
fn bindgen_test_layout__REG_ENUMERATE_KEY_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_REG_ENUMERATE_KEY_INFORMATION>() ,
               64usize);
    assert_eq!(::core::mem::align_of::<_REG_ENUMERATE_KEY_INFORMATION>() ,
               8usize);
}
impl Clone for _REG_ENUMERATE_KEY_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_REG_ENUMERATE_KEY_INFORMATION as REG_ENUMERATE_KEY_INFORMATION;
pub type PREG_ENUMERATE_KEY_INFORMATION = *mut _REG_ENUMERATE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _REG_ENUMERATE_VALUE_KEY_INFORMATION {
    pub Object: PVOID,
    pub Index: ULONG,
    pub KeyValueInformationClass: KEY_VALUE_INFORMATION_CLASS,
    pub KeyValueInformation: PVOID,
    pub Length: ULONG,
    pub ResultLength: PULONG,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
#[test]
fn bindgen_test_layout__REG_ENUMERATE_VALUE_KEY_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_REG_ENUMERATE_VALUE_KEY_INFORMATION>()
               , 64usize);
    assert_eq!(::core::mem::align_of::<_REG_ENUMERATE_VALUE_KEY_INFORMATION>()
               , 8usize);
}
impl Clone for _REG_ENUMERATE_VALUE_KEY_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_REG_ENUMERATE_VALUE_KEY_INFORMATION as
        REG_ENUMERATE_VALUE_KEY_INFORMATION;
pub type PREG_ENUMERATE_VALUE_KEY_INFORMATION =
    *mut _REG_ENUMERATE_VALUE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _REG_QUERY_KEY_INFORMATION {
    pub Object: PVOID,
    pub KeyInformationClass: KEY_INFORMATION_CLASS,
    pub KeyInformation: PVOID,
    pub Length: ULONG,
    pub ResultLength: PULONG,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
#[test]
fn bindgen_test_layout__REG_QUERY_KEY_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_REG_QUERY_KEY_INFORMATION>() ,
               64usize);
    assert_eq!(::core::mem::align_of::<_REG_QUERY_KEY_INFORMATION>() ,
               8usize);
}
impl Clone for _REG_QUERY_KEY_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_REG_QUERY_KEY_INFORMATION as REG_QUERY_KEY_INFORMATION;
pub type PREG_QUERY_KEY_INFORMATION = *mut _REG_QUERY_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _REG_QUERY_VALUE_KEY_INFORMATION {
    pub Object: PVOID,
    pub ValueName: PUNICODE_STRING,
    pub KeyValueInformationClass: KEY_VALUE_INFORMATION_CLASS,
    pub KeyValueInformation: PVOID,
    pub Length: ULONG,
    pub ResultLength: PULONG,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
#[test]
fn bindgen_test_layout__REG_QUERY_VALUE_KEY_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_REG_QUERY_VALUE_KEY_INFORMATION>() ,
               72usize);
    assert_eq!(::core::mem::align_of::<_REG_QUERY_VALUE_KEY_INFORMATION>() ,
               8usize);
}
impl Clone for _REG_QUERY_VALUE_KEY_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_REG_QUERY_VALUE_KEY_INFORMATION as
        REG_QUERY_VALUE_KEY_INFORMATION;
pub type PREG_QUERY_VALUE_KEY_INFORMATION =
    *mut _REG_QUERY_VALUE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _REG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION {
    pub Object: PVOID,
    pub ValueEntries: PKEY_VALUE_ENTRY,
    pub EntryCount: ULONG,
    pub ValueBuffer: PVOID,
    pub BufferLength: PULONG,
    pub RequiredBufferLength: PULONG,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
#[test]
fn bindgen_test_layout__REG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_REG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION>()
               , 72usize);
    assert_eq!(::core::mem::align_of::<_REG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION>()
               , 8usize);
}
impl Clone for _REG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_REG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION as
        REG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION;
pub type PREG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION =
    *mut _REG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _REG_RENAME_KEY_INFORMATION {
    pub Object: PVOID,
    pub NewName: PUNICODE_STRING,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
#[test]
fn bindgen_test_layout__REG_RENAME_KEY_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_REG_RENAME_KEY_INFORMATION>() ,
               40usize);
    assert_eq!(::core::mem::align_of::<_REG_RENAME_KEY_INFORMATION>() ,
               8usize);
}
impl Clone for _REG_RENAME_KEY_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_REG_RENAME_KEY_INFORMATION as REG_RENAME_KEY_INFORMATION;
pub type PREG_RENAME_KEY_INFORMATION = *mut _REG_RENAME_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _REG_KEY_HANDLE_CLOSE_INFORMATION {
    pub Object: PVOID,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
#[test]
fn bindgen_test_layout__REG_KEY_HANDLE_CLOSE_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_REG_KEY_HANDLE_CLOSE_INFORMATION>() ,
               32usize);
    assert_eq!(::core::mem::align_of::<_REG_KEY_HANDLE_CLOSE_INFORMATION>() ,
               8usize);
}
impl Clone for _REG_KEY_HANDLE_CLOSE_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_REG_KEY_HANDLE_CLOSE_INFORMATION as
        REG_KEY_HANDLE_CLOSE_INFORMATION;
pub type PREG_KEY_HANDLE_CLOSE_INFORMATION =
    *mut _REG_KEY_HANDLE_CLOSE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _REG_CREATE_KEY_INFORMATION {
    pub CompleteName: PUNICODE_STRING,
    pub RootObject: PVOID,
    pub ObjectType: PVOID,
    pub CreateOptions: ULONG,
    pub Class: PUNICODE_STRING,
    pub SecurityDescriptor: PVOID,
    pub SecurityQualityOfService: PVOID,
    pub DesiredAccess: ACCESS_MASK,
    pub GrantedAccess: ACCESS_MASK,
    pub Disposition: PULONG,
    pub ResultObject: *mut PVOID,
    pub CallContext: PVOID,
    pub RootObjectContext: PVOID,
    pub Transaction: PVOID,
    pub Reserved: PVOID,
}
#[test]
fn bindgen_test_layout__REG_CREATE_KEY_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_REG_CREATE_KEY_INFORMATION>() ,
               112usize);
    assert_eq!(::core::mem::align_of::<_REG_CREATE_KEY_INFORMATION>() ,
               8usize);
}
impl Clone for _REG_CREATE_KEY_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_REG_CREATE_KEY_INFORMATION as REG_CREATE_KEY_INFORMATION;
pub use self::_REG_CREATE_KEY_INFORMATION as REG_OPEN_KEY_INFORMATION;
pub type PREG_CREATE_KEY_INFORMATION = *mut _REG_CREATE_KEY_INFORMATION;
pub type PREG_OPEN_KEY_INFORMATION = *mut _REG_CREATE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _REG_CREATE_KEY_INFORMATION_V1 {
    pub CompleteName: PUNICODE_STRING,
    pub RootObject: PVOID,
    pub ObjectType: PVOID,
    pub Options: ULONG,
    pub Class: PUNICODE_STRING,
    pub SecurityDescriptor: PVOID,
    pub SecurityQualityOfService: PVOID,
    pub DesiredAccess: ACCESS_MASK,
    pub GrantedAccess: ACCESS_MASK,
    pub Disposition: PULONG,
    pub ResultObject: *mut PVOID,
    pub CallContext: PVOID,
    pub RootObjectContext: PVOID,
    pub Transaction: PVOID,
    pub Version: ULONG_PTR,
    pub RemainingName: PUNICODE_STRING,
    pub Wow64Flags: ULONG,
    pub Attributes: ULONG,
    pub CheckAccessMode: KPROCESSOR_MODE,
}
#[test]
fn bindgen_test_layout__REG_CREATE_KEY_INFORMATION_V1() {
    assert_eq!(::core::mem::size_of::<_REG_CREATE_KEY_INFORMATION_V1>() ,
               136usize);
    assert_eq!(::core::mem::align_of::<_REG_CREATE_KEY_INFORMATION_V1>() ,
               8usize);
}
impl Clone for _REG_CREATE_KEY_INFORMATION_V1 {
    fn clone(&self) -> Self { *self }
}
pub use self::_REG_CREATE_KEY_INFORMATION_V1 as REG_CREATE_KEY_INFORMATION_V1;
pub use self::_REG_CREATE_KEY_INFORMATION_V1 as REG_OPEN_KEY_INFORMATION_V1;
pub type PREG_CREATE_KEY_INFORMATION_V1 = *mut _REG_CREATE_KEY_INFORMATION_V1;
pub type PREG_OPEN_KEY_INFORMATION_V1 = *mut _REG_CREATE_KEY_INFORMATION_V1;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _REG_POST_OPERATION_INFORMATION {
    pub Object: PVOID,
    pub Status: NTSTATUS,
    pub PreInformation: PVOID,
    pub ReturnStatus: NTSTATUS,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
#[test]
fn bindgen_test_layout__REG_POST_OPERATION_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_REG_POST_OPERATION_INFORMATION>() ,
               56usize);
    assert_eq!(::core::mem::align_of::<_REG_POST_OPERATION_INFORMATION>() ,
               8usize);
}
impl Clone for _REG_POST_OPERATION_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_REG_POST_OPERATION_INFORMATION as
        REG_POST_OPERATION_INFORMATION;
pub type PREG_POST_OPERATION_INFORMATION =
    *mut _REG_POST_OPERATION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _REG_PRE_CREATE_KEY_INFORMATION {
    pub CompleteName: PUNICODE_STRING,
}
#[test]
fn bindgen_test_layout__REG_PRE_CREATE_KEY_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_REG_PRE_CREATE_KEY_INFORMATION>() ,
               8usize);
    assert_eq!(::core::mem::align_of::<_REG_PRE_CREATE_KEY_INFORMATION>() ,
               8usize);
}
impl Clone for _REG_PRE_CREATE_KEY_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_REG_PRE_CREATE_KEY_INFORMATION as
        REG_PRE_CREATE_KEY_INFORMATION;
pub use self::_REG_PRE_CREATE_KEY_INFORMATION as REG_PRE_OPEN_KEY_INFORMATION;
pub type PREG_PRE_CREATE_KEY_INFORMATION =
    *mut _REG_PRE_CREATE_KEY_INFORMATION;
pub type PREG_PRE_OPEN_KEY_INFORMATION = *mut _REG_PRE_CREATE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _REG_POST_CREATE_KEY_INFORMATION {
    pub CompleteName: PUNICODE_STRING,
    pub Object: PVOID,
    pub Status: NTSTATUS,
}
#[test]
fn bindgen_test_layout__REG_POST_CREATE_KEY_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_REG_POST_CREATE_KEY_INFORMATION>() ,
               24usize);
    assert_eq!(::core::mem::align_of::<_REG_POST_CREATE_KEY_INFORMATION>() ,
               8usize);
}
impl Clone for _REG_POST_CREATE_KEY_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_REG_POST_CREATE_KEY_INFORMATION as
        REG_POST_CREATE_KEY_INFORMATION;
pub use self::_REG_POST_CREATE_KEY_INFORMATION as
        REG_POST_OPEN_KEY_INFORMATION;
pub type PREG_POST_CREATE_KEY_INFORMATION =
    *mut _REG_POST_CREATE_KEY_INFORMATION;
pub type PREG_POST_OPEN_KEY_INFORMATION =
    *mut _REG_POST_CREATE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _REG_LOAD_KEY_INFORMATION {
    pub Object: PVOID,
    pub KeyName: PUNICODE_STRING,
    pub SourceFile: PUNICODE_STRING,
    pub Flags: ULONG,
    pub TrustClassObject: PVOID,
    pub UserEvent: PVOID,
    pub DesiredAccess: ACCESS_MASK,
    pub RootHandle: PHANDLE,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
#[test]
fn bindgen_test_layout__REG_LOAD_KEY_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_REG_LOAD_KEY_INFORMATION>() , 88usize);
    assert_eq!(::core::mem::align_of::<_REG_LOAD_KEY_INFORMATION>() , 8usize);
}
impl Clone for _REG_LOAD_KEY_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_REG_LOAD_KEY_INFORMATION as REG_LOAD_KEY_INFORMATION;
pub type PREG_LOAD_KEY_INFORMATION = *mut _REG_LOAD_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _REG_UNLOAD_KEY_INFORMATION {
    pub Object: PVOID,
    pub UserEvent: PVOID,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
#[test]
fn bindgen_test_layout__REG_UNLOAD_KEY_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_REG_UNLOAD_KEY_INFORMATION>() ,
               40usize);
    assert_eq!(::core::mem::align_of::<_REG_UNLOAD_KEY_INFORMATION>() ,
               8usize);
}
impl Clone for _REG_UNLOAD_KEY_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_REG_UNLOAD_KEY_INFORMATION as REG_UNLOAD_KEY_INFORMATION;
pub type PREG_UNLOAD_KEY_INFORMATION = *mut _REG_UNLOAD_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _REG_CALLBACK_CONTEXT_CLEANUP_INFORMATION {
    pub Object: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
#[test]
fn bindgen_test_layout__REG_CALLBACK_CONTEXT_CLEANUP_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_REG_CALLBACK_CONTEXT_CLEANUP_INFORMATION>()
               , 24usize);
    assert_eq!(::core::mem::align_of::<_REG_CALLBACK_CONTEXT_CLEANUP_INFORMATION>()
               , 8usize);
}
impl Clone for _REG_CALLBACK_CONTEXT_CLEANUP_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_REG_CALLBACK_CONTEXT_CLEANUP_INFORMATION as
        REG_CALLBACK_CONTEXT_CLEANUP_INFORMATION;
pub type PREG_CALLBACK_CONTEXT_CLEANUP_INFORMATION =
    *mut _REG_CALLBACK_CONTEXT_CLEANUP_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _REG_QUERY_KEY_SECURITY_INFORMATION {
    pub Object: PVOID,
    pub SecurityInformation: PSECURITY_INFORMATION,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
    pub Length: PULONG,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
#[test]
fn bindgen_test_layout__REG_QUERY_KEY_SECURITY_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_REG_QUERY_KEY_SECURITY_INFORMATION>() ,
               56usize);
    assert_eq!(::core::mem::align_of::<_REG_QUERY_KEY_SECURITY_INFORMATION>()
               , 8usize);
}
impl Clone for _REG_QUERY_KEY_SECURITY_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_REG_QUERY_KEY_SECURITY_INFORMATION as
        REG_QUERY_KEY_SECURITY_INFORMATION;
pub type PREG_QUERY_KEY_SECURITY_INFORMATION =
    *mut _REG_QUERY_KEY_SECURITY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _REG_SET_KEY_SECURITY_INFORMATION {
    pub Object: PVOID,
    pub SecurityInformation: PSECURITY_INFORMATION,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
#[test]
fn bindgen_test_layout__REG_SET_KEY_SECURITY_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_REG_SET_KEY_SECURITY_INFORMATION>() ,
               48usize);
    assert_eq!(::core::mem::align_of::<_REG_SET_KEY_SECURITY_INFORMATION>() ,
               8usize);
}
impl Clone for _REG_SET_KEY_SECURITY_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_REG_SET_KEY_SECURITY_INFORMATION as
        REG_SET_KEY_SECURITY_INFORMATION;
pub type PREG_SET_KEY_SECURITY_INFORMATION =
    *mut _REG_SET_KEY_SECURITY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _REG_RESTORE_KEY_INFORMATION {
    pub Object: PVOID,
    pub FileHandle: HANDLE,
    pub Flags: ULONG,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
#[test]
fn bindgen_test_layout__REG_RESTORE_KEY_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_REG_RESTORE_KEY_INFORMATION>() ,
               48usize);
    assert_eq!(::core::mem::align_of::<_REG_RESTORE_KEY_INFORMATION>() ,
               8usize);
}
impl Clone for _REG_RESTORE_KEY_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_REG_RESTORE_KEY_INFORMATION as REG_RESTORE_KEY_INFORMATION;
pub type PREG_RESTORE_KEY_INFORMATION = *mut _REG_RESTORE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _REG_SAVE_KEY_INFORMATION {
    pub Object: PVOID,
    pub FileHandle: HANDLE,
    pub Format: ULONG,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
#[test]
fn bindgen_test_layout__REG_SAVE_KEY_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_REG_SAVE_KEY_INFORMATION>() , 48usize);
    assert_eq!(::core::mem::align_of::<_REG_SAVE_KEY_INFORMATION>() , 8usize);
}
impl Clone for _REG_SAVE_KEY_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_REG_SAVE_KEY_INFORMATION as REG_SAVE_KEY_INFORMATION;
pub type PREG_SAVE_KEY_INFORMATION = *mut _REG_SAVE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _REG_REPLACE_KEY_INFORMATION {
    pub Object: PVOID,
    pub OldFileName: PUNICODE_STRING,
    pub NewFileName: PUNICODE_STRING,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
#[test]
fn bindgen_test_layout__REG_REPLACE_KEY_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_REG_REPLACE_KEY_INFORMATION>() ,
               48usize);
    assert_eq!(::core::mem::align_of::<_REG_REPLACE_KEY_INFORMATION>() ,
               8usize);
}
impl Clone for _REG_REPLACE_KEY_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_REG_REPLACE_KEY_INFORMATION as REG_REPLACE_KEY_INFORMATION;
pub type PREG_REPLACE_KEY_INFORMATION = *mut _REG_REPLACE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _REG_QUERY_KEY_NAME {
    pub Object: PVOID,
    pub ObjectNameInfo: POBJECT_NAME_INFORMATION,
    pub Length: ULONG,
    pub ReturnLength: PULONG,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
#[test]
fn bindgen_test_layout__REG_QUERY_KEY_NAME() {
    assert_eq!(::core::mem::size_of::<_REG_QUERY_KEY_NAME>() , 56usize);
    assert_eq!(::core::mem::align_of::<_REG_QUERY_KEY_NAME>() , 8usize);
}
impl Clone for _REG_QUERY_KEY_NAME {
    fn clone(&self) -> Self { *self }
}
pub use self::_REG_QUERY_KEY_NAME as REG_QUERY_KEY_NAME;
pub type PREG_QUERY_KEY_NAME = *mut _REG_QUERY_KEY_NAME;
extern "C" {
    pub fn CmRegisterCallback(Function: PEX_CALLBACK_FUNCTION, Context: PVOID,
                              Cookie: PLARGE_INTEGER) -> NTSTATUS;
}
extern "C" {
    pub fn CmUnRegisterCallback(Cookie: LARGE_INTEGER) -> NTSTATUS;
}
extern "C" {
    pub fn CmRegisterCallbackEx(Function: PEX_CALLBACK_FUNCTION,
                                Altitude: PCUNICODE_STRING, Driver: PVOID,
                                Context: PVOID, Cookie: PLARGE_INTEGER,
                                Reserved: PVOID) -> NTSTATUS;
}
extern "C" {
    pub fn CmGetCallbackVersion(Major: PULONG, Minor: PULONG);
}
extern "C" {
    pub fn CmSetCallbackObjectContext(Object: PVOID, Cookie: PLARGE_INTEGER,
                                      NewContext: PVOID,
                                      OldContext: *mut PVOID) -> NTSTATUS;
}
extern "C" {
    pub fn CmCallbackGetKeyObjectID(Cookie: PLARGE_INTEGER, Object: PVOID,
                                    ObjectID: PULONG_PTR,
                                    ObjectName: *mut PCUNICODE_STRING)
     -> NTSTATUS;
}
extern "C" {
    pub fn CmGetBoundTransaction(Cookie: PLARGE_INTEGER, Object: PVOID)
     -> PVOID;
}
extern "C" {
    pub fn CmCallbackGetKeyObjectIDEx(Cookie: PLARGE_INTEGER, Object: PVOID,
                                      ObjectID: PULONG_PTR,
                                      ObjectName: *mut PCUNICODE_STRING,
                                      Flags: ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn CmCallbackReleaseKeyObjectIDEx(ObjectName: PCUNICODE_STRING);
}
extern "C" {
    #[link_name = "Mm64BitPhysicalAddress"]
    pub static mut Mm64BitPhysicalAddress: PBOOLEAN;
}
extern "C" {
    #[link_name = "MmBadPointer"]
    pub static mut MmBadPointer: PVOID;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _MM_SYSTEM_SIZE {
    MmSmallSystem = 0,
    MmMediumSystem = 1,
    MmLargeSystem = 2,
}
pub use self::_MM_SYSTEM_SIZE as MM_SYSTEMSIZE;
extern "C" {
    pub fn MmQuerySystemSize() -> MM_SYSTEMSIZE;
}
extern "C" {
    pub fn MmIsVerifierEnabled(VerifierFlags: PULONG) -> NTSTATUS;
}
extern "C" {
    pub fn MmAddVerifierThunks(ThunkBuffer: PVOID, ThunkBufferSize: ULONG)
     -> NTSTATUS;
}
extern "C" {
    pub fn MmAddVerifierSpecialThunks(EntryRoutine: ULONG_PTR,
                                      ThunkBuffer: PVOID,
                                      ThunkBufferSize: ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn MmProbeAndLockSelectedPages(MemoryDescriptorList: PMDL,
                                       SegmentArray: PFILE_SEGMENT_ELEMENT,
                                       AccessMode: KPROCESSOR_MODE,
                                       Operation: LOCK_OPERATION);
}
extern "C" {
    pub fn MmProbeAndLockProcessPages(MemoryDescriptorList: PMDL,
                                      Process: PEPROCESS,
                                      AccessMode: KPROCESSOR_MODE,
                                      Operation: LOCK_OPERATION);
}
extern "C" {
    pub fn MmProbeAndLockPages(MemoryDescriptorList: PMDL,
                               AccessMode: KPROCESSOR_MODE,
                               Operation: LOCK_OPERATION);
}
extern "C" {
    pub fn MmUnlockPages(MemoryDescriptorList: PMDL);
}
extern "C" {
    pub fn MmBuildMdlForNonPagedPool(MemoryDescriptorList: PMDL);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _MM_PHYSICAL_ADDRESS_LIST {
    pub PhysicalAddress: PHYSICAL_ADDRESS,
    pub NumberOfBytes: SIZE_T,
}
#[test]
fn bindgen_test_layout__MM_PHYSICAL_ADDRESS_LIST() {
    assert_eq!(::core::mem::size_of::<_MM_PHYSICAL_ADDRESS_LIST>() , 16usize);
    assert_eq!(::core::mem::align_of::<_MM_PHYSICAL_ADDRESS_LIST>() , 8usize);
}
impl Clone for _MM_PHYSICAL_ADDRESS_LIST {
    fn clone(&self) -> Self { *self }
}
pub use self::_MM_PHYSICAL_ADDRESS_LIST as MM_PHYSICAL_ADDRESS_LIST;
pub type PMM_PHYSICAL_ADDRESS_LIST = *mut _MM_PHYSICAL_ADDRESS_LIST;
extern "C" {
    pub fn MmAllocateMdlForIoSpace(PhysicalAddressList:
                                       PMM_PHYSICAL_ADDRESS_LIST,
                                   NumberOfEntries: SIZE_T, NewMdl: *mut PMDL)
     -> NTSTATUS;
}
extern "C" {
    pub fn MmAreMdlPagesCached(MemoryDescriptorList: PMDL) -> LOGICAL;
}
extern "C" {
    pub fn MmMapLockedPages(MemoryDescriptorList: PMDL,
                            AccessMode: KPROCESSOR_MODE) -> PVOID;
}
extern "C" {
    pub fn MmIsIoSpaceActive(StartAddress: PHYSICAL_ADDRESS,
                             NumberOfBytes: SIZE_T) -> LOGICAL;
}
extern "C" {
    pub fn MmAdvanceMdl(Mdl: PMDL, NumberOfBytes: ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn MmProtectMdlSystemAddress(MemoryDescriptorList: PMDL,
                                     NewProtect: ULONG) -> NTSTATUS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _MM_PAGE_PRIORITY {
    LowPagePriority = 0,
    NormalPagePriority = 16,
    HighPagePriority = 32,
}
pub use self::_MM_PAGE_PRIORITY as MM_PAGE_PRIORITY;
extern "C" {
    pub fn MmMapLockedPagesSpecifyCache(MemoryDescriptorList: PMDL,
                                        AccessMode: KPROCESSOR_MODE,
                                        CacheType: MEMORY_CACHING_TYPE,
                                        RequestedAddress: PVOID,
                                        BugCheckOnFailure: ULONG,
                                        Priority: ULONG) -> PVOID;
}
extern "C" {
    pub fn MmUnmapLockedPages(BaseAddress: PVOID, MemoryDescriptorList: PMDL);
}
extern "C" {
    pub fn MmAllocateMappingAddress(NumberOfBytes: SIZE_T, PoolTag: ULONG)
     -> PVOID;
}
extern "C" {
    pub fn MmFreeMappingAddress(BaseAddress: PVOID, PoolTag: ULONG);
}
extern "C" {
    pub fn MmMapLockedPagesWithReservedMapping(MappingAddress: PVOID,
                                               PoolTag: ULONG,
                                               MemoryDescriptorList: PMDL,
                                               CacheType: MEMORY_CACHING_TYPE)
     -> PVOID;
}
extern "C" {
    pub fn MmUnmapReservedMapping(BaseAddress: PVOID, PoolTag: ULONG,
                                  MemoryDescriptorList: PMDL);
}
extern "C" {
    pub fn MmAllocateNodePagesForMdlEx(LowAddress: PHYSICAL_ADDRESS,
                                       HighAddress: PHYSICAL_ADDRESS,
                                       SkipBytes: PHYSICAL_ADDRESS,
                                       TotalBytes: SIZE_T,
                                       CacheType: MEMORY_CACHING_TYPE,
                                       IdealNode: ULONG, Flags: ULONG)
     -> PMDL;
}
extern "C" {
    pub fn MmAllocatePagesForMdlEx(LowAddress: PHYSICAL_ADDRESS,
                                   HighAddress: PHYSICAL_ADDRESS,
                                   SkipBytes: PHYSICAL_ADDRESS,
                                   TotalBytes: SIZE_T,
                                   CacheType: MEMORY_CACHING_TYPE,
                                   Flags: ULONG) -> PMDL;
}
extern "C" {
    pub fn MmAllocatePagesForMdl(LowAddress: PHYSICAL_ADDRESS,
                                 HighAddress: PHYSICAL_ADDRESS,
                                 SkipBytes: PHYSICAL_ADDRESS,
                                 TotalBytes: SIZE_T) -> PMDL;
}
extern "C" {
    pub fn MmFreePagesFromMdl(MemoryDescriptorList: PMDL);
}
extern "C" {
    pub fn MmMapIoSpace(PhysicalAddress: PHYSICAL_ADDRESS,
                        NumberOfBytes: SIZE_T, CacheType: MEMORY_CACHING_TYPE)
     -> PVOID;
}
extern "C" {
    pub fn MmUnmapIoSpace(BaseAddress: PVOID, NumberOfBytes: SIZE_T);
}
extern "C" {
    pub fn MmMapIoSpaceEx(PhysicalAddress: PHYSICAL_ADDRESS,
                          NumberOfBytes: SIZE_T, Protect: ULONG) -> PVOID;
}
extern "C" {
    pub fn MmAllocateContiguousMemory(NumberOfBytes: SIZE_T,
                                      HighestAcceptableAddress:
                                          PHYSICAL_ADDRESS) -> PVOID;
}
extern "C" {
    pub fn MmAllocateContiguousMemorySpecifyCache(NumberOfBytes: SIZE_T,
                                                  LowestAcceptableAddress:
                                                      PHYSICAL_ADDRESS,
                                                  HighestAcceptableAddress:
                                                      PHYSICAL_ADDRESS,
                                                  BoundaryAddressMultiple:
                                                      PHYSICAL_ADDRESS,
                                                  CacheType:
                                                      MEMORY_CACHING_TYPE)
     -> PVOID;
}
pub type NODE_REQUIREMENT = ULONG;
extern "C" {
    pub fn MmAllocateContiguousMemorySpecifyCacheNode(NumberOfBytes: SIZE_T,
                                                      LowestAcceptableAddress:
                                                          PHYSICAL_ADDRESS,
                                                      HighestAcceptableAddress:
                                                          PHYSICAL_ADDRESS,
                                                      BoundaryAddressMultiple:
                                                          PHYSICAL_ADDRESS,
                                                      CacheType:
                                                          MEMORY_CACHING_TYPE,
                                                      PreferredNode:
                                                          NODE_REQUIREMENT)
     -> PVOID;
}
extern "C" {
    pub fn MmAllocateContiguousNodeMemory(NumberOfBytes: SIZE_T,
                                          LowestAcceptableAddress:
                                              PHYSICAL_ADDRESS,
                                          HighestAcceptableAddress:
                                              PHYSICAL_ADDRESS,
                                          BoundaryAddressMultiple:
                                              PHYSICAL_ADDRESS,
                                          Protect: ULONG,
                                          PreferredNode: NODE_REQUIREMENT)
     -> PVOID;
}
extern "C" {
    pub fn MmFreeContiguousMemory(BaseAddress: PVOID);
}
extern "C" {
    pub fn MmFreeContiguousMemorySpecifyCache(BaseAddress: PVOID,
                                              NumberOfBytes: SIZE_T,
                                              CacheType: MEMORY_CACHING_TYPE);
}
extern "C" {
    pub fn MmSizeOfMdl(Base: PVOID, Length: SIZE_T) -> SIZE_T;
}
extern "C" {
    pub fn MmCreateMdl(MemoryDescriptorList: PMDL, Base: PVOID,
                       Length: SIZE_T) -> PMDL;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _MM_MDL_PAGE_CONTENTS_STATE {
    MmMdlPageContentsDynamic = 0,
    MmMdlPageContentsInvariant = 1,
    MmMdlPageContentsQuery = 2,
}
pub use self::_MM_MDL_PAGE_CONTENTS_STATE as MM_MDL_PAGE_CONTENTS_STATE;
pub use self::_MM_MDL_PAGE_CONTENTS_STATE as PMM_MDL_PAGE_CONTENTS_STATE;
extern "C" {
    pub fn MmMdlPageContentsState(MemoryDescriptorList: PMDL,
                                  State: MM_MDL_PAGE_CONTENTS_STATE)
     -> MM_MDL_PAGE_CONTENTS_STATE;
}
extern "C" {
    pub fn MmLockPagableDataSection(AddressWithinSection: PVOID) -> PVOID;
}
extern "C" {
    pub fn MmResetDriverPaging(AddressWithinSection: PVOID);
}
extern "C" {
    pub fn MmPageEntireDriver(AddressWithinSection: PVOID) -> PVOID;
}
extern "C" {
    pub fn MmUnlockPagableImageSection(ImageSectionHandle: PVOID);
}
pub type PMM_DLL_INITIALIZE =
    ::core::option::Option<unsafe extern "C" fn(RegistryPath: PUNICODE_STRING)
                               -> libc::c_long>;
pub type PMM_DLL_UNLOAD =
    ::core::option::Option<unsafe extern "C" fn() -> libc::c_long>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DRIVER_OBJECT {
    pub Type: CSHORT,
    pub Size: CSHORT,
    pub DeviceObject: PDEVICE_OBJECT,
    pub Flags: ULONG,
    pub DriverStart: PVOID,
    pub DriverSize: ULONG,
    pub DriverSection: PVOID,
    pub DriverExtension: PDRIVER_EXTENSION,
    pub DriverName: UNICODE_STRING,
    pub HardwareDatabase: PUNICODE_STRING,
    pub FastIoDispatch: PFAST_IO_DISPATCH,
    pub DriverInit: PDRIVER_INITIALIZE,
    pub DriverStartIo: PDRIVER_STARTIO,
    pub DriverUnload: PDRIVER_UNLOAD,
    pub MajorFunction: [PDRIVER_DISPATCH; 28usize],
}
#[test]
fn bindgen_test_layout__DRIVER_OBJECT() {
    assert_eq!(::core::mem::size_of::<_DRIVER_OBJECT>() , 336usize);
    assert_eq!(::core::mem::align_of::<_DRIVER_OBJECT>() , 8usize);
}
impl Clone for _DRIVER_OBJECT {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn MmIsDriverSuspectForVerifier(DriverObject: *mut _DRIVER_OBJECT)
     -> LOGICAL;
}
extern "C" {
    pub fn MmIsDriverVerifying(DriverObject: *mut _DRIVER_OBJECT) -> LOGICAL;
}
extern "C" {
    pub fn MmIsDriverVerifyingByAddress(AddressWithinSection: PVOID)
     -> LOGICAL;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _SECURITY_OPERATION_CODE {
    SetSecurityDescriptor = 0,
    QuerySecurityDescriptor = 1,
    DeleteSecurityDescriptor = 2,
    AssignSecurityDescriptor = 3,
}
pub use self::_SECURITY_OPERATION_CODE as SECURITY_OPERATION_CODE;
pub type PSECURITY_OPERATION_CODE = *mut _SECURITY_OPERATION_CODE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SECURITY_SUBJECT_CONTEXT {
    pub ClientToken: PACCESS_TOKEN,
    pub ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    pub PrimaryToken: PACCESS_TOKEN,
    pub ProcessAuditId: PVOID,
}
#[test]
fn bindgen_test_layout__SECURITY_SUBJECT_CONTEXT() {
    assert_eq!(::core::mem::size_of::<_SECURITY_SUBJECT_CONTEXT>() , 32usize);
    assert_eq!(::core::mem::align_of::<_SECURITY_SUBJECT_CONTEXT>() , 8usize);
}
impl Clone for _SECURITY_SUBJECT_CONTEXT {
    fn clone(&self) -> Self { *self }
}
pub use self::_SECURITY_SUBJECT_CONTEXT as SECURITY_SUBJECT_CONTEXT;
pub type PSECURITY_SUBJECT_CONTEXT = *mut _SECURITY_SUBJECT_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _INITIAL_PRIVILEGE_SET {
    pub PrivilegeCount: ULONG,
    pub Control: ULONG,
    pub Privilege: [LUID_AND_ATTRIBUTES; 3usize],
}
#[test]
fn bindgen_test_layout__INITIAL_PRIVILEGE_SET() {
    assert_eq!(::core::mem::size_of::<_INITIAL_PRIVILEGE_SET>() , 44usize);
    assert_eq!(::core::mem::align_of::<_INITIAL_PRIVILEGE_SET>() , 4usize);
}
impl Clone for _INITIAL_PRIVILEGE_SET {
    fn clone(&self) -> Self { *self }
}
pub use self::_INITIAL_PRIVILEGE_SET as INITIAL_PRIVILEGE_SET;
pub type PINITIAL_PRIVILEGE_SET = *mut _INITIAL_PRIVILEGE_SET;
pub use self::_ACCESS_STATE as ACCESS_STATE;
pub type NTFS_DEREF_EXPORTED_SECURITY_DESCRIPTOR =
    ::core::option::Option<unsafe extern "C" fn(Vcb: PVOID,
                                                SecurityDescriptor:
                                                    PSECURITY_DESCRIPTOR)>;
pub type PNTFS_DEREF_EXPORTED_SECURITY_DESCRIPTOR =
    NTFS_DEREF_EXPORTED_SECURITY_DESCRIPTOR;
extern "C" {
    pub fn SeCaptureSubjectContext(SubjectContext: PSECURITY_SUBJECT_CONTEXT);
}
extern "C" {
    pub fn SeLockSubjectContext(SubjectContext: PSECURITY_SUBJECT_CONTEXT);
}
extern "C" {
    pub fn SeUnlockSubjectContext(SubjectContext: PSECURITY_SUBJECT_CONTEXT);
}
extern "C" {
    pub fn SeReleaseSubjectContext(SubjectContext: PSECURITY_SUBJECT_CONTEXT);
}
extern "C" {
    pub fn SeAssignSecurity(ParentDescriptor: PSECURITY_DESCRIPTOR,
                            ExplicitDescriptor: PSECURITY_DESCRIPTOR,
                            NewDescriptor: *mut PSECURITY_DESCRIPTOR,
                            IsDirectoryObject: BOOLEAN,
                            SubjectContext: PSECURITY_SUBJECT_CONTEXT,
                            GenericMapping: PGENERIC_MAPPING,
                            PoolType: POOL_TYPE) -> NTSTATUS;
}
extern "C" {
    pub fn SeComputeAutoInheritByObjectType(ObjectType: PVOID,
                                            SecurityDescriptor:
                                                PSECURITY_DESCRIPTOR,
                                            ParentSecurityDescriptor:
                                                PSECURITY_DESCRIPTOR)
     -> ULONG;
}
extern "C" {
    pub fn SeAssignSecurityEx(ParentDescriptor: PSECURITY_DESCRIPTOR,
                              ExplicitDescriptor: PSECURITY_DESCRIPTOR,
                              NewDescriptor: *mut PSECURITY_DESCRIPTOR,
                              ObjectType: *mut GUID,
                              IsDirectoryObject: BOOLEAN,
                              AutoInheritFlags: ULONG,
                              SubjectContext: PSECURITY_SUBJECT_CONTEXT,
                              GenericMapping: PGENERIC_MAPPING,
                              PoolType: POOL_TYPE) -> NTSTATUS;
}
extern "C" {
    pub fn SeDeassignSecurity(SecurityDescriptor: *mut PSECURITY_DESCRIPTOR)
     -> NTSTATUS;
}
extern "C" {
    pub fn SeObjectCreateSaclAccessBits(SecurityDescriptor:
                                            PSECURITY_DESCRIPTOR) -> ULONG;
}
extern "C" {
    pub fn SeAccessCheck(SecurityDescriptor: PSECURITY_DESCRIPTOR,
                         SubjectSecurityContext: PSECURITY_SUBJECT_CONTEXT,
                         SubjectContextLocked: BOOLEAN,
                         DesiredAccess: ACCESS_MASK,
                         PreviouslyGrantedAccess: ACCESS_MASK,
                         Privileges: *mut PPRIVILEGE_SET,
                         GenericMapping: PGENERIC_MAPPING,
                         AccessMode: KPROCESSOR_MODE,
                         GrantedAccess: PACCESS_MASK, AccessStatus: PNTSTATUS)
     -> BOOLEAN;
}
extern "C" {
    pub fn SeSetAuditParameter(AuditParameters: PSE_ADT_PARAMETER_ARRAY,
                               Type: SE_ADT_PARAMETER_TYPE, Index: ULONG,
                               Data: PVOID) -> NTSTATUS;
}
extern "C" {
    pub fn SeReportSecurityEvent(Flags: ULONG, SourceName: PUNICODE_STRING,
                                 UserSid: PSID,
                                 AuditParameters: PSE_ADT_PARAMETER_ARRAY)
     -> NTSTATUS;
}
extern "C" {
    pub fn SeValidSecurityDescriptor(Length: ULONG,
                                     SecurityDescriptor: PSECURITY_DESCRIPTOR)
     -> BOOLEAN;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _SE_IMAGE_TYPE {
    SeImageTypeElamDriver = 0,
    SeImageTypeDriver = 1,
    SeImageTypeMax = 2,
}
pub use self::_SE_IMAGE_TYPE as SE_IMAGE_TYPE;
pub type PSE_IMAGE_TYPE = *mut _SE_IMAGE_TYPE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _BDCB_IMAGE_INFORMATION {
    pub Classification: BDCB_CLASSIFICATION,
    pub ImageFlags: ULONG,
    pub ImageName: UNICODE_STRING,
    pub RegistryPath: UNICODE_STRING,
    pub CertificatePublisher: UNICODE_STRING,
    pub CertificateIssuer: UNICODE_STRING,
    pub ImageHash: PVOID,
    pub CertificateThumbprint: PVOID,
    pub ImageHashAlgorithm: ULONG,
    pub ThumbprintHashAlgorithm: ULONG,
    pub ImageHashLength: ULONG,
    pub CertificateThumbprintLength: ULONG,
}
#[test]
fn bindgen_test_layout__BDCB_IMAGE_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_BDCB_IMAGE_INFORMATION>() , 104usize);
    assert_eq!(::core::mem::align_of::<_BDCB_IMAGE_INFORMATION>() , 8usize);
}
impl Clone for _BDCB_IMAGE_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub type PBDCB_IMAGE_INFORMATION = *mut _BDCB_IMAGE_INFORMATION;
pub type SE_IMAGE_VERIFICATION_CALLBACK_FUNCTION =
    ::core::option::Option<unsafe extern "C" fn(CallbackContext: PVOID,
                                                ImageType: SE_IMAGE_TYPE,
                                                ImageInformation:
                                                    PBDCB_IMAGE_INFORMATION)>;
pub type PSE_IMAGE_VERIFICATION_CALLBACK_FUNCTION =
    SE_IMAGE_VERIFICATION_CALLBACK_FUNCTION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _SE_IMAGE_VERIFICATION_CALLBACK_TYPE {
    SeImageVerificationCallbackInformational = 0,
}
pub use self::_SE_IMAGE_VERIFICATION_CALLBACK_TYPE as
        SE_IMAGE_VERIFICATION_CALLBACK_TYPE;
pub type PSE_IMAGE_VERIFICATION_CALLBACK_TYPE =
    *mut _SE_IMAGE_VERIFICATION_CALLBACK_TYPE;
pub type SE_IMAGE_VERIFICATION_CALLBACK_TOKEN = PVOID;
pub type PSE_IMAGE_VERIFICATION_CALLBACK_TOKEN = *mut PVOID;
extern "C" {
    pub fn SeRegisterImageVerificationCallback(ImageType: SE_IMAGE_TYPE,
                                               CallbackType:
                                                   SE_IMAGE_VERIFICATION_CALLBACK_TYPE,
                                               CallbackFunction:
                                                   PSE_IMAGE_VERIFICATION_CALLBACK_FUNCTION,
                                               CallbackContext: PVOID,
                                               Token:
                                                   SE_IMAGE_VERIFICATION_CALLBACK_TOKEN,
                                               CallbackHandle: *mut PVOID)
     -> NTSTATUS;
}
extern "C" {
    pub fn SeUnregisterImageVerificationCallback(CallbackHandle: PVOID);
}
extern "C" {
    pub fn PsCreateSystemThread(ThreadHandle: PHANDLE, DesiredAccess: ULONG,
                                ObjectAttributes: POBJECT_ATTRIBUTES,
                                ProcessHandle: HANDLE, ClientId: PCLIENT_ID,
                                StartRoutine: PKSTART_ROUTINE,
                                StartContext: PVOID) -> NTSTATUS;
}
extern "C" {
    pub fn PsTerminateSystemThread(ExitStatus: NTSTATUS) -> NTSTATUS;
}
extern "C" {
    pub fn PsWrapApcWow64Thread(ApcContext: *mut PVOID,
                                ApcRoutine: *mut PVOID) -> NTSTATUS;
}
extern "C" {
    pub fn PsGetVersion(MajorVersion: PULONG, MinorVersion: PULONG,
                        BuildNumber: PULONG, CSDVersion: PUNICODE_STRING)
     -> BOOLEAN;
}
extern "C" {
    pub fn PsQueryTotalCycleTimeProcess(Process: PEPROCESS,
                                        CycleTimeStamp: PULONG64) -> ULONG64;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _CREATE_FILE_TYPE {
    CreateFileTypeNone = 0,
    CreateFileTypeNamedPipe = 1,
    CreateFileTypeMailslot = 2,
}
pub use self::_CREATE_FILE_TYPE as CREATE_FILE_TYPE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _NAMED_PIPE_CREATE_PARAMETERS {
    pub NamedPipeType: ULONG,
    pub ReadMode: ULONG,
    pub CompletionMode: ULONG,
    pub MaximumInstances: ULONG,
    pub InboundQuota: ULONG,
    pub OutboundQuota: ULONG,
    pub DefaultTimeout: LARGE_INTEGER,
    pub TimeoutSpecified: BOOLEAN,
}
#[test]
fn bindgen_test_layout__NAMED_PIPE_CREATE_PARAMETERS() {
    assert_eq!(::core::mem::size_of::<_NAMED_PIPE_CREATE_PARAMETERS>() ,
               40usize);
    assert_eq!(::core::mem::align_of::<_NAMED_PIPE_CREATE_PARAMETERS>() ,
               8usize);
}
impl Clone for _NAMED_PIPE_CREATE_PARAMETERS {
    fn clone(&self) -> Self { *self }
}
pub use self::_NAMED_PIPE_CREATE_PARAMETERS as NAMED_PIPE_CREATE_PARAMETERS;
pub type PNAMED_PIPE_CREATE_PARAMETERS = *mut _NAMED_PIPE_CREATE_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _MAILSLOT_CREATE_PARAMETERS {
    pub MailslotQuota: ULONG,
    pub MaximumMessageSize: ULONG,
    pub ReadTimeout: LARGE_INTEGER,
    pub TimeoutSpecified: BOOLEAN,
}
#[test]
fn bindgen_test_layout__MAILSLOT_CREATE_PARAMETERS() {
    assert_eq!(::core::mem::size_of::<_MAILSLOT_CREATE_PARAMETERS>() ,
               24usize);
    assert_eq!(::core::mem::align_of::<_MAILSLOT_CREATE_PARAMETERS>() ,
               8usize);
}
impl Clone for _MAILSLOT_CREATE_PARAMETERS {
    fn clone(&self) -> Self { *self }
}
pub use self::_MAILSLOT_CREATE_PARAMETERS as MAILSLOT_CREATE_PARAMETERS;
pub type PMAILSLOT_CREATE_PARAMETERS = *mut _MAILSLOT_CREATE_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DEVICE_DESCRIPTION {
    pub Version: ULONG,
    pub Master: BOOLEAN,
    pub ScatterGather: BOOLEAN,
    pub DemandMode: BOOLEAN,
    pub AutoInitialize: BOOLEAN,
    pub Dma32BitAddresses: BOOLEAN,
    pub IgnoreCount: BOOLEAN,
    pub Reserved1: BOOLEAN,
    pub Dma64BitAddresses: BOOLEAN,
    pub BusNumber: ULONG,
    pub DmaChannel: ULONG,
    pub InterfaceType: INTERFACE_TYPE,
    pub DmaWidth: DMA_WIDTH,
    pub DmaSpeed: DMA_SPEED,
    pub MaximumLength: ULONG,
    pub DmaPort: ULONG,
    pub DmaAddressWidth: ULONG,
    pub DmaControllerInstance: ULONG,
    pub DmaRequestLine: ULONG,
    pub DeviceAddress: PHYSICAL_ADDRESS,
}
#[test]
fn bindgen_test_layout__DEVICE_DESCRIPTION() {
    assert_eq!(::core::mem::size_of::<_DEVICE_DESCRIPTION>() , 64usize);
    assert_eq!(::core::mem::align_of::<_DEVICE_DESCRIPTION>() , 8usize);
}
impl Clone for _DEVICE_DESCRIPTION {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DEVICE_OBJECT {
    pub Type: CSHORT,
    pub Size: USHORT,
    pub ReferenceCount: LONG,
    pub DriverObject: *mut _DRIVER_OBJECT,
    pub NextDevice: *mut _DEVICE_OBJECT,
    pub AttachedDevice: *mut _DEVICE_OBJECT,
    pub CurrentIrp: *mut _IRP,
    pub Timer: PIO_TIMER,
    pub Flags: ULONG,
    pub Characteristics: ULONG,
    pub Vpb: PVPB,
    pub DeviceExtension: PVOID,
    pub DeviceType: ULONG,
    pub StackSize: CCHAR,
    pub Queue: _DEVICE_OBJECT__bindgen_ty_1,
    pub AlignmentRequirement: ULONG,
    pub DeviceQueue: KDEVICE_QUEUE,
    pub Dpc: KDPC,
    pub ActiveThreadCount: ULONG,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
    pub DeviceLock: KEVENT,
    pub SectorSize: USHORT,
    pub Spare1: USHORT,
    pub DeviceObjectExtension: *mut _DEVICE_OBJECT__DEVOBJ_EXTENSION,
    pub Reserved: PVOID,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DEVICE_OBJECT__bindgen_ty_1 {
    pub ListEntry: __BindgenUnionField<LIST_ENTRY>,
    pub Wcb: __BindgenUnionField<WAIT_CONTEXT_BLOCK>,
    pub bindgen_union_field: [u64; 9usize],
}
#[test]
fn bindgen_test_layout__DEVICE_OBJECT__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_DEVICE_OBJECT__bindgen_ty_1>() ,
               72usize);
    assert_eq!(::core::mem::align_of::<_DEVICE_OBJECT__bindgen_ty_1>() ,
               8usize);
}
impl Clone for _DEVICE_OBJECT__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DEVICE_OBJECT__DEVOBJ_EXTENSION {
    pub Type: CSHORT,
    pub Size: USHORT,
    pub DeviceObject: PDEVICE_OBJECT,
    pub PowerFlags: ULONG,
    pub Dope: *mut _DEVICE_OBJECT_POWER_EXTENSION,
    pub ExtensionFlags: ULONG,
    pub DeviceNode: PVOID,
    pub AttachedTo: PDEVICE_OBJECT,
    pub StartIoCount: LONG,
    pub StartIoKey: LONG,
    pub StartIoFlags: ULONG,
    pub Vpb: PVPB,
    pub DependencyNode: PVOID,
    pub InterruptContext: PVOID,
    pub VerifierContext: PVOID,
}
#[test]
fn bindgen_test_layout__DEVICE_OBJECT__DEVOBJ_EXTENSION() {
    assert_eq!(::core::mem::size_of::<_DEVICE_OBJECT__DEVOBJ_EXTENSION>() ,
               104usize);
    assert_eq!(::core::mem::align_of::<_DEVICE_OBJECT__DEVOBJ_EXTENSION>() ,
               8usize);
}
impl Clone for _DEVICE_OBJECT__DEVOBJ_EXTENSION {
    fn clone(&self) -> Self { *self }
}
impl Clone for _DEVICE_OBJECT {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DMA_ADAPTER {
    pub Version: USHORT,
    pub Size: USHORT,
    pub DmaOperations: PDMA_OPERATIONS,
}
#[test]
fn bindgen_test_layout__DMA_ADAPTER() {
    assert_eq!(::core::mem::size_of::<_DMA_ADAPTER>() , 16usize);
    assert_eq!(::core::mem::align_of::<_DMA_ADAPTER>() , 8usize);
}
impl Clone for _DMA_ADAPTER {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DRIVE_LAYOUT_INFORMATION {
    pub _address: u8,
}
impl Clone for _DRIVE_LAYOUT_INFORMATION {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DISK_PARTITION {
    pub _address: u8,
}
impl Clone for _DISK_PARTITION {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _FILE_OBJECT {
    pub Type: CSHORT,
    pub Size: CSHORT,
    pub DeviceObject: PDEVICE_OBJECT,
    pub Vpb: PVPB,
    pub FsContext: PVOID,
    pub FsContext2: PVOID,
    pub SectionObjectPointer: PSECTION_OBJECT_POINTERS,
    pub PrivateCacheMap: PVOID,
    pub FinalStatus: NTSTATUS,
    pub RelatedFileObject: *mut _FILE_OBJECT,
    pub LockOperation: BOOLEAN,
    pub DeletePending: BOOLEAN,
    pub ReadAccess: BOOLEAN,
    pub WriteAccess: BOOLEAN,
    pub DeleteAccess: BOOLEAN,
    pub SharedRead: BOOLEAN,
    pub SharedWrite: BOOLEAN,
    pub SharedDelete: BOOLEAN,
    pub Flags: ULONG,
    pub FileName: UNICODE_STRING,
    pub CurrentByteOffset: LARGE_INTEGER,
    pub Waiters: ULONG,
    pub Busy: ULONG,
    pub LastLock: PVOID,
    pub Lock: KEVENT,
    pub Event: KEVENT,
    pub CompletionContext: PIO_COMPLETION_CONTEXT,
    pub IrpListLock: KSPIN_LOCK,
    pub IrpList: LIST_ENTRY,
    pub FileObjectExtension: PVOID,
}
#[test]
fn bindgen_test_layout__FILE_OBJECT() {
    assert_eq!(::core::mem::size_of::<_FILE_OBJECT>() , 216usize);
    assert_eq!(::core::mem::align_of::<_FILE_OBJECT>() , 8usize);
}
impl Clone for _FILE_OBJECT {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IRP {
    pub Type: CSHORT,
    pub Size: USHORT,
    pub MdlAddress: PMDL,
    pub Flags: ULONG,
    pub AssociatedIrp: _IRP__bindgen_ty_1,
    pub ThreadListEntry: LIST_ENTRY,
    pub IoStatus: IO_STATUS_BLOCK,
    pub RequestorMode: KPROCESSOR_MODE,
    pub PendingReturned: BOOLEAN,
    pub StackCount: CHAR,
    pub CurrentLocation: CHAR,
    pub Cancel: BOOLEAN,
    pub CancelIrql: KIRQL,
    pub ApcEnvironment: CCHAR,
    pub AllocationFlags: UCHAR,
    pub UserIosb: PIO_STATUS_BLOCK,
    pub UserEvent: PKEVENT,
    pub Overlay: _IRP__bindgen_ty_2,
    pub CancelRoutine: PDRIVER_CANCEL,
    pub UserBuffer: PVOID,
    pub Tail: _IRP__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IRP__bindgen_ty_1 {
    pub MasterIrp: __BindgenUnionField<*mut _IRP>,
    pub IrpCount: __BindgenUnionField<LONG>,
    pub SystemBuffer: __BindgenUnionField<PVOID>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_IRP__bindgen_ty_1>() , 8usize);
    assert_eq!(::core::mem::align_of::<_IRP__bindgen_ty_1>() , 8usize);
}
impl Clone for _IRP__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IRP__bindgen_ty_2 {
    pub AsynchronousParameters: __BindgenUnionField<_IRP__bindgen_ty_2__bindgen_ty_1>,
    pub AllocationSize: __BindgenUnionField<LARGE_INTEGER>,
    pub bindgen_union_field: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IRP__bindgen_ty_2__bindgen_ty_1 {
    pub __bindgen_anon_1: _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    pub UserApcContext: PVOID,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub UserApcRoutine: __BindgenUnionField<PIO_APC_ROUTINE>,
    pub IssuingProcess: __BindgenUnionField<PVOID>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>()
               , 8usize);
    assert_eq!(::core::mem::align_of::<_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>()
               , 8usize);
}
impl Clone for _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_IRP__bindgen_ty_2__bindgen_ty_1>() ,
               16usize);
    assert_eq!(::core::mem::align_of::<_IRP__bindgen_ty_2__bindgen_ty_1>() ,
               8usize);
}
impl Clone for _IRP__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<_IRP__bindgen_ty_2>() , 16usize);
    assert_eq!(::core::mem::align_of::<_IRP__bindgen_ty_2>() , 8usize);
}
impl Clone for _IRP__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IRP__bindgen_ty_3 {
    pub Overlay: __BindgenUnionField<_IRP__bindgen_ty_3__bindgen_ty_1>,
    pub Apc: __BindgenUnionField<KAPC>,
    pub CompletionKey: __BindgenUnionField<PVOID>,
    pub bindgen_union_field: [u64; 11usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IRP__bindgen_ty_3__bindgen_ty_1 {
    pub __bindgen_anon_1: _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
    pub Thread: PETHREAD,
    pub AuxiliaryBuffer: PCHAR,
    pub __bindgen_anon_2: _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2,
    pub OriginalFileObject: PFILE_OBJECT,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    pub DeviceQueueEntry: __BindgenUnionField<KDEVICE_QUEUE_ENTRY>,
    pub __bindgen_anon_1: __BindgenUnionField<_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: [u64; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub DriverContext: [PVOID; 4usize],
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()
               , 32usize);
    assert_eq!(::core::mem::align_of::<_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()
               , 8usize);
}
impl Clone for _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>()
               , 32usize);
    assert_eq!(::core::mem::align_of::<_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>()
               , 8usize);
}
impl Clone for _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2 {
    pub ListEntry: LIST_ENTRY,
    pub __bindgen_anon_1: _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub CurrentStackLocation: __BindgenUnionField<*mut _IO_STACK_LOCATION>,
    pub PacketType: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()
               , 8usize);
    assert_eq!(::core::mem::align_of::<_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()
               , 8usize);
}
impl Clone for _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2>()
               , 24usize);
    assert_eq!(::core::mem::align_of::<_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2>()
               , 8usize);
}
impl Clone for _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_IRP__bindgen_ty_3__bindgen_ty_1>() ,
               80usize);
    assert_eq!(::core::mem::align_of::<_IRP__bindgen_ty_3__bindgen_ty_1>() ,
               8usize);
}
impl Clone for _IRP__bindgen_ty_3__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<_IRP__bindgen_ty_3>() , 88usize);
    assert_eq!(::core::mem::align_of::<_IRP__bindgen_ty_3>() , 8usize);
}
impl Clone for _IRP__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
impl Clone for _IRP {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SCSI_REQUEST_BLOCK {
    pub _address: u8,
}
impl Clone for _SCSI_REQUEST_BLOCK {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SCATTER_GATHER_LIST {
    pub NumberOfElements: ULONG,
    pub Reserved: ULONG_PTR,
    pub Elements: *mut SCATTER_GATHER_ELEMENT,
}
#[test]
fn bindgen_test_layout__SCATTER_GATHER_LIST() {
    assert_eq!(::core::mem::size_of::<_SCATTER_GATHER_LIST>() , 16usize);
    assert_eq!(::core::mem::align_of::<_SCATTER_GATHER_LIST>() , 8usize);
}
impl Clone for _SCATTER_GATHER_LIST {
    fn clone(&self) -> Self { *self }
}
pub type IO_DPC_ROUTINE =
    ::core::option::Option<unsafe extern "C" fn(Dpc: PKDPC,
                                                DeviceObject:
                                                    *mut _DEVICE_OBJECT,
                                                Irp: *mut _IRP,
                                                Context: PVOID)>;
pub type PIO_DPC_ROUTINE = IO_DPC_ROUTINE;
pub type IO_TIMER_ROUTINE =
    ::core::option::Option<unsafe extern "C" fn(DeviceObject:
                                                    *mut _DEVICE_OBJECT,
                                                Context: PVOID)>;
pub type PIO_TIMER_ROUTINE = IO_TIMER_ROUTINE;
pub type DRIVER_INITIALIZE =
    ::core::option::Option<unsafe extern "C" fn(DriverObject:
                                                    *mut _DRIVER_OBJECT,
                                                RegistryPath: PUNICODE_STRING)
                               -> NTSTATUS>;
pub type PDRIVER_INITIALIZE = DRIVER_INITIALIZE;
pub type DRIVER_CANCEL =
    ::core::option::Option<unsafe extern "C" fn(DeviceObject:
                                                    *mut _DEVICE_OBJECT,
                                                Irp: *mut _IRP)>;
pub type PDRIVER_CANCEL = DRIVER_CANCEL;
pub type DRIVER_DISPATCH =
    ::core::option::Option<unsafe extern "C" fn(DeviceObject:
                                                    *mut _DEVICE_OBJECT,
                                                Irp: *mut _IRP) -> NTSTATUS>;
pub type PDRIVER_DISPATCH = DRIVER_DISPATCH;
pub type DRIVER_DISPATCH_RAISED = DRIVER_DISPATCH;
pub type DRIVER_DISPATCH_PAGED =
    ::core::option::Option<unsafe extern "C" fn(DeviceObject:
                                                    *mut _DEVICE_OBJECT,
                                                Irp: *mut _IRP) -> NTSTATUS>;
pub type PDRIVER_DISPATCH_PAGED = DRIVER_DISPATCH_PAGED;
pub type DRIVER_STARTIO =
    ::core::option::Option<unsafe extern "C" fn(DeviceObject:
                                                    *mut _DEVICE_OBJECT,
                                                Irp: *mut _IRP)>;
pub type PDRIVER_STARTIO = DRIVER_STARTIO;
pub type DRIVER_UNLOAD =
    ::core::option::Option<unsafe extern "C" fn(DriverObject:
                                                    *mut _DRIVER_OBJECT)>;
pub type PDRIVER_UNLOAD = DRIVER_UNLOAD;
pub type DRIVER_ADD_DEVICE =
    ::core::option::Option<unsafe extern "C" fn(DriverObject:
                                                    *mut _DRIVER_OBJECT,
                                                PhysicalDeviceObject:
                                                    *mut _DEVICE_OBJECT)
                               -> NTSTATUS>;
pub type PDRIVER_ADD_DEVICE = DRIVER_ADD_DEVICE;
pub type FAST_IO_CHECK_IF_POSSIBLE =
    ::core::option::Option<unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT,
                                                FileOffset: PLARGE_INTEGER,
                                                Length: ULONG, Wait: BOOLEAN,
                                                LockKey: ULONG,
                                                CheckForReadOperation:
                                                    BOOLEAN,
                                                IoStatus: PIO_STATUS_BLOCK,
                                                DeviceObject:
                                                    *mut _DEVICE_OBJECT)
                               -> BOOLEAN>;
pub type PFAST_IO_CHECK_IF_POSSIBLE = FAST_IO_CHECK_IF_POSSIBLE;
pub type FAST_IO_READ =
    ::core::option::Option<unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT,
                                                FileOffset: PLARGE_INTEGER,
                                                Length: ULONG, Wait: BOOLEAN,
                                                LockKey: ULONG, Buffer: PVOID,
                                                IoStatus: PIO_STATUS_BLOCK,
                                                DeviceObject:
                                                    *mut _DEVICE_OBJECT)
                               -> BOOLEAN>;
pub type PFAST_IO_READ = FAST_IO_READ;
pub type FAST_IO_WRITE =
    ::core::option::Option<unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT,
                                                FileOffset: PLARGE_INTEGER,
                                                Length: ULONG, Wait: BOOLEAN,
                                                LockKey: ULONG, Buffer: PVOID,
                                                IoStatus: PIO_STATUS_BLOCK,
                                                DeviceObject:
                                                    *mut _DEVICE_OBJECT)
                               -> BOOLEAN>;
pub type PFAST_IO_WRITE = FAST_IO_WRITE;
pub type FAST_IO_QUERY_BASIC_INFO =
    ::core::option::Option<unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT,
                                                Wait: BOOLEAN,
                                                Buffer:
                                                    PFILE_BASIC_INFORMATION,
                                                IoStatus: PIO_STATUS_BLOCK,
                                                DeviceObject:
                                                    *mut _DEVICE_OBJECT)
                               -> BOOLEAN>;
pub type PFAST_IO_QUERY_BASIC_INFO = FAST_IO_QUERY_BASIC_INFO;
pub type FAST_IO_QUERY_STANDARD_INFO =
    ::core::option::Option<unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT,
                                                Wait: BOOLEAN,
                                                Buffer:
                                                    PFILE_STANDARD_INFORMATION,
                                                IoStatus: PIO_STATUS_BLOCK,
                                                DeviceObject:
                                                    *mut _DEVICE_OBJECT)
                               -> BOOLEAN>;
pub type PFAST_IO_QUERY_STANDARD_INFO = FAST_IO_QUERY_STANDARD_INFO;
pub type FAST_IO_LOCK =
    ::core::option::Option<unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT,
                                                FileOffset: PLARGE_INTEGER,
                                                Length: PLARGE_INTEGER,
                                                ProcessId: PEPROCESS,
                                                Key: ULONG,
                                                FailImmediately: BOOLEAN,
                                                ExclusiveLock: BOOLEAN,
                                                IoStatus: PIO_STATUS_BLOCK,
                                                DeviceObject:
                                                    *mut _DEVICE_OBJECT)
                               -> BOOLEAN>;
pub type PFAST_IO_LOCK = FAST_IO_LOCK;
pub type FAST_IO_UNLOCK_SINGLE =
    ::core::option::Option<unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT,
                                                FileOffset: PLARGE_INTEGER,
                                                Length: PLARGE_INTEGER,
                                                ProcessId: PEPROCESS,
                                                Key: ULONG,
                                                IoStatus: PIO_STATUS_BLOCK,
                                                DeviceObject:
                                                    *mut _DEVICE_OBJECT)
                               -> BOOLEAN>;
pub type PFAST_IO_UNLOCK_SINGLE = FAST_IO_UNLOCK_SINGLE;
pub type FAST_IO_UNLOCK_ALL =
    ::core::option::Option<unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT,
                                                ProcessId: PEPROCESS,
                                                IoStatus: PIO_STATUS_BLOCK,
                                                DeviceObject:
                                                    *mut _DEVICE_OBJECT)
                               -> BOOLEAN>;
pub type PFAST_IO_UNLOCK_ALL = FAST_IO_UNLOCK_ALL;
pub type FAST_IO_UNLOCK_ALL_BY_KEY =
    ::core::option::Option<unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT,
                                                ProcessId: PVOID, Key: ULONG,
                                                IoStatus: PIO_STATUS_BLOCK,
                                                DeviceObject:
                                                    *mut _DEVICE_OBJECT)
                               -> BOOLEAN>;
pub type PFAST_IO_UNLOCK_ALL_BY_KEY = FAST_IO_UNLOCK_ALL_BY_KEY;
pub type FAST_IO_DEVICE_CONTROL =
    ::core::option::Option<unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT,
                                                Wait: BOOLEAN,
                                                InputBuffer: PVOID,
                                                InputBufferLength: ULONG,
                                                OutputBuffer: PVOID,
                                                OutputBufferLength: ULONG,
                                                IoControlCode: ULONG,
                                                IoStatus: PIO_STATUS_BLOCK,
                                                DeviceObject:
                                                    *mut _DEVICE_OBJECT)
                               -> BOOLEAN>;
pub type PFAST_IO_DEVICE_CONTROL = FAST_IO_DEVICE_CONTROL;
pub type FAST_IO_ACQUIRE_FILE =
    ::core::option::Option<unsafe extern "C" fn(FileObject:
                                                    *mut _FILE_OBJECT)>;
pub type PFAST_IO_ACQUIRE_FILE = FAST_IO_ACQUIRE_FILE;
pub type FAST_IO_RELEASE_FILE =
    ::core::option::Option<unsafe extern "C" fn(FileObject:
                                                    *mut _FILE_OBJECT)>;
pub type PFAST_IO_RELEASE_FILE = FAST_IO_RELEASE_FILE;
pub type FAST_IO_DETACH_DEVICE =
    ::core::option::Option<unsafe extern "C" fn(SourceDevice:
                                                    *mut _DEVICE_OBJECT,
                                                TargetDevice:
                                                    *mut _DEVICE_OBJECT)>;
pub type PFAST_IO_DETACH_DEVICE = FAST_IO_DETACH_DEVICE;
pub type FAST_IO_QUERY_NETWORK_OPEN_INFO =
    ::core::option::Option<unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT,
                                                Wait: BOOLEAN,
                                                Buffer:
                                                    *mut _FILE_NETWORK_OPEN_INFORMATION,
                                                IoStatus:
                                                    *mut _IO_STATUS_BLOCK,
                                                DeviceObject:
                                                    *mut _DEVICE_OBJECT)
                               -> BOOLEAN>;
pub type PFAST_IO_QUERY_NETWORK_OPEN_INFO = FAST_IO_QUERY_NETWORK_OPEN_INFO;
pub type FAST_IO_MDL_READ =
    ::core::option::Option<unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT,
                                                FileOffset: PLARGE_INTEGER,
                                                Length: ULONG, LockKey: ULONG,
                                                MdlChain: *mut PMDL,
                                                IoStatus: PIO_STATUS_BLOCK,
                                                DeviceObject:
                                                    *mut _DEVICE_OBJECT)
                               -> BOOLEAN>;
pub type PFAST_IO_MDL_READ = FAST_IO_MDL_READ;
pub type FAST_IO_MDL_READ_COMPLETE =
    ::core::option::Option<unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT,
                                                MdlChain: PMDL,
                                                DeviceObject:
                                                    *mut _DEVICE_OBJECT)
                               -> BOOLEAN>;
pub type PFAST_IO_MDL_READ_COMPLETE = FAST_IO_MDL_READ_COMPLETE;
pub type FAST_IO_PREPARE_MDL_WRITE =
    ::core::option::Option<unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT,
                                                FileOffset: PLARGE_INTEGER,
                                                Length: ULONG, LockKey: ULONG,
                                                MdlChain: *mut PMDL,
                                                IoStatus: PIO_STATUS_BLOCK,
                                                DeviceObject:
                                                    *mut _DEVICE_OBJECT)
                               -> BOOLEAN>;
pub type PFAST_IO_PREPARE_MDL_WRITE = FAST_IO_PREPARE_MDL_WRITE;
pub type FAST_IO_MDL_WRITE_COMPLETE =
    ::core::option::Option<unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT,
                                                FileOffset: PLARGE_INTEGER,
                                                MdlChain: PMDL,
                                                DeviceObject:
                                                    *mut _DEVICE_OBJECT)
                               -> BOOLEAN>;
pub type PFAST_IO_MDL_WRITE_COMPLETE = FAST_IO_MDL_WRITE_COMPLETE;
pub type FAST_IO_ACQUIRE_FOR_MOD_WRITE =
    ::core::option::Option<unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT,
                                                EndingOffset: PLARGE_INTEGER,
                                                ResourceToRelease:
                                                    *mut *mut _ERESOURCE,
                                                DeviceObject:
                                                    *mut _DEVICE_OBJECT)
                               -> NTSTATUS>;
pub type PFAST_IO_ACQUIRE_FOR_MOD_WRITE = FAST_IO_ACQUIRE_FOR_MOD_WRITE;
pub type FAST_IO_RELEASE_FOR_MOD_WRITE =
    ::core::option::Option<unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT,
                                                ResourceToRelease:
                                                    *mut _ERESOURCE,
                                                DeviceObject:
                                                    *mut _DEVICE_OBJECT)
                               -> NTSTATUS>;
pub type PFAST_IO_RELEASE_FOR_MOD_WRITE = FAST_IO_RELEASE_FOR_MOD_WRITE;
pub type FAST_IO_ACQUIRE_FOR_CCFLUSH =
    ::core::option::Option<unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT,
                                                DeviceObject:
                                                    *mut _DEVICE_OBJECT)
                               -> NTSTATUS>;
pub type PFAST_IO_ACQUIRE_FOR_CCFLUSH = FAST_IO_ACQUIRE_FOR_CCFLUSH;
pub type FAST_IO_RELEASE_FOR_CCFLUSH =
    ::core::option::Option<unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT,
                                                DeviceObject:
                                                    *mut _DEVICE_OBJECT)
                               -> NTSTATUS>;
pub type PFAST_IO_RELEASE_FOR_CCFLUSH = FAST_IO_RELEASE_FOR_CCFLUSH;
pub type FAST_IO_READ_COMPRESSED =
    ::core::option::Option<unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT,
                                                FileOffset: PLARGE_INTEGER,
                                                Length: ULONG, LockKey: ULONG,
                                                Buffer: PVOID,
                                                MdlChain: *mut PMDL,
                                                IoStatus: PIO_STATUS_BLOCK,
                                                CompressedDataInfo:
                                                    *mut _COMPRESSED_DATA_INFO,
                                                CompressedDataInfoLength:
                                                    ULONG,
                                                DeviceObject:
                                                    *mut _DEVICE_OBJECT)
                               -> BOOLEAN>;
pub type PFAST_IO_READ_COMPRESSED = FAST_IO_READ_COMPRESSED;
pub type FAST_IO_WRITE_COMPRESSED =
    ::core::option::Option<unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT,
                                                FileOffset: PLARGE_INTEGER,
                                                Length: ULONG, LockKey: ULONG,
                                                Buffer: PVOID,
                                                MdlChain: *mut PMDL,
                                                IoStatus: PIO_STATUS_BLOCK,
                                                CompressedDataInfo:
                                                    *mut _COMPRESSED_DATA_INFO,
                                                CompressedDataInfoLength:
                                                    ULONG,
                                                DeviceObject:
                                                    *mut _DEVICE_OBJECT)
                               -> BOOLEAN>;
pub type PFAST_IO_WRITE_COMPRESSED = FAST_IO_WRITE_COMPRESSED;
pub type FAST_IO_MDL_READ_COMPLETE_COMPRESSED =
    ::core::option::Option<unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT,
                                                MdlChain: PMDL,
                                                DeviceObject:
                                                    *mut _DEVICE_OBJECT)
                               -> BOOLEAN>;
pub type PFAST_IO_MDL_READ_COMPLETE_COMPRESSED =
    FAST_IO_MDL_READ_COMPLETE_COMPRESSED;
pub type FAST_IO_MDL_WRITE_COMPLETE_COMPRESSED =
    ::core::option::Option<unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT,
                                                FileOffset: PLARGE_INTEGER,
                                                MdlChain: PMDL,
                                                DeviceObject:
                                                    *mut _DEVICE_OBJECT)
                               -> BOOLEAN>;
pub type PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED =
    FAST_IO_MDL_WRITE_COMPLETE_COMPRESSED;
pub type FAST_IO_QUERY_OPEN =
    ::core::option::Option<unsafe extern "C" fn(Irp: *mut _IRP,
                                                NetworkInformation:
                                                    PFILE_NETWORK_OPEN_INFORMATION,
                                                DeviceObject:
                                                    *mut _DEVICE_OBJECT)
                               -> BOOLEAN>;
pub type PFAST_IO_QUERY_OPEN = FAST_IO_QUERY_OPEN;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _FAST_IO_DISPATCH {
    pub SizeOfFastIoDispatch: ULONG,
    pub FastIoCheckIfPossible: PFAST_IO_CHECK_IF_POSSIBLE,
    pub FastIoRead: PFAST_IO_READ,
    pub FastIoWrite: PFAST_IO_WRITE,
    pub FastIoQueryBasicInfo: PFAST_IO_QUERY_BASIC_INFO,
    pub FastIoQueryStandardInfo: PFAST_IO_QUERY_STANDARD_INFO,
    pub FastIoLock: PFAST_IO_LOCK,
    pub FastIoUnlockSingle: PFAST_IO_UNLOCK_SINGLE,
    pub FastIoUnlockAll: PFAST_IO_UNLOCK_ALL,
    pub FastIoUnlockAllByKey: PFAST_IO_UNLOCK_ALL_BY_KEY,
    pub FastIoDeviceControl: PFAST_IO_DEVICE_CONTROL,
    pub AcquireFileForNtCreateSection: PFAST_IO_ACQUIRE_FILE,
    pub ReleaseFileForNtCreateSection: PFAST_IO_RELEASE_FILE,
    pub FastIoDetachDevice: PFAST_IO_DETACH_DEVICE,
    pub FastIoQueryNetworkOpenInfo: PFAST_IO_QUERY_NETWORK_OPEN_INFO,
    pub AcquireForModWrite: PFAST_IO_ACQUIRE_FOR_MOD_WRITE,
    pub MdlRead: PFAST_IO_MDL_READ,
    pub MdlReadComplete: PFAST_IO_MDL_READ_COMPLETE,
    pub PrepareMdlWrite: PFAST_IO_PREPARE_MDL_WRITE,
    pub MdlWriteComplete: PFAST_IO_MDL_WRITE_COMPLETE,
    pub FastIoReadCompressed: PFAST_IO_READ_COMPRESSED,
    pub FastIoWriteCompressed: PFAST_IO_WRITE_COMPRESSED,
    pub MdlReadCompleteCompressed: PFAST_IO_MDL_READ_COMPLETE_COMPRESSED,
    pub MdlWriteCompleteCompressed: PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED,
    pub FastIoQueryOpen: PFAST_IO_QUERY_OPEN,
    pub ReleaseForModWrite: PFAST_IO_RELEASE_FOR_MOD_WRITE,
    pub AcquireForCcFlush: PFAST_IO_ACQUIRE_FOR_CCFLUSH,
    pub ReleaseForCcFlush: PFAST_IO_RELEASE_FOR_CCFLUSH,
}
#[test]
fn bindgen_test_layout__FAST_IO_DISPATCH() {
    assert_eq!(::core::mem::size_of::<_FAST_IO_DISPATCH>() , 224usize);
    assert_eq!(::core::mem::align_of::<_FAST_IO_DISPATCH>() , 8usize);
}
impl Clone for _FAST_IO_DISPATCH {
    fn clone(&self) -> Self { *self }
}
pub use self::_FAST_IO_DISPATCH as FAST_IO_DISPATCH;
pub type PFAST_IO_DISPATCH = *mut _FAST_IO_DISPATCH;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _IO_ALLOCATION_ACTION {
    KeepObject = 1,
    DeallocateObject = 2,
    DeallocateObjectKeepRegisters = 3,
}
pub use self::_IO_ALLOCATION_ACTION as IO_ALLOCATION_ACTION;
pub type PIO_ALLOCATION_ACTION = *mut _IO_ALLOCATION_ACTION;
pub type DRIVER_CONTROL =
    ::core::option::Option<unsafe extern "C" fn(DeviceObject:
                                                    *mut _DEVICE_OBJECT,
                                                Irp: *mut _IRP,
                                                MapRegisterBase: PVOID,
                                                Context: PVOID)
                               -> IO_ALLOCATION_ACTION>;
pub type PDRIVER_CONTROL = DRIVER_CONTROL;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_SECURITY_CONTEXT {
    pub SecurityQos: PSECURITY_QUALITY_OF_SERVICE,
    pub AccessState: PACCESS_STATE,
    pub DesiredAccess: ACCESS_MASK,
    pub FullCreateOptions: ULONG,
}
#[test]
fn bindgen_test_layout__IO_SECURITY_CONTEXT() {
    assert_eq!(::core::mem::size_of::<_IO_SECURITY_CONTEXT>() , 24usize);
    assert_eq!(::core::mem::align_of::<_IO_SECURITY_CONTEXT>() , 8usize);
}
impl Clone for _IO_SECURITY_CONTEXT {
    fn clone(&self) -> Self { *self }
}
pub use self::_IO_SECURITY_CONTEXT as IO_SECURITY_CONTEXT;
pub type PIO_SECURITY_CONTEXT = *mut _IO_SECURITY_CONTEXT;
pub use self::_VPB as VPB;
pub type PADAPTER_OBJECT = *mut _DMA_ADAPTER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WAIT_CONTEXT_BLOCK {
    pub __bindgen_anon_1: _WAIT_CONTEXT_BLOCK__bindgen_ty_1,
    pub DeviceRoutine: PDRIVER_CONTROL,
    pub DeviceContext: PVOID,
    pub NumberOfMapRegisters: ULONG,
    pub DeviceObject: PVOID,
    pub CurrentIrp: PVOID,
    pub BufferChainingDpc: PKDPC,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WAIT_CONTEXT_BLOCK__bindgen_ty_1 {
    pub WaitQueueEntry: __BindgenUnionField<KDEVICE_QUEUE_ENTRY>,
    pub __bindgen_anon_1: __BindgenUnionField<_WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1 {
    pub DmaWaitEntry: LIST_ENTRY,
    pub NumberOfChannels: ULONG,
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1>()
               , 24usize);
    assert_eq!(::core::mem::align_of::<_WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1>()
               , 8usize);
}
impl Clone for _WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn SyncCallback(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_SyncCallback(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn DmaContext(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_DmaContext(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn ZeroMapRegisters(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                        2u32) as u32)
        }
    }
    #[inline]
    pub fn set_ZeroMapRegisters(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967288usize as u32)) >> 3u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967288usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 3u32) & (4294967288usize as u32);
    }
}
#[test]
fn bindgen_test_layout__WAIT_CONTEXT_BLOCK__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_WAIT_CONTEXT_BLOCK__bindgen_ty_1>() ,
               24usize);
    assert_eq!(::core::mem::align_of::<_WAIT_CONTEXT_BLOCK__bindgen_ty_1>() ,
               8usize);
}
impl Clone for _WAIT_CONTEXT_BLOCK__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__WAIT_CONTEXT_BLOCK() {
    assert_eq!(::core::mem::size_of::<_WAIT_CONTEXT_BLOCK>() , 72usize);
    assert_eq!(::core::mem::align_of::<_WAIT_CONTEXT_BLOCK>() , 8usize);
}
impl Clone for _WAIT_CONTEXT_BLOCK {
    fn clone(&self) -> Self { *self }
}
pub use self::_WAIT_CONTEXT_BLOCK as WAIT_CONTEXT_BLOCK;
pub type PWAIT_CONTEXT_BLOCK = *mut _WAIT_CONTEXT_BLOCK;
pub use self::_DEVICE_OBJECT as DEVICE_OBJECT;
pub type PDEVICE_OBJECT = *mut _DEVICE_OBJECT;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DEVICE_OBJECT_POWER_EXTENSION {
    pub _address: u8,
}
impl Clone for _DEVICE_OBJECT_POWER_EXTENSION {
    fn clone(&self) -> Self { *self }
}
pub use self::_DEVICE_OBJECT__DEVOBJ_EXTENSION as DEVOBJ_EXTENSION;
pub type PDEVOBJ_EXTENSION = *mut _DEVICE_OBJECT__DEVOBJ_EXTENSION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DRIVER_EXTENSION {
    pub DriverObject: *mut _DRIVER_OBJECT,
    pub AddDevice: PDRIVER_ADD_DEVICE,
    pub Count: ULONG,
    pub ServiceKeyName: UNICODE_STRING,
}
#[test]
fn bindgen_test_layout__DRIVER_EXTENSION() {
    assert_eq!(::core::mem::size_of::<_DRIVER_EXTENSION>() , 40usize);
    assert_eq!(::core::mem::align_of::<_DRIVER_EXTENSION>() , 8usize);
}
impl Clone for _DRIVER_EXTENSION {
    fn clone(&self) -> Self { *self }
}
pub use self::_DRIVER_EXTENSION as DRIVER_EXTENSION;
pub type PDRIVER_EXTENSION = *mut _DRIVER_EXTENSION;
pub use self::_DRIVER_OBJECT as DRIVER_OBJECT;
pub type PDRIVER_OBJECT = *mut _DRIVER_OBJECT;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SECTION_OBJECT_POINTERS {
    pub DataSectionObject: PVOID,
    pub SharedCacheMap: PVOID,
    pub ImageSectionObject: PVOID,
}
#[test]
fn bindgen_test_layout__SECTION_OBJECT_POINTERS() {
    assert_eq!(::core::mem::size_of::<_SECTION_OBJECT_POINTERS>() , 24usize);
    assert_eq!(::core::mem::align_of::<_SECTION_OBJECT_POINTERS>() , 8usize);
}
impl Clone for _SECTION_OBJECT_POINTERS {
    fn clone(&self) -> Self { *self }
}
pub use self::_SECTION_OBJECT_POINTERS as SECTION_OBJECT_POINTERS;
pub type PSECTION_OBJECT_POINTERS = *mut SECTION_OBJECT_POINTERS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_COMPLETION_CONTEXT {
    pub Port: PVOID,
    pub Key: PVOID,
}
#[test]
fn bindgen_test_layout__IO_COMPLETION_CONTEXT() {
    assert_eq!(::core::mem::size_of::<_IO_COMPLETION_CONTEXT>() , 16usize);
    assert_eq!(::core::mem::align_of::<_IO_COMPLETION_CONTEXT>() , 8usize);
}
impl Clone for _IO_COMPLETION_CONTEXT {
    fn clone(&self) -> Self { *self }
}
pub use self::_IO_COMPLETION_CONTEXT as IO_COMPLETION_CONTEXT;
pub type PIO_COMPLETION_CONTEXT = *mut _IO_COMPLETION_CONTEXT;
pub use self::_FILE_OBJECT as FILE_OBJECT;
pub type PFILE_OBJECT = *mut _FILE_OBJECT;
pub use self::_IRP as IRP;
pub type PIRP = *mut IRP;
pub type IO_COMPLETION_ROUTINE =
    ::core::option::Option<unsafe extern "C" fn(DeviceObject: PDEVICE_OBJECT,
                                                Irp: PIRP, Context: PVOID)
                               -> NTSTATUS>;
pub type PIO_COMPLETION_ROUTINE = IO_COMPLETION_ROUTINE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _DEVICE_RELATION_TYPE {
    BusRelations = 0,
    EjectionRelations = 1,
    PowerRelations = 2,
    RemovalRelations = 3,
    TargetDeviceRelation = 4,
    SingleBusRelations = 5,
    TransportRelations = 6,
}
pub use self::_DEVICE_RELATION_TYPE as DEVICE_RELATION_TYPE;
pub type PDEVICE_RELATION_TYPE = *mut _DEVICE_RELATION_TYPE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DEVICE_RELATIONS {
    pub Count: ULONG,
    pub Objects: [PDEVICE_OBJECT; 1usize],
}
#[test]
fn bindgen_test_layout__DEVICE_RELATIONS() {
    assert_eq!(::core::mem::size_of::<_DEVICE_RELATIONS>() , 16usize);
    assert_eq!(::core::mem::align_of::<_DEVICE_RELATIONS>() , 8usize);
}
impl Clone for _DEVICE_RELATIONS {
    fn clone(&self) -> Self { *self }
}
pub use self::_DEVICE_RELATIONS as DEVICE_RELATIONS;
pub type PDEVICE_RELATIONS = *mut _DEVICE_RELATIONS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _DEVICE_USAGE_NOTIFICATION_TYPE {
    DeviceUsageTypeUndefined = 0,
    DeviceUsageTypePaging = 1,
    DeviceUsageTypeHibernation = 2,
    DeviceUsageTypeDumpFile = 3,
    DeviceUsageTypeBoot = 4,
    DeviceUsageTypePostDisplay = 5,
}
pub use self::_DEVICE_USAGE_NOTIFICATION_TYPE as
        DEVICE_USAGE_NOTIFICATION_TYPE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
}
#[test]
fn bindgen_test_layout__INTERFACE() {
    assert_eq!(::core::mem::size_of::<_INTERFACE>() , 32usize);
    assert_eq!(::core::mem::align_of::<_INTERFACE>() , 8usize);
}
impl Clone for _INTERFACE {
    fn clone(&self) -> Self { *self }
}
pub use self::_INTERFACE as INTERFACE;
pub type PINTERFACE = *mut _INTERFACE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DEVICE_CAPABILITIES {
    pub Size: USHORT,
    pub Version: USHORT,
    pub _bitfield_1: u32,
    pub Address: ULONG,
    pub UINumber: ULONG,
    pub DeviceState: [DEVICE_POWER_STATE; 7usize],
    pub SystemWake: SYSTEM_POWER_STATE,
    pub DeviceWake: DEVICE_POWER_STATE,
    pub D1Latency: ULONG,
    pub D2Latency: ULONG,
    pub D3Latency: ULONG,
}
#[test]
fn bindgen_test_layout__DEVICE_CAPABILITIES() {
    assert_eq!(::core::mem::size_of::<_DEVICE_CAPABILITIES>() , 64usize);
    assert_eq!(::core::mem::align_of::<_DEVICE_CAPABILITIES>() , 4usize);
}
impl Clone for _DEVICE_CAPABILITIES {
    fn clone(&self) -> Self { *self }
}
impl _DEVICE_CAPABILITIES {
    #[inline]
    pub fn DeviceD1(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_DeviceD1(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn DeviceD2(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_DeviceD2(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn LockSupported(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                        2u32) as u32)
        }
    }
    #[inline]
    pub fn set_LockSupported(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn EjectSupported(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u32)) >>
                                        3u32) as u32)
        }
    }
    #[inline]
    pub fn set_EjectSupported(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (8usize as u32);
    }
    #[inline]
    pub fn Removable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u32)) >>
                                        4u32) as u32)
        }
    }
    #[inline]
    pub fn set_Removable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (16usize as u32);
    }
    #[inline]
    pub fn DockDevice(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u32)) >>
                                        5u32) as u32)
        }
    }
    #[inline]
    pub fn set_DockDevice(&mut self, val: ULONG) {
        self._bitfield_1 &= !(32usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (32usize as u32);
    }
    #[inline]
    pub fn UniqueID(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u32)) >>
                                        6u32) as u32)
        }
    }
    #[inline]
    pub fn set_UniqueID(&mut self, val: ULONG) {
        self._bitfield_1 &= !(64usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 6u32) & (64usize as u32);
    }
    #[inline]
    pub fn SilentInstall(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (128usize as u32)) >>
                                        7u32) as u32)
        }
    }
    #[inline]
    pub fn set_SilentInstall(&mut self, val: ULONG) {
        self._bitfield_1 &= !(128usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 7u32) & (128usize as u32);
    }
    #[inline]
    pub fn RawDeviceOK(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (256usize as u32)) >>
                                        8u32) as u32)
        }
    }
    #[inline]
    pub fn set_RawDeviceOK(&mut self, val: ULONG) {
        self._bitfield_1 &= !(256usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 8u32) & (256usize as u32);
    }
    #[inline]
    pub fn SurpriseRemovalOK(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (512usize as u32)) >>
                                        9u32) as u32)
        }
    }
    #[inline]
    pub fn set_SurpriseRemovalOK(&mut self, val: ULONG) {
        self._bitfield_1 &= !(512usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 9u32) & (512usize as u32);
    }
    #[inline]
    pub fn WakeFromD0(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1024usize as u32)) >>
                                        10u32) as u32)
        }
    }
    #[inline]
    pub fn set_WakeFromD0(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1024usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 10u32) & (1024usize as u32);
    }
    #[inline]
    pub fn WakeFromD1(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2048usize as u32)) >>
                                        11u32) as u32)
        }
    }
    #[inline]
    pub fn set_WakeFromD1(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2048usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 11u32) & (2048usize as u32);
    }
    #[inline]
    pub fn WakeFromD2(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4096usize as u32)) >>
                                        12u32) as u32)
        }
    }
    #[inline]
    pub fn set_WakeFromD2(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4096usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 12u32) & (4096usize as u32);
    }
    #[inline]
    pub fn WakeFromD3(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8192usize as u32)) >>
                                        13u32) as u32)
        }
    }
    #[inline]
    pub fn set_WakeFromD3(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8192usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 13u32) & (8192usize as u32);
    }
    #[inline]
    pub fn HardwareDisabled(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16384usize as u32))
                                        >> 14u32) as u32)
        }
    }
    #[inline]
    pub fn set_HardwareDisabled(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16384usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 14u32) & (16384usize as u32);
    }
    #[inline]
    pub fn NonDynamic(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32768usize as u32))
                                        >> 15u32) as u32)
        }
    }
    #[inline]
    pub fn set_NonDynamic(&mut self, val: ULONG) {
        self._bitfield_1 &= !(32768usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 15u32) & (32768usize as u32);
    }
    #[inline]
    pub fn WarmEjectSupported(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65536usize as u32))
                                        >> 16u32) as u32)
        }
    }
    #[inline]
    pub fn set_WarmEjectSupported(&mut self, val: ULONG) {
        self._bitfield_1 &= !(65536usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (65536usize as u32);
    }
    #[inline]
    pub fn NoDisplayInUI(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (131072usize as u32))
                                        >> 17u32) as u32)
        }
    }
    #[inline]
    pub fn set_NoDisplayInUI(&mut self, val: ULONG) {
        self._bitfield_1 &= !(131072usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 17u32) & (131072usize as u32);
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (262144usize as u32))
                                        >> 18u32) as u32)
        }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        self._bitfield_1 &= !(262144usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 18u32) & (262144usize as u32);
    }
    #[inline]
    pub fn WakeFromInterrupt(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (524288usize as u32))
                                        >> 19u32) as u32)
        }
    }
    #[inline]
    pub fn set_WakeFromInterrupt(&mut self, val: ULONG) {
        self._bitfield_1 &= !(524288usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 19u32) & (524288usize as u32);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4293918720usize as u32)) >> 20u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4293918720usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 20u32) & (4293918720usize as u32);
    }
}
pub use self::_DEVICE_CAPABILITIES as DEVICE_CAPABILITIES;
pub type PDEVICE_CAPABILITIES = *mut _DEVICE_CAPABILITIES;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _POWER_SEQUENCE {
    pub SequenceD1: ULONG,
    pub SequenceD2: ULONG,
    pub SequenceD3: ULONG,
}
#[test]
fn bindgen_test_layout__POWER_SEQUENCE() {
    assert_eq!(::core::mem::size_of::<_POWER_SEQUENCE>() , 12usize);
    assert_eq!(::core::mem::align_of::<_POWER_SEQUENCE>() , 4usize);
}
impl Clone for _POWER_SEQUENCE {
    fn clone(&self) -> Self { *self }
}
pub use self::_POWER_SEQUENCE as POWER_SEQUENCE;
pub type PPOWER_SEQUENCE = *mut _POWER_SEQUENCE;
pub const BusQueryDeviceID: _bindgen_ty_13 = _bindgen_ty_13::BusQueryDeviceID;
pub const BusQueryHardwareIDs: _bindgen_ty_13 =
    _bindgen_ty_13::BusQueryHardwareIDs;
pub const BusQueryCompatibleIDs: _bindgen_ty_13 =
    _bindgen_ty_13::BusQueryCompatibleIDs;
pub const BusQueryInstanceID: _bindgen_ty_13 =
    _bindgen_ty_13::BusQueryInstanceID;
pub const BusQueryDeviceSerialNumber: _bindgen_ty_13 =
    _bindgen_ty_13::BusQueryDeviceSerialNumber;
pub const BusQueryContainerID: _bindgen_ty_13 =
    _bindgen_ty_13::BusQueryContainerID;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_13 {
    BusQueryDeviceID = 0,
    BusQueryHardwareIDs = 1,
    BusQueryCompatibleIDs = 2,
    BusQueryInstanceID = 3,
    BusQueryDeviceSerialNumber = 4,
    BusQueryContainerID = 5,
}
pub use self::_bindgen_ty_13 as BUS_QUERY_ID_TYPE;
pub type PBUS_QUERY_ID_TYPE = *mut _bindgen_ty_13;
pub type PNP_DEVICE_STATE = ULONG;
pub type PPNP_DEVICE_STATE = *mut ULONG;
pub const DeviceTextDescription: _bindgen_ty_14 =
    _bindgen_ty_14::DeviceTextDescription;
pub const DeviceTextLocationInformation: _bindgen_ty_14 =
    _bindgen_ty_14::DeviceTextLocationInformation;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_14 {
    DeviceTextDescription = 0,
    DeviceTextLocationInformation = 1,
}
pub use self::_bindgen_ty_14 as DEVICE_TEXT_TYPE;
pub type PDEVICE_TEXT_TYPE = *mut _bindgen_ty_14;
pub use self::_IO_STACK_LOCATION as IO_STACK_LOCATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SHARE_ACCESS {
    pub OpenCount: ULONG,
    pub Readers: ULONG,
    pub Writers: ULONG,
    pub Deleters: ULONG,
    pub SharedRead: ULONG,
    pub SharedWrite: ULONG,
    pub SharedDelete: ULONG,
}
#[test]
fn bindgen_test_layout__SHARE_ACCESS() {
    assert_eq!(::core::mem::size_of::<_SHARE_ACCESS>() , 28usize);
    assert_eq!(::core::mem::align_of::<_SHARE_ACCESS>() , 4usize);
}
impl Clone for _SHARE_ACCESS {
    fn clone(&self) -> Self { *self }
}
pub use self::_SHARE_ACCESS as SHARE_ACCESS;
pub type PSHARE_ACCESS = *mut _SHARE_ACCESS;
extern "C" {
    pub fn IoAcquireCancelSpinLock(Irql: PKIRQL);
}
extern "C" {
    pub fn IoAllocateDriverObjectExtension(DriverObject: PDRIVER_OBJECT,
                                           ClientIdentificationAddress: PVOID,
                                           DriverObjectExtensionSize: ULONG,
                                           DriverObjectExtension: *mut PVOID)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoAllocateErrorLogEntry(IoObject: PVOID, EntrySize: UCHAR)
     -> PVOID;
}
extern "C" {
    pub fn IoAllocateIrp(StackSize: CCHAR, ChargeQuota: BOOLEAN) -> PIRP;
}
extern "C" {
    pub fn IoAllocateIrpEx(DeviceObject: PDEVICE_OBJECT, StackSize: CCHAR,
                           ChargeQuota: BOOLEAN) -> PIRP;
}
extern "C" {
    pub fn IoAllocateMdl(VirtualAddress: PVOID, Length: ULONG,
                         SecondaryBuffer: BOOLEAN, ChargeQuota: BOOLEAN,
                         Irp: PIRP) -> PMDL;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _IO_PAGING_PRIORITY {
    IoPagingPriorityInvalid = 0,
    IoPagingPriorityNormal = 1,
    IoPagingPriorityHigh = 2,
    IoPagingPriorityReserved1 = 3,
    IoPagingPriorityReserved2 = 4,
}
pub use self::_IO_PAGING_PRIORITY as IO_PAGING_PRIORITY;
extern "C" {
    pub fn IoAttachDevice(SourceDevice: PDEVICE_OBJECT,
                          TargetDevice: PUNICODE_STRING,
                          AttachedDevice: *mut PDEVICE_OBJECT) -> NTSTATUS;
}
extern "C" {
    pub fn IoAttachDeviceToDeviceStack(SourceDevice: PDEVICE_OBJECT,
                                       TargetDevice: PDEVICE_OBJECT)
     -> PDEVICE_OBJECT;
}
extern "C" {
    pub fn IoBuildAsynchronousFsdRequest(MajorFunction: ULONG,
                                         DeviceObject: PDEVICE_OBJECT,
                                         Buffer: PVOID, Length: ULONG,
                                         StartingOffset: PLARGE_INTEGER,
                                         IoStatusBlock: PIO_STATUS_BLOCK)
     -> PIRP;
}
extern "C" {
    pub fn IoBuildDeviceIoControlRequest(IoControlCode: ULONG,
                                         DeviceObject: PDEVICE_OBJECT,
                                         InputBuffer: PVOID,
                                         InputBufferLength: ULONG,
                                         OutputBuffer: PVOID,
                                         OutputBufferLength: ULONG,
                                         InternalDeviceIoControl: BOOLEAN,
                                         Event: PKEVENT,
                                         IoStatusBlock: PIO_STATUS_BLOCK)
     -> PIRP;
}
extern "C" {
    pub fn IoBuildPartialMdl(SourceMdl: PMDL, TargetMdl: PMDL,
                             VirtualAddress: PVOID, Length: ULONG);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _BOOTDISK_INFORMATION {
    pub BootPartitionOffset: LONGLONG,
    pub SystemPartitionOffset: LONGLONG,
    pub BootDeviceSignature: ULONG,
    pub SystemDeviceSignature: ULONG,
}
#[test]
fn bindgen_test_layout__BOOTDISK_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_BOOTDISK_INFORMATION>() , 24usize);
    assert_eq!(::core::mem::align_of::<_BOOTDISK_INFORMATION>() , 8usize);
}
impl Clone for _BOOTDISK_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_BOOTDISK_INFORMATION as BOOTDISK_INFORMATION;
pub type PBOOTDISK_INFORMATION = *mut _BOOTDISK_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _BOOTDISK_INFORMATION_EX {
    pub BootPartitionOffset: LONGLONG,
    pub SystemPartitionOffset: LONGLONG,
    pub BootDeviceSignature: ULONG,
    pub SystemDeviceSignature: ULONG,
    pub BootDeviceGuid: GUID,
    pub SystemDeviceGuid: GUID,
    pub BootDeviceIsGpt: BOOLEAN,
    pub SystemDeviceIsGpt: BOOLEAN,
}
#[test]
fn bindgen_test_layout__BOOTDISK_INFORMATION_EX() {
    assert_eq!(::core::mem::size_of::<_BOOTDISK_INFORMATION_EX>() , 64usize);
    assert_eq!(::core::mem::align_of::<_BOOTDISK_INFORMATION_EX>() , 8usize);
}
impl Clone for _BOOTDISK_INFORMATION_EX {
    fn clone(&self) -> Self { *self }
}
pub use self::_BOOTDISK_INFORMATION_EX as BOOTDISK_INFORMATION_EX;
pub type PBOOTDISK_INFORMATION_EX = *mut _BOOTDISK_INFORMATION_EX;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _LOADER_PARTITION_INFORMATION_EX {
    pub PartitionStyle: ULONG,
    pub PartitionNumber: ULONG,
    pub __bindgen_anon_1: _LOADER_PARTITION_INFORMATION_EX__bindgen_ty_1,
    pub Flags: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _LOADER_PARTITION_INFORMATION_EX__bindgen_ty_1 {
    pub Signature: __BindgenUnionField<ULONG>,
    pub DeviceId: __BindgenUnionField<GUID>,
    pub bindgen_union_field: [u32; 4usize],
}
#[test]
fn bindgen_test_layout__LOADER_PARTITION_INFORMATION_EX__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_LOADER_PARTITION_INFORMATION_EX__bindgen_ty_1>()
               , 16usize);
    assert_eq!(::core::mem::align_of::<_LOADER_PARTITION_INFORMATION_EX__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _LOADER_PARTITION_INFORMATION_EX__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__LOADER_PARTITION_INFORMATION_EX() {
    assert_eq!(::core::mem::size_of::<_LOADER_PARTITION_INFORMATION_EX>() ,
               28usize);
    assert_eq!(::core::mem::align_of::<_LOADER_PARTITION_INFORMATION_EX>() ,
               4usize);
}
impl Clone for _LOADER_PARTITION_INFORMATION_EX {
    fn clone(&self) -> Self { *self }
}
pub use self::_LOADER_PARTITION_INFORMATION_EX as
        LOADER_PARTITION_INFORMATION_EX;
pub type PLOADER_PARTITION_INFORMATION_EX =
    *mut _LOADER_PARTITION_INFORMATION_EX;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _BOOTDISK_INFORMATION_LITE {
    pub NumberEntries: ULONG,
    pub Entries: [LOADER_PARTITION_INFORMATION_EX; 1usize],
}
#[test]
fn bindgen_test_layout__BOOTDISK_INFORMATION_LITE() {
    assert_eq!(::core::mem::size_of::<_BOOTDISK_INFORMATION_LITE>() ,
               32usize);
    assert_eq!(::core::mem::align_of::<_BOOTDISK_INFORMATION_LITE>() ,
               4usize);
}
impl Clone for _BOOTDISK_INFORMATION_LITE {
    fn clone(&self) -> Self { *self }
}
pub use self::_BOOTDISK_INFORMATION_LITE as BOOTDISK_INFORMATION_LITE;
pub type PBOOTDISK_INFORMATION_LITE = *mut _BOOTDISK_INFORMATION_LITE;
extern "C" {
    pub fn IoGetBootDiskInformation(BootDiskInformation:
                                        PBOOTDISK_INFORMATION, Size: ULONG)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoGetBootDiskInformationLite(BootDiskInformation:
                                            *mut PBOOTDISK_INFORMATION_LITE)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoBuildSynchronousFsdRequest(MajorFunction: ULONG,
                                        DeviceObject: PDEVICE_OBJECT,
                                        Buffer: PVOID, Length: ULONG,
                                        StartingOffset: PLARGE_INTEGER,
                                        Event: PKEVENT,
                                        IoStatusBlock: PIO_STATUS_BLOCK)
     -> PIRP;
}
extern "C" {
    pub fn IofCallDriver(DeviceObject: PDEVICE_OBJECT, Irp: PIRP) -> NTSTATUS;
}
extern "C" {
    pub fn IoCancelIrp(Irp: PIRP) -> BOOLEAN;
}
extern "C" {
    pub fn IoCheckShareAccess(DesiredAccess: ACCESS_MASK,
                              DesiredShareAccess: ULONG,
                              FileObject: PFILE_OBJECT,
                              ShareAccess: PSHARE_ACCESS, Update: BOOLEAN)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoCheckShareAccessEx(DesiredAccess: ACCESS_MASK,
                                DesiredShareAccess: ULONG,
                                FileObject: PFILE_OBJECT,
                                ShareAccess: PSHARE_ACCESS, Update: BOOLEAN,
                                WritePermission: PBOOLEAN) -> NTSTATUS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _IO_COMPLETION_ROUTINE_RESULT {
    ContinueCompletion = 0,
    StopCompletion = -1073741802,
}
pub use self::_IO_COMPLETION_ROUTINE_RESULT as IO_COMPLETION_ROUTINE_RESULT;
pub type PIO_COMPLETION_ROUTINE_RESULT = *mut _IO_COMPLETION_ROUTINE_RESULT;
extern "C" {
    pub fn IofCompleteRequest(Irp: PIRP, PriorityBoost: CCHAR);
}
extern "C" {
    pub fn IoConnectInterrupt(InterruptObject: *mut PKINTERRUPT,
                              ServiceRoutine: PKSERVICE_ROUTINE,
                              ServiceContext: PVOID, SpinLock: PKSPIN_LOCK,
                              Vector: ULONG, Irql: KIRQL,
                              SynchronizeIrql: KIRQL,
                              InterruptMode: KINTERRUPT_MODE,
                              ShareVector: BOOLEAN,
                              ProcessorEnableMask: KAFFINITY,
                              FloatingSave: BOOLEAN) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_INTERRUPT_MESSAGE_INFO_ENTRY {
    pub MessageAddress: PHYSICAL_ADDRESS,
    pub TargetProcessorSet: KAFFINITY,
    pub InterruptObject: PKINTERRUPT,
    pub MessageData: ULONG,
    pub Vector: ULONG,
    pub Irql: KIRQL,
    pub Mode: KINTERRUPT_MODE,
    pub Polarity: KINTERRUPT_POLARITY,
}
#[test]
fn bindgen_test_layout__IO_INTERRUPT_MESSAGE_INFO_ENTRY() {
    assert_eq!(::core::mem::size_of::<_IO_INTERRUPT_MESSAGE_INFO_ENTRY>() ,
               48usize);
    assert_eq!(::core::mem::align_of::<_IO_INTERRUPT_MESSAGE_INFO_ENTRY>() ,
               8usize);
}
impl Clone for _IO_INTERRUPT_MESSAGE_INFO_ENTRY {
    fn clone(&self) -> Self { *self }
}
pub use self::_IO_INTERRUPT_MESSAGE_INFO_ENTRY as
        IO_INTERRUPT_MESSAGE_INFO_ENTRY;
pub type PIO_INTERRUPT_MESSAGE_INFO_ENTRY =
    *mut _IO_INTERRUPT_MESSAGE_INFO_ENTRY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_INTERRUPT_MESSAGE_INFO {
    pub UnifiedIrql: KIRQL,
    pub MessageCount: ULONG,
    pub MessageInfo: [IO_INTERRUPT_MESSAGE_INFO_ENTRY; 1usize],
}
#[test]
fn bindgen_test_layout__IO_INTERRUPT_MESSAGE_INFO() {
    assert_eq!(::core::mem::size_of::<_IO_INTERRUPT_MESSAGE_INFO>() ,
               56usize);
    assert_eq!(::core::mem::align_of::<_IO_INTERRUPT_MESSAGE_INFO>() ,
               8usize);
}
impl Clone for _IO_INTERRUPT_MESSAGE_INFO {
    fn clone(&self) -> Self { *self }
}
pub use self::_IO_INTERRUPT_MESSAGE_INFO as IO_INTERRUPT_MESSAGE_INFO;
pub type PIO_INTERRUPT_MESSAGE_INFO = *mut _IO_INTERRUPT_MESSAGE_INFO;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS {
    pub PhysicalDeviceObject: PDEVICE_OBJECT,
    pub InterruptObject: *mut PKINTERRUPT,
    pub ServiceRoutine: PKSERVICE_ROUTINE,
    pub ServiceContext: PVOID,
    pub SpinLock: PKSPIN_LOCK,
    pub SynchronizeIrql: KIRQL,
    pub FloatingSave: BOOLEAN,
    pub ShareVector: BOOLEAN,
    pub Vector: ULONG,
    pub Irql: KIRQL,
    pub InterruptMode: KINTERRUPT_MODE,
    pub ProcessorEnableMask: KAFFINITY,
    pub Group: USHORT,
}
#[test]
fn bindgen_test_layout__IO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS() {
    assert_eq!(::core::mem::size_of::<_IO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS>()
               , 72usize);
    assert_eq!(::core::mem::align_of::<_IO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS>()
               , 8usize);
}
impl Clone for _IO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS {
    fn clone(&self) -> Self { *self }
}
pub use self::_IO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS as
        IO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS;
pub type PIO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS =
    *mut _IO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS {
    pub PhysicalDeviceObject: PDEVICE_OBJECT,
    pub InterruptObject: *mut PKINTERRUPT,
    pub ServiceRoutine: PKSERVICE_ROUTINE,
    pub ServiceContext: PVOID,
    pub SpinLock: PKSPIN_LOCK,
    pub SynchronizeIrql: KIRQL,
    pub FloatingSave: BOOLEAN,
}
#[test]
fn bindgen_test_layout__IO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS() {
    assert_eq!(::core::mem::size_of::<_IO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS>()
               , 48usize);
    assert_eq!(::core::mem::align_of::<_IO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS>()
               , 8usize);
}
impl Clone for _IO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS {
    fn clone(&self) -> Self { *self }
}
pub use self::_IO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS as
        IO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS;
pub type PIO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS =
    *mut _IO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS {
    pub PhysicalDeviceObject: PDEVICE_OBJECT,
    pub ConnectionContext: _IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS__bindgen_ty_1,
    pub MessageServiceRoutine: PKMESSAGE_SERVICE_ROUTINE,
    pub ServiceContext: PVOID,
    pub SpinLock: PKSPIN_LOCK,
    pub SynchronizeIrql: KIRQL,
    pub FloatingSave: BOOLEAN,
    pub FallBackServiceRoutine: PKSERVICE_ROUTINE,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS__bindgen_ty_1 {
    pub Generic: __BindgenUnionField<*mut PVOID>,
    pub InterruptMessageTable: __BindgenUnionField<*mut PIO_INTERRUPT_MESSAGE_INFO>,
    pub InterruptObject: __BindgenUnionField<*mut PKINTERRUPT>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS__bindgen_ty_1>()
               , 8usize);
    assert_eq!(::core::mem::align_of::<_IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS__bindgen_ty_1>()
               , 8usize);
}
impl Clone for _IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS() {
    assert_eq!(::core::mem::size_of::<_IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS>()
               , 56usize);
    assert_eq!(::core::mem::align_of::<_IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS>()
               , 8usize);
}
impl Clone for _IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS {
    fn clone(&self) -> Self { *self }
}
pub use self::_IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS as
        IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS;
pub type PIO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS =
    *mut _IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_CONNECT_INTERRUPT_PARAMETERS {
    pub Version: ULONG,
    pub __bindgen_anon_1: _IO_CONNECT_INTERRUPT_PARAMETERS__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_CONNECT_INTERRUPT_PARAMETERS__bindgen_ty_1 {
    pub FullySpecified: __BindgenUnionField<IO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS>,
    pub LineBased: __BindgenUnionField<IO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS>,
    pub MessageBased: __BindgenUnionField<IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS>,
    pub bindgen_union_field: [u64; 9usize],
}
#[test]
fn bindgen_test_layout__IO_CONNECT_INTERRUPT_PARAMETERS__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_IO_CONNECT_INTERRUPT_PARAMETERS__bindgen_ty_1>()
               , 72usize);
    assert_eq!(::core::mem::align_of::<_IO_CONNECT_INTERRUPT_PARAMETERS__bindgen_ty_1>()
               , 8usize);
}
impl Clone for _IO_CONNECT_INTERRUPT_PARAMETERS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__IO_CONNECT_INTERRUPT_PARAMETERS() {
    assert_eq!(::core::mem::size_of::<_IO_CONNECT_INTERRUPT_PARAMETERS>() ,
               80usize);
    assert_eq!(::core::mem::align_of::<_IO_CONNECT_INTERRUPT_PARAMETERS>() ,
               8usize);
}
impl Clone for _IO_CONNECT_INTERRUPT_PARAMETERS {
    fn clone(&self) -> Self { *self }
}
pub use self::_IO_CONNECT_INTERRUPT_PARAMETERS as
        IO_CONNECT_INTERRUPT_PARAMETERS;
pub type PIO_CONNECT_INTERRUPT_PARAMETERS =
    *mut _IO_CONNECT_INTERRUPT_PARAMETERS;
extern "C" {
    pub fn IoConnectInterruptEx(Parameters: PIO_CONNECT_INTERRUPT_PARAMETERS)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoCreateDevice(DriverObject: PDRIVER_OBJECT,
                          DeviceExtensionSize: ULONG,
                          DeviceName: PUNICODE_STRING, DeviceType: ULONG,
                          DeviceCharacteristics: ULONG, Exclusive: BOOLEAN,
                          DeviceObject: *mut PDEVICE_OBJECT) -> NTSTATUS;
}
extern "C" {
    pub fn IoIsWdmVersionAvailable(MajorVersion: UCHAR, MinorVersion: UCHAR)
     -> BOOLEAN;
}
extern "C" {
    pub fn IoCreateFile(FileHandle: PHANDLE, DesiredAccess: ACCESS_MASK,
                        ObjectAttributes: POBJECT_ATTRIBUTES,
                        IoStatusBlock: PIO_STATUS_BLOCK,
                        AllocationSize: PLARGE_INTEGER, FileAttributes: ULONG,
                        ShareAccess: ULONG, Disposition: ULONG,
                        CreateOptions: ULONG, EaBuffer: PVOID,
                        EaLength: ULONG, CreateFileType: CREATE_FILE_TYPE,
                        InternalParameters: PVOID, Options: ULONG)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoCreateNotificationEvent(EventName: PUNICODE_STRING,
                                     EventHandle: PHANDLE) -> PKEVENT;
}
extern "C" {
    pub fn IoCreateSymbolicLink(SymbolicLinkName: PUNICODE_STRING,
                                DeviceName: PUNICODE_STRING) -> NTSTATUS;
}
extern "C" {
    pub fn IoCreateSynchronizationEvent(EventName: PUNICODE_STRING,
                                        EventHandle: PHANDLE) -> PKEVENT;
}
extern "C" {
    pub fn IoCreateUnprotectedSymbolicLink(SymbolicLinkName: PUNICODE_STRING,
                                           DeviceName: PUNICODE_STRING)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoDeleteDevice(DeviceObject: PDEVICE_OBJECT);
}
extern "C" {
    pub fn IoDeleteSymbolicLink(SymbolicLinkName: PUNICODE_STRING)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoDetachDevice(TargetDevice: PDEVICE_OBJECT);
}
extern "C" {
    pub fn IoDisconnectInterrupt(InterruptObject: PKINTERRUPT);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_DISCONNECT_INTERRUPT_PARAMETERS {
    pub Version: ULONG,
    pub ConnectionContext: _IO_DISCONNECT_INTERRUPT_PARAMETERS__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_DISCONNECT_INTERRUPT_PARAMETERS__bindgen_ty_1 {
    pub Generic: __BindgenUnionField<PVOID>,
    pub InterruptObject: __BindgenUnionField<PKINTERRUPT>,
    pub InterruptMessageTable: __BindgenUnionField<PIO_INTERRUPT_MESSAGE_INFO>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__IO_DISCONNECT_INTERRUPT_PARAMETERS__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_IO_DISCONNECT_INTERRUPT_PARAMETERS__bindgen_ty_1>()
               , 8usize);
    assert_eq!(::core::mem::align_of::<_IO_DISCONNECT_INTERRUPT_PARAMETERS__bindgen_ty_1>()
               , 8usize);
}
impl Clone for _IO_DISCONNECT_INTERRUPT_PARAMETERS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__IO_DISCONNECT_INTERRUPT_PARAMETERS() {
    assert_eq!(::core::mem::size_of::<_IO_DISCONNECT_INTERRUPT_PARAMETERS>() ,
               16usize);
    assert_eq!(::core::mem::align_of::<_IO_DISCONNECT_INTERRUPT_PARAMETERS>()
               , 8usize);
}
impl Clone for _IO_DISCONNECT_INTERRUPT_PARAMETERS {
    fn clone(&self) -> Self { *self }
}
pub use self::_IO_DISCONNECT_INTERRUPT_PARAMETERS as
        IO_DISCONNECT_INTERRUPT_PARAMETERS;
pub type PIO_DISCONNECT_INTERRUPT_PARAMETERS =
    *mut _IO_DISCONNECT_INTERRUPT_PARAMETERS;
extern "C" {
    pub fn IoDisconnectInterruptEx(Parameters:
                                       PIO_DISCONNECT_INTERRUPT_PARAMETERS);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS {
    pub Version: ULONG,
    pub ConnectionContext: _IO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS__bindgen_ty_1 {
    pub Generic: __BindgenUnionField<PVOID>,
    pub InterruptObject: __BindgenUnionField<PKINTERRUPT>,
    pub InterruptMessageTable: __BindgenUnionField<PIO_INTERRUPT_MESSAGE_INFO>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__IO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_IO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS__bindgen_ty_1>()
               , 8usize);
    assert_eq!(::core::mem::align_of::<_IO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS__bindgen_ty_1>()
               , 8usize);
}
impl Clone for _IO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__IO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS() {
    assert_eq!(::core::mem::size_of::<_IO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS>()
               , 16usize);
    assert_eq!(::core::mem::align_of::<_IO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS>()
               , 8usize);
}
impl Clone for _IO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS {
    fn clone(&self) -> Self { *self }
}
pub use self::_IO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS as
        IO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS;
pub type PIO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS =
    *mut _IO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS;
extern "C" {
    pub fn IoReportInterruptActive(Parameters:
                                       PIO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS);
}
extern "C" {
    pub fn IoReportInterruptInactive(Parameters:
                                         PIO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS);
}
extern "C" {
    pub fn IoGetAffinityInterrupt(InterruptObject: PKINTERRUPT,
                                  GroupAffinity: PGROUP_AFFINITY) -> NTSTATUS;
}
extern "C" {
    pub fn IoFreeIrp(Irp: PIRP);
}
extern "C" {
    pub fn IoFreeMdl(Mdl: PMDL);
}
extern "C" {
    pub fn IoGetAttachedDeviceReference(DeviceObject: PDEVICE_OBJECT)
     -> PDEVICE_OBJECT;
}
extern "C" {
    pub fn IoGetDriverObjectExtension(DriverObject: PDRIVER_OBJECT,
                                      ClientIdentificationAddress: PVOID)
     -> PVOID;
}
extern "C" {
    pub fn IoGetCurrentProcess() -> PEPROCESS;
}
extern "C" {
    pub fn IoGetDeviceObjectPointer(ObjectName: PUNICODE_STRING,
                                    DesiredAccess: ACCESS_MASK,
                                    FileObject: *mut PFILE_OBJECT,
                                    DeviceObject: *mut PDEVICE_OBJECT)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoGetDmaAdapter(PhysicalDeviceObject: PDEVICE_OBJECT,
                           DeviceDescription: *mut _DEVICE_DESCRIPTION,
                           NumberOfMapRegisters: PULONG) -> *mut _DMA_ADAPTER;
}
extern "C" {
    pub fn IoForwardIrpSynchronously(DeviceObject: PDEVICE_OBJECT, Irp: PIRP)
     -> BOOLEAN;
}
extern "C" {
    pub fn IoSynchronousCallDriver(DeviceObject: PDEVICE_OBJECT, Irp: PIRP)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoGetInitialStack() -> PVOID;
}
extern "C" {
    pub fn IoGetStackLimits(LowLimit: PULONG_PTR, HighLimit: PULONG_PTR);
}
extern "C" {
    pub fn IoWithinStackLimits(RegionStart: ULONG_PTR, RegionSize: SIZE_T)
     -> LOGICAL;
}
extern "C" {
    pub fn IoGetRelatedDeviceObject(FileObject: PFILE_OBJECT)
     -> PDEVICE_OBJECT;
}
extern "C" {
    pub fn IoGetTopLevelIrp() -> PIRP;
}
extern "C" {
    pub fn IoInitializeIrp(Irp: PIRP, PacketSize: USHORT, StackSize: CCHAR);
}
extern "C" {
    pub fn IoInitializeIrpEx(Irp: PIRP, DeviceObject: PDEVICE_OBJECT,
                             PacketSize: USHORT, StackSize: CCHAR);
}
extern "C" {
    pub fn IoInitializeTimer(DeviceObject: PDEVICE_OBJECT,
                             TimerRoutine: PIO_TIMER_ROUTINE, Context: PVOID)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoReuseIrp(Irp: PIRP, Iostatus: NTSTATUS);
}
extern "C" {
    pub fn IoRegisterShutdownNotification(DeviceObject: PDEVICE_OBJECT)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoRegisterLastChanceShutdownNotification(DeviceObject:
                                                        PDEVICE_OBJECT)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoReleaseCancelSpinLock(Irql: KIRQL);
}
extern "C" {
    pub fn IoRemoveShareAccess(FileObject: PFILE_OBJECT,
                               ShareAccess: PSHARE_ACCESS);
}
extern "C" {
    pub fn IoSetCompletionRoutineEx(DeviceObject: PDEVICE_OBJECT, Irp: PIRP,
                                    CompletionRoutine: PIO_COMPLETION_ROUTINE,
                                    Context: PVOID, InvokeOnSuccess: BOOLEAN,
                                    InvokeOnError: BOOLEAN,
                                    InvokeOnCancel: BOOLEAN) -> NTSTATUS;
}
extern "C" {
    pub fn IoSetShareAccess(DesiredAccess: ACCESS_MASK,
                            DesiredShareAccess: ULONG,
                            FileObject: PFILE_OBJECT,
                            ShareAccess: PSHARE_ACCESS);
}
extern "C" {
    pub fn IoSetShareAccessEx(DesiredAccess: ACCESS_MASK,
                              DesiredShareAccess: ULONG,
                              FileObject: PFILE_OBJECT,
                              ShareAccess: PSHARE_ACCESS,
                              WritePermission: PBOOLEAN);
}
extern "C" {
    pub fn IoSetTopLevelIrp(Irp: PIRP);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_REMOVE_LOCK_TRACKING_BLOCK {
    pub _address: u8,
}
impl Clone for _IO_REMOVE_LOCK_TRACKING_BLOCK {
    fn clone(&self) -> Self { *self }
}
pub type PIO_REMOVE_LOCK_TRACKING_BLOCK = *mut _IO_REMOVE_LOCK_TRACKING_BLOCK;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_REMOVE_LOCK_COMMON_BLOCK {
    pub Removed: BOOLEAN,
    pub Reserved: [BOOLEAN; 3usize],
    pub IoCount: LONG,
    pub RemoveEvent: KEVENT,
}
#[test]
fn bindgen_test_layout__IO_REMOVE_LOCK_COMMON_BLOCK() {
    assert_eq!(::core::mem::size_of::<_IO_REMOVE_LOCK_COMMON_BLOCK>() ,
               32usize);
    assert_eq!(::core::mem::align_of::<_IO_REMOVE_LOCK_COMMON_BLOCK>() ,
               8usize);
}
impl Clone for _IO_REMOVE_LOCK_COMMON_BLOCK {
    fn clone(&self) -> Self { *self }
}
pub use self::_IO_REMOVE_LOCK_COMMON_BLOCK as IO_REMOVE_LOCK_COMMON_BLOCK;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_REMOVE_LOCK_DBG_BLOCK {
    pub Signature: LONG,
    pub HighWatermark: ULONG,
    pub MaxLockedTicks: LONGLONG,
    pub AllocateTag: LONG,
    pub LockList: LIST_ENTRY,
    pub Spin: KSPIN_LOCK,
    pub LowMemoryCount: LONG,
    pub Reserved1: [ULONG; 4usize],
    pub Reserved2: PVOID,
    pub Blocks: PIO_REMOVE_LOCK_TRACKING_BLOCK,
}
#[test]
fn bindgen_test_layout__IO_REMOVE_LOCK_DBG_BLOCK() {
    assert_eq!(::core::mem::size_of::<_IO_REMOVE_LOCK_DBG_BLOCK>() , 88usize);
    assert_eq!(::core::mem::align_of::<_IO_REMOVE_LOCK_DBG_BLOCK>() , 8usize);
}
impl Clone for _IO_REMOVE_LOCK_DBG_BLOCK {
    fn clone(&self) -> Self { *self }
}
pub use self::_IO_REMOVE_LOCK_DBG_BLOCK as IO_REMOVE_LOCK_DBG_BLOCK;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_REMOVE_LOCK {
    pub Common: IO_REMOVE_LOCK_COMMON_BLOCK,
}
#[test]
fn bindgen_test_layout__IO_REMOVE_LOCK() {
    assert_eq!(::core::mem::size_of::<_IO_REMOVE_LOCK>() , 32usize);
    assert_eq!(::core::mem::align_of::<_IO_REMOVE_LOCK>() , 8usize);
}
impl Clone for _IO_REMOVE_LOCK {
    fn clone(&self) -> Self { *self }
}
pub use self::_IO_REMOVE_LOCK as IO_REMOVE_LOCK;
pub type PIO_REMOVE_LOCK = *mut _IO_REMOVE_LOCK;
extern "C" {
    pub fn IoInitializeRemoveLockEx(Lock: PIO_REMOVE_LOCK, AllocateTag: ULONG,
                                    MaxLockedMinutes: ULONG,
                                    HighWatermark: ULONG, RemlockSize: ULONG);
}
extern "C" {
    pub fn IoAcquireRemoveLockEx(RemoveLock: PIO_REMOVE_LOCK, Tag: PVOID,
                                 File: PCSTR, Line: ULONG, RemlockSize: ULONG)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoReleaseRemoveLockEx(RemoveLock: PIO_REMOVE_LOCK, Tag: PVOID,
                                 RemlockSize: ULONG);
}
extern "C" {
    pub fn IoReleaseRemoveLockAndWaitEx(RemoveLock: PIO_REMOVE_LOCK,
                                        Tag: PVOID, RemlockSize: ULONG);
}
extern "C" {
    pub fn IoSizeOfIrpEx(DeviceObject: PDEVICE_OBJECT, StackSize: CCHAR)
     -> USHORT;
}
extern "C" {
    pub fn IoStartNextPacket(DeviceObject: PDEVICE_OBJECT,
                             Cancelable: BOOLEAN);
}
extern "C" {
    pub fn IoStartNextPacketByKey(DeviceObject: PDEVICE_OBJECT,
                                  Cancelable: BOOLEAN, Key: ULONG);
}
extern "C" {
    pub fn IoStartPacket(DeviceObject: PDEVICE_OBJECT, Irp: PIRP, Key: PULONG,
                         CancelFunction: PDRIVER_CANCEL);
}
extern "C" {
    pub fn IoSetStartIoAttributes(DeviceObject: PDEVICE_OBJECT,
                                  DeferredStartIo: BOOLEAN,
                                  NonCancelable: BOOLEAN);
}
extern "C" {
    pub fn IoStartTimer(DeviceObject: PDEVICE_OBJECT);
}
extern "C" {
    pub fn IoStopTimer(DeviceObject: PDEVICE_OBJECT);
}
extern "C" {
    pub fn IoUnregisterShutdownNotification(DeviceObject: PDEVICE_OBJECT);
}
extern "C" {
    pub fn IoUpdateShareAccess(FileObject: PFILE_OBJECT,
                               ShareAccess: PSHARE_ACCESS);
}
extern "C" {
    pub fn IoWriteErrorLogEntry(ElEntry: PVOID);
}
extern "C" {
    pub fn IoCreateSystemThread(IoObject: PVOID, ThreadHandle: PHANDLE,
                                DesiredAccess: ULONG,
                                ObjectAttributes: POBJECT_ATTRIBUTES,
                                ProcessHandle: HANDLE, ClientId: PCLIENT_ID,
                                StartRoutine: PKSTART_ROUTINE,
                                StartContext: PVOID) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_WORKITEM {
    pub _address: u8,
}
impl Clone for _IO_WORKITEM {
    fn clone(&self) -> Self { *self }
}
pub type PIO_WORKITEM = *mut _IO_WORKITEM;
pub type IO_WORKITEM_ROUTINE =
    ::core::option::Option<unsafe extern "C" fn(DeviceObject: PDEVICE_OBJECT,
                                                Context: PVOID)>;
pub type PIO_WORKITEM_ROUTINE = IO_WORKITEM_ROUTINE;
extern "C" {
    pub fn IoAllocateWorkItem(DeviceObject: PDEVICE_OBJECT) -> PIO_WORKITEM;
}
extern "C" {
    pub fn IoFreeWorkItem(IoWorkItem: PIO_WORKITEM);
}
extern "C" {
    pub fn IoQueueWorkItem(IoWorkItem: PIO_WORKITEM,
                           WorkerRoutine: PIO_WORKITEM_ROUTINE,
                           QueueType: WORK_QUEUE_TYPE, Context: PVOID);
}
pub type IO_WORKITEM_ROUTINE_EX =
    ::core::option::Option<unsafe extern "C" fn(IoObject: PVOID,
                                                Context: PVOID,
                                                IoWorkItem: PIO_WORKITEM)>;
pub type PIO_WORKITEM_ROUTINE_EX = IO_WORKITEM_ROUTINE_EX;
extern "C" {
    pub fn IoQueueWorkItemEx(IoWorkItem: PIO_WORKITEM,
                             WorkerRoutine: PIO_WORKITEM_ROUTINE_EX,
                             QueueType: WORK_QUEUE_TYPE, Context: PVOID);
}
extern "C" {
    pub fn IoSizeofWorkItem() -> ULONG;
}
extern "C" {
    pub fn IoInitializeWorkItem(IoObject: PVOID, IoWorkItem: PIO_WORKITEM);
}
extern "C" {
    pub fn IoUninitializeWorkItem(IoWorkItem: PIO_WORKITEM);
}
extern "C" {
    pub fn IoTryQueueWorkItem(IoWorkItem: PIO_WORKITEM,
                              WorkerRoutine: PIO_WORKITEM_ROUTINE_EX,
                              QueueType: WORK_QUEUE_TYPE, Context: PVOID)
     -> BOOLEAN;
}
extern "C" {
    pub fn IoWMIRegistrationControl(DeviceObject: PDEVICE_OBJECT,
                                    Action: ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn IoWMIAllocateInstanceIds(Guid: LPCGUID, InstanceCount: ULONG,
                                    FirstInstanceId: *mut ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn IoWMISuggestInstanceName(PhysicalDeviceObject: PDEVICE_OBJECT,
                                    SymbolicLinkName: PUNICODE_STRING,
                                    CombineNames: BOOLEAN,
                                    SuggestedInstanceName: PUNICODE_STRING)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoWMIWriteEvent(WnodeEventItem: PVOID) -> NTSTATUS;
}
extern "C" {
    pub fn IoWMIDeviceObjectToProviderId(DeviceObject: PDEVICE_OBJECT)
     -> ULONG;
}
extern "C" {
    pub fn IoWMIOpenBlock(Guid: LPCGUID, DesiredAccess: ULONG,
                          DataBlockObject: *mut PVOID) -> NTSTATUS;
}
extern "C" {
    pub fn IoWMIQueryAllData(DataBlockObject: PVOID, InOutBufferSize: PULONG,
                             OutBuffer: PVOID) -> NTSTATUS;
}
extern "C" {
    pub fn IoWMIQueryAllDataMultiple(DataBlockObjectList: *mut PVOID,
                                     ObjectCount: ULONG,
                                     InOutBufferSize: PULONG,
                                     OutBuffer: PVOID) -> NTSTATUS;
}
extern "C" {
    pub fn IoWMIQuerySingleInstance(DataBlockObject: PVOID,
                                    InstanceName: PUNICODE_STRING,
                                    InOutBufferSize: PULONG, OutBuffer: PVOID)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoWMIQuerySingleInstanceMultiple(DataBlockObjectList: *mut PVOID,
                                            InstanceNames: PUNICODE_STRING,
                                            ObjectCount: ULONG,
                                            InOutBufferSize: PULONG,
                                            OutBuffer: PVOID) -> NTSTATUS;
}
extern "C" {
    pub fn IoWMISetSingleInstance(DataBlockObject: PVOID,
                                  InstanceName: PUNICODE_STRING,
                                  Version: ULONG, ValueBufferSize: ULONG,
                                  ValueBuffer: PVOID) -> NTSTATUS;
}
extern "C" {
    pub fn IoWMISetSingleItem(DataBlockObject: PVOID,
                              InstanceName: PUNICODE_STRING,
                              DataItemId: ULONG, Version: ULONG,
                              ValueBufferSize: ULONG, ValueBuffer: PVOID)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoWMIExecuteMethod(DataBlockObject: PVOID,
                              InstanceName: PUNICODE_STRING, MethodId: ULONG,
                              InBufferSize: ULONG, OutBufferSize: PULONG,
                              InOutBuffer: PUCHAR) -> NTSTATUS;
}
pub type FWMI_NOTIFICATION_CALLBACK =
    ::core::option::Option<unsafe extern "C" fn(Wnode: PVOID,
                                                Context: PVOID)>;
pub type WMI_NOTIFICATION_CALLBACK = FWMI_NOTIFICATION_CALLBACK;
extern "C" {
    pub fn IoWMISetNotificationCallback(Object: PVOID,
                                        Callback: WMI_NOTIFICATION_CALLBACK,
                                        Context: PVOID) -> NTSTATUS;
}
extern "C" {
    pub fn IoWMIHandleToInstanceName(DataBlockObject: PVOID,
                                     FileHandle: HANDLE,
                                     InstanceName: PUNICODE_STRING)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoWMIDeviceObjectToInstanceName(DataBlockObject: PVOID,
                                           DeviceObject: PDEVICE_OBJECT,
                                           InstanceName: PUNICODE_STRING)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoIs32bitProcess(Irp: PIRP) -> BOOLEAN;
}
extern "C" {
    pub fn IoIsInitiator32bitProcess(Irp: PIRP) -> BOOLEAN;
}
extern "C" {
    pub fn IoFreeErrorLogEntry(ElEntry: PVOID);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_CSQ {
    pub Type: ULONG,
    pub CsqInsertIrp: PIO_CSQ_INSERT_IRP,
    pub CsqRemoveIrp: PIO_CSQ_REMOVE_IRP,
    pub CsqPeekNextIrp: PIO_CSQ_PEEK_NEXT_IRP,
    pub CsqAcquireLock: PIO_CSQ_ACQUIRE_LOCK,
    pub CsqReleaseLock: PIO_CSQ_RELEASE_LOCK,
    pub CsqCompleteCanceledIrp: PIO_CSQ_COMPLETE_CANCELED_IRP,
    pub ReservePointer: PVOID,
}
#[test]
fn bindgen_test_layout__IO_CSQ() {
    assert_eq!(::core::mem::size_of::<_IO_CSQ>() , 64usize);
    assert_eq!(::core::mem::align_of::<_IO_CSQ>() , 8usize);
}
impl Clone for _IO_CSQ {
    fn clone(&self) -> Self { *self }
}
pub use self::_IO_CSQ as IO_CSQ;
pub type PIO_CSQ = *mut _IO_CSQ;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_CSQ_IRP_CONTEXT {
    pub Type: ULONG,
    pub Irp: PIRP,
    pub Csq: PIO_CSQ,
}
#[test]
fn bindgen_test_layout__IO_CSQ_IRP_CONTEXT() {
    assert_eq!(::core::mem::size_of::<_IO_CSQ_IRP_CONTEXT>() , 24usize);
    assert_eq!(::core::mem::align_of::<_IO_CSQ_IRP_CONTEXT>() , 8usize);
}
impl Clone for _IO_CSQ_IRP_CONTEXT {
    fn clone(&self) -> Self { *self }
}
pub use self::_IO_CSQ_IRP_CONTEXT as IO_CSQ_IRP_CONTEXT;
pub type PIO_CSQ_IRP_CONTEXT = *mut _IO_CSQ_IRP_CONTEXT;
pub type IO_CSQ_INSERT_IRP =
    ::core::option::Option<unsafe extern "C" fn(Csq: *mut _IO_CSQ,
                                                Irp: PIRP)>;
pub type PIO_CSQ_INSERT_IRP = IO_CSQ_INSERT_IRP;
pub type IO_CSQ_INSERT_IRP_EX =
    ::core::option::Option<unsafe extern "C" fn(Csq: *mut _IO_CSQ, Irp: PIRP,
                                                InsertContext: PVOID)
                               -> NTSTATUS>;
pub type PIO_CSQ_INSERT_IRP_EX = IO_CSQ_INSERT_IRP_EX;
pub type IO_CSQ_REMOVE_IRP =
    ::core::option::Option<unsafe extern "C" fn(Csq: PIO_CSQ, Irp: PIRP)>;
pub type PIO_CSQ_REMOVE_IRP = IO_CSQ_REMOVE_IRP;
pub type IO_CSQ_PEEK_NEXT_IRP =
    ::core::option::Option<unsafe extern "C" fn(Csq: PIO_CSQ, Irp: PIRP,
                                                PeekContext: PVOID) -> PIRP>;
pub type PIO_CSQ_PEEK_NEXT_IRP = IO_CSQ_PEEK_NEXT_IRP;
pub type IO_CSQ_ACQUIRE_LOCK =
    ::core::option::Option<unsafe extern "C" fn(Csq: PIO_CSQ, Irql: PKIRQL)>;
pub type PIO_CSQ_ACQUIRE_LOCK = IO_CSQ_ACQUIRE_LOCK;
pub type IO_CSQ_RELEASE_LOCK =
    ::core::option::Option<unsafe extern "C" fn(Csq: PIO_CSQ, Irql: KIRQL)>;
pub type PIO_CSQ_RELEASE_LOCK = IO_CSQ_RELEASE_LOCK;
pub type IO_CSQ_COMPLETE_CANCELED_IRP =
    ::core::option::Option<unsafe extern "C" fn(Csq: PIO_CSQ, Irp: PIRP)>;
pub type PIO_CSQ_COMPLETE_CANCELED_IRP = IO_CSQ_COMPLETE_CANCELED_IRP;
extern "C" {
    pub fn IoCsqInitialize(Csq: PIO_CSQ, CsqInsertIrp: PIO_CSQ_INSERT_IRP,
                           CsqRemoveIrp: PIO_CSQ_REMOVE_IRP,
                           CsqPeekNextIrp: PIO_CSQ_PEEK_NEXT_IRP,
                           CsqAcquireLock: PIO_CSQ_ACQUIRE_LOCK,
                           CsqReleaseLock: PIO_CSQ_RELEASE_LOCK,
                           CsqCompleteCanceledIrp:
                               PIO_CSQ_COMPLETE_CANCELED_IRP) -> NTSTATUS;
}
extern "C" {
    pub fn IoCsqInitializeEx(Csq: PIO_CSQ,
                             CsqInsertIrp: PIO_CSQ_INSERT_IRP_EX,
                             CsqRemoveIrp: PIO_CSQ_REMOVE_IRP,
                             CsqPeekNextIrp: PIO_CSQ_PEEK_NEXT_IRP,
                             CsqAcquireLock: PIO_CSQ_ACQUIRE_LOCK,
                             CsqReleaseLock: PIO_CSQ_RELEASE_LOCK,
                             CsqCompleteCanceledIrp:
                                 PIO_CSQ_COMPLETE_CANCELED_IRP) -> NTSTATUS;
}
extern "C" {
    pub fn IoCsqInsertIrp(Csq: PIO_CSQ, Irp: PIRP,
                          Context: PIO_CSQ_IRP_CONTEXT);
}
extern "C" {
    pub fn IoCsqInsertIrpEx(Csq: PIO_CSQ, Irp: PIRP,
                            Context: PIO_CSQ_IRP_CONTEXT,
                            InsertContext: PVOID) -> NTSTATUS;
}
extern "C" {
    pub fn IoCsqRemoveNextIrp(Csq: PIO_CSQ, PeekContext: PVOID) -> PIRP;
}
extern "C" {
    pub fn IoCsqRemoveIrp(Csq: PIO_CSQ, Context: PIO_CSQ_IRP_CONTEXT) -> PIRP;
}
extern "C" {
    pub fn IoValidateDeviceIoControlAccess(Irp: PIRP, RequiredAccess: ULONG)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoGetIoPriorityHint(Irp: PIRP) -> IO_PRIORITY_HINT;
}
extern "C" {
    pub fn IoSetIoPriorityHint(Irp: PIRP, PriorityHint: IO_PRIORITY_HINT)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoAllocateSfioStreamIdentifier(FileObject: PFILE_OBJECT,
                                          Length: ULONG, Signature: PVOID,
                                          StreamIdentifier: *mut PVOID)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoGetSfioStreamIdentifier(FileObject: PFILE_OBJECT,
                                     Signature: PVOID) -> PVOID;
}
extern "C" {
    pub fn IoFreeSfioStreamIdentifier(FileObject: PFILE_OBJECT,
                                      Signature: PVOID) -> NTSTATUS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _IO_ACCESS_TYPE {
    ReadAccess = 0,
    WriteAccess = 1,
    ModifyAccess = 2,
}
pub use self::_IO_ACCESS_TYPE as IO_ACCESS_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _IO_ACCESS_MODE { SequentialAccess = 0, RandomAccess = 1, }
pub use self::_IO_ACCESS_MODE as IO_ACCESS_MODE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _IO_CONTAINER_NOTIFICATION_CLASS {
    IoSessionStateNotification = 0,
    IoMaxContainerNotificationClass = 1,
}
pub use self::_IO_CONTAINER_NOTIFICATION_CLASS as
        IO_CONTAINER_NOTIFICATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_SESSION_STATE_NOTIFICATION {
    pub Size: ULONG,
    pub Flags: ULONG,
    pub IoObject: PVOID,
    pub EventMask: ULONG,
    pub Context: PVOID,
}
#[test]
fn bindgen_test_layout__IO_SESSION_STATE_NOTIFICATION() {
    assert_eq!(::core::mem::size_of::<_IO_SESSION_STATE_NOTIFICATION>() ,
               32usize);
    assert_eq!(::core::mem::align_of::<_IO_SESSION_STATE_NOTIFICATION>() ,
               8usize);
}
impl Clone for _IO_SESSION_STATE_NOTIFICATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_IO_SESSION_STATE_NOTIFICATION as IO_SESSION_STATE_NOTIFICATION;
pub type PIO_SESSION_STATE_NOTIFICATION = *mut _IO_SESSION_STATE_NOTIFICATION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _IO_CONTAINER_INFORMATION_CLASS {
    IoSessionStateInformation = 0,
    IoMaxContainerInformationClass = 1,
}
pub use self::_IO_CONTAINER_INFORMATION_CLASS as
        IO_CONTAINER_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_SESSION_STATE_INFORMATION {
    pub SessionId: ULONG,
    pub SessionState: IO_SESSION_STATE,
    pub LocalSession: BOOLEAN,
}
#[test]
fn bindgen_test_layout__IO_SESSION_STATE_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_IO_SESSION_STATE_INFORMATION>() ,
               12usize);
    assert_eq!(::core::mem::align_of::<_IO_SESSION_STATE_INFORMATION>() ,
               4usize);
}
impl Clone for _IO_SESSION_STATE_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_IO_SESSION_STATE_INFORMATION as IO_SESSION_STATE_INFORMATION;
pub type PIO_SESSION_STATE_INFORMATION = *mut _IO_SESSION_STATE_INFORMATION;
extern "C" {
    pub fn IoGetContainerInformation(InformationClass:
                                         IO_CONTAINER_INFORMATION_CLASS,
                                     ContainerObject: PVOID, Buffer: PVOID,
                                     BufferLength: ULONG) -> NTSTATUS;
}
pub type PIO_CONTAINER_NOTIFICATION_FUNCTION =
    ::core::option::Option<unsafe extern "C" fn() -> libc::c_long>;
pub type IO_SESSION_NOTIFICATION_FUNCTION =
    ::core::option::Option<unsafe extern "C" fn(SessionObject: PVOID,
                                                IoObject: PVOID, Event: ULONG,
                                                Context: PVOID,
                                                NotificationPayload: PVOID,
                                                PayloadLength: ULONG)
                               -> NTSTATUS>;
pub type PIO_SESSION_NOTIFICATION_FUNCTION = IO_SESSION_NOTIFICATION_FUNCTION;
extern "C" {
    pub fn IoRegisterContainerNotification(NotificationClass:
                                               IO_CONTAINER_NOTIFICATION_CLASS,
                                           CallbackFunction:
                                               PIO_CONTAINER_NOTIFICATION_FUNCTION,
                                           NotificationInformation: PVOID,
                                           NotificationInformationLength:
                                               ULONG,
                                           CallbackRegistration: PVOID)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoUnregisterContainerNotification(CallbackRegistration: PVOID);
}
pub type TRACEHANDLE = ULONG64;
pub type PTRACEHANDLE = *mut ULONG64;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _ETW_TRACE_SESSION_SETTINGS {
    pub Version: ULONG,
    pub BufferSize: ULONG,
    pub MinimumBuffers: ULONG,
    pub MaximumBuffers: ULONG,
    pub LoggerMode: ULONG,
    pub FlushTimer: ULONG,
    pub FlushThreshold: ULONG,
    pub ClockType: ULONG,
}
#[test]
fn bindgen_test_layout__ETW_TRACE_SESSION_SETTINGS() {
    assert_eq!(::core::mem::size_of::<_ETW_TRACE_SESSION_SETTINGS>() ,
               32usize);
    assert_eq!(::core::mem::align_of::<_ETW_TRACE_SESSION_SETTINGS>() ,
               4usize);
}
impl Clone for _ETW_TRACE_SESSION_SETTINGS {
    fn clone(&self) -> Self { *self }
}
pub use self::_ETW_TRACE_SESSION_SETTINGS as ETW_TRACE_SESSION_SETTINGS;
pub type PETW_TRACE_SESSION_SETTINGS = *mut _ETW_TRACE_SESSION_SETTINGS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _TRACE_INFORMATION_CLASS {
    TraceIdClass = 0,
    TraceHandleClass = 1,
    TraceEnableFlagsClass = 2,
    TraceEnableLevelClass = 3,
    GlobalLoggerHandleClass = 4,
    EventLoggerHandleClass = 5,
    AllLoggerHandlesClass = 6,
    TraceHandleByNameClass = 7,
    LoggerEventsLostClass = 8,
    TraceSessionSettingsClass = 9,
    LoggerEventsLoggedClass = 10,
    DiskIoNotifyRoutinesClass = 11,
    TraceInformationClassReserved1 = 12,
    FltIoNotifyRoutinesClass = 13,
    TraceInformationClassReserved2 = 14,
    WdfNotifyRoutinesClass = 15,
    MaxTraceInformationClass = 16,
}
pub use self::_TRACE_INFORMATION_CLASS as TRACE_INFORMATION_CLASS;
extern "C" {
    pub fn WmiQueryTraceInformation(TraceInformationClass:
                                        TRACE_INFORMATION_CLASS,
                                    TraceInformation: PVOID,
                                    TraceInformationLength: ULONG,
                                    RequiredLength: PULONG, Buffer: PVOID)
     -> NTSTATUS;
}
pub type REGHANDLE = ULONGLONG;
pub type PREGHANDLE = *mut ULONGLONG;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _EVENT_DATA_DESCRIPTOR {
    pub Ptr: ULONGLONG,
    pub Size: ULONG,
    pub __bindgen_anon_1: _EVENT_DATA_DESCRIPTOR__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _EVENT_DATA_DESCRIPTOR__bindgen_ty_1 {
    pub Reserved: __BindgenUnionField<ULONG>,
    pub __bindgen_anon_1: __BindgenUnionField<_EVENT_DATA_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _EVENT_DATA_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    pub Type: UCHAR,
    pub Reserved1: UCHAR,
    pub Reserved2: USHORT,
}
#[test]
fn bindgen_test_layout__EVENT_DATA_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_EVENT_DATA_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_EVENT_DATA_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>()
               , 2usize);
}
impl Clone for _EVENT_DATA_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__EVENT_DATA_DESCRIPTOR__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_EVENT_DATA_DESCRIPTOR__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_EVENT_DATA_DESCRIPTOR__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _EVENT_DATA_DESCRIPTOR__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__EVENT_DATA_DESCRIPTOR() {
    assert_eq!(::core::mem::size_of::<_EVENT_DATA_DESCRIPTOR>() , 16usize);
    assert_eq!(::core::mem::align_of::<_EVENT_DATA_DESCRIPTOR>() , 8usize);
}
impl Clone for _EVENT_DATA_DESCRIPTOR {
    fn clone(&self) -> Self { *self }
}
pub use self::_EVENT_DATA_DESCRIPTOR as EVENT_DATA_DESCRIPTOR;
pub type PEVENT_DATA_DESCRIPTOR = *mut _EVENT_DATA_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _EVENT_DESCRIPTOR {
    pub Id: USHORT,
    pub Version: UCHAR,
    pub Channel: UCHAR,
    pub Level: UCHAR,
    pub Opcode: UCHAR,
    pub Task: USHORT,
    pub Keyword: ULONGLONG,
}
#[test]
fn bindgen_test_layout__EVENT_DESCRIPTOR() {
    assert_eq!(::core::mem::size_of::<_EVENT_DESCRIPTOR>() , 16usize);
    assert_eq!(::core::mem::align_of::<_EVENT_DESCRIPTOR>() , 8usize);
}
impl Clone for _EVENT_DESCRIPTOR {
    fn clone(&self) -> Self { *self }
}
pub use self::_EVENT_DESCRIPTOR as EVENT_DESCRIPTOR;
pub type PEVENT_DESCRIPTOR = *mut _EVENT_DESCRIPTOR;
pub type PCEVENT_DESCRIPTOR = *const EVENT_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _EVENT_FILTER_DESCRIPTOR {
    pub Ptr: ULONGLONG,
    pub Size: ULONG,
    pub Type: ULONG,
}
#[test]
fn bindgen_test_layout__EVENT_FILTER_DESCRIPTOR() {
    assert_eq!(::core::mem::size_of::<_EVENT_FILTER_DESCRIPTOR>() , 16usize);
    assert_eq!(::core::mem::align_of::<_EVENT_FILTER_DESCRIPTOR>() , 8usize);
}
impl Clone for _EVENT_FILTER_DESCRIPTOR {
    fn clone(&self) -> Self { *self }
}
pub use self::_EVENT_FILTER_DESCRIPTOR as EVENT_FILTER_DESCRIPTOR;
pub type PEVENT_FILTER_DESCRIPTOR = *mut _EVENT_FILTER_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _EVENT_FILTER_HEADER {
    pub Id: USHORT,
    pub Version: UCHAR,
    pub Reserved: [UCHAR; 5usize],
    pub InstanceId: ULONGLONG,
    pub Size: ULONG,
    pub NextOffset: ULONG,
}
#[test]
fn bindgen_test_layout__EVENT_FILTER_HEADER() {
    assert_eq!(::core::mem::size_of::<_EVENT_FILTER_HEADER>() , 24usize);
    assert_eq!(::core::mem::align_of::<_EVENT_FILTER_HEADER>() , 8usize);
}
impl Clone for _EVENT_FILTER_HEADER {
    fn clone(&self) -> Self { *self }
}
pub use self::_EVENT_FILTER_HEADER as EVENT_FILTER_HEADER;
pub type PEVENT_FILTER_HEADER = *mut _EVENT_FILTER_HEADER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _EVENT_FILTER_EVENT_ID {
    pub FilterIn: BOOLEAN,
    pub Reserved: UCHAR,
    pub Count: USHORT,
    pub Events: [USHORT; 1usize],
}
#[test]
fn bindgen_test_layout__EVENT_FILTER_EVENT_ID() {
    assert_eq!(::core::mem::size_of::<_EVENT_FILTER_EVENT_ID>() , 6usize);
    assert_eq!(::core::mem::align_of::<_EVENT_FILTER_EVENT_ID>() , 2usize);
}
impl Clone for _EVENT_FILTER_EVENT_ID {
    fn clone(&self) -> Self { *self }
}
pub use self::_EVENT_FILTER_EVENT_ID as EVENT_FILTER_EVENT_ID;
pub type PEVENT_FILTER_EVENT_ID = *mut _EVENT_FILTER_EVENT_ID;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _EVENT_FILTER_EVENT_NAME {
    pub MatchAnyKeyword: ULONGLONG,
    pub MatchAllKeyword: ULONGLONG,
    pub Level: UCHAR,
    pub FilterIn: BOOLEAN,
    pub NameCount: USHORT,
    pub Names: [UCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__EVENT_FILTER_EVENT_NAME() {
    assert_eq!(::core::mem::size_of::<_EVENT_FILTER_EVENT_NAME>() , 24usize);
    assert_eq!(::core::mem::align_of::<_EVENT_FILTER_EVENT_NAME>() , 8usize);
}
impl Clone for _EVENT_FILTER_EVENT_NAME {
    fn clone(&self) -> Self { *self }
}
pub use self::_EVENT_FILTER_EVENT_NAME as EVENT_FILTER_EVENT_NAME;
pub type PEVENT_FILTER_EVENT_NAME = *mut _EVENT_FILTER_EVENT_NAME;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _EVENT_INFO_CLASS {
    EventProviderBinaryTrackInfo = 0,
    EventProviderSetEnableAllKeywords = 1,
    EventProviderSetTraits = 2,
    EventProviderUseDescriptorType = 3,
    MaxEventInfo = 4,
}
pub use self::_EVENT_INFO_CLASS as EVENT_INFO_CLASS;
pub type PETWENABLECALLBACK = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn EtwRegister(ProviderId: LPCGUID,
                       EnableCallback: PETWENABLECALLBACK,
                       CallbackContext: PVOID, RegHandle: PREGHANDLE)
     -> NTSTATUS;
}
extern "C" {
    pub fn EtwUnregister(RegHandle: REGHANDLE) -> NTSTATUS;
}
extern "C" {
    pub fn EtwSetInformation(RegHandle: REGHANDLE,
                             InformationClass: EVENT_INFO_CLASS,
                             EventInformation: PVOID,
                             InformationLength: ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn EtwEventEnabled(RegHandle: REGHANDLE,
                           EventDescriptor: PCEVENT_DESCRIPTOR) -> BOOLEAN;
}
extern "C" {
    pub fn EtwProviderEnabled(RegHandle: REGHANDLE, Level: UCHAR,
                              Keyword: ULONGLONG) -> BOOLEAN;
}
extern "C" {
    pub fn EtwActivityIdControl(ControlCode: ULONG, ActivityId: LPGUID)
     -> NTSTATUS;
}
extern "C" {
    pub fn EtwActivityIdControlKernel(ControlCode: ULONG,
                                      ActivityId: *mut LPCGUID) -> NTSTATUS;
}
extern "C" {
    pub fn EtwWrite(RegHandle: REGHANDLE, EventDescriptor: PCEVENT_DESCRIPTOR,
                    ActivityId: LPCGUID, UserDataCount: ULONG,
                    UserData: PEVENT_DATA_DESCRIPTOR) -> NTSTATUS;
}
extern "C" {
    pub fn EtwWriteTransfer(RegHandle: REGHANDLE,
                            EventDescriptor: PCEVENT_DESCRIPTOR,
                            ActivityId: LPCGUID, RelatedActivityId: LPCGUID,
                            UserDataCount: ULONG,
                            UserData: PEVENT_DATA_DESCRIPTOR) -> NTSTATUS;
}
extern "C" {
    pub fn EtwWriteString(RegHandle: REGHANDLE, Level: UCHAR,
                          Keyword: ULONGLONG, ActivityId: LPCGUID,
                          String: PCWSTR) -> NTSTATUS;
}
extern "C" {
    pub fn EtwWriteEx(RegHandle: REGHANDLE,
                      EventDescriptor: PCEVENT_DESCRIPTOR, Filter: ULONG64,
                      Flags: ULONG, ActivityId: LPCGUID,
                      RelatedActivityId: LPCGUID, UserDataCount: ULONG,
                      UserData: PEVENT_DATA_DESCRIPTOR) -> NTSTATUS;
}
extern "C" {
    pub fn SeEtwWriteKMCveEvent(CveId: PCUNICODE_STRING,
                                AdditionalDetails: PCUNICODE_STRING)
     -> NTSTATUS;
}
pub const DevicePropertyDeviceDescription: _bindgen_ty_15 =
    _bindgen_ty_15::DevicePropertyDeviceDescription;
pub const DevicePropertyHardwareID: _bindgen_ty_15 =
    _bindgen_ty_15::DevicePropertyHardwareID;
pub const DevicePropertyCompatibleIDs: _bindgen_ty_15 =
    _bindgen_ty_15::DevicePropertyCompatibleIDs;
pub const DevicePropertyBootConfiguration: _bindgen_ty_15 =
    _bindgen_ty_15::DevicePropertyBootConfiguration;
pub const DevicePropertyBootConfigurationTranslated: _bindgen_ty_15 =
    _bindgen_ty_15::DevicePropertyBootConfigurationTranslated;
pub const DevicePropertyClassName: _bindgen_ty_15 =
    _bindgen_ty_15::DevicePropertyClassName;
pub const DevicePropertyClassGuid: _bindgen_ty_15 =
    _bindgen_ty_15::DevicePropertyClassGuid;
pub const DevicePropertyDriverKeyName: _bindgen_ty_15 =
    _bindgen_ty_15::DevicePropertyDriverKeyName;
pub const DevicePropertyManufacturer: _bindgen_ty_15 =
    _bindgen_ty_15::DevicePropertyManufacturer;
pub const DevicePropertyFriendlyName: _bindgen_ty_15 =
    _bindgen_ty_15::DevicePropertyFriendlyName;
pub const DevicePropertyLocationInformation: _bindgen_ty_15 =
    _bindgen_ty_15::DevicePropertyLocationInformation;
pub const DevicePropertyPhysicalDeviceObjectName: _bindgen_ty_15 =
    _bindgen_ty_15::DevicePropertyPhysicalDeviceObjectName;
pub const DevicePropertyBusTypeGuid: _bindgen_ty_15 =
    _bindgen_ty_15::DevicePropertyBusTypeGuid;
pub const DevicePropertyLegacyBusType: _bindgen_ty_15 =
    _bindgen_ty_15::DevicePropertyLegacyBusType;
pub const DevicePropertyBusNumber: _bindgen_ty_15 =
    _bindgen_ty_15::DevicePropertyBusNumber;
pub const DevicePropertyEnumeratorName: _bindgen_ty_15 =
    _bindgen_ty_15::DevicePropertyEnumeratorName;
pub const DevicePropertyAddress: _bindgen_ty_15 =
    _bindgen_ty_15::DevicePropertyAddress;
pub const DevicePropertyUINumber: _bindgen_ty_15 =
    _bindgen_ty_15::DevicePropertyUINumber;
pub const DevicePropertyInstallState: _bindgen_ty_15 =
    _bindgen_ty_15::DevicePropertyInstallState;
pub const DevicePropertyRemovalPolicy: _bindgen_ty_15 =
    _bindgen_ty_15::DevicePropertyRemovalPolicy;
pub const DevicePropertyResourceRequirements: _bindgen_ty_15 =
    _bindgen_ty_15::DevicePropertyResourceRequirements;
pub const DevicePropertyAllocatedResources: _bindgen_ty_15 =
    _bindgen_ty_15::DevicePropertyAllocatedResources;
pub const DevicePropertyContainerID: _bindgen_ty_15 =
    _bindgen_ty_15::DevicePropertyContainerID;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_15 {
    DevicePropertyDeviceDescription = 0,
    DevicePropertyHardwareID = 1,
    DevicePropertyCompatibleIDs = 2,
    DevicePropertyBootConfiguration = 3,
    DevicePropertyBootConfigurationTranslated = 4,
    DevicePropertyClassName = 5,
    DevicePropertyClassGuid = 6,
    DevicePropertyDriverKeyName = 7,
    DevicePropertyManufacturer = 8,
    DevicePropertyFriendlyName = 9,
    DevicePropertyLocationInformation = 10,
    DevicePropertyPhysicalDeviceObjectName = 11,
    DevicePropertyBusTypeGuid = 12,
    DevicePropertyLegacyBusType = 13,
    DevicePropertyBusNumber = 14,
    DevicePropertyEnumeratorName = 15,
    DevicePropertyAddress = 16,
    DevicePropertyUINumber = 17,
    DevicePropertyInstallState = 18,
    DevicePropertyRemovalPolicy = 19,
    DevicePropertyResourceRequirements = 20,
    DevicePropertyAllocatedResources = 21,
    DevicePropertyContainerID = 22,
}
pub use self::_bindgen_ty_15 as DEVICE_REGISTRY_PROPERTY;
pub type TRANSLATE_BUS_ADDRESS =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                BusAddress: PHYSICAL_ADDRESS,
                                                Length: ULONG,
                                                AddressSpace: PULONG,
                                                TranslatedAddress:
                                                    PPHYSICAL_ADDRESS)
                               -> BOOLEAN>;
pub type PTRANSLATE_BUS_ADDRESS = TRANSLATE_BUS_ADDRESS;
pub type GET_DMA_ADAPTER =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                DeviceDescriptor:
                                                    *mut _DEVICE_DESCRIPTION,
                                                NumberOfMapRegisters: PULONG)
                               -> *mut _DMA_ADAPTER>;
pub type PGET_DMA_ADAPTER = GET_DMA_ADAPTER;
pub type GET_SET_DEVICE_DATA =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                DataType: ULONG,
                                                Buffer: PVOID, Offset: ULONG,
                                                Length: ULONG) -> ULONG>;
pub type PGET_SET_DEVICE_DATA = GET_SET_DEVICE_DATA;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _DEVICE_INSTALL_STATE {
    InstallStateInstalled = 0,
    InstallStateNeedsReinstall = 1,
    InstallStateFailedInstall = 2,
    InstallStateFinishInstall = 3,
}
pub use self::_DEVICE_INSTALL_STATE as DEVICE_INSTALL_STATE;
pub type PDEVICE_INSTALL_STATE = *mut _DEVICE_INSTALL_STATE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PNP_BUS_INFORMATION {
    pub BusTypeGuid: GUID,
    pub LegacyBusType: INTERFACE_TYPE,
    pub BusNumber: ULONG,
}
#[test]
fn bindgen_test_layout__PNP_BUS_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_PNP_BUS_INFORMATION>() , 24usize);
    assert_eq!(::core::mem::align_of::<_PNP_BUS_INFORMATION>() , 4usize);
}
impl Clone for _PNP_BUS_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_PNP_BUS_INFORMATION as PNP_BUS_INFORMATION;
pub type PPNP_BUS_INFORMATION = *mut _PNP_BUS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _LEGACY_BUS_INFORMATION {
    pub BusTypeGuid: GUID,
    pub LegacyBusType: INTERFACE_TYPE,
    pub BusNumber: ULONG,
}
#[test]
fn bindgen_test_layout__LEGACY_BUS_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_LEGACY_BUS_INFORMATION>() , 24usize);
    assert_eq!(::core::mem::align_of::<_LEGACY_BUS_INFORMATION>() , 4usize);
}
impl Clone for _LEGACY_BUS_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_LEGACY_BUS_INFORMATION as LEGACY_BUS_INFORMATION;
pub type PLEGACY_BUS_INFORMATION = *mut _LEGACY_BUS_INFORMATION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _DEVICE_REMOVAL_POLICY {
    RemovalPolicyExpectNoRemoval = 1,
    RemovalPolicyExpectOrderlyRemoval = 2,
    RemovalPolicyExpectSurpriseRemoval = 3,
}
pub use self::_DEVICE_REMOVAL_POLICY as DEVICE_REMOVAL_POLICY;
pub type PDEVICE_REMOVAL_POLICY = *mut _DEVICE_REMOVAL_POLICY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _BUS_INTERFACE_STANDARD {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub TranslateBusAddress: PTRANSLATE_BUS_ADDRESS,
    pub GetDmaAdapter: PGET_DMA_ADAPTER,
    pub SetBusData: PGET_SET_DEVICE_DATA,
    pub GetBusData: PGET_SET_DEVICE_DATA,
}
#[test]
fn bindgen_test_layout__BUS_INTERFACE_STANDARD() {
    assert_eq!(::core::mem::size_of::<_BUS_INTERFACE_STANDARD>() , 64usize);
    assert_eq!(::core::mem::align_of::<_BUS_INTERFACE_STANDARD>() , 8usize);
}
impl Clone for _BUS_INTERFACE_STANDARD {
    fn clone(&self) -> Self { *self }
}
pub use self::_BUS_INTERFACE_STANDARD as BUS_INTERFACE_STANDARD;
pub type PBUS_INTERFACE_STANDARD = *mut _BUS_INTERFACE_STANDARD;
pub type GET_VIRTUAL_DEVICE_DATA =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                VirtualFunction: USHORT,
                                                Buffer: PVOID, Offset: ULONG,
                                                Length: ULONG) -> ULONG>;
pub type PGET_VIRTUAL_DEVICE_DATA = GET_VIRTUAL_DEVICE_DATA;
pub type SET_VIRTUAL_DEVICE_DATA =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                VirtualFunction: USHORT,
                                                Buffer: PVOID, Offset: ULONG,
                                                Length: ULONG) -> ULONG>;
pub type PSET_VIRTUAL_DEVICE_DATA = SET_VIRTUAL_DEVICE_DATA;
pub type GET_VIRTUAL_DEVICE_LOCATION =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                VirtualFunction: USHORT,
                                                SegmentNumber: PUINT16,
                                                BusNumber: PUINT8,
                                                FunctionNumber: PUINT8)
                               -> NTSTATUS>;
pub type PGET_VIRTUAL_DEVICE_LOCATION = GET_VIRTUAL_DEVICE_LOCATION;
pub type GET_VIRTUAL_DEVICE_RESOURCES =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                CapturedBusNumbers: PUINT8)>;
pub type PGET_VIRTUAL_DEVICE_RESOURCES = GET_VIRTUAL_DEVICE_RESOURCES;
pub type ENABLE_VIRTUALIZATION =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                NumVFs: UINT16,
                                                EnableVfMigration: BOOLEAN,
                                                EnableMigrationInterrupt:
                                                    BOOLEAN,
                                                EnableVirtualization: BOOLEAN)
                               -> NTSTATUS>;
pub type PENABLE_VIRTUALIZATION = ENABLE_VIRTUALIZATION;
pub type GET_VIRTUAL_FUNCTION_PROBED_BARS =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                BaseRegisterValues: PULONG)
                               -> NTSTATUS>;
pub type PGET_VIRTUAL_FUNCTION_PROBED_BARS = GET_VIRTUAL_FUNCTION_PROBED_BARS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_VIRTUALIZATION_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub SetVirtualFunctionData: PSET_VIRTUAL_DEVICE_DATA,
    pub GetVirtualFunctionData: PGET_VIRTUAL_DEVICE_DATA,
    pub GetLocation: PGET_VIRTUAL_DEVICE_LOCATION,
    pub GetResources: PGET_VIRTUAL_DEVICE_RESOURCES,
    pub EnableVirtualization: PENABLE_VIRTUALIZATION,
    pub GetVirtualFunctionProbedBars: PGET_VIRTUAL_FUNCTION_PROBED_BARS,
}
#[test]
fn bindgen_test_layout__PCI_VIRTUALIZATION_INTERFACE() {
    assert_eq!(::core::mem::size_of::<_PCI_VIRTUALIZATION_INTERFACE>() ,
               80usize);
    assert_eq!(::core::mem::align_of::<_PCI_VIRTUALIZATION_INTERFACE>() ,
               8usize);
}
impl Clone for _PCI_VIRTUALIZATION_INTERFACE {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_VIRTUALIZATION_INTERFACE as PCI_VIRTUALIZATION_INTERFACE;
pub type PPCI_VIRTUALIZATION_INTERFACE = *mut _PCI_VIRTUALIZATION_INTERFACE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _PCI_ACS_BIT {
    PciAcsReserved = 0,
    PciAcsBitEnable = 1,
    PciAcsBitDisable = 2,
    PciAcsBitDontCare = 3,
}
pub use self::_PCI_ACS_BIT as PCI_ACS_BIT;
pub type PPCI_ACS_BIT = *mut _PCI_ACS_BIT;
pub type PCI_SET_ACS =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                EnableSourceValidation:
                                                    PCI_ACS_BIT,
                                                EnableTranslationBlocking:
                                                    PCI_ACS_BIT,
                                                EnableP2PRequestRedirect:
                                                    PCI_ACS_BIT,
                                                EnableCompletionRedirect:
                                                    PCI_ACS_BIT,
                                                EnableUpstreamForwarding:
                                                    PCI_ACS_BIT,
                                                EnableEgressControl:
                                                    PCI_ACS_BIT,
                                                EnableDirectTranslatedP2P:
                                                    PCI_ACS_BIT) -> NTSTATUS>;
pub type PPCI_SET_ACS = PCI_SET_ACS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_SECURITY_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub SetAccessControlServices: PPCI_SET_ACS,
}
#[test]
fn bindgen_test_layout__PCI_SECURITY_INTERFACE() {
    assert_eq!(::core::mem::size_of::<_PCI_SECURITY_INTERFACE>() , 40usize);
    assert_eq!(::core::mem::align_of::<_PCI_SECURITY_INTERFACE>() , 8usize);
}
impl Clone for _PCI_SECURITY_INTERFACE {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_SECURITY_INTERFACE as PCI_SECURITY_INTERFACE;
pub type PPCI_SECURITY_INTERFACE = *mut _PCI_SECURITY_INTERFACE;
pub type PREENUMERATE_SELF =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _REENUMERATE_SELF_INTERFACE_STANDARD {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub SurpriseRemoveAndReenumerateSelf: PREENUMERATE_SELF,
}
#[test]
fn bindgen_test_layout__REENUMERATE_SELF_INTERFACE_STANDARD() {
    assert_eq!(::core::mem::size_of::<_REENUMERATE_SELF_INTERFACE_STANDARD>()
               , 40usize);
    assert_eq!(::core::mem::align_of::<_REENUMERATE_SELF_INTERFACE_STANDARD>()
               , 8usize);
}
impl Clone for _REENUMERATE_SELF_INTERFACE_STANDARD {
    fn clone(&self) -> Self { *self }
}
pub use self::_REENUMERATE_SELF_INTERFACE_STANDARD as
        REENUMERATE_SELF_INTERFACE_STANDARD;
pub type PREENUMERATE_SELF_INTERFACE_STANDARD =
    *mut _REENUMERATE_SELF_INTERFACE_STANDARD;
pub type SET_D3COLD_SUPPORT =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                D3ColdSupport: BOOLEAN)>;
pub type PSET_D3COLD_SUPPORT = SET_D3COLD_SUPPORT;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _DEVICE_WAKE_DEPTH {
    DeviceWakeDepthNotWakeable = 0,
    DeviceWakeDepthD0 = 1,
    DeviceWakeDepthD1 = 2,
    DeviceWakeDepthD2 = 3,
    DeviceWakeDepthD3hot = 4,
    DeviceWakeDepthD3cold = 5,
    DeviceWakeDepthMaximum = 6,
}
pub use self::_DEVICE_WAKE_DEPTH as DEVICE_WAKE_DEPTH;
pub type PDEVICE_WAKE_DEPTH = *mut _DEVICE_WAKE_DEPTH;
pub type GET_IDLE_WAKE_INFO =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                SystemPowerState:
                                                    SYSTEM_POWER_STATE,
                                                DeepestWakeableDstate:
                                                    PDEVICE_WAKE_DEPTH)
                               -> NTSTATUS>;
pub type PGET_IDLE_WAKE_INFO = GET_IDLE_WAKE_INFO;
pub type GET_D3COLD_CAPABILITY =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                D3ColdSupported: PBOOLEAN)
                               -> NTSTATUS>;
pub type PGET_D3COLD_CAPABILITY = GET_D3COLD_CAPABILITY;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _D3COLD_LAST_TRANSITION_STATUS {
    LastDStateTransitionStatusUnknown = 0,
    LastDStateTransitionD3hot = 1,
    LastDStateTransitionD3cold = 2,
}
pub use self::_D3COLD_LAST_TRANSITION_STATUS as D3COLD_LAST_TRANSITION_STATUS;
pub type PD3COLD_LAST_TRANSITION_STATUS = *mut _D3COLD_LAST_TRANSITION_STATUS;
pub type GET_D3COLD_LAST_TRANSITION_STATUS =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                LastTransitionStatus:
                                                    PD3COLD_LAST_TRANSITION_STATUS)>;
pub type PGET_D3COLD_LAST_TRANSITION_STATUS =
    GET_D3COLD_LAST_TRANSITION_STATUS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _D3COLD_SUPPORT_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub SetD3ColdSupport: PSET_D3COLD_SUPPORT,
    pub GetIdleWakeInfo: PGET_IDLE_WAKE_INFO,
    pub GetD3ColdCapability: PGET_D3COLD_CAPABILITY,
    pub GetBusDriverD3ColdSupport: PGET_D3COLD_CAPABILITY,
    pub GetLastTransitionStatus: PGET_D3COLD_LAST_TRANSITION_STATUS,
}
#[test]
fn bindgen_test_layout__D3COLD_SUPPORT_INTERFACE() {
    assert_eq!(::core::mem::size_of::<_D3COLD_SUPPORT_INTERFACE>() , 72usize);
    assert_eq!(::core::mem::align_of::<_D3COLD_SUPPORT_INTERFACE>() , 8usize);
}
impl Clone for _D3COLD_SUPPORT_INTERFACE {
    fn clone(&self) -> Self { *self }
}
pub use self::_D3COLD_SUPPORT_INTERFACE as D3COLD_SUPPORT_INTERFACE;
pub type PD3COLD_SUPPORT_INTERFACE = *mut _D3COLD_SUPPORT_INTERFACE;
pub type PGPE_SERVICE_ROUTINE =
    ::core::option::Option<unsafe extern "C" fn(arg1: PVOID, arg2: PVOID)
                               -> libc::c_uchar>;
pub type PGPE_CONNECT_VECTOR =
    ::core::option::Option<unsafe extern "C" fn(arg1: PDEVICE_OBJECT,
                                                arg2: ULONG,
                                                arg3: KINTERRUPT_MODE,
                                                arg4: BOOLEAN,
                                                arg5: PGPE_SERVICE_ROUTINE,
                                                arg6: PVOID, arg7: PVOID)
                               -> libc::c_long>;
pub type PGPE_DISCONNECT_VECTOR =
    ::core::option::Option<unsafe extern "C" fn(arg1: PVOID) -> libc::c_long>;
pub type PGPE_ENABLE_EVENT =
    ::core::option::Option<unsafe extern "C" fn(arg1: PDEVICE_OBJECT,
                                                arg2: PVOID) -> libc::c_long>;
pub type PGPE_DISABLE_EVENT =
    ::core::option::Option<unsafe extern "C" fn(arg1: PDEVICE_OBJECT,
                                                arg2: PVOID) -> libc::c_long>;
pub type PGPE_CLEAR_STATUS =
    ::core::option::Option<unsafe extern "C" fn(arg1: PDEVICE_OBJECT,
                                                arg2: PVOID) -> libc::c_long>;
pub type PDEVICE_NOTIFY_CALLBACK =
    ::core::option::Option<unsafe extern "C" fn(arg1: PVOID, arg2: ULONG)>;
pub type PREGISTER_FOR_DEVICE_NOTIFICATIONS =
    ::core::option::Option<unsafe extern "C" fn(arg1: PDEVICE_OBJECT,
                                                arg2: PDEVICE_NOTIFY_CALLBACK,
                                                arg3: PVOID) -> libc::c_long>;
pub type PUNREGISTER_FOR_DEVICE_NOTIFICATIONS =
    ::core::option::Option<unsafe extern "C" fn(arg1: PDEVICE_OBJECT,
                                                arg2:
                                                    PDEVICE_NOTIFY_CALLBACK)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _ACPI_INTERFACE_STANDARD {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub GpeConnectVector: PGPE_CONNECT_VECTOR,
    pub GpeDisconnectVector: PGPE_DISCONNECT_VECTOR,
    pub GpeEnableEvent: PGPE_ENABLE_EVENT,
    pub GpeDisableEvent: PGPE_DISABLE_EVENT,
    pub GpeClearStatus: PGPE_CLEAR_STATUS,
    pub RegisterForDeviceNotifications: PREGISTER_FOR_DEVICE_NOTIFICATIONS,
    pub UnregisterForDeviceNotifications: PUNREGISTER_FOR_DEVICE_NOTIFICATIONS,
}
#[test]
fn bindgen_test_layout__ACPI_INTERFACE_STANDARD() {
    assert_eq!(::core::mem::size_of::<_ACPI_INTERFACE_STANDARD>() , 88usize);
    assert_eq!(::core::mem::align_of::<_ACPI_INTERFACE_STANDARD>() , 8usize);
}
impl Clone for _ACPI_INTERFACE_STANDARD {
    fn clone(&self) -> Self { *self }
}
pub use self::_ACPI_INTERFACE_STANDARD as ACPI_INTERFACE_STANDARD;
pub type PACPI_INTERFACE_STANDARD = *mut _ACPI_INTERFACE_STANDARD;
pub type PGPE_SERVICE_ROUTINE2 =
    ::core::option::Option<unsafe extern "C" fn(ObjectContext: PVOID,
                                                ServiceContext: PVOID)
                               -> libc::c_uchar>;
pub type PGPE_CONNECT_VECTOR2 =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                GpeNumber: ULONG,
                                                Mode: KINTERRUPT_MODE,
                                                Shareable: BOOLEAN,
                                                ServiceRoutine:
                                                    PGPE_SERVICE_ROUTINE,
                                                ServiceContext: PVOID,
                                                ObjectContext: *mut PVOID)
                               -> libc::c_long>;
pub type PGPE_DISCONNECT_VECTOR2 =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                ObjectContext: PVOID)
                               -> libc::c_long>;
pub type PGPE_ENABLE_EVENT2 =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                ObjectContext: PVOID)
                               -> libc::c_long>;
pub type PGPE_DISABLE_EVENT2 =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                ObjectContext: PVOID)
                               -> libc::c_long>;
pub type PGPE_CLEAR_STATUS2 =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                ObjectContext: PVOID)
                               -> libc::c_long>;
pub type PDEVICE_NOTIFY_CALLBACK2 =
    ::core::option::Option<unsafe extern "C" fn(NotificationContext: PVOID,
                                                NotifyCode: ULONG)>;
pub type PREGISTER_FOR_DEVICE_NOTIFICATIONS2 =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                NotificationHandler:
                                                    PDEVICE_NOTIFY_CALLBACK2,
                                                NotificationContext: PVOID)
                               -> libc::c_long>;
pub type PUNREGISTER_FOR_DEVICE_NOTIFICATIONS2 =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_16 {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub GpeConnectVector: PGPE_CONNECT_VECTOR2,
    pub GpeDisconnectVector: PGPE_DISCONNECT_VECTOR2,
    pub GpeEnableEvent: PGPE_ENABLE_EVENT2,
    pub GpeDisableEvent: PGPE_DISABLE_EVENT2,
    pub GpeClearStatus: PGPE_CLEAR_STATUS2,
    pub RegisterForDeviceNotifications: PREGISTER_FOR_DEVICE_NOTIFICATIONS2,
    pub UnregisterForDeviceNotifications: PUNREGISTER_FOR_DEVICE_NOTIFICATIONS2,
}
#[test]
fn bindgen_test_layout__bindgen_ty_16() {
    assert_eq!(::core::mem::size_of::<_bindgen_ty_16>() , 88usize);
    assert_eq!(::core::mem::align_of::<_bindgen_ty_16>() , 8usize);
}
impl Clone for _bindgen_ty_16 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_16 as ACPI_INTERFACE_STANDARD2;
pub type PACPI_INTERFACE_STANDARD2 = *mut _bindgen_ty_16;
extern "C" {
    pub fn IoInvalidateDeviceRelations(DeviceObject: PDEVICE_OBJECT,
                                       Type: DEVICE_RELATION_TYPE);
}
extern "C" {
    pub fn IoRequestDeviceEject(PhysicalDeviceObject: PDEVICE_OBJECT);
}
pub type PIO_DEVICE_EJECT_CALLBACK =
    ::core::option::Option<unsafe extern "C" fn(Status: NTSTATUS,
                                                Context: PVOID)>;
extern "C" {
    pub fn IoRequestDeviceEjectEx(PhysicalDeviceObject: PDEVICE_OBJECT,
                                  Callback: PIO_DEVICE_EJECT_CALLBACK,
                                  Context: PVOID,
                                  DriverObject: PDRIVER_OBJECT) -> NTSTATUS;
}
extern "C" {
    pub fn IoGetDeviceProperty(DeviceObject: PDEVICE_OBJECT,
                               DeviceProperty: DEVICE_REGISTRY_PROPERTY,
                               BufferLength: ULONG, PropertyBuffer: PVOID,
                               ResultLength: PULONG) -> NTSTATUS;
}
extern "C" {
    pub fn IoOpenDeviceRegistryKey(DeviceObject: PDEVICE_OBJECT,
                                   DevInstKeyType: ULONG,
                                   DesiredAccess: ACCESS_MASK,
                                   DevInstRegKey: PHANDLE) -> NTSTATUS;
}
extern "C" {
    pub fn IoRegisterDeviceInterface(PhysicalDeviceObject: PDEVICE_OBJECT,
                                     InterfaceClassGuid: *const GUID,
                                     ReferenceString: PUNICODE_STRING,
                                     SymbolicLinkName: PUNICODE_STRING)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoOpenDeviceInterfaceRegistryKey(SymbolicLinkName: PUNICODE_STRING,
                                            DesiredAccess: ACCESS_MASK,
                                            DeviceInterfaceKey: PHANDLE)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoSetDeviceInterfaceState(SymbolicLinkName: PUNICODE_STRING,
                                     Enable: BOOLEAN) -> NTSTATUS;
}
extern "C" {
    pub fn IoGetDeviceInterfaces(InterfaceClassGuid: *const GUID,
                                 PhysicalDeviceObject: PDEVICE_OBJECT,
                                 Flags: ULONG, SymbolicLinkList: *mut PZZWSTR)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoGetDeviceInterfaceAlias(SymbolicLinkName: PUNICODE_STRING,
                                     AliasInterfaceClassGuid: *const GUID,
                                     AliasSymbolicLinkName: PUNICODE_STRING)
     -> NTSTATUS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _IO_NOTIFICATION_EVENT_CATEGORY {
    EventCategoryReserved = 0,
    EventCategoryHardwareProfileChange = 1,
    EventCategoryDeviceInterfaceChange = 2,
    EventCategoryTargetDeviceChange = 3,
}
pub use self::_IO_NOTIFICATION_EVENT_CATEGORY as
        IO_NOTIFICATION_EVENT_CATEGORY;
pub type DRIVER_NOTIFICATION_CALLBACK_ROUTINE =
    ::core::option::Option<unsafe extern "C" fn(NotificationStructure: PVOID,
                                                Context: PVOID) -> NTSTATUS>;
pub type PDRIVER_NOTIFICATION_CALLBACK_ROUTINE =
    DRIVER_NOTIFICATION_CALLBACK_ROUTINE;
extern "C" {
    pub fn IoRegisterPlugPlayNotification(EventCategory:
                                              IO_NOTIFICATION_EVENT_CATEGORY,
                                          EventCategoryFlags: ULONG,
                                          EventCategoryData: PVOID,
                                          DriverObject: PDRIVER_OBJECT,
                                          CallbackRoutine:
                                              PDRIVER_NOTIFICATION_CALLBACK_ROUTINE,
                                          Context: PVOID,
                                          NotificationEntry: *mut PVOID)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoUnregisterPlugPlayNotification(NotificationEntry: PVOID)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoUnregisterPlugPlayNotificationEx(NotificationEntry: PVOID)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoReportTargetDeviceChange(PhysicalDeviceObject: PDEVICE_OBJECT,
                                      NotificationStructure: PVOID)
     -> NTSTATUS;
}
pub type DEVICE_CHANGE_COMPLETE_CALLBACK =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID)>;
pub type PDEVICE_CHANGE_COMPLETE_CALLBACK = DEVICE_CHANGE_COMPLETE_CALLBACK;
extern "C" {
    pub fn IoInvalidateDeviceState(PhysicalDeviceObject: PDEVICE_OBJECT);
}
extern "C" {
    pub fn IoReportTargetDeviceChangeAsynchronous(PhysicalDeviceObject:
                                                      PDEVICE_OBJECT,
                                                  NotificationStructure:
                                                      PVOID,
                                                  Callback:
                                                      PDEVICE_CHANGE_COMPLETE_CALLBACK,
                                                  Context: PVOID) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PLUGPLAY_NOTIFICATION_HEADER {
    pub Version: USHORT,
    pub Size: USHORT,
    pub Event: GUID,
}
#[test]
fn bindgen_test_layout__PLUGPLAY_NOTIFICATION_HEADER() {
    assert_eq!(::core::mem::size_of::<_PLUGPLAY_NOTIFICATION_HEADER>() ,
               20usize);
    assert_eq!(::core::mem::align_of::<_PLUGPLAY_NOTIFICATION_HEADER>() ,
               4usize);
}
impl Clone for _PLUGPLAY_NOTIFICATION_HEADER {
    fn clone(&self) -> Self { *self }
}
pub use self::_PLUGPLAY_NOTIFICATION_HEADER as PLUGPLAY_NOTIFICATION_HEADER;
pub type PPLUGPLAY_NOTIFICATION_HEADER = *mut _PLUGPLAY_NOTIFICATION_HEADER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _HWPROFILE_CHANGE_NOTIFICATION {
    pub Version: USHORT,
    pub Size: USHORT,
    pub Event: GUID,
}
#[test]
fn bindgen_test_layout__HWPROFILE_CHANGE_NOTIFICATION() {
    assert_eq!(::core::mem::size_of::<_HWPROFILE_CHANGE_NOTIFICATION>() ,
               20usize);
    assert_eq!(::core::mem::align_of::<_HWPROFILE_CHANGE_NOTIFICATION>() ,
               4usize);
}
impl Clone for _HWPROFILE_CHANGE_NOTIFICATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_HWPROFILE_CHANGE_NOTIFICATION as HWPROFILE_CHANGE_NOTIFICATION;
pub type PHWPROFILE_CHANGE_NOTIFICATION = *mut _HWPROFILE_CHANGE_NOTIFICATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DEVICE_INTERFACE_CHANGE_NOTIFICATION {
    pub Version: USHORT,
    pub Size: USHORT,
    pub Event: GUID,
    pub InterfaceClassGuid: GUID,
    pub SymbolicLinkName: PUNICODE_STRING,
}
#[test]
fn bindgen_test_layout__DEVICE_INTERFACE_CHANGE_NOTIFICATION() {
    assert_eq!(::core::mem::size_of::<_DEVICE_INTERFACE_CHANGE_NOTIFICATION>()
               , 48usize);
    assert_eq!(::core::mem::align_of::<_DEVICE_INTERFACE_CHANGE_NOTIFICATION>()
               , 8usize);
}
impl Clone for _DEVICE_INTERFACE_CHANGE_NOTIFICATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_DEVICE_INTERFACE_CHANGE_NOTIFICATION as
        DEVICE_INTERFACE_CHANGE_NOTIFICATION;
pub type PDEVICE_INTERFACE_CHANGE_NOTIFICATION =
    *mut _DEVICE_INTERFACE_CHANGE_NOTIFICATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _TARGET_DEVICE_REMOVAL_NOTIFICATION {
    pub Version: USHORT,
    pub Size: USHORT,
    pub Event: GUID,
    pub FileObject: PFILE_OBJECT,
}
#[test]
fn bindgen_test_layout__TARGET_DEVICE_REMOVAL_NOTIFICATION() {
    assert_eq!(::core::mem::size_of::<_TARGET_DEVICE_REMOVAL_NOTIFICATION>() ,
               32usize);
    assert_eq!(::core::mem::align_of::<_TARGET_DEVICE_REMOVAL_NOTIFICATION>()
               , 8usize);
}
impl Clone for _TARGET_DEVICE_REMOVAL_NOTIFICATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_TARGET_DEVICE_REMOVAL_NOTIFICATION as
        TARGET_DEVICE_REMOVAL_NOTIFICATION;
pub type PTARGET_DEVICE_REMOVAL_NOTIFICATION =
    *mut _TARGET_DEVICE_REMOVAL_NOTIFICATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _TARGET_DEVICE_CUSTOM_NOTIFICATION {
    pub Version: USHORT,
    pub Size: USHORT,
    pub Event: GUID,
    pub FileObject: PFILE_OBJECT,
    pub NameBufferOffset: LONG,
    pub CustomDataBuffer: [UCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__TARGET_DEVICE_CUSTOM_NOTIFICATION() {
    assert_eq!(::core::mem::size_of::<_TARGET_DEVICE_CUSTOM_NOTIFICATION>() ,
               40usize);
    assert_eq!(::core::mem::align_of::<_TARGET_DEVICE_CUSTOM_NOTIFICATION>() ,
               8usize);
}
impl Clone for _TARGET_DEVICE_CUSTOM_NOTIFICATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_TARGET_DEVICE_CUSTOM_NOTIFICATION as
        TARGET_DEVICE_CUSTOM_NOTIFICATION;
pub type PTARGET_DEVICE_CUSTOM_NOTIFICATION =
    *mut _TARGET_DEVICE_CUSTOM_NOTIFICATION;
pub type DEVPROPTYPE = ULONG;
pub type PDEVPROPTYPE = *mut ULONG;
pub type DEVPROP_BOOLEAN = CHAR;
pub type PDEVPROP_BOOLEAN = *mut CHAR;
pub use self::GUID as DEVPROPGUID;
pub type PDEVPROPGUID = *mut GUID;
pub type DEVPROPID = ULONG;
pub type PDEVPROPID = *mut ULONG;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DEVPROPKEY {
    pub fmtid: DEVPROPGUID,
    pub pid: DEVPROPID,
}
#[test]
fn bindgen_test_layout__DEVPROPKEY() {
    assert_eq!(::core::mem::size_of::<_DEVPROPKEY>() , 20usize);
    assert_eq!(::core::mem::align_of::<_DEVPROPKEY>() , 4usize);
}
impl Clone for _DEVPROPKEY {
    fn clone(&self) -> Self { *self }
}
pub use self::_DEVPROPKEY as DEVPROPKEY;
pub type PDEVPROPKEY = *mut _DEVPROPKEY;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _DEVPROPSTORE { DEVPROP_STORE_SYSTEM = 0, DEVPROP_STORE_USER = 1, }
pub use self::_DEVPROPSTORE as DEVPROPSTORE;
pub type PDEVPROPSTORE = *mut _DEVPROPSTORE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DEVPROPCOMPKEY {
    pub Key: DEVPROPKEY,
    pub Store: DEVPROPSTORE,
    pub LocaleName: PCWSTR,
}
#[test]
fn bindgen_test_layout__DEVPROPCOMPKEY() {
    assert_eq!(::core::mem::size_of::<_DEVPROPCOMPKEY>() , 32usize);
    assert_eq!(::core::mem::align_of::<_DEVPROPCOMPKEY>() , 8usize);
}
impl Clone for _DEVPROPCOMPKEY {
    fn clone(&self) -> Self { *self }
}
pub use self::_DEVPROPCOMPKEY as DEVPROPCOMPKEY;
pub type PDEVPROPCOMPKEY = *mut _DEVPROPCOMPKEY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DEVPROPERTY {
    pub CompKey: DEVPROPCOMPKEY,
    pub Type: DEVPROPTYPE,
    pub BufferSize: ULONG,
    pub Buffer: PVOID,
}
#[test]
fn bindgen_test_layout__DEVPROPERTY() {
    assert_eq!(::core::mem::size_of::<_DEVPROPERTY>() , 48usize);
    assert_eq!(::core::mem::align_of::<_DEVPROPERTY>() , 8usize);
}
impl Clone for _DEVPROPERTY {
    fn clone(&self) -> Self { *self }
}
pub use self::_DEVPROPERTY as DEVPROPERTY;
pub type PDEVPROPERTY = *mut _DEVPROPERTY;
extern "C" {
    pub fn IoSetDevicePropertyData(Pdo: PDEVICE_OBJECT,
                                   PropertyKey: *const DEVPROPKEY, Lcid: LCID,
                                   Flags: ULONG, Type: DEVPROPTYPE,
                                   Size: ULONG, Data: PVOID) -> NTSTATUS;
}
extern "C" {
    pub fn IoGetDevicePropertyData(Pdo: PDEVICE_OBJECT,
                                   PropertyKey: *const DEVPROPKEY, Lcid: LCID,
                                   Flags: ULONG, Size: ULONG, Data: PVOID,
                                   RequiredSize: PULONG, Type: PDEVPROPTYPE)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoSetDeviceInterfacePropertyData(SymbolicLinkName: PUNICODE_STRING,
                                            PropertyKey: *const DEVPROPKEY,
                                            Lcid: LCID, Flags: ULONG,
                                            Type: DEVPROPTYPE, Size: ULONG,
                                            Data: PVOID) -> NTSTATUS;
}
extern "C" {
    pub fn IoGetDeviceInterfacePropertyData(SymbolicLinkName: PUNICODE_STRING,
                                            PropertyKey: *const DEVPROPKEY,
                                            Lcid: LCID, Flags: ULONG,
                                            Size: ULONG, Data: PVOID,
                                            RequiredSize: PULONG,
                                            Type: PDEVPROPTYPE) -> NTSTATUS;
}
extern "C" {
    pub fn IoGetDeviceNumaNode(Pdo: PDEVICE_OBJECT, NodeNumber: PUSHORT)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoReplacePartitionUnit(TargetPdo: PDEVICE_OBJECT,
                                  SparePdo: PDEVICE_OBJECT, Flags: ULONG)
     -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PNP_REPLACE_DRIVER_INTERFACE {
    pub Size: ULONG,
    pub Version: ULONG,
    pub Flags: ULONG,
    pub Unload: PREPLACE_UNLOAD,
    pub BeginReplace: PREPLACE_BEGIN,
    pub EndReplace: PREPLACE_END,
    pub MirrorPhysicalMemory: PREPLACE_MIRROR_PHYSICAL_MEMORY,
    pub SetProcessorId: PREPLACE_SET_PROCESSOR_ID,
    pub Swap: PREPLACE_SWAP,
    pub InitiateHardwareMirror: PREPLACE_INITIATE_HARDWARE_MIRROR,
    pub MirrorPlatformMemory: PREPLACE_MIRROR_PLATFORM_MEMORY,
    pub GetMemoryDestination: PREPLACE_GET_MEMORY_DESTINATION,
    pub EnableDisableHardwareQuiesce: PREPLACE_ENABLE_DISABLE_HARDWARE_QUIESCE,
}
#[test]
fn bindgen_test_layout__PNP_REPLACE_DRIVER_INTERFACE() {
    assert_eq!(::core::mem::size_of::<_PNP_REPLACE_DRIVER_INTERFACE>() ,
               96usize);
    assert_eq!(::core::mem::align_of::<_PNP_REPLACE_DRIVER_INTERFACE>() ,
               8usize);
}
impl Clone for _PNP_REPLACE_DRIVER_INTERFACE {
    fn clone(&self) -> Self { *self }
}
pub type PPNP_REPLACE_DRIVER_INTERFACE = *mut _PNP_REPLACE_DRIVER_INTERFACE;
pub type PREPLACE_DRIVER_INIT =
    ::core::option::Option<unsafe extern "C" fn(Interface:
                                                    PPNP_REPLACE_DRIVER_INTERFACE,
                                                Unused: PVOID)
                               -> libc::c_long>;
pub type PREPLACE_MAP_MEMORY =
    ::core::option::Option<unsafe extern "C" fn(TargetPhysicalAddress:
                                                    PHYSICAL_ADDRESS,
                                                SparePhysicalAddress:
                                                    PHYSICAL_ADDRESS,
                                                NumberOfBytes: PLARGE_INTEGER,
                                                TargetAddress: *mut PVOID,
                                                SpareAddress: *mut PVOID)
                               -> libc::c_long>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PNP_REPLACE_MEMORY_LIST {
    pub AllocatedCount: ULONG,
    pub Count: ULONG,
    pub TotalLength: ULONGLONG,
    pub Ranges: [_PNP_REPLACE_MEMORY_LIST__bindgen_ty_1; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PNP_REPLACE_MEMORY_LIST__bindgen_ty_1 {
    pub Address: PHYSICAL_ADDRESS,
    pub Length: ULONGLONG,
}
#[test]
fn bindgen_test_layout__PNP_REPLACE_MEMORY_LIST__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PNP_REPLACE_MEMORY_LIST__bindgen_ty_1>()
               , 16usize);
    assert_eq!(::core::mem::align_of::<_PNP_REPLACE_MEMORY_LIST__bindgen_ty_1>()
               , 8usize);
}
impl Clone for _PNP_REPLACE_MEMORY_LIST__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__PNP_REPLACE_MEMORY_LIST() {
    assert_eq!(::core::mem::size_of::<_PNP_REPLACE_MEMORY_LIST>() , 32usize);
    assert_eq!(::core::mem::align_of::<_PNP_REPLACE_MEMORY_LIST>() , 8usize);
}
impl Clone for _PNP_REPLACE_MEMORY_LIST {
    fn clone(&self) -> Self { *self }
}
pub use self::_PNP_REPLACE_MEMORY_LIST as PNP_REPLACE_MEMORY_LIST;
pub type PPNP_REPLACE_MEMORY_LIST = *mut _PNP_REPLACE_MEMORY_LIST;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PNP_REPLACE_PROCESSOR_LIST {
    pub Affinity: PKAFFINITY,
    pub GroupCount: ULONG,
    pub AllocatedCount: ULONG,
    pub Count: ULONG,
    pub ApicIds: [ULONG; 1usize],
}
#[test]
fn bindgen_test_layout__PNP_REPLACE_PROCESSOR_LIST() {
    assert_eq!(::core::mem::size_of::<_PNP_REPLACE_PROCESSOR_LIST>() ,
               24usize);
    assert_eq!(::core::mem::align_of::<_PNP_REPLACE_PROCESSOR_LIST>() ,
               8usize);
}
impl Clone for _PNP_REPLACE_PROCESSOR_LIST {
    fn clone(&self) -> Self { *self }
}
pub use self::_PNP_REPLACE_PROCESSOR_LIST as PNP_REPLACE_PROCESSOR_LIST;
pub type PPNP_REPLACE_PROCESSOR_LIST = *mut _PNP_REPLACE_PROCESSOR_LIST;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PNP_REPLACE_PROCESSOR_LIST_V1 {
    pub AffinityMask: KAFFINITY,
    pub AllocatedCount: ULONG,
    pub Count: ULONG,
    pub ApicIds: [ULONG; 1usize],
}
#[test]
fn bindgen_test_layout__PNP_REPLACE_PROCESSOR_LIST_V1() {
    assert_eq!(::core::mem::size_of::<_PNP_REPLACE_PROCESSOR_LIST_V1>() ,
               24usize);
    assert_eq!(::core::mem::align_of::<_PNP_REPLACE_PROCESSOR_LIST_V1>() ,
               8usize);
}
impl Clone for _PNP_REPLACE_PROCESSOR_LIST_V1 {
    fn clone(&self) -> Self { *self }
}
pub use self::_PNP_REPLACE_PROCESSOR_LIST_V1 as PNP_REPLACE_PROCESSOR_LIST_V1;
pub type PPNP_REPLACE_PROCESSOR_LIST_V1 = *mut _PNP_REPLACE_PROCESSOR_LIST_V1;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PNP_REPLACE_PARAMETERS {
    pub Size: ULONG,
    pub Version: ULONG,
    pub Target: ULONG64,
    pub Spare: ULONG64,
    pub TargetProcessors: PPNP_REPLACE_PROCESSOR_LIST,
    pub SpareProcessors: PPNP_REPLACE_PROCESSOR_LIST,
    pub TargetMemory: PPNP_REPLACE_MEMORY_LIST,
    pub SpareMemory: PPNP_REPLACE_MEMORY_LIST,
    pub MapMemory: PREPLACE_MAP_MEMORY,
}
#[test]
fn bindgen_test_layout__PNP_REPLACE_PARAMETERS() {
    assert_eq!(::core::mem::size_of::<_PNP_REPLACE_PARAMETERS>() , 64usize);
    assert_eq!(::core::mem::align_of::<_PNP_REPLACE_PARAMETERS>() , 8usize);
}
impl Clone for _PNP_REPLACE_PARAMETERS {
    fn clone(&self) -> Self { *self }
}
pub use self::_PNP_REPLACE_PARAMETERS as PNP_REPLACE_PARAMETERS;
pub type PPNP_REPLACE_PARAMETERS = *mut _PNP_REPLACE_PARAMETERS;
pub type PREPLACE_UNLOAD = ::core::option::Option<unsafe extern "C" fn()>;
pub type PREPLACE_BEGIN =
    ::core::option::Option<unsafe extern "C" fn(Parameters:
                                                    PPNP_REPLACE_PARAMETERS,
                                                Context: *mut PVOID)
                               -> libc::c_long>;
pub type PREPLACE_END =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID)
                               -> libc::c_long>;
pub type PREPLACE_MIRROR_PHYSICAL_MEMORY =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                PhysicalAddress:
                                                    PHYSICAL_ADDRESS,
                                                ByteCount: LARGE_INTEGER)
                               -> libc::c_long>;
pub type PREPLACE_SET_PROCESSOR_ID =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID, ApicId: ULONG,
                                                Target: BOOLEAN)
                               -> libc::c_long>;
pub type PREPLACE_SWAP =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID)
                               -> libc::c_long>;
pub type PREPLACE_INITIATE_HARDWARE_MIRROR =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID)
                               -> libc::c_long>;
pub type PREPLACE_MIRROR_PLATFORM_MEMORY =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID)
                               -> libc::c_long>;
pub type PREPLACE_GET_MEMORY_DESTINATION =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                SourceAddress:
                                                    PHYSICAL_ADDRESS,
                                                DestinationAddress:
                                                    PPHYSICAL_ADDRESS)
                               -> libc::c_long>;
pub type PREPLACE_ENABLE_DISABLE_HARDWARE_QUIESCE =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                Enable: BOOLEAN)
                               -> libc::c_long>;
pub use self::_PNP_REPLACE_DRIVER_INTERFACE as PNP_REPLACE_DRIVER_INTERFACE;
pub type PCRASHDUMP_POWER_ON =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID)
                               -> libc::c_long>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CRASHDUMP_FUNCTIONS_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub PowerOn: PCRASHDUMP_POWER_ON,
}
#[test]
fn bindgen_test_layout__CRASHDUMP_FUNCTIONS_INTERFACE() {
    assert_eq!(::core::mem::size_of::<_CRASHDUMP_FUNCTIONS_INTERFACE>() ,
               40usize);
    assert_eq!(::core::mem::align_of::<_CRASHDUMP_FUNCTIONS_INTERFACE>() ,
               8usize);
}
impl Clone for _CRASHDUMP_FUNCTIONS_INTERFACE {
    fn clone(&self) -> Self { *self }
}
pub use self::_CRASHDUMP_FUNCTIONS_INTERFACE as CRASHDUMP_FUNCTIONS_INTERFACE;
pub type PCRASHDUMP_FUNCTIONS_INTERFACE = *mut _CRASHDUMP_FUNCTIONS_INTERFACE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _DEVICE_RESET_TYPE {
    FunctionLevelDeviceReset = 0,
    PlatformLevelDeviceReset = 1,
}
pub use self::_DEVICE_RESET_TYPE as DEVICE_RESET_TYPE;
pub type DEVICE_RESET_COMPLETION =
    ::core::option::Option<unsafe extern "C" fn(Status: NTSTATUS,
                                                Context: PVOID)>;
pub type PDEVICE_RESET_COMPLETION = DEVICE_RESET_COMPLETION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _FUNCTION_LEVEL_DEVICE_RESET_PARAMETERS {
    pub Size: ULONG,
    pub DeviceResetCompletion: PDEVICE_RESET_COMPLETION,
    pub CompletionContext: PVOID,
}
#[test]
fn bindgen_test_layout__FUNCTION_LEVEL_DEVICE_RESET_PARAMETERS() {
    assert_eq!(::core::mem::size_of::<_FUNCTION_LEVEL_DEVICE_RESET_PARAMETERS>()
               , 24usize);
    assert_eq!(::core::mem::align_of::<_FUNCTION_LEVEL_DEVICE_RESET_PARAMETERS>()
               , 8usize);
}
impl Clone for _FUNCTION_LEVEL_DEVICE_RESET_PARAMETERS {
    fn clone(&self) -> Self { *self }
}
pub use self::_FUNCTION_LEVEL_DEVICE_RESET_PARAMETERS as
        FUNCTION_LEVEL_DEVICE_RESET_PARAMETERS;
pub type PFUNCTION_LEVEL_DEVICE_RESET_PARAMETERS =
    *mut _FUNCTION_LEVEL_DEVICE_RESET_PARAMETERS;
pub type PDEVICE_RESET_HANDLER =
    ::core::option::Option<unsafe extern "C" fn(InterfaceContext: PVOID,
                                                ResetType: DEVICE_RESET_TYPE,
                                                Flags: ULONG,
                                                ResetParameters: PVOID)
                               -> libc::c_long>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DEVICE_RESET_INTERFACE_STANDARD {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub DeviceReset: PDEVICE_RESET_HANDLER,
    pub SupportedResetTypes: ULONG,
    pub Reserved: PVOID,
}
#[test]
fn bindgen_test_layout__DEVICE_RESET_INTERFACE_STANDARD() {
    assert_eq!(::core::mem::size_of::<_DEVICE_RESET_INTERFACE_STANDARD>() ,
               56usize);
    assert_eq!(::core::mem::align_of::<_DEVICE_RESET_INTERFACE_STANDARD>() ,
               8usize);
}
impl Clone for _DEVICE_RESET_INTERFACE_STANDARD {
    fn clone(&self) -> Self { *self }
}
pub use self::_DEVICE_RESET_INTERFACE_STANDARD as
        DEVICE_RESET_INTERFACE_STANDARD;
pub type PDEVICE_RESET_INTERFACE_STANDARD =
    *mut _DEVICE_RESET_INTERFACE_STANDARD;
pub use self::_DEVICE_DESCRIPTION as DEVICE_DESCRIPTION;
pub type PDEVICE_DESCRIPTION = *mut _DEVICE_DESCRIPTION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DMA_ADAPTER_INFO_V1 {
    pub ReadDmaCounterAvailable: ULONG,
    pub ScatterGatherLimit: ULONG,
    pub DmaAddressWidth: ULONG,
    pub Flags: ULONG,
    pub MinimumTransferUnit: ULONG,
}
#[test]
fn bindgen_test_layout__DMA_ADAPTER_INFO_V1() {
    assert_eq!(::core::mem::size_of::<_DMA_ADAPTER_INFO_V1>() , 20usize);
    assert_eq!(::core::mem::align_of::<_DMA_ADAPTER_INFO_V1>() , 4usize);
}
impl Clone for _DMA_ADAPTER_INFO_V1 {
    fn clone(&self) -> Self { *self }
}
pub use self::_DMA_ADAPTER_INFO_V1 as DMA_ADAPTER_INFO_V1;
pub type PDMA_ADAPTER_INFO_V1 = *mut _DMA_ADAPTER_INFO_V1;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DMA_ADAPTER_INFO {
    pub Version: ULONG,
    pub __bindgen_anon_1: _DMA_ADAPTER_INFO__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DMA_ADAPTER_INFO__bindgen_ty_1 {
    pub V1: __BindgenUnionField<DMA_ADAPTER_INFO_V1>,
    pub bindgen_union_field: [u32; 5usize],
}
#[test]
fn bindgen_test_layout__DMA_ADAPTER_INFO__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_DMA_ADAPTER_INFO__bindgen_ty_1>() ,
               20usize);
    assert_eq!(::core::mem::align_of::<_DMA_ADAPTER_INFO__bindgen_ty_1>() ,
               4usize);
}
impl Clone for _DMA_ADAPTER_INFO__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__DMA_ADAPTER_INFO() {
    assert_eq!(::core::mem::size_of::<_DMA_ADAPTER_INFO>() , 24usize);
    assert_eq!(::core::mem::align_of::<_DMA_ADAPTER_INFO>() , 4usize);
}
impl Clone for _DMA_ADAPTER_INFO {
    fn clone(&self) -> Self { *self }
}
pub use self::_DMA_ADAPTER_INFO as DMA_ADAPTER_INFO;
pub type PDMA_ADAPTER_INFO = *mut _DMA_ADAPTER_INFO;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DMA_TRANSFER_INFO_V1 {
    pub MapRegisterCount: ULONG,
    pub ScatterGatherElementCount: ULONG,
    pub ScatterGatherListSize: ULONG,
}
#[test]
fn bindgen_test_layout__DMA_TRANSFER_INFO_V1() {
    assert_eq!(::core::mem::size_of::<_DMA_TRANSFER_INFO_V1>() , 12usize);
    assert_eq!(::core::mem::align_of::<_DMA_TRANSFER_INFO_V1>() , 4usize);
}
impl Clone for _DMA_TRANSFER_INFO_V1 {
    fn clone(&self) -> Self { *self }
}
pub use self::_DMA_TRANSFER_INFO_V1 as DMA_TRANSFER_INFO_V1;
pub type PDMA_TRANSFER_INFO_V1 = *mut _DMA_TRANSFER_INFO_V1;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DMA_TRANSFER_INFO {
    pub Version: ULONG,
    pub __bindgen_anon_1: _DMA_TRANSFER_INFO__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DMA_TRANSFER_INFO__bindgen_ty_1 {
    pub V1: __BindgenUnionField<DMA_TRANSFER_INFO_V1>,
    pub bindgen_union_field: [u32; 3usize],
}
#[test]
fn bindgen_test_layout__DMA_TRANSFER_INFO__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_DMA_TRANSFER_INFO__bindgen_ty_1>() ,
               12usize);
    assert_eq!(::core::mem::align_of::<_DMA_TRANSFER_INFO__bindgen_ty_1>() ,
               4usize);
}
impl Clone for _DMA_TRANSFER_INFO__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__DMA_TRANSFER_INFO() {
    assert_eq!(::core::mem::size_of::<_DMA_TRANSFER_INFO>() , 16usize);
    assert_eq!(::core::mem::align_of::<_DMA_TRANSFER_INFO>() , 4usize);
}
impl Clone for _DMA_TRANSFER_INFO {
    fn clone(&self) -> Self { *self }
}
pub use self::_DMA_TRANSFER_INFO as DMA_TRANSFER_INFO;
pub type PDMA_TRANSFER_INFO = *mut _DMA_TRANSFER_INFO;
extern "C" {
    pub fn KeFlushWriteBuffer();
}
extern "C" {
    pub fn KeQueryPerformanceCounter(PerformanceFrequency: PLARGE_INTEGER)
     -> LARGE_INTEGER;
}
extern "C" {
    pub fn KeStallExecutionProcessor(MicroSeconds: ULONG);
}
pub type PROCESSOR_HALT_ROUTINE =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID) -> NTSTATUS>;
pub type PPROCESSOR_HALT_ROUTINE = PROCESSOR_HALT_ROUTINE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SCATTER_GATHER_ELEMENT {
    pub Address: PHYSICAL_ADDRESS,
    pub Length: ULONG,
    pub Reserved: ULONG_PTR,
}
#[test]
fn bindgen_test_layout__SCATTER_GATHER_ELEMENT() {
    assert_eq!(::core::mem::size_of::<_SCATTER_GATHER_ELEMENT>() , 24usize);
    assert_eq!(::core::mem::align_of::<_SCATTER_GATHER_ELEMENT>() , 8usize);
}
impl Clone for _SCATTER_GATHER_ELEMENT {
    fn clone(&self) -> Self { *self }
}
pub use self::_SCATTER_GATHER_ELEMENT as SCATTER_GATHER_ELEMENT;
pub type PSCATTER_GATHER_ELEMENT = *mut _SCATTER_GATHER_ELEMENT;
pub use self::_SCATTER_GATHER_LIST as SCATTER_GATHER_LIST;
pub type PSCATTER_GATHER_LIST = *mut _SCATTER_GATHER_LIST;
#[repr(C)]
#[derive(Copy)]
pub struct _DMA_OPERATIONS {
    pub Size: ULONG,
    pub PutDmaAdapter: PPUT_DMA_ADAPTER,
    pub AllocateCommonBuffer: PALLOCATE_COMMON_BUFFER,
    pub FreeCommonBuffer: PFREE_COMMON_BUFFER,
    pub AllocateAdapterChannel: PALLOCATE_ADAPTER_CHANNEL,
    pub FlushAdapterBuffers: PFLUSH_ADAPTER_BUFFERS,
    pub FreeAdapterChannel: PFREE_ADAPTER_CHANNEL,
    pub FreeMapRegisters: PFREE_MAP_REGISTERS,
    pub MapTransfer: PMAP_TRANSFER,
    pub GetDmaAlignment: PGET_DMA_ALIGNMENT,
    pub ReadDmaCounter: PREAD_DMA_COUNTER,
    pub GetScatterGatherList: PGET_SCATTER_GATHER_LIST,
    pub PutScatterGatherList: PPUT_SCATTER_GATHER_LIST,
    pub CalculateScatterGatherList: PCALCULATE_SCATTER_GATHER_LIST_SIZE,
    pub BuildScatterGatherList: PBUILD_SCATTER_GATHER_LIST,
    pub BuildMdlFromScatterGatherList: PBUILD_MDL_FROM_SCATTER_GATHER_LIST,
    pub GetDmaAdapterInfo: PGET_DMA_ADAPTER_INFO,
    pub GetDmaTransferInfo: PGET_DMA_TRANSFER_INFO,
    pub InitializeDmaTransferContext: PINITIALIZE_DMA_TRANSFER_CONTEXT,
    pub AllocateCommonBufferEx: PALLOCATE_COMMON_BUFFER_EX,
    pub AllocateAdapterChannelEx: PALLOCATE_ADAPTER_CHANNEL_EX,
    pub ConfigureAdapterChannel: PCONFIGURE_ADAPTER_CHANNEL,
    pub CancelAdapterChannel: PCANCEL_ADAPTER_CHANNEL,
    pub MapTransferEx: PMAP_TRANSFER_EX,
    pub GetScatterGatherListEx: PGET_SCATTER_GATHER_LIST_EX,
    pub BuildScatterGatherListEx: PBUILD_SCATTER_GATHER_LIST_EX,
    pub FlushAdapterBuffersEx: PFLUSH_ADAPTER_BUFFERS_EX,
    pub FreeAdapterObject: PFREE_ADAPTER_OBJECT,
    pub CancelMappedTransfer: PCANCEL_MAPPED_TRANSFER,
    pub AllocateDomainCommonBuffer: PALLOCATE_DOMAIN_COMMON_BUFFER,
    pub FlushDmaBuffer: PFLUSH_DMA_BUFFER,
    pub JoinDmaDomain: PJOIN_DMA_DOMAIN,
    pub LeaveDmaDomain: PLEAVE_DMA_DOMAIN,
    pub GetDmaDomain: PGET_DMA_DOMAIN,
}
#[test]
fn bindgen_test_layout__DMA_OPERATIONS() {
    assert_eq!(::core::mem::size_of::<_DMA_OPERATIONS>() , 272usize);
    assert_eq!(::core::mem::align_of::<_DMA_OPERATIONS>() , 8usize);
}
impl Clone for _DMA_OPERATIONS {
    fn clone(&self) -> Self { *self }
}
pub type PDMA_OPERATIONS = *mut _DMA_OPERATIONS;
pub use self::_DMA_ADAPTER as DMA_ADAPTER;
pub type PDMA_ADAPTER = *mut _DMA_ADAPTER;
pub const DmaComplete: _bindgen_ty_17 = _bindgen_ty_17::DmaComplete;
pub const DmaAborted: _bindgen_ty_17 = _bindgen_ty_17::DmaAborted;
pub const DmaError: _bindgen_ty_17 = _bindgen_ty_17::DmaError;
pub const DmaCancelled: _bindgen_ty_17 = _bindgen_ty_17::DmaCancelled;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_17 {
    DmaComplete = 0,
    DmaAborted = 1,
    DmaError = 2,
    DmaCancelled = 3,
}
pub use self::_bindgen_ty_17 as DMA_COMPLETION_STATUS;
pub type PPUT_DMA_ADAPTER =
    ::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER)>;
pub type PALLOCATE_COMMON_BUFFER =
    ::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER,
                                                Length: ULONG,
                                                LogicalAddress:
                                                    PPHYSICAL_ADDRESS,
                                                CacheEnabled: BOOLEAN)
                               -> *mut libc::c_void>;
pub type PFREE_COMMON_BUFFER =
    ::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER,
                                                Length: ULONG,
                                                LogicalAddress:
                                                    PHYSICAL_ADDRESS,
                                                VirtualAddress: PVOID,
                                                CacheEnabled: BOOLEAN)>;
pub type PALLOCATE_ADAPTER_CHANNEL =
    ::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER,
                                                DeviceObject: PDEVICE_OBJECT,
                                                NumberOfMapRegisters: ULONG,
                                                ExecutionRoutine:
                                                    PDRIVER_CONTROL,
                                                Context: PVOID)
                               -> libc::c_long>;
pub type PFLUSH_ADAPTER_BUFFERS =
    ::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER,
                                                Mdl: PMDL,
                                                MapRegisterBase: PVOID,
                                                CurrentVa: PVOID,
                                                Length: ULONG,
                                                WriteToDevice: BOOLEAN)
                               -> libc::c_uchar>;
pub type PFREE_ADAPTER_CHANNEL =
    ::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER)>;
pub type PFREE_ADAPTER_OBJECT =
    ::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER,
                                                AllocationAction:
                                                    IO_ALLOCATION_ACTION)>;
pub type PFREE_MAP_REGISTERS =
    ::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER,
                                                MapRegisterBase: PVOID,
                                                NumberOfMapRegisters: ULONG)>;
pub type PMAP_TRANSFER =
    ::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER,
                                                Mdl: PMDL,
                                                MapRegisterBase: PVOID,
                                                CurrentVa: PVOID,
                                                Length: PULONG,
                                                WriteToDevice: BOOLEAN)
                               -> _LARGE_INTEGER>;
pub type PGET_DMA_ALIGNMENT =
    ::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER)
                               -> libc::c_ulong>;
pub type PREAD_DMA_COUNTER =
    ::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER)
                               -> libc::c_ulong>;
pub type DRIVER_LIST_CONTROL =
    ::core::option::Option<unsafe extern "C" fn(DeviceObject:
                                                    *mut _DEVICE_OBJECT,
                                                Irp: *mut _IRP,
                                                ScatterGather:
                                                    PSCATTER_GATHER_LIST,
                                                Context: PVOID)>;
pub type PDRIVER_LIST_CONTROL = DRIVER_LIST_CONTROL;
pub type PGET_SCATTER_GATHER_LIST =
    ::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER,
                                                DeviceObject: PDEVICE_OBJECT,
                                                Mdl: PMDL, CurrentVa: PVOID,
                                                Length: ULONG,
                                                ExecutionRoutine:
                                                    PDRIVER_LIST_CONTROL,
                                                Context: PVOID,
                                                WriteToDevice: BOOLEAN)
                               -> libc::c_long>;
pub type PPUT_SCATTER_GATHER_LIST =
    ::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER,
                                                ScatterGather:
                                                    PSCATTER_GATHER_LIST,
                                                WriteToDevice: BOOLEAN)>;
pub type PCALCULATE_SCATTER_GATHER_LIST_SIZE =
    ::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER,
                                                Mdl: PMDL, CurrentVa: PVOID,
                                                Length: ULONG,
                                                ScatterGatherListSize: PULONG,
                                                pNumberOfMapRegisters: PULONG)
                               -> libc::c_long>;
pub type PBUILD_SCATTER_GATHER_LIST =
    ::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER,
                                                DeviceObject: PDEVICE_OBJECT,
                                                Mdl: PMDL, CurrentVa: PVOID,
                                                Length: ULONG,
                                                ExecutionRoutine:
                                                    PDRIVER_LIST_CONTROL,
                                                Context: PVOID,
                                                WriteToDevice: BOOLEAN,
                                                ScatterGatherBuffer: PVOID,
                                                ScatterGatherLength: ULONG)
                               -> libc::c_long>;
pub type PBUILD_MDL_FROM_SCATTER_GATHER_LIST =
    ::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER,
                                                ScatterGather:
                                                    PSCATTER_GATHER_LIST,
                                                OriginalMdl: PMDL,
                                                TargetMdl: *mut PMDL)
                               -> libc::c_long>;
pub type PGET_DMA_ADAPTER_INFO =
    ::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER,
                                                AdapterInfo:
                                                    PDMA_ADAPTER_INFO)
                               -> libc::c_long>;
pub type PGET_DMA_TRANSFER_INFO =
    ::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER,
                                                Mdl: PMDL, Offset: ULONGLONG,
                                                Length: ULONG,
                                                WriteOnly: BOOLEAN,
                                                TransferInfo:
                                                    PDMA_TRANSFER_INFO)
                               -> libc::c_long>;
pub type PCONFIGURE_ADAPTER_CHANNEL =
    ::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER,
                                                FunctionNumber: ULONG,
                                                Context: PVOID)
                               -> libc::c_long>;
pub type PINITIALIZE_DMA_TRANSFER_CONTEXT =
    ::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER,
                                                DmaTransferContext: PVOID)
                               -> libc::c_long>;
pub type PALLOCATE_COMMON_BUFFER_EX =
    ::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER,
                                                MaximumAddress:
                                                    PPHYSICAL_ADDRESS,
                                                Length: ULONG,
                                                LogicalAddress:
                                                    PPHYSICAL_ADDRESS,
                                                CacheEnabled: BOOLEAN,
                                                PreferredNode:
                                                    NODE_REQUIREMENT)
                               -> *mut libc::c_void>;
pub type PALLOCATE_ADAPTER_CHANNEL_EX =
    ::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER,
                                                DeviceObject: PDEVICE_OBJECT,
                                                DmaTransferContext: PVOID,
                                                NumberOfMapRegisters: ULONG,
                                                Flags: ULONG,
                                                ExecutionRoutine:
                                                    PDRIVER_CONTROL,
                                                ExecutionContext: PVOID,
                                                MapRegisterBase: *mut PVOID)
                               -> libc::c_long>;
pub type DMA_COMPLETION_ROUTINE =
    ::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER,
                                                DeviceObject: PDEVICE_OBJECT,
                                                CompletionContext: PVOID,
                                                Status:
                                                    DMA_COMPLETION_STATUS)>;
pub type PDMA_COMPLETION_ROUTINE = DMA_COMPLETION_ROUTINE;
pub type PMAP_TRANSFER_EX =
    ::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER,
                                                Mdl: PMDL,
                                                MapRegisterBase: PVOID,
                                                Offset: ULONGLONG,
                                                DeviceOffset: ULONG,
                                                Length: PULONG,
                                                WriteToDevice: BOOLEAN,
                                                ScatterGatherBuffer:
                                                    PSCATTER_GATHER_LIST,
                                                ScatterGatherBufferLength:
                                                    ULONG,
                                                DmaCompletionRoutine:
                                                    PDMA_COMPLETION_ROUTINE,
                                                CompletionContext: PVOID)
                               -> libc::c_long>;
pub type PCANCEL_ADAPTER_CHANNEL =
    ::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER,
                                                DeviceObject: PDEVICE_OBJECT,
                                                DmaTransferContext: PVOID)
                               -> libc::c_uchar>;
pub type PCANCEL_MAPPED_TRANSFER =
    ::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER,
                                                DmaTransferContext: PVOID)
                               -> libc::c_long>;
pub type PFLUSH_ADAPTER_BUFFERS_EX =
    ::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER,
                                                Mdl: PMDL,
                                                MapRegisterBase: PVOID,
                                                Offset: ULONGLONG,
                                                Length: ULONG,
                                                WriteToDevice: BOOLEAN)
                               -> libc::c_long>;
pub type PGET_SCATTER_GATHER_LIST_EX =
    ::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER,
                                                DeviceObject: PDEVICE_OBJECT,
                                                DmaTransferContext: PVOID,
                                                Mdl: PMDL, Offset: ULONGLONG,
                                                Length: ULONG, Flags: ULONG,
                                                ExecutionRoutine:
                                                    PDRIVER_LIST_CONTROL,
                                                Context: PVOID,
                                                WriteToDevice: BOOLEAN,
                                                DmaCompletionRoutine:
                                                    PDMA_COMPLETION_ROUTINE,
                                                CompletionContext: PVOID,
                                                ScatterGatherList:
                                                    *mut PSCATTER_GATHER_LIST)
                               -> libc::c_long>;
pub type PBUILD_SCATTER_GATHER_LIST_EX =
    ::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER,
                                                DeviceObject: PDEVICE_OBJECT,
                                                DmaTransferContext: PVOID,
                                                Mdl: PMDL, Offset: ULONGLONG,
                                                Length: ULONG, Flags: ULONG,
                                                ExecutionRoutine:
                                                    PDRIVER_LIST_CONTROL,
                                                Context: PVOID,
                                                WriteToDevice: BOOLEAN,
                                                ScatterGatherBuffer: PVOID,
                                                ScatterGatherLength: ULONG,
                                                DmaCompletionRoutine:
                                                    PDMA_COMPLETION_ROUTINE,
                                                CompletionContext: PVOID,
                                                ScatterGatherList: PVOID)
                               -> libc::c_long>;
pub type PALLOCATE_DOMAIN_COMMON_BUFFER =
    ::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER,
                                                DomainHandle: HANDLE,
                                                MaximumAddress:
                                                    PPHYSICAL_ADDRESS,
                                                Length: ULONG, Flags: ULONG,
                                                CacheType:
                                                    *mut MEMORY_CACHING_TYPE,
                                                PreferredNode:
                                                    NODE_REQUIREMENT,
                                                LogicalAddress:
                                                    PPHYSICAL_ADDRESS,
                                                VirtualAddress: *mut PVOID)
                               -> libc::c_long>;
pub type PFLUSH_DMA_BUFFER =
    ::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER,
                                                Mdl: PMDL,
                                                ReadOperation: BOOLEAN)
                               -> libc::c_long>;
pub type PJOIN_DMA_DOMAIN =
    ::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER,
                                                DomainHandle: HANDLE)
                               -> libc::c_long>;
pub type PLEAVE_DMA_DOMAIN =
    ::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER)
                               -> libc::c_long>;
pub type PGET_DMA_DOMAIN =
    ::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER)
                               -> *mut libc::c_void>;
pub use self::_DMA_OPERATIONS as DMA_OPERATIONS;
extern "C" {
    pub fn PoSetHiberRange(MemoryMap: PVOID, Flags: ULONG, Address: PVOID,
                           Length: ULONG_PTR, Tag: ULONG);
}
extern "C" {
    pub fn PoSetSystemState(Flags: EXECUTION_STATE);
}
extern "C" {
    pub fn PoRegisterSystemState(StateHandle: PVOID, Flags: EXECUTION_STATE)
     -> PVOID;
}
extern "C" {
    pub fn PoCreatePowerRequest(PowerRequest: *mut PVOID,
                                DeviceObject: PDEVICE_OBJECT,
                                Context: PCOUNTED_REASON_CONTEXT) -> NTSTATUS;
}
extern "C" {
    pub fn PoSetPowerRequest(PowerRequest: PVOID, Type: POWER_REQUEST_TYPE)
     -> NTSTATUS;
}
extern "C" {
    pub fn PoClearPowerRequest(PowerRequest: PVOID, Type: POWER_REQUEST_TYPE)
     -> NTSTATUS;
}
extern "C" {
    pub fn PoDeletePowerRequest(PowerRequest: PVOID);
}
pub type REQUEST_POWER_COMPLETE =
    ::core::option::Option<unsafe extern "C" fn(DeviceObject: PDEVICE_OBJECT,
                                                MinorFunction: UCHAR,
                                                PowerState: POWER_STATE,
                                                Context: PVOID,
                                                IoStatus: PIO_STATUS_BLOCK)>;
pub type PREQUEST_POWER_COMPLETE = REQUEST_POWER_COMPLETE;
extern "C" {
    pub fn PoRequestPowerIrp(DeviceObject: PDEVICE_OBJECT,
                             MinorFunction: UCHAR, PowerState: POWER_STATE,
                             CompletionFunction: PREQUEST_POWER_COMPLETE,
                             Context: PVOID, Irp: *mut PIRP) -> NTSTATUS;
}
extern "C" {
    pub fn PoSetSystemWake(Irp: PIRP);
}
extern "C" {
    pub fn PoGetSystemWake(Irp: PIRP) -> BOOLEAN;
}
extern "C" {
    pub fn PoUnregisterSystemState(StateHandle: PVOID);
}
extern "C" {
    pub fn PoSetPowerState(DeviceObject: PDEVICE_OBJECT,
                           Type: POWER_STATE_TYPE, State: POWER_STATE)
     -> POWER_STATE;
}
extern "C" {
    pub fn PoCallDriver(DeviceObject: PDEVICE_OBJECT, Irp: PIRP) -> NTSTATUS;
}
extern "C" {
    pub fn PoStartNextPowerIrp(Irp: PIRP);
}
extern "C" {
    pub fn PoRegisterDeviceForIdleDetection(DeviceObject: PDEVICE_OBJECT,
                                            ConservationIdleTime: ULONG,
                                            PerformanceIdleTime: ULONG,
                                            State: DEVICE_POWER_STATE)
     -> PULONG;
}
extern "C" {
    pub fn PoSetDeviceBusyEx(IdlePointer: PULONG);
}
extern "C" {
    pub fn PoStartDeviceBusy(IdlePointer: PULONG);
}
extern "C" {
    pub fn PoEndDeviceBusy(IdlePointer: PULONG);
}
extern "C" {
    pub fn PoQueryWatchdogTime(Pdo: PDEVICE_OBJECT, SecondsRemaining: PULONG)
     -> BOOLEAN;
}
pub type POWER_SETTING_CALLBACK =
    ::core::option::Option<unsafe extern "C" fn(SettingGuid: LPCGUID,
                                                Value: PVOID,
                                                ValueLength: ULONG,
                                                Context: PVOID) -> NTSTATUS>;
pub type PPOWER_SETTING_CALLBACK = POWER_SETTING_CALLBACK;
extern "C" {
    pub fn PoRegisterPowerSettingCallback(DeviceObject: PDEVICE_OBJECT,
                                          SettingGuid: LPCGUID,
                                          Callback: PPOWER_SETTING_CALLBACK,
                                          Context: PVOID, Handle: *mut PVOID)
     -> NTSTATUS;
}
extern "C" {
    pub fn PoUnregisterPowerSettingCallback(Handle: PVOID) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct POHANDLE__ {
    pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_POHANDLE__() {
    assert_eq!(::core::mem::size_of::<POHANDLE__>() , 4usize);
    assert_eq!(::core::mem::align_of::<POHANDLE__>() , 4usize);
}
impl Clone for POHANDLE__ {
    fn clone(&self) -> Self { *self }
}
pub type POHANDLE = *mut POHANDLE__;
pub type PO_FX_COMPONENT_ACTIVE_CONDITION_CALLBACK =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                Component: ULONG)>;
pub type PPO_FX_COMPONENT_ACTIVE_CONDITION_CALLBACK =
    PO_FX_COMPONENT_ACTIVE_CONDITION_CALLBACK;
pub type PO_FX_COMPONENT_IDLE_CONDITION_CALLBACK =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                Component: ULONG)>;
pub type PPO_FX_COMPONENT_IDLE_CONDITION_CALLBACK =
    PO_FX_COMPONENT_IDLE_CONDITION_CALLBACK;
pub type PO_FX_COMPONENT_IDLE_STATE_CALLBACK =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                Component: ULONG,
                                                State: ULONG)>;
pub type PPO_FX_COMPONENT_IDLE_STATE_CALLBACK =
    PO_FX_COMPONENT_IDLE_STATE_CALLBACK;
pub type PO_FX_DEVICE_POWER_REQUIRED_CALLBACK =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID)>;
pub type PPO_FX_DEVICE_POWER_REQUIRED_CALLBACK =
    PO_FX_DEVICE_POWER_REQUIRED_CALLBACK;
pub type PO_FX_DEVICE_POWER_NOT_REQUIRED_CALLBACK =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID)>;
pub type PPO_FX_DEVICE_POWER_NOT_REQUIRED_CALLBACK =
    PO_FX_DEVICE_POWER_NOT_REQUIRED_CALLBACK;
pub type PO_FX_POWER_CONTROL_CALLBACK =
    ::core::option::Option<unsafe extern "C" fn(DeviceContext: PVOID,
                                                PowerControlCode: LPCGUID,
                                                InBuffer: PVOID,
                                                InBufferSize: SIZE_T,
                                                OutBuffer: PVOID,
                                                OutBufferSize: SIZE_T,
                                                BytesReturned: PSIZE_T)
                               -> NTSTATUS>;
pub type PPO_FX_POWER_CONTROL_CALLBACK = PO_FX_POWER_CONTROL_CALLBACK;
pub type PO_FX_COMPONENT_CRITICAL_TRANSITION_CALLBACK =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                Component: ULONG,
                                                Active: BOOLEAN)>;
pub type PPO_FX_COMPONENT_CRITICAL_TRANSITION_CALLBACK =
    PO_FX_COMPONENT_CRITICAL_TRANSITION_CALLBACK;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PO_FX_COMPONENT_IDLE_STATE {
    pub TransitionLatency: ULONGLONG,
    pub ResidencyRequirement: ULONGLONG,
    pub NominalPower: ULONG,
}
#[test]
fn bindgen_test_layout__PO_FX_COMPONENT_IDLE_STATE() {
    assert_eq!(::core::mem::size_of::<_PO_FX_COMPONENT_IDLE_STATE>() ,
               24usize);
    assert_eq!(::core::mem::align_of::<_PO_FX_COMPONENT_IDLE_STATE>() ,
               8usize);
}
impl Clone for _PO_FX_COMPONENT_IDLE_STATE {
    fn clone(&self) -> Self { *self }
}
pub use self::_PO_FX_COMPONENT_IDLE_STATE as PO_FX_COMPONENT_IDLE_STATE;
pub type PPO_FX_COMPONENT_IDLE_STATE = *mut _PO_FX_COMPONENT_IDLE_STATE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PO_FX_COMPONENT_V1 {
    pub Id: GUID,
    pub IdleStateCount: ULONG,
    pub DeepestWakeableIdleState: ULONG,
    pub IdleStates: PPO_FX_COMPONENT_IDLE_STATE,
}
#[test]
fn bindgen_test_layout__PO_FX_COMPONENT_V1() {
    assert_eq!(::core::mem::size_of::<_PO_FX_COMPONENT_V1>() , 32usize);
    assert_eq!(::core::mem::align_of::<_PO_FX_COMPONENT_V1>() , 8usize);
}
impl Clone for _PO_FX_COMPONENT_V1 {
    fn clone(&self) -> Self { *self }
}
pub use self::_PO_FX_COMPONENT_V1 as PO_FX_COMPONENT_V1;
pub type PPO_FX_COMPONENT_V1 = *mut _PO_FX_COMPONENT_V1;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PO_FX_DEVICE_V1 {
    pub Version: ULONG,
    pub ComponentCount: ULONG,
    pub ComponentActiveConditionCallback: PPO_FX_COMPONENT_ACTIVE_CONDITION_CALLBACK,
    pub ComponentIdleConditionCallback: PPO_FX_COMPONENT_IDLE_CONDITION_CALLBACK,
    pub ComponentIdleStateCallback: PPO_FX_COMPONENT_IDLE_STATE_CALLBACK,
    pub DevicePowerRequiredCallback: PPO_FX_DEVICE_POWER_REQUIRED_CALLBACK,
    pub DevicePowerNotRequiredCallback: PPO_FX_DEVICE_POWER_NOT_REQUIRED_CALLBACK,
    pub PowerControlCallback: PPO_FX_POWER_CONTROL_CALLBACK,
    pub DeviceContext: PVOID,
    pub Components: [PO_FX_COMPONENT_V1; 1usize],
}
#[test]
fn bindgen_test_layout__PO_FX_DEVICE_V1() {
    assert_eq!(::core::mem::size_of::<_PO_FX_DEVICE_V1>() , 96usize);
    assert_eq!(::core::mem::align_of::<_PO_FX_DEVICE_V1>() , 8usize);
}
impl Clone for _PO_FX_DEVICE_V1 {
    fn clone(&self) -> Self { *self }
}
pub use self::_PO_FX_DEVICE_V1 as PO_FX_DEVICE_V1;
pub type PPO_FX_DEVICE_V1 = *mut _PO_FX_DEVICE_V1;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PO_FX_COMPONENT_V2 {
    pub Id: GUID,
    pub Flags: ULONGLONG,
    pub DeepestWakeableIdleState: ULONG,
    pub IdleStateCount: ULONG,
    pub IdleStates: PPO_FX_COMPONENT_IDLE_STATE,
    pub ProviderCount: ULONG,
    pub Providers: PULONG,
}
#[test]
fn bindgen_test_layout__PO_FX_COMPONENT_V2() {
    assert_eq!(::core::mem::size_of::<_PO_FX_COMPONENT_V2>() , 56usize);
    assert_eq!(::core::mem::align_of::<_PO_FX_COMPONENT_V2>() , 8usize);
}
impl Clone for _PO_FX_COMPONENT_V2 {
    fn clone(&self) -> Self { *self }
}
pub use self::_PO_FX_COMPONENT_V2 as PO_FX_COMPONENT_V2;
pub type PPO_FX_COMPONENT_V2 = *mut _PO_FX_COMPONENT_V2;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PO_FX_DEVICE_V2 {
    pub Version: ULONG,
    pub Flags: ULONGLONG,
    pub ComponentActiveConditionCallback: PPO_FX_COMPONENT_ACTIVE_CONDITION_CALLBACK,
    pub ComponentIdleConditionCallback: PPO_FX_COMPONENT_IDLE_CONDITION_CALLBACK,
    pub ComponentIdleStateCallback: PPO_FX_COMPONENT_IDLE_STATE_CALLBACK,
    pub DevicePowerRequiredCallback: PPO_FX_DEVICE_POWER_REQUIRED_CALLBACK,
    pub DevicePowerNotRequiredCallback: PPO_FX_DEVICE_POWER_NOT_REQUIRED_CALLBACK,
    pub PowerControlCallback: PPO_FX_POWER_CONTROL_CALLBACK,
    pub DeviceContext: PVOID,
    pub ComponentCount: ULONG,
    pub Components: [PO_FX_COMPONENT_V2; 1usize],
}
#[test]
fn bindgen_test_layout__PO_FX_DEVICE_V2() {
    assert_eq!(::core::mem::size_of::<_PO_FX_DEVICE_V2>() , 136usize);
    assert_eq!(::core::mem::align_of::<_PO_FX_DEVICE_V2>() , 8usize);
}
impl Clone for _PO_FX_DEVICE_V2 {
    fn clone(&self) -> Self { *self }
}
pub use self::_PO_FX_DEVICE_V2 as PO_FX_DEVICE_V2;
pub type PPO_FX_DEVICE_V2 = *mut _PO_FX_DEVICE_V2;
pub use self::PO_FX_COMPONENT_V1 as PO_FX_COMPONENT;
pub type PPO_FX_COMPONENT = *mut PO_FX_COMPONENT_V1;
pub use self::PO_FX_DEVICE_V1 as PO_FX_DEVICE;
pub type PPO_FX_DEVICE = *mut PO_FX_DEVICE_V1;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _PO_FX_PERF_STATE_UNIT {
    PoFxPerfStateUnitOther = 0,
    PoFxPerfStateUnitFrequency = 1,
    PoFxPerfStateUnitBandwidth = 2,
    PoFxPerfStateUnitMaximum = 3,
}
pub use self::_PO_FX_PERF_STATE_UNIT as PO_FX_PERF_STATE_UNIT;
pub type PPO_FX_PERF_STATE_UNIT = *mut _PO_FX_PERF_STATE_UNIT;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _PO_FX_PERF_STATE_TYPE {
    PoFxPerfStateTypeDiscrete = 0,
    PoFxPerfStateTypeRange = 1,
    PoFxPerfStateTypeMaximum = 2,
}
pub use self::_PO_FX_PERF_STATE_TYPE as PO_FX_PERF_STATE_TYPE;
pub type PPO_FX_PERF_STATE_TYPE = *mut _PO_FX_PERF_STATE_TYPE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PO_FX_PERF_STATE {
    pub Value: ULONGLONG,
    pub Context: PVOID,
}
#[test]
fn bindgen_test_layout__PO_FX_PERF_STATE() {
    assert_eq!(::core::mem::size_of::<_PO_FX_PERF_STATE>() , 16usize);
    assert_eq!(::core::mem::align_of::<_PO_FX_PERF_STATE>() , 8usize);
}
impl Clone for _PO_FX_PERF_STATE {
    fn clone(&self) -> Self { *self }
}
pub use self::_PO_FX_PERF_STATE as PO_FX_PERF_STATE;
pub type PPO_FX_PERF_STATE = *mut _PO_FX_PERF_STATE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PO_FX_COMPONENT_PERF_SET {
    pub Name: UNICODE_STRING,
    pub Flags: ULONGLONG,
    pub Unit: PO_FX_PERF_STATE_UNIT,
    pub Type: PO_FX_PERF_STATE_TYPE,
    pub __bindgen_anon_1: _PO_FX_COMPONENT_PERF_SET__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PO_FX_COMPONENT_PERF_SET__bindgen_ty_1 {
    pub Discrete: __BindgenUnionField<_PO_FX_COMPONENT_PERF_SET__bindgen_ty_1__bindgen_ty_1>,
    pub Range: __BindgenUnionField<_PO_FX_COMPONENT_PERF_SET__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PO_FX_COMPONENT_PERF_SET__bindgen_ty_1__bindgen_ty_1 {
    pub Count: ULONG,
    pub States: PPO_FX_PERF_STATE,
}
#[test]
fn bindgen_test_layout__PO_FX_COMPONENT_PERF_SET__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PO_FX_COMPONENT_PERF_SET__bindgen_ty_1__bindgen_ty_1>()
               , 16usize);
    assert_eq!(::core::mem::align_of::<_PO_FX_COMPONENT_PERF_SET__bindgen_ty_1__bindgen_ty_1>()
               , 8usize);
}
impl Clone for _PO_FX_COMPONENT_PERF_SET__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PO_FX_COMPONENT_PERF_SET__bindgen_ty_1__bindgen_ty_2 {
    pub Minimum: ULONGLONG,
    pub Maximum: ULONGLONG,
}
#[test]
fn bindgen_test_layout__PO_FX_COMPONENT_PERF_SET__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<_PO_FX_COMPONENT_PERF_SET__bindgen_ty_1__bindgen_ty_2>()
               , 16usize);
    assert_eq!(::core::mem::align_of::<_PO_FX_COMPONENT_PERF_SET__bindgen_ty_1__bindgen_ty_2>()
               , 8usize);
}
impl Clone for _PO_FX_COMPONENT_PERF_SET__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__PO_FX_COMPONENT_PERF_SET__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PO_FX_COMPONENT_PERF_SET__bindgen_ty_1>()
               , 16usize);
    assert_eq!(::core::mem::align_of::<_PO_FX_COMPONENT_PERF_SET__bindgen_ty_1>()
               , 8usize);
}
impl Clone for _PO_FX_COMPONENT_PERF_SET__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__PO_FX_COMPONENT_PERF_SET() {
    assert_eq!(::core::mem::size_of::<_PO_FX_COMPONENT_PERF_SET>() , 48usize);
    assert_eq!(::core::mem::align_of::<_PO_FX_COMPONENT_PERF_SET>() , 8usize);
}
impl Clone for _PO_FX_COMPONENT_PERF_SET {
    fn clone(&self) -> Self { *self }
}
pub use self::_PO_FX_COMPONENT_PERF_SET as PO_FX_COMPONENT_PERF_SET;
pub type PPO_FX_COMPONENT_PERF_SET = *mut _PO_FX_COMPONENT_PERF_SET;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PO_FX_COMPONENT_PERF_INFO {
    pub PerfStateSetsCount: ULONG,
    pub PerfStateSets: [PO_FX_COMPONENT_PERF_SET; 1usize],
}
#[test]
fn bindgen_test_layout__PO_FX_COMPONENT_PERF_INFO() {
    assert_eq!(::core::mem::size_of::<_PO_FX_COMPONENT_PERF_INFO>() ,
               56usize);
    assert_eq!(::core::mem::align_of::<_PO_FX_COMPONENT_PERF_INFO>() ,
               8usize);
}
impl Clone for _PO_FX_COMPONENT_PERF_INFO {
    fn clone(&self) -> Self { *self }
}
pub use self::_PO_FX_COMPONENT_PERF_INFO as PO_FX_COMPONENT_PERF_INFO;
pub type PPO_FX_COMPONENT_PERF_INFO = *mut _PO_FX_COMPONENT_PERF_INFO;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PO_FX_PERF_STATE_CHANGE {
    pub Set: ULONG,
    pub __bindgen_anon_1: _PO_FX_PERF_STATE_CHANGE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PO_FX_PERF_STATE_CHANGE__bindgen_ty_1 {
    pub StateIndex: __BindgenUnionField<ULONG>,
    pub StateValue: __BindgenUnionField<ULONGLONG>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__PO_FX_PERF_STATE_CHANGE__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PO_FX_PERF_STATE_CHANGE__bindgen_ty_1>()
               , 8usize);
    assert_eq!(::core::mem::align_of::<_PO_FX_PERF_STATE_CHANGE__bindgen_ty_1>()
               , 8usize);
}
impl Clone for _PO_FX_PERF_STATE_CHANGE__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__PO_FX_PERF_STATE_CHANGE() {
    assert_eq!(::core::mem::size_of::<_PO_FX_PERF_STATE_CHANGE>() , 16usize);
    assert_eq!(::core::mem::align_of::<_PO_FX_PERF_STATE_CHANGE>() , 8usize);
}
impl Clone for _PO_FX_PERF_STATE_CHANGE {
    fn clone(&self) -> Self { *self }
}
pub use self::_PO_FX_PERF_STATE_CHANGE as PO_FX_PERF_STATE_CHANGE;
pub type PPO_FX_PERF_STATE_CHANGE = *mut _PO_FX_PERF_STATE_CHANGE;
extern "C" {
    pub fn PoFxRegisterDevice(Pdo: PDEVICE_OBJECT, Device: PPO_FX_DEVICE,
                              Handle: *mut POHANDLE) -> NTSTATUS;
}
extern "C" {
    pub fn PoFxStartDevicePowerManagement(Handle: POHANDLE);
}
extern "C" {
    pub fn PoFxUnregisterDevice(Handle: POHANDLE);
}
extern "C" {
    pub fn PoFxRegisterCrashdumpDevice(Handle: POHANDLE) -> NTSTATUS;
}
extern "C" {
    pub fn PoFxPowerOnCrashdumpDevice(Handle: POHANDLE, Context: PVOID)
     -> NTSTATUS;
}
extern "C" {
    pub fn PoFxActivateComponent(Handle: POHANDLE, Component: ULONG,
                                 Flags: ULONG);
}
extern "C" {
    pub fn PoFxCompleteDevicePowerNotRequired(Handle: POHANDLE);
}
extern "C" {
    pub fn PoFxCompleteIdleCondition(Handle: POHANDLE, Component: ULONG);
}
extern "C" {
    pub fn PoFxCompleteIdleState(Handle: POHANDLE, Component: ULONG);
}
extern "C" {
    pub fn PoFxIdleComponent(Handle: POHANDLE, Component: ULONG,
                             Flags: ULONG);
}
extern "C" {
    pub fn PoFxSetComponentLatency(Handle: POHANDLE, Component: ULONG,
                                   Latency: ULONGLONG);
}
extern "C" {
    pub fn PoFxSetComponentResidency(Handle: POHANDLE, Component: ULONG,
                                     Residency: ULONGLONG);
}
extern "C" {
    pub fn PoFxSetComponentWake(Handle: POHANDLE, Component: ULONG,
                                WakeHint: BOOLEAN);
}
extern "C" {
    pub fn PoFxSetDeviceIdleTimeout(Handle: POHANDLE, IdleTimeout: ULONGLONG);
}
extern "C" {
    pub fn PoFxReportDevicePoweredOn(Handle: POHANDLE);
}
extern "C" {
    pub fn PoFxPowerControl(Handle: POHANDLE, PowerControlCode: LPCGUID,
                            InBuffer: PVOID, InBufferSize: SIZE_T,
                            OutBuffer: PVOID, OutBufferSize: SIZE_T,
                            BytesReturned: PSIZE_T) -> NTSTATUS;
}
extern "C" {
    pub fn PoFxNotifySurprisePowerOn(Pdo: PDEVICE_OBJECT);
}
pub type PO_FX_COMPONENT_PERF_STATE_CALLBACK =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                Component: ULONG,
                                                Succeeded: BOOLEAN,
                                                RequestContext: PVOID)>;
pub type PPO_FX_COMPONENT_PERF_STATE_CALLBACK =
    PO_FX_COMPONENT_PERF_STATE_CALLBACK;
extern "C" {
    pub fn PoFxRegisterComponentPerfStates(Handle: POHANDLE, Component: ULONG,
                                           Flags: ULONGLONG,
                                           ComponentPerfStateCallback:
                                               PPO_FX_COMPONENT_PERF_STATE_CALLBACK,
                                           InputStateInfo:
                                               PPO_FX_COMPONENT_PERF_INFO,
                                           OutputStateInfo:
                                               *mut PPO_FX_COMPONENT_PERF_INFO)
     -> NTSTATUS;
}
extern "C" {
    pub fn PoFxIssueComponentPerfStateChange(Handle: POHANDLE, Flags: ULONG,
                                             Component: ULONG,
                                             PerfChange:
                                                 PPO_FX_PERF_STATE_CHANGE,
                                             Context: PVOID);
}
extern "C" {
    pub fn PoFxIssueComponentPerfStateChangeMultiple(Handle: POHANDLE,
                                                     Flags: ULONG,
                                                     Component: ULONG,
                                                     PerfChangesCount: ULONG,
                                                     PerfChanges:
                                                         *mut PO_FX_PERF_STATE_CHANGE,
                                                     Context: PVOID);
}
extern "C" {
    pub fn PoFxQueryCurrentComponentPerfState(Handle: POHANDLE, Flags: ULONG,
                                              Component: ULONG,
                                              SetIndex: ULONG,
                                              CurrentPerf: PULONGLONG)
     -> NTSTATUS;
}
extern "C" {
    pub fn PoCreateThermalRequest(ThermalRequest: *mut PVOID,
                                  TargetDeviceObject: PDEVICE_OBJECT,
                                  PolicyDeviceObject: PDEVICE_OBJECT,
                                  Context: PCOUNTED_REASON_CONTEXT,
                                  Flags: ULONG) -> NTSTATUS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _PO_THERMAL_REQUEST_TYPE {
    PoThermalRequestPassive = 0,
    PoThermalRequestActive = 1,
}
pub use self::_PO_THERMAL_REQUEST_TYPE as PO_THERMAL_REQUEST_TYPE;
pub type PPO_THERMAL_REQUEST_TYPE = *mut _PO_THERMAL_REQUEST_TYPE;
extern "C" {
    pub fn PoGetThermalRequestSupport(ThermalRequest: PVOID,
                                      Type: PO_THERMAL_REQUEST_TYPE)
     -> BOOLEAN;
}
extern "C" {
    pub fn PoSetThermalPassiveCooling(ThermalRequest: PVOID, Throttle: UCHAR)
     -> NTSTATUS;
}
extern "C" {
    pub fn PoSetThermalActiveCooling(ThermalRequest: PVOID, Engaged: BOOLEAN)
     -> NTSTATUS;
}
extern "C" {
    pub fn PoDeleteThermalRequest(ThermalRequest: PVOID);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _OBJECT_HANDLE_INFORMATION {
    pub HandleAttributes: ULONG,
    pub GrantedAccess: ACCESS_MASK,
}
#[test]
fn bindgen_test_layout__OBJECT_HANDLE_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_OBJECT_HANDLE_INFORMATION>() , 8usize);
    assert_eq!(::core::mem::align_of::<_OBJECT_HANDLE_INFORMATION>() ,
               4usize);
}
impl Clone for _OBJECT_HANDLE_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_OBJECT_HANDLE_INFORMATION as OBJECT_HANDLE_INFORMATION;
pub type POBJECT_HANDLE_INFORMATION = *mut _OBJECT_HANDLE_INFORMATION;
extern "C" {
    pub fn ObReferenceObjectByHandle(Handle: HANDLE,
                                     DesiredAccess: ACCESS_MASK,
                                     ObjectType: POBJECT_TYPE,
                                     AccessMode: KPROCESSOR_MODE,
                                     Object: *mut PVOID,
                                     HandleInformation:
                                         POBJECT_HANDLE_INFORMATION)
     -> NTSTATUS;
}
extern "C" {
    pub fn ObReferenceObjectByHandleWithTag(Handle: HANDLE,
                                            DesiredAccess: ACCESS_MASK,
                                            ObjectType: POBJECT_TYPE,
                                            AccessMode: KPROCESSOR_MODE,
                                            Tag: ULONG, Object: *mut PVOID,
                                            HandleInformation:
                                                POBJECT_HANDLE_INFORMATION)
     -> NTSTATUS;
}
extern "C" {
    pub fn ObReferenceObjectSafe(Object: PVOID) -> BOOLEAN;
}
extern "C" {
    pub fn ObReferenceObjectSafeWithTag(Object: PVOID, Tag: ULONG) -> BOOLEAN;
}
extern "C" {
    pub fn ObCloseHandle(Handle: HANDLE, PreviousMode: KPROCESSOR_MODE)
     -> NTSTATUS;
}
extern "C" {
    pub fn ObfReferenceObject(Object: PVOID) -> LONG_PTR;
}
extern "C" {
    pub fn ObfReferenceObjectWithTag(Object: PVOID, Tag: ULONG) -> LONG_PTR;
}
extern "C" {
    pub fn ObReferenceObjectByPointer(Object: PVOID,
                                      DesiredAccess: ACCESS_MASK,
                                      ObjectType: POBJECT_TYPE,
                                      AccessMode: KPROCESSOR_MODE)
     -> NTSTATUS;
}
extern "C" {
    pub fn ObReferenceObjectByPointerWithTag(Object: PVOID,
                                             DesiredAccess: ACCESS_MASK,
                                             ObjectType: POBJECT_TYPE,
                                             AccessMode: KPROCESSOR_MODE,
                                             Tag: ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn ObfDereferenceObject(Object: PVOID) -> LONG_PTR;
}
extern "C" {
    pub fn ObfDereferenceObjectWithTag(Object: PVOID, Tag: ULONG) -> LONG_PTR;
}
extern "C" {
    pub fn ObDereferenceObjectDeferDelete(Object: PVOID);
}
extern "C" {
    pub fn ObDereferenceObjectDeferDeleteWithTag(Object: PVOID, Tag: ULONG);
}
extern "C" {
    pub fn ObGetObjectSecurity(Object: PVOID,
                               SecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
                               MemoryAllocated: PBOOLEAN) -> NTSTATUS;
}
extern "C" {
    pub fn ObReleaseObjectSecurity(SecurityDescriptor: PSECURITY_DESCRIPTOR,
                                   MemoryAllocated: BOOLEAN);
}
pub type OB_OPERATION = ULONG;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _OB_PRE_CREATE_HANDLE_INFORMATION {
    pub DesiredAccess: ACCESS_MASK,
    pub OriginalDesiredAccess: ACCESS_MASK,
}
#[test]
fn bindgen_test_layout__OB_PRE_CREATE_HANDLE_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_OB_PRE_CREATE_HANDLE_INFORMATION>() ,
               8usize);
    assert_eq!(::core::mem::align_of::<_OB_PRE_CREATE_HANDLE_INFORMATION>() ,
               4usize);
}
impl Clone for _OB_PRE_CREATE_HANDLE_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_OB_PRE_CREATE_HANDLE_INFORMATION as
        OB_PRE_CREATE_HANDLE_INFORMATION;
pub type POB_PRE_CREATE_HANDLE_INFORMATION =
    *mut _OB_PRE_CREATE_HANDLE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _OB_PRE_DUPLICATE_HANDLE_INFORMATION {
    pub DesiredAccess: ACCESS_MASK,
    pub OriginalDesiredAccess: ACCESS_MASK,
    pub SourceProcess: PVOID,
    pub TargetProcess: PVOID,
}
#[test]
fn bindgen_test_layout__OB_PRE_DUPLICATE_HANDLE_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_OB_PRE_DUPLICATE_HANDLE_INFORMATION>()
               , 24usize);
    assert_eq!(::core::mem::align_of::<_OB_PRE_DUPLICATE_HANDLE_INFORMATION>()
               , 8usize);
}
impl Clone for _OB_PRE_DUPLICATE_HANDLE_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_OB_PRE_DUPLICATE_HANDLE_INFORMATION as
        OB_PRE_DUPLICATE_HANDLE_INFORMATION;
pub type POB_PRE_DUPLICATE_HANDLE_INFORMATION =
    *mut _OB_PRE_DUPLICATE_HANDLE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _OB_PRE_OPERATION_PARAMETERS {
    pub CreateHandleInformation: __BindgenUnionField<OB_PRE_CREATE_HANDLE_INFORMATION>,
    pub DuplicateHandleInformation: __BindgenUnionField<OB_PRE_DUPLICATE_HANDLE_INFORMATION>,
    pub bindgen_union_field: [u64; 3usize],
}
#[test]
fn bindgen_test_layout__OB_PRE_OPERATION_PARAMETERS() {
    assert_eq!(::core::mem::size_of::<_OB_PRE_OPERATION_PARAMETERS>() ,
               24usize);
    assert_eq!(::core::mem::align_of::<_OB_PRE_OPERATION_PARAMETERS>() ,
               8usize);
}
impl Clone for _OB_PRE_OPERATION_PARAMETERS {
    fn clone(&self) -> Self { *self }
}
pub use self::_OB_PRE_OPERATION_PARAMETERS as OB_PRE_OPERATION_PARAMETERS;
pub type POB_PRE_OPERATION_PARAMETERS = *mut _OB_PRE_OPERATION_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _OB_PRE_OPERATION_INFORMATION {
    pub Operation: OB_OPERATION,
    pub __bindgen_anon_1: _OB_PRE_OPERATION_INFORMATION__bindgen_ty_1,
    pub Object: PVOID,
    pub ObjectType: POBJECT_TYPE,
    pub CallContext: PVOID,
    pub Parameters: POB_PRE_OPERATION_PARAMETERS,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _OB_PRE_OPERATION_INFORMATION__bindgen_ty_1 {
    pub Flags: __BindgenUnionField<ULONG>,
    pub __bindgen_anon_1: __BindgenUnionField<_OB_PRE_OPERATION_INFORMATION__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _OB_PRE_OPERATION_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__OB_PRE_OPERATION_INFORMATION__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_OB_PRE_OPERATION_INFORMATION__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_OB_PRE_OPERATION_INFORMATION__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _OB_PRE_OPERATION_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _OB_PRE_OPERATION_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn KernelHandle(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_KernelHandle(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967294usize as u32)) >> 1u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967294usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 1u32) & (4294967294usize as u32);
    }
}
#[test]
fn bindgen_test_layout__OB_PRE_OPERATION_INFORMATION__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_OB_PRE_OPERATION_INFORMATION__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_OB_PRE_OPERATION_INFORMATION__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _OB_PRE_OPERATION_INFORMATION__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__OB_PRE_OPERATION_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_OB_PRE_OPERATION_INFORMATION>() ,
               40usize);
    assert_eq!(::core::mem::align_of::<_OB_PRE_OPERATION_INFORMATION>() ,
               8usize);
}
impl Clone for _OB_PRE_OPERATION_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_OB_PRE_OPERATION_INFORMATION as OB_PRE_OPERATION_INFORMATION;
pub type POB_PRE_OPERATION_INFORMATION = *mut _OB_PRE_OPERATION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _OB_POST_CREATE_HANDLE_INFORMATION {
    pub GrantedAccess: ACCESS_MASK,
}
#[test]
fn bindgen_test_layout__OB_POST_CREATE_HANDLE_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_OB_POST_CREATE_HANDLE_INFORMATION>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_OB_POST_CREATE_HANDLE_INFORMATION>() ,
               4usize);
}
impl Clone for _OB_POST_CREATE_HANDLE_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_OB_POST_CREATE_HANDLE_INFORMATION as
        OB_POST_CREATE_HANDLE_INFORMATION;
pub type POB_POST_CREATE_HANDLE_INFORMATION =
    *mut _OB_POST_CREATE_HANDLE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _OB_POST_DUPLICATE_HANDLE_INFORMATION {
    pub GrantedAccess: ACCESS_MASK,
}
#[test]
fn bindgen_test_layout__OB_POST_DUPLICATE_HANDLE_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_OB_POST_DUPLICATE_HANDLE_INFORMATION>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_OB_POST_DUPLICATE_HANDLE_INFORMATION>()
               , 4usize);
}
impl Clone for _OB_POST_DUPLICATE_HANDLE_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_OB_POST_DUPLICATE_HANDLE_INFORMATION as
        OB_POST_DUPLICATE_HANDLE_INFORMATION;
pub type POB_POST_DUPLICATE_HANDLE_INFORMATION =
    *mut _OB_POST_DUPLICATE_HANDLE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _OB_POST_OPERATION_PARAMETERS {
    pub CreateHandleInformation: __BindgenUnionField<OB_POST_CREATE_HANDLE_INFORMATION>,
    pub DuplicateHandleInformation: __BindgenUnionField<OB_POST_DUPLICATE_HANDLE_INFORMATION>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout__OB_POST_OPERATION_PARAMETERS() {
    assert_eq!(::core::mem::size_of::<_OB_POST_OPERATION_PARAMETERS>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_OB_POST_OPERATION_PARAMETERS>() ,
               4usize);
}
impl Clone for _OB_POST_OPERATION_PARAMETERS {
    fn clone(&self) -> Self { *self }
}
pub use self::_OB_POST_OPERATION_PARAMETERS as OB_POST_OPERATION_PARAMETERS;
pub type POB_POST_OPERATION_PARAMETERS = *mut _OB_POST_OPERATION_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _OB_POST_OPERATION_INFORMATION {
    pub Operation: OB_OPERATION,
    pub __bindgen_anon_1: _OB_POST_OPERATION_INFORMATION__bindgen_ty_1,
    pub Object: PVOID,
    pub ObjectType: POBJECT_TYPE,
    pub CallContext: PVOID,
    pub ReturnStatus: NTSTATUS,
    pub Parameters: POB_POST_OPERATION_PARAMETERS,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _OB_POST_OPERATION_INFORMATION__bindgen_ty_1 {
    pub Flags: __BindgenUnionField<ULONG>,
    pub __bindgen_anon_1: __BindgenUnionField<_OB_POST_OPERATION_INFORMATION__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _OB_POST_OPERATION_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__OB_POST_OPERATION_INFORMATION__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_OB_POST_OPERATION_INFORMATION__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_OB_POST_OPERATION_INFORMATION__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _OB_POST_OPERATION_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _OB_POST_OPERATION_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn KernelHandle(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_KernelHandle(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967294usize as u32)) >> 1u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967294usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 1u32) & (4294967294usize as u32);
    }
}
#[test]
fn bindgen_test_layout__OB_POST_OPERATION_INFORMATION__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_OB_POST_OPERATION_INFORMATION__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_OB_POST_OPERATION_INFORMATION__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _OB_POST_OPERATION_INFORMATION__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__OB_POST_OPERATION_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_OB_POST_OPERATION_INFORMATION>() ,
               48usize);
    assert_eq!(::core::mem::align_of::<_OB_POST_OPERATION_INFORMATION>() ,
               8usize);
}
impl Clone for _OB_POST_OPERATION_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_OB_POST_OPERATION_INFORMATION as OB_POST_OPERATION_INFORMATION;
pub type POB_POST_OPERATION_INFORMATION = *mut _OB_POST_OPERATION_INFORMATION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _OB_PREOP_CALLBACK_STATUS { OB_PREOP_SUCCESS = 0, }
pub use self::_OB_PREOP_CALLBACK_STATUS as OB_PREOP_CALLBACK_STATUS;
pub type POB_PREOP_CALLBACK_STATUS = *mut _OB_PREOP_CALLBACK_STATUS;
pub type POB_PRE_OPERATION_CALLBACK =
    ::core::option::Option<unsafe extern "C" fn(RegistrationContext: PVOID,
                                                OperationInformation:
                                                    POB_PRE_OPERATION_INFORMATION)
                               -> _OB_PREOP_CALLBACK_STATUS>;
pub type POB_POST_OPERATION_CALLBACK =
    ::core::option::Option<unsafe extern "C" fn(RegistrationContext: PVOID,
                                                OperationInformation:
                                                    POB_POST_OPERATION_INFORMATION)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _OB_OPERATION_REGISTRATION {
    pub ObjectType: *mut POBJECT_TYPE,
    pub Operations: OB_OPERATION,
    pub PreOperation: POB_PRE_OPERATION_CALLBACK,
    pub PostOperation: POB_POST_OPERATION_CALLBACK,
}
#[test]
fn bindgen_test_layout__OB_OPERATION_REGISTRATION() {
    assert_eq!(::core::mem::size_of::<_OB_OPERATION_REGISTRATION>() ,
               32usize);
    assert_eq!(::core::mem::align_of::<_OB_OPERATION_REGISTRATION>() ,
               8usize);
}
impl Clone for _OB_OPERATION_REGISTRATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_OB_OPERATION_REGISTRATION as OB_OPERATION_REGISTRATION;
pub type POB_OPERATION_REGISTRATION = *mut _OB_OPERATION_REGISTRATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _OB_CALLBACK_REGISTRATION {
    pub Version: USHORT,
    pub OperationRegistrationCount: USHORT,
    pub Altitude: UNICODE_STRING,
    pub RegistrationContext: PVOID,
    pub OperationRegistration: *mut OB_OPERATION_REGISTRATION,
}
#[test]
fn bindgen_test_layout__OB_CALLBACK_REGISTRATION() {
    assert_eq!(::core::mem::size_of::<_OB_CALLBACK_REGISTRATION>() , 40usize);
    assert_eq!(::core::mem::align_of::<_OB_CALLBACK_REGISTRATION>() , 8usize);
}
impl Clone for _OB_CALLBACK_REGISTRATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_OB_CALLBACK_REGISTRATION as OB_CALLBACK_REGISTRATION;
pub type POB_CALLBACK_REGISTRATION = *mut _OB_CALLBACK_REGISTRATION;
extern "C" {
    pub fn ObRegisterCallbacks(CallbackRegistration:
                                   POB_CALLBACK_REGISTRATION,
                               RegistrationHandle: *mut PVOID) -> NTSTATUS;
}
extern "C" {
    pub fn ObUnRegisterCallbacks(RegistrationHandle: PVOID);
}
extern "C" {
    pub fn ObGetFilterVersion() -> USHORT;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_SLOT_NUMBER {
    pub u: _PCI_SLOT_NUMBER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_SLOT_NUMBER__bindgen_ty_1 {
    pub bits: __BindgenUnionField<_PCI_SLOT_NUMBER__bindgen_ty_1__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_SLOT_NUMBER__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCI_SLOT_NUMBER__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_SLOT_NUMBER__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_SLOT_NUMBER__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PCI_SLOT_NUMBER__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_SLOT_NUMBER__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn DeviceNumber(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (31usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_DeviceNumber(&mut self, val: ULONG) {
        self._bitfield_1 &= !(31usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (31usize as u32);
    }
    #[inline]
    pub fn FunctionNumber(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (224usize as u32)) >>
                                        5u32) as u32)
        }
    }
    #[inline]
    pub fn set_FunctionNumber(&mut self, val: ULONG) {
        self._bitfield_1 &= !(224usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (224usize as u32);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967040usize as u32)) >> 8u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967040usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 8u32) & (4294967040usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PCI_SLOT_NUMBER__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_SLOT_NUMBER__bindgen_ty_1>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_PCI_SLOT_NUMBER__bindgen_ty_1>() ,
               4usize);
}
impl Clone for _PCI_SLOT_NUMBER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__PCI_SLOT_NUMBER() {
    assert_eq!(::core::mem::size_of::<_PCI_SLOT_NUMBER>() , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_SLOT_NUMBER>() , 4usize);
}
impl Clone for _PCI_SLOT_NUMBER {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_SLOT_NUMBER as PCI_SLOT_NUMBER;
pub type PPCI_SLOT_NUMBER = *mut _PCI_SLOT_NUMBER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_COMMON_HEADER {
    pub VendorID: USHORT,
    pub DeviceID: USHORT,
    pub Command: USHORT,
    pub Status: USHORT,
    pub RevisionID: UCHAR,
    pub ProgIf: UCHAR,
    pub SubClass: UCHAR,
    pub BaseClass: UCHAR,
    pub CacheLineSize: UCHAR,
    pub LatencyTimer: UCHAR,
    pub HeaderType: UCHAR,
    pub BIST: UCHAR,
    pub u: _PCI_COMMON_HEADER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_COMMON_HEADER__bindgen_ty_1 {
    pub type0: __BindgenUnionField<_PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_0>,
    pub type1: __BindgenUnionField<_PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_1>,
    pub type2: __BindgenUnionField<_PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_2>,
    pub bindgen_union_field: [u32; 12usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_0 {
    pub BaseAddresses: [ULONG; 6usize],
    pub CIS: ULONG,
    pub SubVendorID: USHORT,
    pub SubSystemID: USHORT,
    pub ROMBaseAddress: ULONG,
    pub CapabilitiesPtr: UCHAR,
    pub Reserved1: [UCHAR; 3usize],
    pub Reserved2: ULONG,
    pub InterruptLine: UCHAR,
    pub InterruptPin: UCHAR,
    pub MinimumGrant: UCHAR,
    pub MaximumLatency: UCHAR,
}
#[test]
fn bindgen_test_layout__PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_0() {
    assert_eq!(::core::mem::size_of::<_PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_0>()
               , 48usize);
    assert_eq!(::core::mem::align_of::<_PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_0>()
               , 4usize);
}
impl Clone for _PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_0 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_1 {
    pub BaseAddresses: [ULONG; 2usize],
    pub PrimaryBus: UCHAR,
    pub SecondaryBus: UCHAR,
    pub SubordinateBus: UCHAR,
    pub SecondaryLatency: UCHAR,
    pub IOBase: UCHAR,
    pub IOLimit: UCHAR,
    pub SecondaryStatus: USHORT,
    pub MemoryBase: USHORT,
    pub MemoryLimit: USHORT,
    pub PrefetchBase: USHORT,
    pub PrefetchLimit: USHORT,
    pub PrefetchBaseUpper32: ULONG,
    pub PrefetchLimitUpper32: ULONG,
    pub IOBaseUpper16: USHORT,
    pub IOLimitUpper16: USHORT,
    pub CapabilitiesPtr: UCHAR,
    pub Reserved1: [UCHAR; 3usize],
    pub ROMBaseAddress: ULONG,
    pub InterruptLine: UCHAR,
    pub InterruptPin: UCHAR,
    pub BridgeControl: USHORT,
}
#[test]
fn bindgen_test_layout__PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_1() {
    assert_eq!(::core::mem::size_of::<_PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_1>()
               , 48usize);
    assert_eq!(::core::mem::align_of::<_PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_1>()
               , 4usize);
}
impl Clone for _PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_2 {
    pub SocketRegistersBaseAddress: ULONG,
    pub CapabilitiesPtr: UCHAR,
    pub Reserved: UCHAR,
    pub SecondaryStatus: USHORT,
    pub PrimaryBus: UCHAR,
    pub SecondaryBus: UCHAR,
    pub SubordinateBus: UCHAR,
    pub SecondaryLatency: UCHAR,
    pub Range: [_PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_2__bindgen_ty_1; 4usize],
    pub InterruptLine: UCHAR,
    pub InterruptPin: UCHAR,
    pub BridgeControl: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_2__bindgen_ty_1 {
    pub Base: ULONG,
    pub Limit: ULONG,
}
#[test]
fn bindgen_test_layout__PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_2__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_2__bindgen_ty_1>()
               , 8usize);
    assert_eq!(::core::mem::align_of::<_PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_2__bindgen_ty_1>()
               , 4usize);
}
impl Clone for
 _PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_2() {
    assert_eq!(::core::mem::size_of::<_PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_2>()
               , 48usize);
    assert_eq!(::core::mem::align_of::<_PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_2>()
               , 4usize);
}
impl Clone for _PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__PCI_COMMON_HEADER__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_COMMON_HEADER__bindgen_ty_1>() ,
               48usize);
    assert_eq!(::core::mem::align_of::<_PCI_COMMON_HEADER__bindgen_ty_1>() ,
               4usize);
}
impl Clone for _PCI_COMMON_HEADER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__PCI_COMMON_HEADER() {
    assert_eq!(::core::mem::size_of::<_PCI_COMMON_HEADER>() , 64usize);
    assert_eq!(::core::mem::align_of::<_PCI_COMMON_HEADER>() , 4usize);
}
impl Clone for _PCI_COMMON_HEADER {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_COMMON_HEADER as PCI_COMMON_HEADER;
pub type PPCI_COMMON_HEADER = *mut _PCI_COMMON_HEADER;
#[repr(C)]
pub struct _PCI_COMMON_CONFIG {
    pub DeviceSpecific: [UCHAR; 192usize],
}
#[test]
fn bindgen_test_layout__PCI_COMMON_CONFIG() {
    assert_eq!(::core::mem::size_of::<_PCI_COMMON_CONFIG>() , 256usize);
    assert_eq!(::core::mem::align_of::<_PCI_COMMON_CONFIG>() , 4usize);
}
pub use self::_PCI_COMMON_CONFIG as PCI_COMMON_CONFIG;
pub type PPCI_COMMON_CONFIG = *mut _PCI_COMMON_CONFIG;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_CAPABILITIES_HEADER {
    pub CapabilityID: UCHAR,
    pub Next: UCHAR,
}
#[test]
fn bindgen_test_layout__PCI_CAPABILITIES_HEADER() {
    assert_eq!(::core::mem::size_of::<_PCI_CAPABILITIES_HEADER>() , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_CAPABILITIES_HEADER>() , 1usize);
}
impl Clone for _PCI_CAPABILITIES_HEADER {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_CAPABILITIES_HEADER as PCI_CAPABILITIES_HEADER;
pub type PPCI_CAPABILITIES_HEADER = *mut _PCI_CAPABILITIES_HEADER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_PMC {
    pub _bitfield_1: u8,
    pub Support: _PCI_PMC__PM_SUPPORT,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_PMC__PM_SUPPORT {
    pub _bitfield_1: u8,
}
#[test]
fn bindgen_test_layout__PCI_PMC__PM_SUPPORT() {
    assert_eq!(::core::mem::size_of::<_PCI_PMC__PM_SUPPORT>() , 1usize);
    assert_eq!(::core::mem::align_of::<_PCI_PMC__PM_SUPPORT>() , 1usize);
}
impl Clone for _PCI_PMC__PM_SUPPORT {
    fn clone(&self) -> Self { *self }
}
impl _PCI_PMC__PM_SUPPORT {
    #[inline]
    pub fn Rsvd2(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                        0u32) as u8)
        }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 0u32) & (1usize as u8);
    }
    #[inline]
    pub fn D1(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u8)) >>
                                        1u32) as u8)
        }
    }
    #[inline]
    pub fn set_D1(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(2usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 1u32) & (2usize as u8);
    }
    #[inline]
    pub fn D2(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u8)) >>
                                        2u32) as u8)
        }
    }
    #[inline]
    pub fn set_D2(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(4usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 2u32) & (4usize as u8);
    }
    #[inline]
    pub fn PMED0(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u8)) >>
                                        3u32) as u8)
        }
    }
    #[inline]
    pub fn set_PMED0(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(8usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 3u32) & (8usize as u8);
    }
    #[inline]
    pub fn PMED1(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u8)) >>
                                        4u32) as u8)
        }
    }
    #[inline]
    pub fn set_PMED1(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(16usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 4u32) & (16usize as u8);
    }
    #[inline]
    pub fn PMED2(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u8)) >>
                                        5u32) as u8)
        }
    }
    #[inline]
    pub fn set_PMED2(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(32usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 5u32) & (32usize as u8);
    }
    #[inline]
    pub fn PMED3Hot(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u8)) >>
                                        6u32) as u8)
        }
    }
    #[inline]
    pub fn set_PMED3Hot(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(64usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 6u32) & (64usize as u8);
    }
    #[inline]
    pub fn PMED3Cold(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (128usize as u8)) >>
                                        7u32) as u8)
        }
    }
    #[inline]
    pub fn set_PMED3Cold(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(128usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 7u32) & (128usize as u8);
    }
}
#[test]
fn bindgen_test_layout__PCI_PMC() {
    assert_eq!(::core::mem::size_of::<_PCI_PMC>() , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_PMC>() , 1usize);
}
impl Clone for _PCI_PMC {
    fn clone(&self) -> Self { *self }
}
impl _PCI_PMC {
    #[inline]
    pub fn Version(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (7usize as u8)) >>
                                        0u32) as u8)
        }
    }
    #[inline]
    pub fn set_Version(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(7usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 0u32) & (7usize as u8);
    }
    #[inline]
    pub fn PMEClock(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u8)) >>
                                        3u32) as u8)
        }
    }
    #[inline]
    pub fn set_PMEClock(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(8usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 3u32) & (8usize as u8);
    }
    #[inline]
    pub fn Rsvd1(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u8)) >>
                                        4u32) as u8)
        }
    }
    #[inline]
    pub fn set_Rsvd1(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(16usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 4u32) & (16usize as u8);
    }
    #[inline]
    pub fn DeviceSpecificInitialization(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u8)) >>
                                        5u32) as u8)
        }
    }
    #[inline]
    pub fn set_DeviceSpecificInitialization(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(32usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 5u32) & (32usize as u8);
    }
    #[inline]
    pub fn Rsvd2(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (192usize as u8)) >>
                                        6u32) as u8)
        }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(192usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 6u32) & (192usize as u8);
    }
}
pub use self::_PCI_PMC as PCI_PMC;
pub type PPCI_PMC = *mut _PCI_PMC;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_PMCSR {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__PCI_PMCSR() {
    assert_eq!(::core::mem::size_of::<_PCI_PMCSR>() , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_PMCSR>() , 2usize);
}
impl Clone for _PCI_PMCSR {
    fn clone(&self) -> Self { *self }
}
impl _PCI_PMCSR {
    #[inline]
    pub fn PowerState(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (3usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_PowerState(&mut self, val: USHORT) {
        self._bitfield_1 &= !(3usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (3usize as u16);
    }
    #[inline]
    pub fn Rsvd1(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u16)) >>
                                        2u32) as u16)
        }
    }
    #[inline]
    pub fn set_Rsvd1(&mut self, val: USHORT) {
        self._bitfield_1 &= !(4usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 2u32) & (4usize as u16);
    }
    #[inline]
    pub fn NoSoftReset(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u16)) >>
                                        3u32) as u16)
        }
    }
    #[inline]
    pub fn set_NoSoftReset(&mut self, val: USHORT) {
        self._bitfield_1 &= !(8usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 3u32) & (8usize as u16);
    }
    #[inline]
    pub fn Rsvd2(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (240usize as u16)) >>
                                        4u32) as u16)
        }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: USHORT) {
        self._bitfield_1 &= !(240usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 4u32) & (240usize as u16);
    }
    #[inline]
    pub fn PMEEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (256usize as u16)) >>
                                        8u32) as u16)
        }
    }
    #[inline]
    pub fn set_PMEEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(256usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 8u32) & (256usize as u16);
    }
    #[inline]
    pub fn DataSelect(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (7680usize as u16)) >>
                                        9u32) as u16)
        }
    }
    #[inline]
    pub fn set_DataSelect(&mut self, val: USHORT) {
        self._bitfield_1 &= !(7680usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 9u32) & (7680usize as u16);
    }
    #[inline]
    pub fn DataScale(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (24576usize as u16))
                                        >> 13u32) as u16)
        }
    }
    #[inline]
    pub fn set_DataScale(&mut self, val: USHORT) {
        self._bitfield_1 &= !(24576usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 13u32) & (24576usize as u16);
    }
    #[inline]
    pub fn PMEStatus(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32768usize as u16))
                                        >> 15u32) as u16)
        }
    }
    #[inline]
    pub fn set_PMEStatus(&mut self, val: USHORT) {
        self._bitfield_1 &= !(32768usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 15u32) & (32768usize as u16);
    }
}
pub use self::_PCI_PMCSR as PCI_PMCSR;
pub type PPCI_PMCSR = *mut _PCI_PMCSR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_PMCSR_BSE {
    pub _bitfield_1: u8,
}
#[test]
fn bindgen_test_layout__PCI_PMCSR_BSE() {
    assert_eq!(::core::mem::size_of::<_PCI_PMCSR_BSE>() , 1usize);
    assert_eq!(::core::mem::align_of::<_PCI_PMCSR_BSE>() , 1usize);
}
impl Clone for _PCI_PMCSR_BSE {
    fn clone(&self) -> Self { *self }
}
impl _PCI_PMCSR_BSE {
    #[inline]
    pub fn Rsvd1(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (63usize as u8)) >>
                                        0u32) as u8)
        }
    }
    #[inline]
    pub fn set_Rsvd1(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(63usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 0u32) & (63usize as u8);
    }
    #[inline]
    pub fn D3HotSupportsStopClock(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u8)) >>
                                        6u32) as u8)
        }
    }
    #[inline]
    pub fn set_D3HotSupportsStopClock(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(64usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 6u32) & (64usize as u8);
    }
    #[inline]
    pub fn BusPowerClockControlEnabled(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (128usize as u8)) >>
                                        7u32) as u8)
        }
    }
    #[inline]
    pub fn set_BusPowerClockControlEnabled(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(128usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 7u32) & (128usize as u8);
    }
}
pub use self::_PCI_PMCSR_BSE as PCI_PMCSR_BSE;
pub type PPCI_PMCSR_BSE = *mut _PCI_PMCSR_BSE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_PM_CAPABILITY {
    pub Header: PCI_CAPABILITIES_HEADER,
    pub PMC: _PCI_PM_CAPABILITY__bindgen_ty_1,
    pub PMCSR: _PCI_PM_CAPABILITY__bindgen_ty_2,
    pub PMCSR_BSE: _PCI_PM_CAPABILITY__bindgen_ty_3,
    pub Data: UCHAR,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_PM_CAPABILITY__bindgen_ty_1 {
    pub Capabilities: __BindgenUnionField<PCI_PMC>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: u16,
}
#[test]
fn bindgen_test_layout__PCI_PM_CAPABILITY__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_PM_CAPABILITY__bindgen_ty_1>() ,
               2usize);
    assert_eq!(::core::mem::align_of::<_PCI_PM_CAPABILITY__bindgen_ty_1>() ,
               2usize);
}
impl Clone for _PCI_PM_CAPABILITY__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_PM_CAPABILITY__bindgen_ty_2 {
    pub ControlStatus: __BindgenUnionField<PCI_PMCSR>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: u16,
}
#[test]
fn bindgen_test_layout__PCI_PM_CAPABILITY__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<_PCI_PM_CAPABILITY__bindgen_ty_2>() ,
               2usize);
    assert_eq!(::core::mem::align_of::<_PCI_PM_CAPABILITY__bindgen_ty_2>() ,
               2usize);
}
impl Clone for _PCI_PM_CAPABILITY__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_PM_CAPABILITY__bindgen_ty_3 {
    pub BridgeSupport: __BindgenUnionField<PCI_PMCSR_BSE>,
    pub AsUCHAR: __BindgenUnionField<UCHAR>,
    pub bindgen_union_field: u8,
}
#[test]
fn bindgen_test_layout__PCI_PM_CAPABILITY__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<_PCI_PM_CAPABILITY__bindgen_ty_3>() ,
               1usize);
    assert_eq!(::core::mem::align_of::<_PCI_PM_CAPABILITY__bindgen_ty_3>() ,
               1usize);
}
impl Clone for _PCI_PM_CAPABILITY__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__PCI_PM_CAPABILITY() {
    assert_eq!(::core::mem::size_of::<_PCI_PM_CAPABILITY>() , 8usize);
    assert_eq!(::core::mem::align_of::<_PCI_PM_CAPABILITY>() , 2usize);
}
impl Clone for _PCI_PM_CAPABILITY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_PM_CAPABILITY as PCI_PM_CAPABILITY;
pub type PPCI_PM_CAPABILITY = *mut _PCI_PM_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_18 {
    pub Header: PCI_CAPABILITIES_HEADER,
    pub Command: _bindgen_ty_18__bindgen_ty_1,
    pub Status: _bindgen_ty_18__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_18__bindgen_ty_1 {
    pub bits: __BindgenUnionField<_bindgen_ty_18__bindgen_ty_1__bindgen_ty_1>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: u16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_18__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__bindgen_ty_18__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_bindgen_ty_18__bindgen_ty_1__bindgen_ty_1>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_bindgen_ty_18__bindgen_ty_1__bindgen_ty_1>()
               , 2usize);
}
impl Clone for _bindgen_ty_18__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _bindgen_ty_18__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn DataParityErrorRecoveryEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_DataParityErrorRecoveryEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn EnableRelaxedOrdering(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u16)) >>
                                        1u32) as u16)
        }
    }
    #[inline]
    pub fn set_EnableRelaxedOrdering(&mut self, val: USHORT) {
        self._bitfield_1 &= !(2usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 1u32) & (2usize as u16);
    }
    #[inline]
    pub fn MaxMemoryReadByteCount(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (12usize as u16)) >>
                                        2u32) as u16)
        }
    }
    #[inline]
    pub fn set_MaxMemoryReadByteCount(&mut self, val: USHORT) {
        self._bitfield_1 &= !(12usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 2u32) & (12usize as u16);
    }
    #[inline]
    pub fn MaxOutstandingSplitTransactions(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (112usize as u16)) >>
                                        4u32) as u16)
        }
    }
    #[inline]
    pub fn set_MaxOutstandingSplitTransactions(&mut self, val: USHORT) {
        self._bitfield_1 &= !(112usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 4u32) & (112usize as u16);
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65408usize as u16))
                                        >> 7u32) as u16)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        self._bitfield_1 &= !(65408usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 7u32) & (65408usize as u16);
    }
}
#[test]
fn bindgen_test_layout__bindgen_ty_18__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_bindgen_ty_18__bindgen_ty_1>() ,
               2usize);
    assert_eq!(::core::mem::align_of::<_bindgen_ty_18__bindgen_ty_1>() ,
               2usize);
}
impl Clone for _bindgen_ty_18__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_18__bindgen_ty_2 {
    pub bits: __BindgenUnionField<_bindgen_ty_18__bindgen_ty_2__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_18__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__bindgen_ty_18__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_bindgen_ty_18__bindgen_ty_2__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_bindgen_ty_18__bindgen_ty_2__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _bindgen_ty_18__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _bindgen_ty_18__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn FunctionNumber(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (7usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_FunctionNumber(&mut self, val: ULONG) {
        self._bitfield_1 &= !(7usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (7usize as u32);
    }
    #[inline]
    pub fn DeviceNumber(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (248usize as u32)) >>
                                        3u32) as u32)
        }
    }
    #[inline]
    pub fn set_DeviceNumber(&mut self, val: ULONG) {
        self._bitfield_1 &= !(248usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (248usize as u32);
    }
    #[inline]
    pub fn BusNumber(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65280usize as u32))
                                        >> 8u32) as u32)
        }
    }
    #[inline]
    pub fn set_BusNumber(&mut self, val: ULONG) {
        self._bitfield_1 &= !(65280usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 8u32) & (65280usize as u32);
    }
    #[inline]
    pub fn Device64Bit(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65536usize as u32))
                                        >> 16u32) as u32)
        }
    }
    #[inline]
    pub fn set_Device64Bit(&mut self, val: ULONG) {
        self._bitfield_1 &= !(65536usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (65536usize as u32);
    }
    #[inline]
    pub fn Capable133MHz(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (131072usize as u32))
                                        >> 17u32) as u32)
        }
    }
    #[inline]
    pub fn set_Capable133MHz(&mut self, val: ULONG) {
        self._bitfield_1 &= !(131072usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 17u32) & (131072usize as u32);
    }
    #[inline]
    pub fn SplitCompletionDiscarded(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (262144usize as u32))
                                        >> 18u32) as u32)
        }
    }
    #[inline]
    pub fn set_SplitCompletionDiscarded(&mut self, val: ULONG) {
        self._bitfield_1 &= !(262144usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 18u32) & (262144usize as u32);
    }
    #[inline]
    pub fn UnexpectedSplitCompletion(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (524288usize as u32))
                                        >> 19u32) as u32)
        }
    }
    #[inline]
    pub fn set_UnexpectedSplitCompletion(&mut self, val: ULONG) {
        self._bitfield_1 &= !(524288usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 19u32) & (524288usize as u32);
    }
    #[inline]
    pub fn DeviceComplexity(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1048576usize as u32))
                                        >> 20u32) as u32)
        }
    }
    #[inline]
    pub fn set_DeviceComplexity(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1048576usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 20u32) & (1048576usize as u32);
    }
    #[inline]
    pub fn DesignedMaxMemoryReadByteCount(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (6291456usize as u32))
                                        >> 21u32) as u32)
        }
    }
    #[inline]
    pub fn set_DesignedMaxMemoryReadByteCount(&mut self, val: ULONG) {
        self._bitfield_1 &= !(6291456usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 21u32) & (6291456usize as u32);
    }
    #[inline]
    pub fn DesignedMaxOutstandingSplitTransactions(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (58720256usize as u32)) >> 23u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_DesignedMaxOutstandingSplitTransactions(&mut self,
                                                       val: ULONG) {
        self._bitfield_1 &= !(58720256usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 23u32) & (58720256usize as u32);
    }
    #[inline]
    pub fn DesignedMaxCumulativeReadSize(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (469762048usize as u32)) >> 26u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_DesignedMaxCumulativeReadSize(&mut self, val: ULONG) {
        self._bitfield_1 &= !(469762048usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 26u32) & (469762048usize as u32);
    }
    #[inline]
    pub fn ReceivedSplitCompletionErrorMessage(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (536870912usize as u32)) >> 29u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_ReceivedSplitCompletionErrorMessage(&mut self, val: ULONG) {
        self._bitfield_1 &= !(536870912usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 29u32) & (536870912usize as u32);
    }
    #[inline]
    pub fn CapablePCIX266(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (1073741824usize as u32)) >> 30u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_CapablePCIX266(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1073741824usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 30u32) & (1073741824usize as u32);
    }
    #[inline]
    pub fn CapablePCIX533(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (2147483648usize as u32)) >> 31u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_CapablePCIX533(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2147483648usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 31u32) & (2147483648usize as u32);
    }
}
#[test]
fn bindgen_test_layout__bindgen_ty_18__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<_bindgen_ty_18__bindgen_ty_2>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_bindgen_ty_18__bindgen_ty_2>() ,
               4usize);
}
impl Clone for _bindgen_ty_18__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__bindgen_ty_18() {
    assert_eq!(::core::mem::size_of::<_bindgen_ty_18>() , 8usize);
    assert_eq!(::core::mem::align_of::<_bindgen_ty_18>() , 4usize);
}
impl Clone for _bindgen_ty_18 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_18 as PCI_X_CAPABILITY;
pub type PPCI_X_CAPABILITY = *mut _bindgen_ty_18;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER {
    pub CapabilityID: USHORT,
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER>()
               , 2usize);
}
impl Clone for _PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER {
    #[inline]
    pub fn Version(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (15usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_Version(&mut self, val: USHORT) {
        self._bitfield_1 &= !(15usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (15usize as u16);
    }
    #[inline]
    pub fn Next(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65520usize as u16))
                                        >> 4u32) as u16)
        }
    }
    #[inline]
    pub fn set_Next(&mut self, val: USHORT) {
        self._bitfield_1 &= !(65520usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 4u32) & (65520usize as u16);
    }
}
pub use self::_PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER as
        PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER;
pub type PPCI_EXPRESS_ENHANCED_CAPABILITY_HEADER =
    *mut _PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_VENDOR_SPECIFIC_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub VsecId: USHORT,
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_VENDOR_SPECIFIC_CAPABILITY() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_VENDOR_SPECIFIC_CAPABILITY>()
               , 8usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_VENDOR_SPECIFIC_CAPABILITY>()
               , 2usize);
}
impl Clone for _PCI_EXPRESS_VENDOR_SPECIFIC_CAPABILITY {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_VENDOR_SPECIFIC_CAPABILITY {
    #[inline]
    pub fn VsecRev(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (15usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_VsecRev(&mut self, val: USHORT) {
        self._bitfield_1 &= !(15usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (15usize as u16);
    }
    #[inline]
    pub fn VsecLength(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65520usize as u16))
                                        >> 4u32) as u16)
        }
    }
    #[inline]
    pub fn set_VsecLength(&mut self, val: USHORT) {
        self._bitfield_1 &= !(65520usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 4u32) & (65520usize as u16);
    }
}
pub use self::_PCI_EXPRESS_VENDOR_SPECIFIC_CAPABILITY as
        PCI_EXPRESS_VENDOR_SPECIFIC_CAPABILITY;
pub type PPCI_EXPRESS_VENDOR_SPECIFIC_CAPABILITY =
    *mut _PCI_EXPRESS_VENDOR_SPECIFIC_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_SERIAL_NUMBER_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub LowSerialNumber: ULONG,
    pub HighSerialNumber: ULONG,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_SERIAL_NUMBER_CAPABILITY() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_SERIAL_NUMBER_CAPABILITY>()
               , 12usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_SERIAL_NUMBER_CAPABILITY>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_SERIAL_NUMBER_CAPABILITY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_SERIAL_NUMBER_CAPABILITY as
        PCI_EXPRESS_SERIAL_NUMBER_CAPABILITY;
pub type PPCI_EXPRESS_SERIAL_NUMBER_CAPABILITY =
    *mut _PCI_EXPRESS_SERIAL_NUMBER_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_ARI_CAPABILITY_REGISTER {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_ARI_CAPABILITY_REGISTER() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_ARI_CAPABILITY_REGISTER>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_ARI_CAPABILITY_REGISTER>()
               , 2usize);
}
impl Clone for _PCI_EXPRESS_ARI_CAPABILITY_REGISTER {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_ARI_CAPABILITY_REGISTER {
    #[inline]
    pub fn MfvcFunctionGroupsCapability(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_MfvcFunctionGroupsCapability(&mut self, val: USHORT) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn AcsFunctionGroupsCapability(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u16)) >>
                                        1u32) as u16)
        }
    }
    #[inline]
    pub fn set_AcsFunctionGroupsCapability(&mut self, val: USHORT) {
        self._bitfield_1 &= !(2usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 1u32) & (2usize as u16);
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (252usize as u16)) >>
                                        2u32) as u16)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        self._bitfield_1 &= !(252usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 2u32) & (252usize as u16);
    }
    #[inline]
    pub fn NextFunctionNumber(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65280usize as u16))
                                        >> 8u32) as u16)
        }
    }
    #[inline]
    pub fn set_NextFunctionNumber(&mut self, val: USHORT) {
        self._bitfield_1 &= !(65280usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 8u32) & (65280usize as u16);
    }
}
pub use self::_PCI_EXPRESS_ARI_CAPABILITY_REGISTER as
        PCI_EXPRESS_ARI_CAPABILITY_REGISTER;
pub type PPCI_EXPRESS_ARI_CAPABILITY_REGISTER =
    *mut _PCI_EXPRESS_ARI_CAPABILITY_REGISTER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_ARI_CONTROL_REGISTER {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_ARI_CONTROL_REGISTER() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_ARI_CONTROL_REGISTER>() ,
               2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_ARI_CONTROL_REGISTER>() ,
               2usize);
}
impl Clone for _PCI_EXPRESS_ARI_CONTROL_REGISTER {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_ARI_CONTROL_REGISTER {
    #[inline]
    pub fn MfvcFunctionGroupsEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_MfvcFunctionGroupsEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn AcsFunctionGroupsEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u16)) >>
                                        1u32) as u16)
        }
    }
    #[inline]
    pub fn set_AcsFunctionGroupsEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(2usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 1u32) & (2usize as u16);
    }
    #[inline]
    pub fn Reserved1(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (12usize as u16)) >>
                                        2u32) as u16)
        }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: USHORT) {
        self._bitfield_1 &= !(12usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 2u32) & (12usize as u16);
    }
    #[inline]
    pub fn FunctionGroup(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (112usize as u16)) >>
                                        4u32) as u16)
        }
    }
    #[inline]
    pub fn set_FunctionGroup(&mut self, val: USHORT) {
        self._bitfield_1 &= !(112usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 4u32) & (112usize as u16);
    }
    #[inline]
    pub fn Reserved2(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65408usize as u16))
                                        >> 7u32) as u16)
        }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: USHORT) {
        self._bitfield_1 &= !(65408usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 7u32) & (65408usize as u16);
    }
}
pub use self::_PCI_EXPRESS_ARI_CONTROL_REGISTER as
        PCI_EXPRESS_ARI_CONTROL_REGISTER;
pub type PPCI_EXPRESS_ARI_CONTROL_REGISTER =
    *mut _PCI_EXPRESS_ARI_CONTROL_REGISTER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_ARI_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub Capability: PCI_EXPRESS_ARI_CAPABILITY_REGISTER,
    pub Control: PCI_EXPRESS_ARI_CONTROL_REGISTER,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_ARI_CAPABILITY() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_ARI_CAPABILITY>() ,
               8usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_ARI_CAPABILITY>() ,
               2usize);
}
impl Clone for _PCI_EXPRESS_ARI_CAPABILITY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_ARI_CAPABILITY as PCI_EXPRESS_ARI_CAPABILITY;
pub type PPCI_EXPRESS_ARI_CAPABILITY = *mut _PCI_EXPRESS_ARI_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VIRTUAL_CHANNEL_CAPABILITIES1 {
    pub __bindgen_anon_1: __BindgenUnionField<_VIRTUAL_CHANNEL_CAPABILITIES1__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VIRTUAL_CHANNEL_CAPABILITIES1__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__VIRTUAL_CHANNEL_CAPABILITIES1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_VIRTUAL_CHANNEL_CAPABILITIES1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_VIRTUAL_CHANNEL_CAPABILITIES1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VIRTUAL_CHANNEL_CAPABILITIES1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VIRTUAL_CHANNEL_CAPABILITIES1__bindgen_ty_1 {
    #[inline]
    pub fn ExtendedVCCount(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (3usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_ExtendedVCCount(&mut self, val: ULONG) {
        self._bitfield_1 &= !(3usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (3usize as u32);
    }
    #[inline]
    pub fn RsvdP1(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                        2u32) as u32)
        }
    }
    #[inline]
    pub fn set_RsvdP1(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn LowPriorityExtendedVCCount(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (24usize as u32)) >>
                                        3u32) as u32)
        }
    }
    #[inline]
    pub fn set_LowPriorityExtendedVCCount(&mut self, val: ULONG) {
        self._bitfield_1 &= !(24usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (24usize as u32);
    }
    #[inline]
    pub fn RsvdP2(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u32)) >>
                                        5u32) as u32)
        }
    }
    #[inline]
    pub fn set_RsvdP2(&mut self, val: ULONG) {
        self._bitfield_1 &= !(32usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (32usize as u32);
    }
    #[inline]
    pub fn ReferenceClock(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (192usize as u32)) >>
                                        6u32) as u32)
        }
    }
    #[inline]
    pub fn set_ReferenceClock(&mut self, val: ULONG) {
        self._bitfield_1 &= !(192usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 6u32) & (192usize as u32);
    }
    #[inline]
    pub fn PortArbitrationTableEntrySize(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (768usize as u32)) >>
                                        8u32) as u32)
        }
    }
    #[inline]
    pub fn set_PortArbitrationTableEntrySize(&mut self, val: ULONG) {
        self._bitfield_1 &= !(768usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 8u32) & (768usize as u32);
    }
    #[inline]
    pub fn RsvdP3(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (1073740800usize as u32)) >> 10u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_RsvdP3(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1073740800usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 10u32) & (1073740800usize as u32);
    }
}
#[test]
fn bindgen_test_layout__VIRTUAL_CHANNEL_CAPABILITIES1() {
    assert_eq!(::core::mem::size_of::<_VIRTUAL_CHANNEL_CAPABILITIES1>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_VIRTUAL_CHANNEL_CAPABILITIES1>() ,
               4usize);
}
impl Clone for _VIRTUAL_CHANNEL_CAPABILITIES1 {
    fn clone(&self) -> Self { *self }
}
pub use self::_VIRTUAL_CHANNEL_CAPABILITIES1 as VIRTUAL_CHANNEL_CAPABILITIES1;
pub type PVIRTUAL_CHANNEL_CAPABILITIES1 = *mut _VIRTUAL_CHANNEL_CAPABILITIES1;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VIRTUAL_CHANNEL_CAPABILITIES2 {
    pub __bindgen_anon_1: __BindgenUnionField<_VIRTUAL_CHANNEL_CAPABILITIES2__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VIRTUAL_CHANNEL_CAPABILITIES2__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__VIRTUAL_CHANNEL_CAPABILITIES2__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_VIRTUAL_CHANNEL_CAPABILITIES2__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_VIRTUAL_CHANNEL_CAPABILITIES2__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VIRTUAL_CHANNEL_CAPABILITIES2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VIRTUAL_CHANNEL_CAPABILITIES2__bindgen_ty_1 {
    #[inline]
    pub fn VCArbitrationCapability(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (255usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_VCArbitrationCapability(&mut self, val: ULONG) {
        self._bitfield_1 &= !(255usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (255usize as u32);
    }
    #[inline]
    pub fn RsvdP(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (16776960usize as u32)) >> 8u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_RsvdP(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16776960usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 8u32) & (16776960usize as u32);
    }
    #[inline]
    pub fn VCArbitrationTableOffset(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4278190080usize as u32)) >> 24u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_VCArbitrationTableOffset(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4278190080usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 24u32) & (4278190080usize as u32);
    }
}
#[test]
fn bindgen_test_layout__VIRTUAL_CHANNEL_CAPABILITIES2() {
    assert_eq!(::core::mem::size_of::<_VIRTUAL_CHANNEL_CAPABILITIES2>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_VIRTUAL_CHANNEL_CAPABILITIES2>() ,
               4usize);
}
impl Clone for _VIRTUAL_CHANNEL_CAPABILITIES2 {
    fn clone(&self) -> Self { *self }
}
pub use self::_VIRTUAL_CHANNEL_CAPABILITIES2 as VIRTUAL_CHANNEL_CAPABILITIES2;
pub type PVIRTUAL_CHANNEL_CAPABILITIES2 = *mut _VIRTUAL_CHANNEL_CAPABILITIES2;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VIRTUAL_CHANNEL_CONTROL {
    pub __bindgen_anon_1: __BindgenUnionField<_VIRTUAL_CHANNEL_CONTROL__bindgen_ty_1>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: u16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VIRTUAL_CHANNEL_CONTROL__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__VIRTUAL_CHANNEL_CONTROL__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_VIRTUAL_CHANNEL_CONTROL__bindgen_ty_1>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_VIRTUAL_CHANNEL_CONTROL__bindgen_ty_1>()
               , 2usize);
}
impl Clone for _VIRTUAL_CHANNEL_CONTROL__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VIRTUAL_CHANNEL_CONTROL__bindgen_ty_1 {
    #[inline]
    pub fn LoadVCArbitrationTable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_LoadVCArbitrationTable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn VCArbitrationSelect(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (14usize as u16)) >>
                                        1u32) as u16)
        }
    }
    #[inline]
    pub fn set_VCArbitrationSelect(&mut self, val: USHORT) {
        self._bitfield_1 &= !(14usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 1u32) & (14usize as u16);
    }
    #[inline]
    pub fn RsvdP(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65520usize as u16))
                                        >> 4u32) as u16)
        }
    }
    #[inline]
    pub fn set_RsvdP(&mut self, val: USHORT) {
        self._bitfield_1 &= !(65520usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 4u32) & (65520usize as u16);
    }
}
#[test]
fn bindgen_test_layout__VIRTUAL_CHANNEL_CONTROL() {
    assert_eq!(::core::mem::size_of::<_VIRTUAL_CHANNEL_CONTROL>() , 2usize);
    assert_eq!(::core::mem::align_of::<_VIRTUAL_CHANNEL_CONTROL>() , 2usize);
}
impl Clone for _VIRTUAL_CHANNEL_CONTROL {
    fn clone(&self) -> Self { *self }
}
pub use self::_VIRTUAL_CHANNEL_CONTROL as VIRTUAL_CHANNEL_CONTROL;
pub type PVIRTUAL_CHANNEL_CONTROL = *mut _VIRTUAL_CHANNEL_CONTROL;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VIRTUAL_CHANNEL_STATUS {
    pub __bindgen_anon_1: __BindgenUnionField<_VIRTUAL_CHANNEL_STATUS__bindgen_ty_1>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: u16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VIRTUAL_CHANNEL_STATUS__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__VIRTUAL_CHANNEL_STATUS__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_VIRTUAL_CHANNEL_STATUS__bindgen_ty_1>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_VIRTUAL_CHANNEL_STATUS__bindgen_ty_1>()
               , 2usize);
}
impl Clone for _VIRTUAL_CHANNEL_STATUS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VIRTUAL_CHANNEL_STATUS__bindgen_ty_1 {
    #[inline]
    pub fn VCArbitrationTableStatus(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_VCArbitrationTableStatus(&mut self, val: USHORT) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn RsvdZ(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65534usize as u16))
                                        >> 1u32) as u16)
        }
    }
    #[inline]
    pub fn set_RsvdZ(&mut self, val: USHORT) {
        self._bitfield_1 &= !(65534usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 1u32) & (65534usize as u16);
    }
}
#[test]
fn bindgen_test_layout__VIRTUAL_CHANNEL_STATUS() {
    assert_eq!(::core::mem::size_of::<_VIRTUAL_CHANNEL_STATUS>() , 2usize);
    assert_eq!(::core::mem::align_of::<_VIRTUAL_CHANNEL_STATUS>() , 2usize);
}
impl Clone for _VIRTUAL_CHANNEL_STATUS {
    fn clone(&self) -> Self { *self }
}
pub use self::_VIRTUAL_CHANNEL_STATUS as VIRTUAL_CHANNEL_STATUS;
pub type PVIRTUAL_CHANNEL_STATUS = *mut _VIRTUAL_CHANNEL_STATUS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VIRTUAL_RESOURCE_CAPABILITY {
    pub __bindgen_anon_1: __BindgenUnionField<_VIRTUAL_RESOURCE_CAPABILITY__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VIRTUAL_RESOURCE_CAPABILITY__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__VIRTUAL_RESOURCE_CAPABILITY__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_VIRTUAL_RESOURCE_CAPABILITY__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_VIRTUAL_RESOURCE_CAPABILITY__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VIRTUAL_RESOURCE_CAPABILITY__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VIRTUAL_RESOURCE_CAPABILITY__bindgen_ty_1 {
    #[inline]
    pub fn PortArbitrationCapability(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (255usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_PortArbitrationCapability(&mut self, val: ULONG) {
        self._bitfield_1 &= !(255usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (255usize as u32);
    }
    #[inline]
    pub fn RsvdP1(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16128usize as u32))
                                        >> 8u32) as u32)
        }
    }
    #[inline]
    pub fn set_RsvdP1(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16128usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 8u32) & (16128usize as u32);
    }
    #[inline]
    pub fn Undefined(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16384usize as u32))
                                        >> 14u32) as u32)
        }
    }
    #[inline]
    pub fn set_Undefined(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16384usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 14u32) & (16384usize as u32);
    }
    #[inline]
    pub fn RejectSnoopTransactions(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32768usize as u32))
                                        >> 15u32) as u32)
        }
    }
    #[inline]
    pub fn set_RejectSnoopTransactions(&mut self, val: ULONG) {
        self._bitfield_1 &= !(32768usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 15u32) & (32768usize as u32);
    }
    #[inline]
    pub fn MaximumTimeSlots(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8323072usize as u32))
                                        >> 16u32) as u32)
        }
    }
    #[inline]
    pub fn set_MaximumTimeSlots(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8323072usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (8323072usize as u32);
    }
    #[inline]
    pub fn RsvdP2(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8388608usize as u32))
                                        >> 23u32) as u32)
        }
    }
    #[inline]
    pub fn set_RsvdP2(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8388608usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 23u32) & (8388608usize as u32);
    }
    #[inline]
    pub fn PortArbitrationTableOffset(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4278190080usize as u32)) >> 24u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_PortArbitrationTableOffset(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4278190080usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 24u32) & (4278190080usize as u32);
    }
}
#[test]
fn bindgen_test_layout__VIRTUAL_RESOURCE_CAPABILITY() {
    assert_eq!(::core::mem::size_of::<_VIRTUAL_RESOURCE_CAPABILITY>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_VIRTUAL_RESOURCE_CAPABILITY>() ,
               4usize);
}
impl Clone for _VIRTUAL_RESOURCE_CAPABILITY {
    fn clone(&self) -> Self { *self }
}
pub use self::_VIRTUAL_RESOURCE_CAPABILITY as VIRTUAL_RESOURCE_CAPABILITY;
pub type PVIRTUAL_RESOURCE_CAPABILITY = *mut _VIRTUAL_RESOURCE_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VIRTUAL_RESOURCE_CONTROL {
    pub __bindgen_anon_1: __BindgenUnionField<_VIRTUAL_RESOURCE_CONTROL__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VIRTUAL_RESOURCE_CONTROL__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__VIRTUAL_RESOURCE_CONTROL__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_VIRTUAL_RESOURCE_CONTROL__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_VIRTUAL_RESOURCE_CONTROL__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VIRTUAL_RESOURCE_CONTROL__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VIRTUAL_RESOURCE_CONTROL__bindgen_ty_1 {
    #[inline]
    pub fn TcVcMap(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (255usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_TcVcMap(&mut self, val: ULONG) {
        self._bitfield_1 &= !(255usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (255usize as u32);
    }
    #[inline]
    pub fn RsvdP1(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65280usize as u32))
                                        >> 8u32) as u32)
        }
    }
    #[inline]
    pub fn set_RsvdP1(&mut self, val: ULONG) {
        self._bitfield_1 &= !(65280usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 8u32) & (65280usize as u32);
    }
    #[inline]
    pub fn LoadPortArbitrationTable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65536usize as u32))
                                        >> 16u32) as u32)
        }
    }
    #[inline]
    pub fn set_LoadPortArbitrationTable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(65536usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (65536usize as u32);
    }
    #[inline]
    pub fn PortArbitrationSelect(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (917504usize as u32))
                                        >> 17u32) as u32)
        }
    }
    #[inline]
    pub fn set_PortArbitrationSelect(&mut self, val: ULONG) {
        self._bitfield_1 &= !(917504usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 17u32) & (917504usize as u32);
    }
    #[inline]
    pub fn RsvdP2(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (15728640usize as u32)) >> 20u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_RsvdP2(&mut self, val: ULONG) {
        self._bitfield_1 &= !(15728640usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 20u32) & (15728640usize as u32);
    }
    #[inline]
    pub fn VcID(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (117440512usize as u32)) >> 24u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_VcID(&mut self, val: ULONG) {
        self._bitfield_1 &= !(117440512usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 24u32) & (117440512usize as u32);
    }
    #[inline]
    pub fn RsvdP3(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (2013265920usize as u32)) >> 27u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_RsvdP3(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2013265920usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 27u32) & (2013265920usize as u32);
    }
    #[inline]
    pub fn VcEnable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (2147483648usize as u32)) >> 31u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_VcEnable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2147483648usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 31u32) & (2147483648usize as u32);
    }
}
#[test]
fn bindgen_test_layout__VIRTUAL_RESOURCE_CONTROL() {
    assert_eq!(::core::mem::size_of::<_VIRTUAL_RESOURCE_CONTROL>() , 4usize);
    assert_eq!(::core::mem::align_of::<_VIRTUAL_RESOURCE_CONTROL>() , 4usize);
}
impl Clone for _VIRTUAL_RESOURCE_CONTROL {
    fn clone(&self) -> Self { *self }
}
pub use self::_VIRTUAL_RESOURCE_CONTROL as VIRTUAL_RESOURCE_CONTROL;
pub type PVIRTUAL_RESOURCE_CONTROL = *mut _VIRTUAL_RESOURCE_CONTROL;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VIRTUAL_RESOURCE_STATUS {
    pub __bindgen_anon_1: __BindgenUnionField<_VIRTUAL_RESOURCE_STATUS__bindgen_ty_1>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: u16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VIRTUAL_RESOURCE_STATUS__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__VIRTUAL_RESOURCE_STATUS__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_VIRTUAL_RESOURCE_STATUS__bindgen_ty_1>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_VIRTUAL_RESOURCE_STATUS__bindgen_ty_1>()
               , 2usize);
}
impl Clone for _VIRTUAL_RESOURCE_STATUS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VIRTUAL_RESOURCE_STATUS__bindgen_ty_1 {
    #[inline]
    pub fn PortArbitrationTableStatus(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_PortArbitrationTableStatus(&mut self, val: USHORT) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn VcNegotiationPending(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u16)) >>
                                        1u32) as u16)
        }
    }
    #[inline]
    pub fn set_VcNegotiationPending(&mut self, val: USHORT) {
        self._bitfield_1 &= !(2usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 1u32) & (2usize as u16);
    }
    #[inline]
    pub fn RsvdZ(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65532usize as u16))
                                        >> 2u32) as u16)
        }
    }
    #[inline]
    pub fn set_RsvdZ(&mut self, val: USHORT) {
        self._bitfield_1 &= !(65532usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 2u32) & (65532usize as u16);
    }
}
#[test]
fn bindgen_test_layout__VIRTUAL_RESOURCE_STATUS() {
    assert_eq!(::core::mem::size_of::<_VIRTUAL_RESOURCE_STATUS>() , 2usize);
    assert_eq!(::core::mem::align_of::<_VIRTUAL_RESOURCE_STATUS>() , 2usize);
}
impl Clone for _VIRTUAL_RESOURCE_STATUS {
    fn clone(&self) -> Self { *self }
}
pub use self::_VIRTUAL_RESOURCE_STATUS as VIRTUAL_RESOURCE_STATUS;
pub type PVIRTUAL_RESOURCE_STATUS = *mut _VIRTUAL_RESOURCE_STATUS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VIRTUAL_RESOURCE {
    pub Capability: VIRTUAL_RESOURCE_CAPABILITY,
    pub Control: VIRTUAL_RESOURCE_CONTROL,
    pub RsvdP: USHORT,
    pub Status: VIRTUAL_RESOURCE_STATUS,
}
#[test]
fn bindgen_test_layout__VIRTUAL_RESOURCE() {
    assert_eq!(::core::mem::size_of::<_VIRTUAL_RESOURCE>() , 12usize);
    assert_eq!(::core::mem::align_of::<_VIRTUAL_RESOURCE>() , 4usize);
}
impl Clone for _VIRTUAL_RESOURCE {
    fn clone(&self) -> Self { *self }
}
pub use self::_VIRTUAL_RESOURCE as VIRTUAL_RESOURCE;
pub type PVIRTUAL_RESOURCE = *mut _VIRTUAL_RESOURCE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_VIRTUAL_CHANNEL_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub Capabilities1: VIRTUAL_CHANNEL_CAPABILITIES1,
    pub Capabilities2: VIRTUAL_CHANNEL_CAPABILITIES2,
    pub Control: VIRTUAL_CHANNEL_CONTROL,
    pub Status: VIRTUAL_CHANNEL_STATUS,
    pub Resource: [VIRTUAL_RESOURCE; 8usize],
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_VIRTUAL_CHANNEL_CAPABILITY() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_VIRTUAL_CHANNEL_CAPABILITY>()
               , 112usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_VIRTUAL_CHANNEL_CAPABILITY>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_VIRTUAL_CHANNEL_CAPABILITY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_VIRTUAL_CHANNEL_CAPABILITY as
        PCI_EXPRESS_VIRTUAL_CHANNEL_CAPABILITY;
pub type PPCI_EXPRESS_VIRTUAL_CHANNEL_CAPABILITY =
    *mut _PCI_EXPRESS_VIRTUAL_CHANNEL_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_ATS_CAPABILITY_REGISTER {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_ATS_CAPABILITY_REGISTER() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_ATS_CAPABILITY_REGISTER>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_ATS_CAPABILITY_REGISTER>()
               , 2usize);
}
impl Clone for _PCI_EXPRESS_ATS_CAPABILITY_REGISTER {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_ATS_CAPABILITY_REGISTER {
    #[inline]
    pub fn InvalidateQueueDepth(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (31usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_InvalidateQueueDepth(&mut self, val: USHORT) {
        self._bitfield_1 &= !(31usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (31usize as u16);
    }
    #[inline]
    pub fn PageAlignedRequest(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u16)) >>
                                        5u32) as u16)
        }
    }
    #[inline]
    pub fn set_PageAlignedRequest(&mut self, val: USHORT) {
        self._bitfield_1 &= !(32usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 5u32) & (32usize as u16);
    }
    #[inline]
    pub fn GlobalInvalidateSupported(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u16)) >>
                                        6u32) as u16)
        }
    }
    #[inline]
    pub fn set_GlobalInvalidateSupported(&mut self, val: USHORT) {
        self._bitfield_1 &= !(64usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 6u32) & (64usize as u16);
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65408usize as u16))
                                        >> 7u32) as u16)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        self._bitfield_1 &= !(65408usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 7u32) & (65408usize as u16);
    }
}
pub use self::_PCI_EXPRESS_ATS_CAPABILITY_REGISTER as
        PCI_EXPRESS_ATS_CAPABILITY_REGISTER;
pub type PPCI_EXPRESS_ATS_CAPABILITY_REGISTER =
    *mut _PCI_EXPRESS_ATS_CAPABILITY_REGISTER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_ATS_CONTROL_REGISTER {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_ATS_CONTROL_REGISTER() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_ATS_CONTROL_REGISTER>() ,
               2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_ATS_CONTROL_REGISTER>() ,
               2usize);
}
impl Clone for _PCI_EXPRESS_ATS_CONTROL_REGISTER {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_ATS_CONTROL_REGISTER {
    #[inline]
    pub fn SmallestTransactionUnit(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (31usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_SmallestTransactionUnit(&mut self, val: USHORT) {
        self._bitfield_1 &= !(31usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (31usize as u16);
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32736usize as u16))
                                        >> 5u32) as u16)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        self._bitfield_1 &= !(32736usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 5u32) & (32736usize as u16);
    }
    #[inline]
    pub fn Enable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32768usize as u16))
                                        >> 15u32) as u16)
        }
    }
    #[inline]
    pub fn set_Enable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(32768usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 15u32) & (32768usize as u16);
    }
}
pub use self::_PCI_EXPRESS_ATS_CONTROL_REGISTER as
        PCI_EXPRESS_ATS_CONTROL_REGISTER;
pub type PPCI_EXPRESS_ATS_CONTROL_REGISTER =
    *mut _PCI_EXPRESS_ATS_CONTROL_REGISTER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_ATS_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub Capability: PCI_EXPRESS_ATS_CAPABILITY_REGISTER,
    pub Control: PCI_EXPRESS_ATS_CONTROL_REGISTER,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_ATS_CAPABILITY() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_ATS_CAPABILITY>() ,
               8usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_ATS_CAPABILITY>() ,
               2usize);
}
impl Clone for _PCI_EXPRESS_ATS_CAPABILITY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_ATS_CAPABILITY as PCI_EXPRESS_ATS_CAPABILITY;
pub type PPCI_EXPRESS_ATS_CAPABILITY = *mut _PCI_EXPRESS_ATS_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_PASID_CAPABILITY_REGISTER {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_PASID_CAPABILITY_REGISTER__bindgen_ty_1>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: u16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_PASID_CAPABILITY_REGISTER__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_PASID_CAPABILITY_REGISTER__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_PASID_CAPABILITY_REGISTER__bindgen_ty_1>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_PASID_CAPABILITY_REGISTER__bindgen_ty_1>()
               , 2usize);
}
impl Clone for _PCI_EXPRESS_PASID_CAPABILITY_REGISTER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_PASID_CAPABILITY_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn Rsvd(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: USHORT) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn ExecutePermissionSupported(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u16)) >>
                                        1u32) as u16)
        }
    }
    #[inline]
    pub fn set_ExecutePermissionSupported(&mut self, val: USHORT) {
        self._bitfield_1 &= !(2usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 1u32) & (2usize as u16);
    }
    #[inline]
    pub fn PrivilegedModeSupported(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u16)) >>
                                        2u32) as u16)
        }
    }
    #[inline]
    pub fn set_PrivilegedModeSupported(&mut self, val: USHORT) {
        self._bitfield_1 &= !(4usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 2u32) & (4usize as u16);
    }
    #[inline]
    pub fn Rsvd2(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (248usize as u16)) >>
                                        3u32) as u16)
        }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: USHORT) {
        self._bitfield_1 &= !(248usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 3u32) & (248usize as u16);
    }
    #[inline]
    pub fn MaxPASIDWidth(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (7936usize as u16)) >>
                                        8u32) as u16)
        }
    }
    #[inline]
    pub fn set_MaxPASIDWidth(&mut self, val: USHORT) {
        self._bitfield_1 &= !(7936usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 8u32) & (7936usize as u16);
    }
    #[inline]
    pub fn Rsvd3(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (57344usize as u16))
                                        >> 13u32) as u16)
        }
    }
    #[inline]
    pub fn set_Rsvd3(&mut self, val: USHORT) {
        self._bitfield_1 &= !(57344usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 13u32) & (57344usize as u16);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_PASID_CAPABILITY_REGISTER() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_PASID_CAPABILITY_REGISTER>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_PASID_CAPABILITY_REGISTER>()
               , 2usize);
}
impl Clone for _PCI_EXPRESS_PASID_CAPABILITY_REGISTER {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_PASID_CAPABILITY_REGISTER as
        PCI_EXPRESS_PASID_CAPABILITY_REGISTER;
pub type PPCI_EXPRESS_PASID_CAPABILITY_REGISTER =
    *mut _PCI_EXPRESS_PASID_CAPABILITY_REGISTER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_PASID_CONTROL_REGISTER {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_PASID_CONTROL_REGISTER__bindgen_ty_1>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: u16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_PASID_CONTROL_REGISTER__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_PASID_CONTROL_REGISTER__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_PASID_CONTROL_REGISTER__bindgen_ty_1>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_PASID_CONTROL_REGISTER__bindgen_ty_1>()
               , 2usize);
}
impl Clone for _PCI_EXPRESS_PASID_CONTROL_REGISTER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_PASID_CONTROL_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn PASIDEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_PASIDEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn ExecutePermissionEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u16)) >>
                                        1u32) as u16)
        }
    }
    #[inline]
    pub fn set_ExecutePermissionEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(2usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 1u32) & (2usize as u16);
    }
    #[inline]
    pub fn PrivilegedModeEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u16)) >>
                                        2u32) as u16)
        }
    }
    #[inline]
    pub fn set_PrivilegedModeEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(4usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 2u32) & (4usize as u16);
    }
    #[inline]
    pub fn Rsvd(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65528usize as u16))
                                        >> 3u32) as u16)
        }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: USHORT) {
        self._bitfield_1 &= !(65528usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 3u32) & (65528usize as u16);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_PASID_CONTROL_REGISTER() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_PASID_CONTROL_REGISTER>() ,
               2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_PASID_CONTROL_REGISTER>()
               , 2usize);
}
impl Clone for _PCI_EXPRESS_PASID_CONTROL_REGISTER {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_PASID_CONTROL_REGISTER as
        PCI_EXPRESS_PASID_CONTROL_REGISTER;
pub type PPCI_EXPRESS_PASID_CONTROL_REGISTER =
    *mut _PCI_EXPRESS_PASID_CONTROL_REGISTER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_PASID_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub Capability: PCI_EXPRESS_PASID_CAPABILITY_REGISTER,
    pub Control: PCI_EXPRESS_PASID_CONTROL_REGISTER,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_PASID_CAPABILITY() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_PASID_CAPABILITY>() ,
               8usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_PASID_CAPABILITY>() ,
               2usize);
}
impl Clone for _PCI_EXPRESS_PASID_CAPABILITY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_PASID_CAPABILITY as PCI_EXPRESS_PASID_CAPABILITY;
pub type PPCI_EXPRESS_PASID_CAPABILITY = *mut _PCI_EXPRESS_PASID_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_PRI_STATUS_REGISTER {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_PRI_STATUS_REGISTER__bindgen_ty_1>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: u16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_PRI_STATUS_REGISTER__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_PRI_STATUS_REGISTER__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_PRI_STATUS_REGISTER__bindgen_ty_1>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_PRI_STATUS_REGISTER__bindgen_ty_1>()
               , 2usize);
}
impl Clone for _PCI_EXPRESS_PRI_STATUS_REGISTER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_PRI_STATUS_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn ResponseFailure(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_ResponseFailure(&mut self, val: USHORT) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn UnexpectedPageRequestGroupIndex(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u16)) >>
                                        1u32) as u16)
        }
    }
    #[inline]
    pub fn set_UnexpectedPageRequestGroupIndex(&mut self, val: USHORT) {
        self._bitfield_1 &= !(2usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 1u32) & (2usize as u16);
    }
    #[inline]
    pub fn Rsvd(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (252usize as u16)) >>
                                        2u32) as u16)
        }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: USHORT) {
        self._bitfield_1 &= !(252usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 2u32) & (252usize as u16);
    }
    #[inline]
    pub fn Stopped(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (256usize as u16)) >>
                                        8u32) as u16)
        }
    }
    #[inline]
    pub fn set_Stopped(&mut self, val: USHORT) {
        self._bitfield_1 &= !(256usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 8u32) & (256usize as u16);
    }
    #[inline]
    pub fn Rsvd2(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32256usize as u16))
                                        >> 9u32) as u16)
        }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: USHORT) {
        self._bitfield_1 &= !(32256usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 9u32) & (32256usize as u16);
    }
    #[inline]
    pub fn PrgResponsePasidRequired(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32768usize as u16))
                                        >> 15u32) as u16)
        }
    }
    #[inline]
    pub fn set_PrgResponsePasidRequired(&mut self, val: USHORT) {
        self._bitfield_1 &= !(32768usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 15u32) & (32768usize as u16);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_PRI_STATUS_REGISTER() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_PRI_STATUS_REGISTER>() ,
               2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_PRI_STATUS_REGISTER>() ,
               2usize);
}
impl Clone for _PCI_EXPRESS_PRI_STATUS_REGISTER {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_PRI_STATUS_REGISTER as
        PCI_EXPRESS_PRI_STATUS_REGISTER;
pub type PPCI_EXPRESS_PRI_STATUS_REGISTER =
    *mut _PCI_EXPRESS_PRI_STATUS_REGISTER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_PRI_CONTROL_REGISTER {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_PRI_CONTROL_REGISTER__bindgen_ty_1>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: u16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_PRI_CONTROL_REGISTER__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_PRI_CONTROL_REGISTER__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_PRI_CONTROL_REGISTER__bindgen_ty_1>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_PRI_CONTROL_REGISTER__bindgen_ty_1>()
               , 2usize);
}
impl Clone for _PCI_EXPRESS_PRI_CONTROL_REGISTER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_PRI_CONTROL_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn Enable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_Enable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn Reset(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u16)) >>
                                        1u32) as u16)
        }
    }
    #[inline]
    pub fn set_Reset(&mut self, val: USHORT) {
        self._bitfield_1 &= !(2usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 1u32) & (2usize as u16);
    }
    #[inline]
    pub fn Rsvd(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65532usize as u16))
                                        >> 2u32) as u16)
        }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: USHORT) {
        self._bitfield_1 &= !(65532usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 2u32) & (65532usize as u16);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_PRI_CONTROL_REGISTER() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_PRI_CONTROL_REGISTER>() ,
               2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_PRI_CONTROL_REGISTER>() ,
               2usize);
}
impl Clone for _PCI_EXPRESS_PRI_CONTROL_REGISTER {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_PRI_CONTROL_REGISTER as
        PCI_EXPRESS_PRI_CONTROL_REGISTER;
pub type PPCI_EXPRESS_PRI_CONTROL_REGISTER =
    *mut _PCI_EXPRESS_PRI_CONTROL_REGISTER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_PRI_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub Control: PCI_EXPRESS_PRI_CONTROL_REGISTER,
    pub Status: PCI_EXPRESS_PRI_STATUS_REGISTER,
    pub PRCapacity: ULONG,
    pub PRAllocation: ULONG,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_PRI_CAPABILITY() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_PRI_CAPABILITY>() ,
               16usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_PRI_CAPABILITY>() ,
               4usize);
}
impl Clone for _PCI_EXPRESS_PRI_CAPABILITY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_PRI_CAPABILITY as PCI_EXPRESS_PRI_CAPABILITY;
pub type PPCI_EXPRESS_PRI_CAPABILITY = *mut _PCI_EXPRESS_PRI_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS__bindgen_ty_1 {
    #[inline]
    pub fn Undefined(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_Undefined(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (14usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        self._bitfield_1 &= !(14usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (14usize as u32);
    }
    #[inline]
    pub fn DataLinkProtocolError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u32)) >>
                                        4u32) as u32)
        }
    }
    #[inline]
    pub fn set_DataLinkProtocolError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (16usize as u32);
    }
    #[inline]
    pub fn SurpriseDownError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u32)) >>
                                        5u32) as u32)
        }
    }
    #[inline]
    pub fn set_SurpriseDownError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(32usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (32usize as u32);
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4032usize as u32)) >>
                                        6u32) as u32)
        }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4032usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 6u32) & (4032usize as u32);
    }
    #[inline]
    pub fn PoisonedTLP(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4096usize as u32)) >>
                                        12u32) as u32)
        }
    }
    #[inline]
    pub fn set_PoisonedTLP(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4096usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 12u32) & (4096usize as u32);
    }
    #[inline]
    pub fn FlowControlProtocolError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8192usize as u32)) >>
                                        13u32) as u32)
        }
    }
    #[inline]
    pub fn set_FlowControlProtocolError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8192usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 13u32) & (8192usize as u32);
    }
    #[inline]
    pub fn CompletionTimeout(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16384usize as u32))
                                        >> 14u32) as u32)
        }
    }
    #[inline]
    pub fn set_CompletionTimeout(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16384usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 14u32) & (16384usize as u32);
    }
    #[inline]
    pub fn CompleterAbort(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32768usize as u32))
                                        >> 15u32) as u32)
        }
    }
    #[inline]
    pub fn set_CompleterAbort(&mut self, val: ULONG) {
        self._bitfield_1 &= !(32768usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 15u32) & (32768usize as u32);
    }
    #[inline]
    pub fn UnexpectedCompletion(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65536usize as u32))
                                        >> 16u32) as u32)
        }
    }
    #[inline]
    pub fn set_UnexpectedCompletion(&mut self, val: ULONG) {
        self._bitfield_1 &= !(65536usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (65536usize as u32);
    }
    #[inline]
    pub fn ReceiverOverflow(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (131072usize as u32))
                                        >> 17u32) as u32)
        }
    }
    #[inline]
    pub fn set_ReceiverOverflow(&mut self, val: ULONG) {
        self._bitfield_1 &= !(131072usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 17u32) & (131072usize as u32);
    }
    #[inline]
    pub fn MalformedTLP(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (262144usize as u32))
                                        >> 18u32) as u32)
        }
    }
    #[inline]
    pub fn set_MalformedTLP(&mut self, val: ULONG) {
        self._bitfield_1 &= !(262144usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 18u32) & (262144usize as u32);
    }
    #[inline]
    pub fn ECRCError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (524288usize as u32))
                                        >> 19u32) as u32)
        }
    }
    #[inline]
    pub fn set_ECRCError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(524288usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 19u32) & (524288usize as u32);
    }
    #[inline]
    pub fn UnsupportedRequestError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1048576usize as u32))
                                        >> 20u32) as u32)
        }
    }
    #[inline]
    pub fn set_UnsupportedRequestError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1048576usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 20u32) & (1048576usize as u32);
    }
    #[inline]
    pub fn AcsViolation(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2097152usize as u32))
                                        >> 21u32) as u32)
        }
    }
    #[inline]
    pub fn set_AcsViolation(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2097152usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 21u32) & (2097152usize as u32);
    }
    #[inline]
    pub fn UncorrectableInternalError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4194304usize as u32))
                                        >> 22u32) as u32)
        }
    }
    #[inline]
    pub fn set_UncorrectableInternalError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4194304usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 22u32) & (4194304usize as u32);
    }
    #[inline]
    pub fn MCBlockedTlp(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8388608usize as u32))
                                        >> 23u32) as u32)
        }
    }
    #[inline]
    pub fn set_MCBlockedTlp(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8388608usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 23u32) & (8388608usize as u32);
    }
    #[inline]
    pub fn AtomicOpEgressBlocked(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (16777216usize as u32)) >> 24u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_AtomicOpEgressBlocked(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16777216usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 24u32) & (16777216usize as u32);
    }
    #[inline]
    pub fn TlpPrefixBlocked(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (33554432usize as u32)) >> 25u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_TlpPrefixBlocked(&mut self, val: ULONG) {
        self._bitfield_1 &= !(33554432usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 25u32) & (33554432usize as u32);
    }
    #[inline]
    pub fn Reserved3(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4227858432usize as u32)) >> 26u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_Reserved3(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4227858432usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 26u32) & (4227858432usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS as
        PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS;
pub type PPCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS =
    *mut _PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK__bindgen_ty_1 {
    #[inline]
    pub fn Undefined(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_Undefined(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (14usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        self._bitfield_1 &= !(14usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (14usize as u32);
    }
    #[inline]
    pub fn DataLinkProtocolError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u32)) >>
                                        4u32) as u32)
        }
    }
    #[inline]
    pub fn set_DataLinkProtocolError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (16usize as u32);
    }
    #[inline]
    pub fn SurpriseDownError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u32)) >>
                                        5u32) as u32)
        }
    }
    #[inline]
    pub fn set_SurpriseDownError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(32usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (32usize as u32);
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4032usize as u32)) >>
                                        6u32) as u32)
        }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4032usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 6u32) & (4032usize as u32);
    }
    #[inline]
    pub fn PoisonedTLP(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4096usize as u32)) >>
                                        12u32) as u32)
        }
    }
    #[inline]
    pub fn set_PoisonedTLP(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4096usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 12u32) & (4096usize as u32);
    }
    #[inline]
    pub fn FlowControlProtocolError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8192usize as u32)) >>
                                        13u32) as u32)
        }
    }
    #[inline]
    pub fn set_FlowControlProtocolError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8192usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 13u32) & (8192usize as u32);
    }
    #[inline]
    pub fn CompletionTimeout(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16384usize as u32))
                                        >> 14u32) as u32)
        }
    }
    #[inline]
    pub fn set_CompletionTimeout(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16384usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 14u32) & (16384usize as u32);
    }
    #[inline]
    pub fn CompleterAbort(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32768usize as u32))
                                        >> 15u32) as u32)
        }
    }
    #[inline]
    pub fn set_CompleterAbort(&mut self, val: ULONG) {
        self._bitfield_1 &= !(32768usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 15u32) & (32768usize as u32);
    }
    #[inline]
    pub fn UnexpectedCompletion(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65536usize as u32))
                                        >> 16u32) as u32)
        }
    }
    #[inline]
    pub fn set_UnexpectedCompletion(&mut self, val: ULONG) {
        self._bitfield_1 &= !(65536usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (65536usize as u32);
    }
    #[inline]
    pub fn ReceiverOverflow(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (131072usize as u32))
                                        >> 17u32) as u32)
        }
    }
    #[inline]
    pub fn set_ReceiverOverflow(&mut self, val: ULONG) {
        self._bitfield_1 &= !(131072usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 17u32) & (131072usize as u32);
    }
    #[inline]
    pub fn MalformedTLP(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (262144usize as u32))
                                        >> 18u32) as u32)
        }
    }
    #[inline]
    pub fn set_MalformedTLP(&mut self, val: ULONG) {
        self._bitfield_1 &= !(262144usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 18u32) & (262144usize as u32);
    }
    #[inline]
    pub fn ECRCError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (524288usize as u32))
                                        >> 19u32) as u32)
        }
    }
    #[inline]
    pub fn set_ECRCError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(524288usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 19u32) & (524288usize as u32);
    }
    #[inline]
    pub fn UnsupportedRequestError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1048576usize as u32))
                                        >> 20u32) as u32)
        }
    }
    #[inline]
    pub fn set_UnsupportedRequestError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1048576usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 20u32) & (1048576usize as u32);
    }
    #[inline]
    pub fn AcsViolation(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2097152usize as u32))
                                        >> 21u32) as u32)
        }
    }
    #[inline]
    pub fn set_AcsViolation(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2097152usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 21u32) & (2097152usize as u32);
    }
    #[inline]
    pub fn UncorrectableInternalError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4194304usize as u32))
                                        >> 22u32) as u32)
        }
    }
    #[inline]
    pub fn set_UncorrectableInternalError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4194304usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 22u32) & (4194304usize as u32);
    }
    #[inline]
    pub fn MCBlockedTlp(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8388608usize as u32))
                                        >> 23u32) as u32)
        }
    }
    #[inline]
    pub fn set_MCBlockedTlp(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8388608usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 23u32) & (8388608usize as u32);
    }
    #[inline]
    pub fn AtomicOpEgressBlocked(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (16777216usize as u32)) >> 24u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_AtomicOpEgressBlocked(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16777216usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 24u32) & (16777216usize as u32);
    }
    #[inline]
    pub fn TlpPrefixBlocked(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (33554432usize as u32)) >> 25u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_TlpPrefixBlocked(&mut self, val: ULONG) {
        self._bitfield_1 &= !(33554432usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 25u32) & (33554432usize as u32);
    }
    #[inline]
    pub fn Reserved3(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4227858432usize as u32)) >> 26u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_Reserved3(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4227858432usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 26u32) & (4227858432usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK as
        PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK;
pub type PPCI_EXPRESS_UNCORRECTABLE_ERROR_MASK =
    *mut _PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY__bindgen_ty_1 {
    #[inline]
    pub fn Undefined(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_Undefined(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (14usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        self._bitfield_1 &= !(14usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (14usize as u32);
    }
    #[inline]
    pub fn DataLinkProtocolError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u32)) >>
                                        4u32) as u32)
        }
    }
    #[inline]
    pub fn set_DataLinkProtocolError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (16usize as u32);
    }
    #[inline]
    pub fn SurpriseDownError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u32)) >>
                                        5u32) as u32)
        }
    }
    #[inline]
    pub fn set_SurpriseDownError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(32usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (32usize as u32);
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4032usize as u32)) >>
                                        6u32) as u32)
        }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4032usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 6u32) & (4032usize as u32);
    }
    #[inline]
    pub fn PoisonedTLP(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4096usize as u32)) >>
                                        12u32) as u32)
        }
    }
    #[inline]
    pub fn set_PoisonedTLP(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4096usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 12u32) & (4096usize as u32);
    }
    #[inline]
    pub fn FlowControlProtocolError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8192usize as u32)) >>
                                        13u32) as u32)
        }
    }
    #[inline]
    pub fn set_FlowControlProtocolError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8192usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 13u32) & (8192usize as u32);
    }
    #[inline]
    pub fn CompletionTimeout(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16384usize as u32))
                                        >> 14u32) as u32)
        }
    }
    #[inline]
    pub fn set_CompletionTimeout(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16384usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 14u32) & (16384usize as u32);
    }
    #[inline]
    pub fn CompleterAbort(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32768usize as u32))
                                        >> 15u32) as u32)
        }
    }
    #[inline]
    pub fn set_CompleterAbort(&mut self, val: ULONG) {
        self._bitfield_1 &= !(32768usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 15u32) & (32768usize as u32);
    }
    #[inline]
    pub fn UnexpectedCompletion(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65536usize as u32))
                                        >> 16u32) as u32)
        }
    }
    #[inline]
    pub fn set_UnexpectedCompletion(&mut self, val: ULONG) {
        self._bitfield_1 &= !(65536usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (65536usize as u32);
    }
    #[inline]
    pub fn ReceiverOverflow(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (131072usize as u32))
                                        >> 17u32) as u32)
        }
    }
    #[inline]
    pub fn set_ReceiverOverflow(&mut self, val: ULONG) {
        self._bitfield_1 &= !(131072usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 17u32) & (131072usize as u32);
    }
    #[inline]
    pub fn MalformedTLP(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (262144usize as u32))
                                        >> 18u32) as u32)
        }
    }
    #[inline]
    pub fn set_MalformedTLP(&mut self, val: ULONG) {
        self._bitfield_1 &= !(262144usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 18u32) & (262144usize as u32);
    }
    #[inline]
    pub fn ECRCError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (524288usize as u32))
                                        >> 19u32) as u32)
        }
    }
    #[inline]
    pub fn set_ECRCError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(524288usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 19u32) & (524288usize as u32);
    }
    #[inline]
    pub fn UnsupportedRequestError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1048576usize as u32))
                                        >> 20u32) as u32)
        }
    }
    #[inline]
    pub fn set_UnsupportedRequestError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1048576usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 20u32) & (1048576usize as u32);
    }
    #[inline]
    pub fn AcsViolation(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2097152usize as u32))
                                        >> 21u32) as u32)
        }
    }
    #[inline]
    pub fn set_AcsViolation(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2097152usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 21u32) & (2097152usize as u32);
    }
    #[inline]
    pub fn UncorrectableInternalError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4194304usize as u32))
                                        >> 22u32) as u32)
        }
    }
    #[inline]
    pub fn set_UncorrectableInternalError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4194304usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 22u32) & (4194304usize as u32);
    }
    #[inline]
    pub fn MCBlockedTlp(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8388608usize as u32))
                                        >> 23u32) as u32)
        }
    }
    #[inline]
    pub fn set_MCBlockedTlp(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8388608usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 23u32) & (8388608usize as u32);
    }
    #[inline]
    pub fn AtomicOpEgressBlocked(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (16777216usize as u32)) >> 24u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_AtomicOpEgressBlocked(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16777216usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 24u32) & (16777216usize as u32);
    }
    #[inline]
    pub fn TlpPrefixBlocked(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (33554432usize as u32)) >> 25u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_TlpPrefixBlocked(&mut self, val: ULONG) {
        self._bitfield_1 &= !(33554432usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 25u32) & (33554432usize as u32);
    }
    #[inline]
    pub fn Reserved3(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4227858432usize as u32)) >> 26u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_Reserved3(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4227858432usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 26u32) & (4227858432usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY as
        PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY;
pub type PPCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY =
    *mut _PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_CORRECTABLE_ERROR_STATUS {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_CORRECTABLE_ERROR_STATUS__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_CORRECTABLE_ERROR_STATUS__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_CORRECTABLE_ERROR_STATUS__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_CORRECTABLE_ERROR_STATUS__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_CORRECTABLE_ERROR_STATUS__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_CORRECTABLE_ERROR_STATUS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_CORRECTABLE_ERROR_STATUS__bindgen_ty_1 {
    #[inline]
    pub fn ReceiverError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_ReceiverError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (62usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        self._bitfield_1 &= !(62usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (62usize as u32);
    }
    #[inline]
    pub fn BadTLP(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u32)) >>
                                        6u32) as u32)
        }
    }
    #[inline]
    pub fn set_BadTLP(&mut self, val: ULONG) {
        self._bitfield_1 &= !(64usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 6u32) & (64usize as u32);
    }
    #[inline]
    pub fn BadDLLP(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (128usize as u32)) >>
                                        7u32) as u32)
        }
    }
    #[inline]
    pub fn set_BadDLLP(&mut self, val: ULONG) {
        self._bitfield_1 &= !(128usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 7u32) & (128usize as u32);
    }
    #[inline]
    pub fn ReplayNumRollover(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (256usize as u32)) >>
                                        8u32) as u32)
        }
    }
    #[inline]
    pub fn set_ReplayNumRollover(&mut self, val: ULONG) {
        self._bitfield_1 &= !(256usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 8u32) & (256usize as u32);
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (3584usize as u32)) >>
                                        9u32) as u32)
        }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        self._bitfield_1 &= !(3584usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 9u32) & (3584usize as u32);
    }
    #[inline]
    pub fn ReplayTimerTimeout(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4096usize as u32)) >>
                                        12u32) as u32)
        }
    }
    #[inline]
    pub fn set_ReplayTimerTimeout(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4096usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 12u32) & (4096usize as u32);
    }
    #[inline]
    pub fn AdvisoryNonFatalError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8192usize as u32)) >>
                                        13u32) as u32)
        }
    }
    #[inline]
    pub fn set_AdvisoryNonFatalError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8192usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 13u32) & (8192usize as u32);
    }
    #[inline]
    pub fn CorrectedInternalError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16384usize as u32))
                                        >> 14u32) as u32)
        }
    }
    #[inline]
    pub fn set_CorrectedInternalError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16384usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 14u32) & (16384usize as u32);
    }
    #[inline]
    pub fn HeaderLogOverflow(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32768usize as u32))
                                        >> 15u32) as u32)
        }
    }
    #[inline]
    pub fn set_HeaderLogOverflow(&mut self, val: ULONG) {
        self._bitfield_1 &= !(32768usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 15u32) & (32768usize as u32);
    }
    #[inline]
    pub fn Reserved3(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294901760usize as u32)) >> 16u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_Reserved3(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294901760usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (4294901760usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_CORRECTABLE_ERROR_STATUS() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_CORRECTABLE_ERROR_STATUS>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_CORRECTABLE_ERROR_STATUS>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_CORRECTABLE_ERROR_STATUS {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_CORRECTABLE_ERROR_STATUS as
        PCI_EXPRESS_CORRECTABLE_ERROR_STATUS;
pub type PPCI_CORRECTABLE_ERROR_STATUS =
    *mut _PCI_EXPRESS_CORRECTABLE_ERROR_STATUS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_CORRECTABLE_ERROR_MASK {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_CORRECTABLE_ERROR_MASK__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_CORRECTABLE_ERROR_MASK__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_CORRECTABLE_ERROR_MASK__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_CORRECTABLE_ERROR_MASK__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_CORRECTABLE_ERROR_MASK__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_CORRECTABLE_ERROR_MASK__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_CORRECTABLE_ERROR_MASK__bindgen_ty_1 {
    #[inline]
    pub fn ReceiverError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_ReceiverError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (62usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        self._bitfield_1 &= !(62usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (62usize as u32);
    }
    #[inline]
    pub fn BadTLP(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u32)) >>
                                        6u32) as u32)
        }
    }
    #[inline]
    pub fn set_BadTLP(&mut self, val: ULONG) {
        self._bitfield_1 &= !(64usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 6u32) & (64usize as u32);
    }
    #[inline]
    pub fn BadDLLP(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (128usize as u32)) >>
                                        7u32) as u32)
        }
    }
    #[inline]
    pub fn set_BadDLLP(&mut self, val: ULONG) {
        self._bitfield_1 &= !(128usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 7u32) & (128usize as u32);
    }
    #[inline]
    pub fn ReplayNumRollover(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (256usize as u32)) >>
                                        8u32) as u32)
        }
    }
    #[inline]
    pub fn set_ReplayNumRollover(&mut self, val: ULONG) {
        self._bitfield_1 &= !(256usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 8u32) & (256usize as u32);
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (3584usize as u32)) >>
                                        9u32) as u32)
        }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        self._bitfield_1 &= !(3584usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 9u32) & (3584usize as u32);
    }
    #[inline]
    pub fn ReplayTimerTimeout(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4096usize as u32)) >>
                                        12u32) as u32)
        }
    }
    #[inline]
    pub fn set_ReplayTimerTimeout(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4096usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 12u32) & (4096usize as u32);
    }
    #[inline]
    pub fn AdvisoryNonFatalError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8192usize as u32)) >>
                                        13u32) as u32)
        }
    }
    #[inline]
    pub fn set_AdvisoryNonFatalError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8192usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 13u32) & (8192usize as u32);
    }
    #[inline]
    pub fn CorrectedInternalError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16384usize as u32))
                                        >> 14u32) as u32)
        }
    }
    #[inline]
    pub fn set_CorrectedInternalError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16384usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 14u32) & (16384usize as u32);
    }
    #[inline]
    pub fn HeaderLogOverflow(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32768usize as u32))
                                        >> 15u32) as u32)
        }
    }
    #[inline]
    pub fn set_HeaderLogOverflow(&mut self, val: ULONG) {
        self._bitfield_1 &= !(32768usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 15u32) & (32768usize as u32);
    }
    #[inline]
    pub fn Reserved3(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294901760usize as u32)) >> 16u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_Reserved3(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294901760usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (4294901760usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_CORRECTABLE_ERROR_MASK() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_CORRECTABLE_ERROR_MASK>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_CORRECTABLE_ERROR_MASK>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_CORRECTABLE_ERROR_MASK {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_CORRECTABLE_ERROR_MASK as
        PCI_EXPRESS_CORRECTABLE_ERROR_MASK;
pub type PPCI_CORRECTABLE_ERROR_MASK =
    *mut _PCI_EXPRESS_CORRECTABLE_ERROR_MASK;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_AER_CAPABILITIES {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_AER_CAPABILITIES__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_AER_CAPABILITIES__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_AER_CAPABILITIES__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_AER_CAPABILITIES__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_AER_CAPABILITIES__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_AER_CAPABILITIES__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_AER_CAPABILITIES__bindgen_ty_1 {
    #[inline]
    pub fn FirstErrorPointer(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (31usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_FirstErrorPointer(&mut self, val: ULONG) {
        self._bitfield_1 &= !(31usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (31usize as u32);
    }
    #[inline]
    pub fn ECRCGenerationCapable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u32)) >>
                                        5u32) as u32)
        }
    }
    #[inline]
    pub fn set_ECRCGenerationCapable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(32usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (32usize as u32);
    }
    #[inline]
    pub fn ECRCGenerationEnable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u32)) >>
                                        6u32) as u32)
        }
    }
    #[inline]
    pub fn set_ECRCGenerationEnable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(64usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 6u32) & (64usize as u32);
    }
    #[inline]
    pub fn ECRCCheckCapable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (128usize as u32)) >>
                                        7u32) as u32)
        }
    }
    #[inline]
    pub fn set_ECRCCheckCapable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(128usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 7u32) & (128usize as u32);
    }
    #[inline]
    pub fn ECRCCheckEnable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (256usize as u32)) >>
                                        8u32) as u32)
        }
    }
    #[inline]
    pub fn set_ECRCCheckEnable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(256usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 8u32) & (256usize as u32);
    }
    #[inline]
    pub fn MultipleHeaderRecordingCapable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (512usize as u32)) >>
                                        9u32) as u32)
        }
    }
    #[inline]
    pub fn set_MultipleHeaderRecordingCapable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(512usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 9u32) & (512usize as u32);
    }
    #[inline]
    pub fn MultipleHeaderRecordingEnable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1024usize as u32)) >>
                                        10u32) as u32)
        }
    }
    #[inline]
    pub fn set_MultipleHeaderRecordingEnable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1024usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 10u32) & (1024usize as u32);
    }
    #[inline]
    pub fn TlpPrefixLogPresent(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2048usize as u32)) >>
                                        11u32) as u32)
        }
    }
    #[inline]
    pub fn set_TlpPrefixLogPresent(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2048usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 11u32) & (2048usize as u32);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294963200usize as u32)) >> 12u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294963200usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 12u32) & (4294963200usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_AER_CAPABILITIES() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_AER_CAPABILITIES>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_AER_CAPABILITIES>() ,
               4usize);
}
impl Clone for _PCI_EXPRESS_AER_CAPABILITIES {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_AER_CAPABILITIES as PCI_EXPRESS_AER_CAPABILITIES;
pub type PPCI_EXPRESS_AER_CAPABILITIES = *mut _PCI_EXPRESS_AER_CAPABILITIES;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_ROOT_ERROR_COMMAND {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_ROOT_ERROR_COMMAND__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_ROOT_ERROR_COMMAND__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_ROOT_ERROR_COMMAND__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_ROOT_ERROR_COMMAND__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_ROOT_ERROR_COMMAND__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_ROOT_ERROR_COMMAND__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_ROOT_ERROR_COMMAND__bindgen_ty_1 {
    #[inline]
    pub fn CorrectableErrorReportingEnable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_CorrectableErrorReportingEnable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn NonFatalErrorReportingEnable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_NonFatalErrorReportingEnable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn FatalErrorReportingEnable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                        2u32) as u32)
        }
    }
    #[inline]
    pub fn set_FatalErrorReportingEnable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967288usize as u32)) >> 3u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967288usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 3u32) & (4294967288usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_ROOT_ERROR_COMMAND() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_ROOT_ERROR_COMMAND>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_ROOT_ERROR_COMMAND>() ,
               4usize);
}
impl Clone for _PCI_EXPRESS_ROOT_ERROR_COMMAND {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_ROOT_ERROR_COMMAND as
        PCI_EXPRESS_ROOT_ERROR_COMMAND;
pub type PPCI_EXPRESS_ROOT_ERROR_COMMAND =
    *mut _PCI_EXPRESS_ROOT_ERROR_COMMAND;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_ROOT_ERROR_STATUS {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_ROOT_ERROR_STATUS__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_ROOT_ERROR_STATUS__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_ROOT_ERROR_STATUS__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_ROOT_ERROR_STATUS__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_ROOT_ERROR_STATUS__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_ROOT_ERROR_STATUS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_ROOT_ERROR_STATUS__bindgen_ty_1 {
    #[inline]
    pub fn CorrectableErrorReceived(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_CorrectableErrorReceived(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn MultipleCorrectableErrorsReceived(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_MultipleCorrectableErrorsReceived(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn UncorrectableErrorReceived(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                        2u32) as u32)
        }
    }
    #[inline]
    pub fn set_UncorrectableErrorReceived(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn MultipleUncorrectableErrorsReceived(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u32)) >>
                                        3u32) as u32)
        }
    }
    #[inline]
    pub fn set_MultipleUncorrectableErrorsReceived(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (8usize as u32);
    }
    #[inline]
    pub fn FirstUncorrectableFatal(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u32)) >>
                                        4u32) as u32)
        }
    }
    #[inline]
    pub fn set_FirstUncorrectableFatal(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (16usize as u32);
    }
    #[inline]
    pub fn NonFatalErrorMessagesReceived(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u32)) >>
                                        5u32) as u32)
        }
    }
    #[inline]
    pub fn set_NonFatalErrorMessagesReceived(&mut self, val: ULONG) {
        self._bitfield_1 &= !(32usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (32usize as u32);
    }
    #[inline]
    pub fn FatalErrorMessagesReceived(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u32)) >>
                                        6u32) as u32)
        }
    }
    #[inline]
    pub fn set_FatalErrorMessagesReceived(&mut self, val: ULONG) {
        self._bitfield_1 &= !(64usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 6u32) & (64usize as u32);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (134217600usize as u32)) >> 7u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        self._bitfield_1 &= !(134217600usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 7u32) & (134217600usize as u32);
    }
    #[inline]
    pub fn AdvancedErrorInterruptMessageNumber(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4160749568usize as u32)) >> 27u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_AdvancedErrorInterruptMessageNumber(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4160749568usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 27u32) & (4160749568usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_ROOT_ERROR_STATUS() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_ROOT_ERROR_STATUS>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_ROOT_ERROR_STATUS>() ,
               4usize);
}
impl Clone for _PCI_EXPRESS_ROOT_ERROR_STATUS {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_ROOT_ERROR_STATUS as PCI_EXPRESS_ROOT_ERROR_STATUS;
pub type PPCI_EXPRESS_ROOT_ERROR_STATUS = *mut _PCI_EXPRESS_ROOT_ERROR_STATUS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_ERROR_SOURCE_ID {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_ERROR_SOURCE_ID__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_ERROR_SOURCE_ID__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_ERROR_SOURCE_ID__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_ERROR_SOURCE_ID__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_ERROR_SOURCE_ID__bindgen_ty_1>()
               , 2usize);
}
impl Clone for _PCI_EXPRESS_ERROR_SOURCE_ID__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_ERROR_SOURCE_ID__bindgen_ty_1 {
    #[inline]
    pub fn CorrectableSourceIdFun(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (7usize as u32)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_CorrectableSourceIdFun(&mut self, val: USHORT) {
        self._bitfield_1 &= !(7usize as u32);
        self._bitfield_1 |= ((val as u16 as u32) << 0u32) & (7usize as u32);
    }
    #[inline]
    pub fn CorrectableSourceIdDev(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (248usize as u32)) >>
                                        3u32) as u16)
        }
    }
    #[inline]
    pub fn set_CorrectableSourceIdDev(&mut self, val: USHORT) {
        self._bitfield_1 &= !(248usize as u32);
        self._bitfield_1 |= ((val as u16 as u32) << 3u32) & (248usize as u32);
    }
    #[inline]
    pub fn CorrectableSourceIdBus(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65280usize as u32))
                                        >> 8u32) as u16)
        }
    }
    #[inline]
    pub fn set_CorrectableSourceIdBus(&mut self, val: USHORT) {
        self._bitfield_1 &= !(65280usize as u32);
        self._bitfield_1 |=
            ((val as u16 as u32) << 8u32) & (65280usize as u32);
    }
    #[inline]
    pub fn UncorrectableSourceIdFun(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (458752usize as u32))
                                        >> 16u32) as u16)
        }
    }
    #[inline]
    pub fn set_UncorrectableSourceIdFun(&mut self, val: USHORT) {
        self._bitfield_1 &= !(458752usize as u32);
        self._bitfield_1 |=
            ((val as u16 as u32) << 16u32) & (458752usize as u32);
    }
    #[inline]
    pub fn UncorrectableSourceIdDev(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (16252928usize as u32)) >> 19u32) as
                                       u16)
        }
    }
    #[inline]
    pub fn set_UncorrectableSourceIdDev(&mut self, val: USHORT) {
        self._bitfield_1 &= !(16252928usize as u32);
        self._bitfield_1 |=
            ((val as u16 as u32) << 19u32) & (16252928usize as u32);
    }
    #[inline]
    pub fn UncorrectableSourceIdBus(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4278190080usize as u32)) >> 24u32)
                                       as u16)
        }
    }
    #[inline]
    pub fn set_UncorrectableSourceIdBus(&mut self, val: USHORT) {
        self._bitfield_1 &= !(4278190080usize as u32);
        self._bitfield_1 |=
            ((val as u16 as u32) << 24u32) & (4278190080usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_ERROR_SOURCE_ID() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_ERROR_SOURCE_ID>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_ERROR_SOURCE_ID>() ,
               4usize);
}
impl Clone for _PCI_EXPRESS_ERROR_SOURCE_ID {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_ERROR_SOURCE_ID as PCI_EXPRESS_ERROR_SOURCE_ID;
pub type PPCI_EXPRESS_ERROR_SOURCE_ID = *mut _PCI_EXPRESS_ERROR_SOURCE_ID;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS__bindgen_ty_1 {
    #[inline]
    pub fn TargetAbortOnSplitCompletion(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_TargetAbortOnSplitCompletion(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn MasterAbortOnSplitCompletion(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_MasterAbortOnSplitCompletion(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn ReceivedTargetAbort(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                        2u32) as u32)
        }
    }
    #[inline]
    pub fn set_ReceivedTargetAbort(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn ReceivedMasterAbort(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u32)) >>
                                        3u32) as u32)
        }
    }
    #[inline]
    pub fn set_ReceivedMasterAbort(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (8usize as u32);
    }
    #[inline]
    pub fn RsvdZ(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u32)) >>
                                        4u32) as u32)
        }
    }
    #[inline]
    pub fn set_RsvdZ(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (16usize as u32);
    }
    #[inline]
    pub fn UnexpectedSplitCompletionError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u32)) >>
                                        5u32) as u32)
        }
    }
    #[inline]
    pub fn set_UnexpectedSplitCompletionError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(32usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (32usize as u32);
    }
    #[inline]
    pub fn UncorrectableSplitCompletion(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u32)) >>
                                        6u32) as u32)
        }
    }
    #[inline]
    pub fn set_UncorrectableSplitCompletion(&mut self, val: ULONG) {
        self._bitfield_1 &= !(64usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 6u32) & (64usize as u32);
    }
    #[inline]
    pub fn UncorrectableDataError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (128usize as u32)) >>
                                        7u32) as u32)
        }
    }
    #[inline]
    pub fn set_UncorrectableDataError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(128usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 7u32) & (128usize as u32);
    }
    #[inline]
    pub fn UncorrectableAttributeError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (256usize as u32)) >>
                                        8u32) as u32)
        }
    }
    #[inline]
    pub fn set_UncorrectableAttributeError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(256usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 8u32) & (256usize as u32);
    }
    #[inline]
    pub fn UncorrectableAddressError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (512usize as u32)) >>
                                        9u32) as u32)
        }
    }
    #[inline]
    pub fn set_UncorrectableAddressError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(512usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 9u32) & (512usize as u32);
    }
    #[inline]
    pub fn DelayedTransactionDiscardTimerExpired(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1024usize as u32)) >>
                                        10u32) as u32)
        }
    }
    #[inline]
    pub fn set_DelayedTransactionDiscardTimerExpired(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1024usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 10u32) & (1024usize as u32);
    }
    #[inline]
    pub fn PERRAsserted(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2048usize as u32)) >>
                                        11u32) as u32)
        }
    }
    #[inline]
    pub fn set_PERRAsserted(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2048usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 11u32) & (2048usize as u32);
    }
    #[inline]
    pub fn SERRAsserted(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4096usize as u32)) >>
                                        12u32) as u32)
        }
    }
    #[inline]
    pub fn set_SERRAsserted(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4096usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 12u32) & (4096usize as u32);
    }
    #[inline]
    pub fn InternalBridgeError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8192usize as u32)) >>
                                        13u32) as u32)
        }
    }
    #[inline]
    pub fn set_InternalBridgeError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8192usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 13u32) & (8192usize as u32);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294950912usize as u32)) >> 14u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294950912usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 14u32) & (4294950912usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS as
        PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS;
pub type PPCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS =
    *mut _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK__bindgen_ty_1 {
    #[inline]
    pub fn TargetAbortOnSplitCompletion(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_TargetAbortOnSplitCompletion(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn MasterAbortOnSplitCompletion(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_MasterAbortOnSplitCompletion(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn ReceivedTargetAbort(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                        2u32) as u32)
        }
    }
    #[inline]
    pub fn set_ReceivedTargetAbort(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn ReceivedMasterAbort(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u32)) >>
                                        3u32) as u32)
        }
    }
    #[inline]
    pub fn set_ReceivedMasterAbort(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (8usize as u32);
    }
    #[inline]
    pub fn RsvdZ(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u32)) >>
                                        4u32) as u32)
        }
    }
    #[inline]
    pub fn set_RsvdZ(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (16usize as u32);
    }
    #[inline]
    pub fn UnexpectedSplitCompletionError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u32)) >>
                                        5u32) as u32)
        }
    }
    #[inline]
    pub fn set_UnexpectedSplitCompletionError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(32usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (32usize as u32);
    }
    #[inline]
    pub fn UncorrectableSplitCompletion(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u32)) >>
                                        6u32) as u32)
        }
    }
    #[inline]
    pub fn set_UncorrectableSplitCompletion(&mut self, val: ULONG) {
        self._bitfield_1 &= !(64usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 6u32) & (64usize as u32);
    }
    #[inline]
    pub fn UncorrectableDataError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (128usize as u32)) >>
                                        7u32) as u32)
        }
    }
    #[inline]
    pub fn set_UncorrectableDataError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(128usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 7u32) & (128usize as u32);
    }
    #[inline]
    pub fn UncorrectableAttributeError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (256usize as u32)) >>
                                        8u32) as u32)
        }
    }
    #[inline]
    pub fn set_UncorrectableAttributeError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(256usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 8u32) & (256usize as u32);
    }
    #[inline]
    pub fn UncorrectableAddressError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (512usize as u32)) >>
                                        9u32) as u32)
        }
    }
    #[inline]
    pub fn set_UncorrectableAddressError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(512usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 9u32) & (512usize as u32);
    }
    #[inline]
    pub fn DelayedTransactionDiscardTimerExpired(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1024usize as u32)) >>
                                        10u32) as u32)
        }
    }
    #[inline]
    pub fn set_DelayedTransactionDiscardTimerExpired(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1024usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 10u32) & (1024usize as u32);
    }
    #[inline]
    pub fn PERRAsserted(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2048usize as u32)) >>
                                        11u32) as u32)
        }
    }
    #[inline]
    pub fn set_PERRAsserted(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2048usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 11u32) & (2048usize as u32);
    }
    #[inline]
    pub fn SERRAsserted(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4096usize as u32)) >>
                                        12u32) as u32)
        }
    }
    #[inline]
    pub fn set_SERRAsserted(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4096usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 12u32) & (4096usize as u32);
    }
    #[inline]
    pub fn InternalBridgeError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8192usize as u32)) >>
                                        13u32) as u32)
        }
    }
    #[inline]
    pub fn set_InternalBridgeError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8192usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 13u32) & (8192usize as u32);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294950912usize as u32)) >> 14u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294950912usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 14u32) & (4294950912usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK as
        PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK;
pub type PPCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK =
    *mut _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY__bindgen_ty_1 {
    #[inline]
    pub fn TargetAbortOnSplitCompletion(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_TargetAbortOnSplitCompletion(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn MasterAbortOnSplitCompletion(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_MasterAbortOnSplitCompletion(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn ReceivedTargetAbort(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                        2u32) as u32)
        }
    }
    #[inline]
    pub fn set_ReceivedTargetAbort(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn ReceivedMasterAbort(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u32)) >>
                                        3u32) as u32)
        }
    }
    #[inline]
    pub fn set_ReceivedMasterAbort(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (8usize as u32);
    }
    #[inline]
    pub fn RsvdZ(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u32)) >>
                                        4u32) as u32)
        }
    }
    #[inline]
    pub fn set_RsvdZ(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (16usize as u32);
    }
    #[inline]
    pub fn UnexpectedSplitCompletionError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u32)) >>
                                        5u32) as u32)
        }
    }
    #[inline]
    pub fn set_UnexpectedSplitCompletionError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(32usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (32usize as u32);
    }
    #[inline]
    pub fn UncorrectableSplitCompletion(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u32)) >>
                                        6u32) as u32)
        }
    }
    #[inline]
    pub fn set_UncorrectableSplitCompletion(&mut self, val: ULONG) {
        self._bitfield_1 &= !(64usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 6u32) & (64usize as u32);
    }
    #[inline]
    pub fn UncorrectableDataError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (128usize as u32)) >>
                                        7u32) as u32)
        }
    }
    #[inline]
    pub fn set_UncorrectableDataError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(128usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 7u32) & (128usize as u32);
    }
    #[inline]
    pub fn UncorrectableAttributeError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (256usize as u32)) >>
                                        8u32) as u32)
        }
    }
    #[inline]
    pub fn set_UncorrectableAttributeError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(256usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 8u32) & (256usize as u32);
    }
    #[inline]
    pub fn UncorrectableAddressError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (512usize as u32)) >>
                                        9u32) as u32)
        }
    }
    #[inline]
    pub fn set_UncorrectableAddressError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(512usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 9u32) & (512usize as u32);
    }
    #[inline]
    pub fn DelayedTransactionDiscardTimerExpired(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1024usize as u32)) >>
                                        10u32) as u32)
        }
    }
    #[inline]
    pub fn set_DelayedTransactionDiscardTimerExpired(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1024usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 10u32) & (1024usize as u32);
    }
    #[inline]
    pub fn PERRAsserted(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2048usize as u32)) >>
                                        11u32) as u32)
        }
    }
    #[inline]
    pub fn set_PERRAsserted(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2048usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 11u32) & (2048usize as u32);
    }
    #[inline]
    pub fn SERRAsserted(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4096usize as u32)) >>
                                        12u32) as u32)
        }
    }
    #[inline]
    pub fn set_SERRAsserted(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4096usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 12u32) & (4096usize as u32);
    }
    #[inline]
    pub fn InternalBridgeError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8192usize as u32)) >>
                                        13u32) as u32)
        }
    }
    #[inline]
    pub fn set_InternalBridgeError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8192usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 13u32) & (8192usize as u32);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294950912usize as u32)) >> 14u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294950912usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 14u32) & (4294950912usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY as
        PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY;
pub type PPCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY =
    *mut _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_SEC_AER_CAPABILITIES {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_SEC_AER_CAPABILITIES__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_SEC_AER_CAPABILITIES__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_SEC_AER_CAPABILITIES__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_SEC_AER_CAPABILITIES__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_SEC_AER_CAPABILITIES__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_SEC_AER_CAPABILITIES__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_SEC_AER_CAPABILITIES__bindgen_ty_1 {
    #[inline]
    pub fn SecondaryUncorrectableFirstErrorPtr(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (31usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_SecondaryUncorrectableFirstErrorPtr(&mut self, val: ULONG) {
        self._bitfield_1 &= !(31usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (31usize as u32);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967264usize as u32)) >> 5u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967264usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 5u32) & (4294967264usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_SEC_AER_CAPABILITIES() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_SEC_AER_CAPABILITIES>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_SEC_AER_CAPABILITIES>() ,
               4usize);
}
impl Clone for _PCI_EXPRESS_SEC_AER_CAPABILITIES {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_SEC_AER_CAPABILITIES as
        PCI_EXPRESS_SEC_AER_CAPABILITIES;
pub type PPCI_EXPRESS_SEC_AER_CAPABILITIES =
    *mut _PCI_EXPRESS_SEC_AER_CAPABILITIES;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_AER_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub UncorrectableErrorStatus: PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS,
    pub UncorrectableErrorMask: PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK,
    pub UncorrectableErrorSeverity: PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY,
    pub CorrectableErrorStatus: PCI_EXPRESS_CORRECTABLE_ERROR_STATUS,
    pub CorrectableErrorMask: PCI_EXPRESS_CORRECTABLE_ERROR_MASK,
    pub CapabilitiesAndControl: PCI_EXPRESS_AER_CAPABILITIES,
    pub HeaderLog: [ULONG; 4usize],
    pub SecUncorrectableErrorStatus: PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS,
    pub SecUncorrectableErrorMask: PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK,
    pub SecUncorrectableErrorSeverity: PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY,
    pub SecCapabilitiesAndControl: PCI_EXPRESS_SEC_AER_CAPABILITIES,
    pub SecHeaderLog: [ULONG; 4usize],
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_AER_CAPABILITY() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_AER_CAPABILITY>() ,
               76usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_AER_CAPABILITY>() ,
               4usize);
}
impl Clone for _PCI_EXPRESS_AER_CAPABILITY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_AER_CAPABILITY as PCI_EXPRESS_AER_CAPABILITY;
pub type PPCI_EXPRESS_AER_CAPABILITY = *mut _PCI_EXPRESS_AER_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_ROOTPORT_AER_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub UncorrectableErrorStatus: PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS,
    pub UncorrectableErrorMask: PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK,
    pub UncorrectableErrorSeverity: PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY,
    pub CorrectableErrorStatus: PCI_EXPRESS_CORRECTABLE_ERROR_STATUS,
    pub CorrectableErrorMask: PCI_EXPRESS_CORRECTABLE_ERROR_MASK,
    pub CapabilitiesAndControl: PCI_EXPRESS_AER_CAPABILITIES,
    pub HeaderLog: [ULONG; 4usize],
    pub RootErrorCommand: PCI_EXPRESS_ROOT_ERROR_COMMAND,
    pub RootErrorStatus: PCI_EXPRESS_ROOT_ERROR_STATUS,
    pub ErrorSourceId: PCI_EXPRESS_ERROR_SOURCE_ID,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_ROOTPORT_AER_CAPABILITY() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_ROOTPORT_AER_CAPABILITY>()
               , 56usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_ROOTPORT_AER_CAPABILITY>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_ROOTPORT_AER_CAPABILITY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_ROOTPORT_AER_CAPABILITY as
        PCI_EXPRESS_ROOTPORT_AER_CAPABILITY;
pub type PPCI_EXPRESS_ROOTPORT_AER_CAPABILITY =
    *mut _PCI_EXPRESS_ROOTPORT_AER_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_BRIDGE_AER_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub UncorrectableErrorStatus: PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS,
    pub UncorrectableErrorMask: PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK,
    pub UncorrectableErrorSeverity: PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY,
    pub CorrectableErrorStatus: PCI_EXPRESS_CORRECTABLE_ERROR_STATUS,
    pub CorrectableErrorMask: PCI_EXPRESS_CORRECTABLE_ERROR_MASK,
    pub CapabilitiesAndControl: PCI_EXPRESS_AER_CAPABILITIES,
    pub HeaderLog: [ULONG; 4usize],
    pub SecUncorrectableErrorStatus: PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS,
    pub SecUncorrectableErrorMask: PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK,
    pub SecUncorrectableErrorSeverity: PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY,
    pub SecCapabilitiesAndControl: PCI_EXPRESS_SEC_AER_CAPABILITIES,
    pub SecHeaderLog: [ULONG; 4usize],
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_BRIDGE_AER_CAPABILITY() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_BRIDGE_AER_CAPABILITY>() ,
               76usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_BRIDGE_AER_CAPABILITY>() ,
               4usize);
}
impl Clone for _PCI_EXPRESS_BRIDGE_AER_CAPABILITY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_BRIDGE_AER_CAPABILITY as
        PCI_EXPRESS_BRIDGE_AER_CAPABILITY;
pub type PPCI_EXPRESS_BRIDGE_AER_CAPABILITY =
    *mut _PCI_EXPRESS_BRIDGE_AER_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_ACS_CAPABILITY_REGISTER {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_ACS_CAPABILITY_REGISTER__bindgen_ty_1>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: u16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_ACS_CAPABILITY_REGISTER__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_ACS_CAPABILITY_REGISTER__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_ACS_CAPABILITY_REGISTER__bindgen_ty_1>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_ACS_CAPABILITY_REGISTER__bindgen_ty_1>()
               , 2usize);
}
impl Clone for _PCI_EXPRESS_ACS_CAPABILITY_REGISTER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_ACS_CAPABILITY_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn SourceValidation(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_SourceValidation(&mut self, val: USHORT) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn TranslationBlocking(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u16)) >>
                                        1u32) as u16)
        }
    }
    #[inline]
    pub fn set_TranslationBlocking(&mut self, val: USHORT) {
        self._bitfield_1 &= !(2usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 1u32) & (2usize as u16);
    }
    #[inline]
    pub fn RequestRedirect(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u16)) >>
                                        2u32) as u16)
        }
    }
    #[inline]
    pub fn set_RequestRedirect(&mut self, val: USHORT) {
        self._bitfield_1 &= !(4usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 2u32) & (4usize as u16);
    }
    #[inline]
    pub fn CompletionRedirect(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u16)) >>
                                        3u32) as u16)
        }
    }
    #[inline]
    pub fn set_CompletionRedirect(&mut self, val: USHORT) {
        self._bitfield_1 &= !(8usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 3u32) & (8usize as u16);
    }
    #[inline]
    pub fn UpstreamForwarding(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u16)) >>
                                        4u32) as u16)
        }
    }
    #[inline]
    pub fn set_UpstreamForwarding(&mut self, val: USHORT) {
        self._bitfield_1 &= !(16usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 4u32) & (16usize as u16);
    }
    #[inline]
    pub fn EgressControl(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u16)) >>
                                        5u32) as u16)
        }
    }
    #[inline]
    pub fn set_EgressControl(&mut self, val: USHORT) {
        self._bitfield_1 &= !(32usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 5u32) & (32usize as u16);
    }
    #[inline]
    pub fn DirectTranslation(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u16)) >>
                                        6u32) as u16)
        }
    }
    #[inline]
    pub fn set_DirectTranslation(&mut self, val: USHORT) {
        self._bitfield_1 &= !(64usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 6u32) & (64usize as u16);
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (128usize as u16)) >>
                                        7u32) as u16)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        self._bitfield_1 &= !(128usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 7u32) & (128usize as u16);
    }
    #[inline]
    pub fn EgressControlVectorSize(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65280usize as u16))
                                        >> 8u32) as u16)
        }
    }
    #[inline]
    pub fn set_EgressControlVectorSize(&mut self, val: USHORT) {
        self._bitfield_1 &= !(65280usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 8u32) & (65280usize as u16);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_ACS_CAPABILITY_REGISTER() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_ACS_CAPABILITY_REGISTER>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_ACS_CAPABILITY_REGISTER>()
               , 2usize);
}
impl Clone for _PCI_EXPRESS_ACS_CAPABILITY_REGISTER {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_ACS_CAPABILITY_REGISTER as
        PCI_EXPRESS_ACS_CAPABILITY_REGISTER;
pub type PPCI_EXPRESS_ACS_CAPABILITY_REGISTER =
    *mut _PCI_EXPRESS_ACS_CAPABILITY_REGISTER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_ACS_CONTROL {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_ACS_CONTROL__bindgen_ty_1>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: u16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_ACS_CONTROL__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_ACS_CONTROL__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_ACS_CONTROL__bindgen_ty_1>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_ACS_CONTROL__bindgen_ty_1>()
               , 2usize);
}
impl Clone for _PCI_EXPRESS_ACS_CONTROL__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_ACS_CONTROL__bindgen_ty_1 {
    #[inline]
    pub fn SourceValidation(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_SourceValidation(&mut self, val: USHORT) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn TranslationBlocking(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u16)) >>
                                        1u32) as u16)
        }
    }
    #[inline]
    pub fn set_TranslationBlocking(&mut self, val: USHORT) {
        self._bitfield_1 &= !(2usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 1u32) & (2usize as u16);
    }
    #[inline]
    pub fn RequestRedirect(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u16)) >>
                                        2u32) as u16)
        }
    }
    #[inline]
    pub fn set_RequestRedirect(&mut self, val: USHORT) {
        self._bitfield_1 &= !(4usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 2u32) & (4usize as u16);
    }
    #[inline]
    pub fn CompletionRedirect(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u16)) >>
                                        3u32) as u16)
        }
    }
    #[inline]
    pub fn set_CompletionRedirect(&mut self, val: USHORT) {
        self._bitfield_1 &= !(8usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 3u32) & (8usize as u16);
    }
    #[inline]
    pub fn UpstreamForwarding(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u16)) >>
                                        4u32) as u16)
        }
    }
    #[inline]
    pub fn set_UpstreamForwarding(&mut self, val: USHORT) {
        self._bitfield_1 &= !(16usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 4u32) & (16usize as u16);
    }
    #[inline]
    pub fn EgressControl(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u16)) >>
                                        5u32) as u16)
        }
    }
    #[inline]
    pub fn set_EgressControl(&mut self, val: USHORT) {
        self._bitfield_1 &= !(32usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 5u32) & (32usize as u16);
    }
    #[inline]
    pub fn DirectTranslation(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u16)) >>
                                        6u32) as u16)
        }
    }
    #[inline]
    pub fn set_DirectTranslation(&mut self, val: USHORT) {
        self._bitfield_1 &= !(64usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 6u32) & (64usize as u16);
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65408usize as u16))
                                        >> 7u32) as u16)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        self._bitfield_1 &= !(65408usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 7u32) & (65408usize as u16);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_ACS_CONTROL() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_ACS_CONTROL>() , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_ACS_CONTROL>() , 2usize);
}
impl Clone for _PCI_EXPRESS_ACS_CONTROL {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_ACS_CONTROL as PCI_EXPRESS_ACS_CONTROL;
pub type PPCI_EXPRESS_ACS_CONTROL = *mut _PCI_EXPRESS_ACS_CONTROL;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_ACS_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub Capability: PCI_EXPRESS_ACS_CAPABILITY_REGISTER,
    pub Control: PCI_EXPRESS_ACS_CONTROL,
    pub EgressControl: [ULONG; 1usize],
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_ACS_CAPABILITY() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_ACS_CAPABILITY>() ,
               12usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_ACS_CAPABILITY>() ,
               4usize);
}
impl Clone for _PCI_EXPRESS_ACS_CAPABILITY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_ACS_CAPABILITY as PCI_EXPRESS_ACS_CAPABILITY;
pub type PPCI_EXPRESS_ACS_CAPABILITY = *mut _PCI_EXPRESS_ACS_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_SRIOV_CAPS {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_SRIOV_CAPS__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_SRIOV_CAPS__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_SRIOV_CAPS__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_SRIOV_CAPS__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_SRIOV_CAPS__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_SRIOV_CAPS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_SRIOV_CAPS__bindgen_ty_1 {
    #[inline]
    pub fn VFMigrationCapable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_VFMigrationCapable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2097150usize as u32))
                                        >> 1u32) as u32)
        }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2097150usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 1u32) & (2097150usize as u32);
    }
    #[inline]
    pub fn VFMigrationInterruptNumber(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4292870144usize as u32)) >> 21u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_VFMigrationInterruptNumber(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4292870144usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 21u32) & (4292870144usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_SRIOV_CAPS() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_SRIOV_CAPS>() , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_SRIOV_CAPS>() , 4usize);
}
impl Clone for _PCI_EXPRESS_SRIOV_CAPS {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_SRIOV_CAPS as PCI_EXPRESS_SRIOV_CAPS;
pub type PPCI_EXPRESS_SRIOV_CAPS = *mut _PCI_EXPRESS_SRIOV_CAPS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_SRIOV_CONTROL {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_SRIOV_CONTROL__bindgen_ty_1>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: u16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_SRIOV_CONTROL__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_SRIOV_CONTROL__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_SRIOV_CONTROL__bindgen_ty_1>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_SRIOV_CONTROL__bindgen_ty_1>()
               , 2usize);
}
impl Clone for _PCI_EXPRESS_SRIOV_CONTROL__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_SRIOV_CONTROL__bindgen_ty_1 {
    #[inline]
    pub fn VFEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_VFEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn VFMigrationEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u16)) >>
                                        1u32) as u16)
        }
    }
    #[inline]
    pub fn set_VFMigrationEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(2usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 1u32) & (2usize as u16);
    }
    #[inline]
    pub fn VFMigrationInterruptEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u16)) >>
                                        2u32) as u16)
        }
    }
    #[inline]
    pub fn set_VFMigrationInterruptEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(4usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 2u32) & (4usize as u16);
    }
    #[inline]
    pub fn VFMemorySpaceEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u16)) >>
                                        3u32) as u16)
        }
    }
    #[inline]
    pub fn set_VFMemorySpaceEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(8usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 3u32) & (8usize as u16);
    }
    #[inline]
    pub fn ARICapableHierarchy(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u16)) >>
                                        4u32) as u16)
        }
    }
    #[inline]
    pub fn set_ARICapableHierarchy(&mut self, val: USHORT) {
        self._bitfield_1 &= !(16usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 4u32) & (16usize as u16);
    }
    #[inline]
    pub fn Reserved1(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65504usize as u16))
                                        >> 5u32) as u16)
        }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: USHORT) {
        self._bitfield_1 &= !(65504usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 5u32) & (65504usize as u16);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_SRIOV_CONTROL() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_SRIOV_CONTROL>() , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_SRIOV_CONTROL>() ,
               2usize);
}
impl Clone for _PCI_EXPRESS_SRIOV_CONTROL {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_SRIOV_CONTROL as PCI_EXPRESS_SRIOV_CONTROL;
pub type PPCI_EXPRESS_SRIOV_CONTROL = *mut _PCI_EXPRESS_SRIOV_CONTROL;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_SRIOV_STATUS {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_SRIOV_STATUS__bindgen_ty_1>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: u16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_SRIOV_STATUS__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_SRIOV_STATUS__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_SRIOV_STATUS__bindgen_ty_1>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_SRIOV_STATUS__bindgen_ty_1>()
               , 2usize);
}
impl Clone for _PCI_EXPRESS_SRIOV_STATUS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_SRIOV_STATUS__bindgen_ty_1 {
    #[inline]
    pub fn VFMigrationStatus(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_VFMigrationStatus(&mut self, val: USHORT) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn Reserved1(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65534usize as u16))
                                        >> 1u32) as u16)
        }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: USHORT) {
        self._bitfield_1 &= !(65534usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 1u32) & (65534usize as u16);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_SRIOV_STATUS() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_SRIOV_STATUS>() , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_SRIOV_STATUS>() , 2usize);
}
impl Clone for _PCI_EXPRESS_SRIOV_STATUS {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_SRIOV_STATUS as PCI_EXPRESS_SRIOV_STATUS;
pub type PPCI_EXPRESS_SRIOV_STATUS = *mut _PCI_EXPRESS_SRIOV_STATUS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY__bindgen_ty_1 {
    #[inline]
    pub fn VFMigrationStateBIR(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (7usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_VFMigrationStateBIR(&mut self, val: ULONG) {
        self._bitfield_1 &= !(7usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (7usize as u32);
    }
    #[inline]
    pub fn VFMigrationStateOffset(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967288usize as u32)) >> 3u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_VFMigrationStateOffset(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967288usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 3u32) & (4294967288usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY as
        PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY;
pub type PPCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY =
    *mut _PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_SRIOV_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub SRIOVCapabilities: PCI_EXPRESS_SRIOV_CAPS,
    pub SRIOVControl: PCI_EXPRESS_SRIOV_CONTROL,
    pub SRIOVStatus: PCI_EXPRESS_SRIOV_STATUS,
    pub InitialVFs: USHORT,
    pub TotalVFs: USHORT,
    pub NumVFs: USHORT,
    pub FunctionDependencyLink: UCHAR,
    pub RsvdP1: UCHAR,
    pub FirstVFOffset: USHORT,
    pub VFStride: USHORT,
    pub RsvdP2: USHORT,
    pub VFDeviceId: USHORT,
    pub SupportedPageSizes: ULONG,
    pub SystemPageSize: ULONG,
    pub BaseAddresses: [ULONG; 6usize],
    pub VFMigrationStateArrayOffset: PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_SRIOV_CAPABILITY() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_SRIOV_CAPABILITY>() ,
               64usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_SRIOV_CAPABILITY>() ,
               4usize);
}
impl Clone for _PCI_EXPRESS_SRIOV_CAPABILITY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_SRIOV_CAPABILITY as PCI_EXPRESS_SRIOV_CAPABILITY;
pub type PPCI_EXPRESS_SRIOV_CAPABILITY = *mut _PCI_EXPRESS_SRIOV_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_DEVICE_PRESENCE_PARAMETERS {
    pub Size: ULONG,
    pub Flags: ULONG,
    pub VendorID: USHORT,
    pub DeviceID: USHORT,
    pub RevisionID: UCHAR,
    pub SubVendorID: USHORT,
    pub SubSystemID: USHORT,
    pub BaseClass: UCHAR,
    pub SubClass: UCHAR,
    pub ProgIf: UCHAR,
}
#[test]
fn bindgen_test_layout__PCI_DEVICE_PRESENCE_PARAMETERS() {
    assert_eq!(::core::mem::size_of::<_PCI_DEVICE_PRESENCE_PARAMETERS>() ,
               24usize);
    assert_eq!(::core::mem::align_of::<_PCI_DEVICE_PRESENCE_PARAMETERS>() ,
               4usize);
}
impl Clone for _PCI_DEVICE_PRESENCE_PARAMETERS {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_DEVICE_PRESENCE_PARAMETERS as
        PCI_DEVICE_PRESENCE_PARAMETERS;
pub type PPCI_DEVICE_PRESENCE_PARAMETERS =
    *mut _PCI_DEVICE_PRESENCE_PARAMETERS;
pub type PCI_IS_DEVICE_PRESENT =
    ::core::option::Option<unsafe extern "C" fn(VendorID: USHORT,
                                                DeviceID: USHORT,
                                                RevisionID: UCHAR,
                                                SubVendorID: USHORT,
                                                SubSystemID: USHORT,
                                                Flags: ULONG) -> BOOLEAN>;
pub type PPCI_IS_DEVICE_PRESENT = PCI_IS_DEVICE_PRESENT;
pub type PCI_IS_DEVICE_PRESENT_EX =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                Parameters:
                                                    PPCI_DEVICE_PRESENCE_PARAMETERS)
                               -> BOOLEAN>;
pub type PPCI_IS_DEVICE_PRESENT_EX = PCI_IS_DEVICE_PRESENT_EX;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_DEVICE_PRESENT_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub IsDevicePresent: PPCI_IS_DEVICE_PRESENT,
    pub IsDevicePresentEx: PPCI_IS_DEVICE_PRESENT_EX,
}
#[test]
fn bindgen_test_layout__PCI_DEVICE_PRESENT_INTERFACE() {
    assert_eq!(::core::mem::size_of::<_PCI_DEVICE_PRESENT_INTERFACE>() ,
               48usize);
    assert_eq!(::core::mem::align_of::<_PCI_DEVICE_PRESENT_INTERFACE>() ,
               8usize);
}
impl Clone for _PCI_DEVICE_PRESENT_INTERFACE {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_DEVICE_PRESENT_INTERFACE as PCI_DEVICE_PRESENT_INTERFACE;
pub type PPCI_DEVICE_PRESENT_INTERFACE = *mut _PCI_DEVICE_PRESENT_INTERFACE;
pub type PCI_EXPRESS_ENTER_LINK_QUIESCENT_MODE =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID) -> NTSTATUS>;
pub type PPCI_EXPRESS_ENTER_LINK_QUIESCENT_MODE =
    PCI_EXPRESS_ENTER_LINK_QUIESCENT_MODE;
pub type PCI_EXPRESS_EXIT_LINK_QUIESCENT_MODE =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID) -> NTSTATUS>;
pub type PPCI_EXPRESS_EXIT_LINK_QUIESCENT_MODE =
    PCI_EXPRESS_EXIT_LINK_QUIESCENT_MODE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_LINK_QUIESCENT_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub PciExpressEnterLinkQuiescentMode: PPCI_EXPRESS_ENTER_LINK_QUIESCENT_MODE,
    pub PciExpressExitLinkQuiescentMode: PPCI_EXPRESS_EXIT_LINK_QUIESCENT_MODE,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_LINK_QUIESCENT_INTERFACE() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_LINK_QUIESCENT_INTERFACE>()
               , 48usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_LINK_QUIESCENT_INTERFACE>()
               , 8usize);
}
impl Clone for _PCI_EXPRESS_LINK_QUIESCENT_INTERFACE {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_LINK_QUIESCENT_INTERFACE as
        PCI_EXPRESS_LINK_QUIESCENT_INTERFACE;
pub type PPCI_EXPRESS_LINK_QUIESCENT_INTERFACE =
    *mut _PCI_EXPRESS_LINK_QUIESCENT_INTERFACE;
pub type PPCI_EXPRESS_ROOT_PORT_READ_CONFIG_SPACE =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID, Buffer: PVOID,
                                                Offset: ULONG, Length: ULONG)
                               -> libc::c_ulong>;
pub type PPCI_EXPRESS_ROOT_PORT_WRITE_CONFIG_SPACE =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID, Buffer: PVOID,
                                                Offset: ULONG, Length: ULONG)
                               -> libc::c_ulong>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_ROOT_PORT_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub ReadConfigSpace: PPCI_EXPRESS_ROOT_PORT_READ_CONFIG_SPACE,
    pub WriteConfigSpace: PPCI_EXPRESS_ROOT_PORT_WRITE_CONFIG_SPACE,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_ROOT_PORT_INTERFACE() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_ROOT_PORT_INTERFACE>() ,
               48usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_ROOT_PORT_INTERFACE>() ,
               8usize);
}
impl Clone for _PCI_EXPRESS_ROOT_PORT_INTERFACE {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_ROOT_PORT_INTERFACE as
        PCI_EXPRESS_ROOT_PORT_INTERFACE;
pub type PPCI_EXPRESS_ROOT_PORT_INTERFACE =
    *mut _PCI_EXPRESS_ROOT_PORT_INTERFACE;
pub type PCI_MSIX_SET_ENTRY =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                TableEntry: ULONG,
                                                MessageNumber: ULONG)
                               -> NTSTATUS>;
pub type PPCI_MSIX_SET_ENTRY = PCI_MSIX_SET_ENTRY;
pub type PCI_MSIX_MASKUNMASK_ENTRY =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                TableEntry: ULONG)
                               -> NTSTATUS>;
pub type PPCI_MSIX_MASKUNMASK_ENTRY = PCI_MSIX_MASKUNMASK_ENTRY;
pub type PCI_MSIX_GET_ENTRY =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                TableEntry: ULONG,
                                                MessageNumber: PULONG,
                                                Masked: PBOOLEAN)
                               -> NTSTATUS>;
pub type PPCI_MSIX_GET_ENTRY = PCI_MSIX_GET_ENTRY;
pub type PCI_MSIX_GET_TABLE_SIZE =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                TableSize: PULONG)
                               -> NTSTATUS>;
pub type PPCI_MSIX_GET_TABLE_SIZE = PCI_MSIX_GET_TABLE_SIZE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_MSIX_TABLE_CONFIG_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub SetTableEntry: PPCI_MSIX_SET_ENTRY,
    pub MaskTableEntry: PPCI_MSIX_MASKUNMASK_ENTRY,
    pub UnmaskTableEntry: PPCI_MSIX_MASKUNMASK_ENTRY,
    pub GetTableEntry: PPCI_MSIX_GET_ENTRY,
    pub GetTableSize: PPCI_MSIX_GET_TABLE_SIZE,
}
#[test]
fn bindgen_test_layout__PCI_MSIX_TABLE_CONFIG_INTERFACE() {
    assert_eq!(::core::mem::size_of::<_PCI_MSIX_TABLE_CONFIG_INTERFACE>() ,
               72usize);
    assert_eq!(::core::mem::align_of::<_PCI_MSIX_TABLE_CONFIG_INTERFACE>() ,
               8usize);
}
impl Clone for _PCI_MSIX_TABLE_CONFIG_INTERFACE {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_MSIX_TABLE_CONFIG_INTERFACE as
        PCI_MSIX_TABLE_CONFIG_INTERFACE;
pub type PPCI_MSIX_TABLE_CONFIG_INTERFACE =
    *mut _PCI_MSIX_TABLE_CONFIG_INTERFACE;
extern "C" {
    pub fn ZwCreateFile(FileHandle: PHANDLE, DesiredAccess: ACCESS_MASK,
                        ObjectAttributes: POBJECT_ATTRIBUTES,
                        IoStatusBlock: PIO_STATUS_BLOCK,
                        AllocationSize: PLARGE_INTEGER, FileAttributes: ULONG,
                        ShareAccess: ULONG, CreateDisposition: ULONG,
                        CreateOptions: ULONG, EaBuffer: PVOID,
                        EaLength: ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn ZwOpenFile(FileHandle: PHANDLE, DesiredAccess: ACCESS_MASK,
                      ObjectAttributes: POBJECT_ATTRIBUTES,
                      IoStatusBlock: PIO_STATUS_BLOCK, ShareAccess: ULONG,
                      OpenOptions: ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn ZwLoadDriver(DriverServiceName: PUNICODE_STRING) -> NTSTATUS;
}
extern "C" {
    pub fn ZwUnloadDriver(DriverServiceName: PUNICODE_STRING) -> NTSTATUS;
}
extern "C" {
    pub fn ZwQueryInformationFile(FileHandle: HANDLE,
                                  IoStatusBlock: PIO_STATUS_BLOCK,
                                  FileInformation: PVOID, Length: ULONG,
                                  FileInformationClass:
                                      FILE_INFORMATION_CLASS) -> NTSTATUS;
}
extern "C" {
    pub fn ZwSetInformationFile(FileHandle: HANDLE,
                                IoStatusBlock: PIO_STATUS_BLOCK,
                                FileInformation: PVOID, Length: ULONG,
                                FileInformationClass: FILE_INFORMATION_CLASS)
     -> NTSTATUS;
}
extern "C" {
    pub fn ZwReadFile(FileHandle: HANDLE, Event: HANDLE,
                      ApcRoutine: PIO_APC_ROUTINE, ApcContext: PVOID,
                      IoStatusBlock: PIO_STATUS_BLOCK, Buffer: PVOID,
                      Length: ULONG, ByteOffset: PLARGE_INTEGER, Key: PULONG)
     -> NTSTATUS;
}
extern "C" {
    pub fn ZwWriteFile(FileHandle: HANDLE, Event: HANDLE,
                       ApcRoutine: PIO_APC_ROUTINE, ApcContext: PVOID,
                       IoStatusBlock: PIO_STATUS_BLOCK, Buffer: PVOID,
                       Length: ULONG, ByteOffset: PLARGE_INTEGER, Key: PULONG)
     -> NTSTATUS;
}
extern "C" {
    pub fn ZwClose(Handle: HANDLE) -> NTSTATUS;
}
extern "C" {
    pub fn ZwCreateDirectoryObject(DirectoryHandle: PHANDLE,
                                   DesiredAccess: ACCESS_MASK,
                                   ObjectAttributes: POBJECT_ATTRIBUTES)
     -> NTSTATUS;
}
extern "C" {
    pub fn ZwMakeTemporaryObject(Handle: HANDLE) -> NTSTATUS;
}
extern "C" {
    pub fn ZwCreateSection(SectionHandle: PHANDLE, DesiredAccess: ACCESS_MASK,
                           ObjectAttributes: POBJECT_ATTRIBUTES,
                           MaximumSize: PLARGE_INTEGER,
                           SectionPageProtection: ULONG,
                           AllocationAttributes: ULONG, FileHandle: HANDLE)
     -> NTSTATUS;
}
extern "C" {
    pub fn ZwOpenSection(SectionHandle: PHANDLE, DesiredAccess: ACCESS_MASK,
                         ObjectAttributes: POBJECT_ATTRIBUTES) -> NTSTATUS;
}
extern "C" {
    pub fn ZwMapViewOfSection(SectionHandle: HANDLE, ProcessHandle: HANDLE,
                              BaseAddress: *mut PVOID, ZeroBits: ULONG_PTR,
                              CommitSize: SIZE_T,
                              SectionOffset: PLARGE_INTEGER,
                              ViewSize: PSIZE_T,
                              InheritDisposition: SECTION_INHERIT,
                              AllocationType: ULONG, Win32Protect: ULONG)
     -> NTSTATUS;
}
extern "C" {
    pub fn ZwUnmapViewOfSection(ProcessHandle: HANDLE, BaseAddress: PVOID)
     -> NTSTATUS;
}
extern "C" {
    pub fn ZwCreateKey(KeyHandle: PHANDLE, DesiredAccess: ACCESS_MASK,
                       ObjectAttributes: POBJECT_ATTRIBUTES,
                       TitleIndex: ULONG, Class: PUNICODE_STRING,
                       CreateOptions: ULONG, Disposition: PULONG) -> NTSTATUS;
}
extern "C" {
    pub fn ZwCreateKeyTransacted(KeyHandle: PHANDLE,
                                 DesiredAccess: ACCESS_MASK,
                                 ObjectAttributes: POBJECT_ATTRIBUTES,
                                 TitleIndex: ULONG, Class: PUNICODE_STRING,
                                 CreateOptions: ULONG,
                                 TransactionHandle: HANDLE,
                                 Disposition: PULONG) -> NTSTATUS;
}
extern "C" {
    pub fn ZwOpenKey(KeyHandle: PHANDLE, DesiredAccess: ACCESS_MASK,
                     ObjectAttributes: POBJECT_ATTRIBUTES) -> NTSTATUS;
}
extern "C" {
    pub fn ZwOpenKeyEx(KeyHandle: PHANDLE, DesiredAccess: ACCESS_MASK,
                       ObjectAttributes: POBJECT_ATTRIBUTES,
                       OpenOptions: ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn ZwOpenKeyTransacted(KeyHandle: PHANDLE, DesiredAccess: ACCESS_MASK,
                               ObjectAttributes: POBJECT_ATTRIBUTES,
                               TransactionHandle: HANDLE) -> NTSTATUS;
}
extern "C" {
    pub fn ZwOpenKeyTransactedEx(KeyHandle: PHANDLE,
                                 DesiredAccess: ACCESS_MASK,
                                 ObjectAttributes: POBJECT_ATTRIBUTES,
                                 OpenOptions: ULONG,
                                 TransactionHandle: HANDLE) -> NTSTATUS;
}
extern "C" {
    pub fn ZwDeleteKey(KeyHandle: HANDLE) -> NTSTATUS;
}
extern "C" {
    pub fn ZwDeleteValueKey(KeyHandle: HANDLE, ValueName: PUNICODE_STRING)
     -> NTSTATUS;
}
extern "C" {
    pub fn ZwEnumerateKey(KeyHandle: HANDLE, Index: ULONG,
                          KeyInformationClass: KEY_INFORMATION_CLASS,
                          KeyInformation: PVOID, Length: ULONG,
                          ResultLength: PULONG) -> NTSTATUS;
}
extern "C" {
    pub fn ZwEnumerateValueKey(KeyHandle: HANDLE, Index: ULONG,
                               KeyValueInformationClass:
                                   KEY_VALUE_INFORMATION_CLASS,
                               KeyValueInformation: PVOID, Length: ULONG,
                               ResultLength: PULONG) -> NTSTATUS;
}
extern "C" {
    pub fn ZwFlushKey(KeyHandle: HANDLE) -> NTSTATUS;
}
extern "C" {
    pub fn ZwQueryKey(KeyHandle: HANDLE,
                      KeyInformationClass: KEY_INFORMATION_CLASS,
                      KeyInformation: PVOID, Length: ULONG,
                      ResultLength: PULONG) -> NTSTATUS;
}
extern "C" {
    pub fn ZwQueryValueKey(KeyHandle: HANDLE, ValueName: PUNICODE_STRING,
                           KeyValueInformationClass:
                               KEY_VALUE_INFORMATION_CLASS,
                           KeyValueInformation: PVOID, Length: ULONG,
                           ResultLength: PULONG) -> NTSTATUS;
}
extern "C" {
    pub fn ZwRenameKey(KeyHandle: HANDLE, NewName: PUNICODE_STRING)
     -> NTSTATUS;
}
extern "C" {
    pub fn ZwSaveKey(KeyHandle: HANDLE, FileHandle: HANDLE) -> NTSTATUS;
}
extern "C" {
    pub fn ZwSaveKeyEx(KeyHandle: HANDLE, FileHandle: HANDLE, Format: ULONG)
     -> NTSTATUS;
}
extern "C" {
    pub fn ZwRestoreKey(KeyHandle: HANDLE, FileHandle: HANDLE, Flags: ULONG)
     -> NTSTATUS;
}
extern "C" {
    pub fn ZwSetInformationKey(KeyHandle: HANDLE,
                               KeySetInformationClass:
                                   KEY_SET_INFORMATION_CLASS,
                               KeySetInformation: PVOID,
                               KeySetInformationLength: ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn ZwSetValueKey(KeyHandle: HANDLE, ValueName: PUNICODE_STRING,
                         TitleIndex: ULONG, Type: ULONG, Data: PVOID,
                         DataSize: ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn ZwOpenSymbolicLinkObject(LinkHandle: PHANDLE,
                                    DesiredAccess: ACCESS_MASK,
                                    ObjectAttributes: POBJECT_ATTRIBUTES)
     -> NTSTATUS;
}
extern "C" {
    pub fn ZwQuerySymbolicLinkObject(LinkHandle: HANDLE,
                                     LinkTarget: PUNICODE_STRING,
                                     ReturnedLength: PULONG) -> NTSTATUS;
}
extern "C" {
    pub fn ZwCreateTransactionManager(TmHandle: PHANDLE,
                                      DesiredAccess: ACCESS_MASK,
                                      ObjectAttributes: POBJECT_ATTRIBUTES,
                                      LogFileName: PUNICODE_STRING,
                                      CreateOptions: ULONG,
                                      CommitStrength: ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn ZwOpenTransactionManager(TmHandle: PHANDLE,
                                    DesiredAccess: ACCESS_MASK,
                                    ObjectAttributes: POBJECT_ATTRIBUTES,
                                    LogFileName: PUNICODE_STRING,
                                    TmIdentity: LPGUID, OpenOptions: ULONG)
     -> NTSTATUS;
}
extern "C" {
    pub fn ZwRollforwardTransactionManager(TransactionManagerHandle: HANDLE,
                                           TmVirtualClock: PLARGE_INTEGER)
     -> NTSTATUS;
}
extern "C" {
    pub fn ZwRecoverTransactionManager(TransactionManagerHandle: HANDLE)
     -> NTSTATUS;
}
extern "C" {
    pub fn ZwQueryInformationTransactionManager(TransactionManagerHandle:
                                                    HANDLE,
                                                TransactionManagerInformationClass:
                                                    TRANSACTIONMANAGER_INFORMATION_CLASS,
                                                TransactionManagerInformation:
                                                    PVOID,
                                                TransactionManagerInformationLength:
                                                    ULONG,
                                                ReturnLength: PULONG)
     -> NTSTATUS;
}
extern "C" {
    pub fn ZwSetInformationTransactionManager(TmHandle: HANDLE,
                                              TransactionManagerInformationClass:
                                                  TRANSACTIONMANAGER_INFORMATION_CLASS,
                                              TransactionManagerInformation:
                                                  PVOID,
                                              TransactionManagerInformationLength:
                                                  ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn ZwEnumerateTransactionObject(RootObjectHandle: HANDLE,
                                        QueryType: KTMOBJECT_TYPE,
                                        ObjectCursor: PKTMOBJECT_CURSOR,
                                        ObjectCursorLength: ULONG,
                                        ReturnLength: PULONG) -> NTSTATUS;
}
extern "C" {
    pub fn ZwCreateTransaction(TransactionHandle: PHANDLE,
                               DesiredAccess: ACCESS_MASK,
                               ObjectAttributes: POBJECT_ATTRIBUTES,
                               Uow: LPGUID, TmHandle: HANDLE,
                               CreateOptions: ULONG, IsolationLevel: ULONG,
                               IsolationFlags: ULONG, Timeout: PLARGE_INTEGER,
                               Description: PUNICODE_STRING) -> NTSTATUS;
}
extern "C" {
    pub fn ZwOpenTransaction(TransactionHandle: PHANDLE,
                             DesiredAccess: ACCESS_MASK,
                             ObjectAttributes: POBJECT_ATTRIBUTES,
                             Uow: LPGUID, TmHandle: HANDLE) -> NTSTATUS;
}
extern "C" {
    pub fn ZwQueryInformationTransaction(TransactionHandle: HANDLE,
                                         TransactionInformationClass:
                                             TRANSACTION_INFORMATION_CLASS,
                                         TransactionInformation: PVOID,
                                         TransactionInformationLength: ULONG,
                                         ReturnLength: PULONG) -> NTSTATUS;
}
extern "C" {
    pub fn ZwSetInformationTransaction(TransactionHandle: HANDLE,
                                       TransactionInformationClass:
                                           TRANSACTION_INFORMATION_CLASS,
                                       TransactionInformation: PVOID,
                                       TransactionInformationLength: ULONG)
     -> NTSTATUS;
}
extern "C" {
    pub fn ZwCommitTransaction(TransactionHandle: HANDLE, Wait: BOOLEAN)
     -> NTSTATUS;
}
extern "C" {
    pub fn ZwRollbackTransaction(TransactionHandle: HANDLE, Wait: BOOLEAN)
     -> NTSTATUS;
}
extern "C" {
    pub fn ZwCreateResourceManager(ResourceManagerHandle: PHANDLE,
                                   DesiredAccess: ACCESS_MASK,
                                   TmHandle: HANDLE,
                                   ResourceManagerGuid: LPGUID,
                                   ObjectAttributes: POBJECT_ATTRIBUTES,
                                   CreateOptions: ULONG,
                                   Description: PUNICODE_STRING) -> NTSTATUS;
}
extern "C" {
    pub fn ZwOpenResourceManager(ResourceManagerHandle: PHANDLE,
                                 DesiredAccess: ACCESS_MASK, TmHandle: HANDLE,
                                 ResourceManagerGuid: LPGUID,
                                 ObjectAttributes: POBJECT_ATTRIBUTES)
     -> NTSTATUS;
}
extern "C" {
    pub fn ZwRecoverResourceManager(ResourceManagerHandle: HANDLE)
     -> NTSTATUS;
}
extern "C" {
    pub fn ZwGetNotificationResourceManager(ResourceManagerHandle: HANDLE,
                                            TransactionNotification:
                                                PTRANSACTION_NOTIFICATION,
                                            NotificationLength: ULONG,
                                            Timeout: PLARGE_INTEGER,
                                            ReturnLength: PULONG,
                                            Asynchronous: ULONG,
                                            AsynchronousContext: ULONG_PTR)
     -> NTSTATUS;
}
extern "C" {
    pub fn ZwQueryInformationResourceManager(ResourceManagerHandle: HANDLE,
                                             ResourceManagerInformationClass:
                                                 RESOURCEMANAGER_INFORMATION_CLASS,
                                             ResourceManagerInformation:
                                                 PVOID,
                                             ResourceManagerInformationLength:
                                                 ULONG, ReturnLength: PULONG)
     -> NTSTATUS;
}
extern "C" {
    pub fn ZwSetInformationResourceManager(ResourceManagerHandle: HANDLE,
                                           ResourceManagerInformationClass:
                                               RESOURCEMANAGER_INFORMATION_CLASS,
                                           ResourceManagerInformation: PVOID,
                                           ResourceManagerInformationLength:
                                               ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn ZwCreateEnlistment(EnlistmentHandle: PHANDLE,
                              DesiredAccess: ACCESS_MASK,
                              ResourceManagerHandle: HANDLE,
                              TransactionHandle: HANDLE,
                              ObjectAttributes: POBJECT_ATTRIBUTES,
                              CreateOptions: ULONG,
                              NotificationMask: NOTIFICATION_MASK,
                              EnlistmentKey: PVOID) -> NTSTATUS;
}
extern "C" {
    pub fn ZwOpenEnlistment(EnlistmentHandle: PHANDLE,
                            DesiredAccess: ACCESS_MASK, RmHandle: HANDLE,
                            EnlistmentGuid: LPGUID,
                            ObjectAttributes: POBJECT_ATTRIBUTES) -> NTSTATUS;
}
extern "C" {
    pub fn ZwQueryInformationEnlistment(EnlistmentHandle: HANDLE,
                                        EnlistmentInformationClass:
                                            ENLISTMENT_INFORMATION_CLASS,
                                        EnlistmentInformation: PVOID,
                                        EnlistmentInformationLength: ULONG,
                                        ReturnLength: PULONG) -> NTSTATUS;
}
extern "C" {
    pub fn ZwSetInformationEnlistment(EnlistmentHandle: HANDLE,
                                      EnlistmentInformationClass:
                                          ENLISTMENT_INFORMATION_CLASS,
                                      EnlistmentInformation: PVOID,
                                      EnlistmentInformationLength: ULONG)
     -> NTSTATUS;
}
extern "C" {
    pub fn ZwRecoverEnlistment(EnlistmentHandle: HANDLE, EnlistmentKey: PVOID)
     -> NTSTATUS;
}
extern "C" {
    pub fn ZwPrePrepareEnlistment(EnlistmentHandle: HANDLE,
                                  TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
extern "C" {
    pub fn ZwPrepareEnlistment(EnlistmentHandle: HANDLE,
                               TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
extern "C" {
    pub fn ZwCommitEnlistment(EnlistmentHandle: HANDLE,
                              TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
extern "C" {
    pub fn ZwRollbackEnlistment(EnlistmentHandle: HANDLE,
                                TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
extern "C" {
    pub fn ZwPrePrepareComplete(EnlistmentHandle: HANDLE,
                                TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
extern "C" {
    pub fn ZwPrepareComplete(EnlistmentHandle: HANDLE,
                             TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
extern "C" {
    pub fn ZwCommitComplete(EnlistmentHandle: HANDLE,
                            TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
extern "C" {
    pub fn ZwReadOnlyEnlistment(EnlistmentHandle: HANDLE,
                                TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
extern "C" {
    pub fn ZwRollbackComplete(EnlistmentHandle: HANDLE,
                              TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
extern "C" {
    pub fn ZwSinglePhaseReject(EnlistmentHandle: HANDLE,
                               TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
extern "C" {
    pub fn ZwOpenEvent(EventHandle: PHANDLE, DesiredAccess: ACCESS_MASK,
                       ObjectAttributes: POBJECT_ATTRIBUTES) -> NTSTATUS;
}
extern "C" {
    pub fn ZwQueryFullAttributesFile(ObjectAttributes: POBJECT_ATTRIBUTES,
                                     FileInformation:
                                         PFILE_NETWORK_OPEN_INFORMATION)
     -> NTSTATUS;
}
pub type CLFS_CONTAINER_ID = ULONG;
pub type PCLFS_CONTAINER_ID = *mut CLFS_CONTAINER_ID;
pub type PPCLFS_CONTAINER_ID = *mut *mut CLFS_CONTAINER_ID;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CLS_LSN {
    pub Internal: ULONGLONG,
}
#[test]
fn bindgen_test_layout__CLS_LSN() {
    assert_eq!(::core::mem::size_of::<_CLS_LSN>() , 8usize);
    assert_eq!(::core::mem::align_of::<_CLS_LSN>() , 8usize);
}
impl Clone for _CLS_LSN {
    fn clone(&self) -> Self { *self }
}
pub use self::_CLS_LSN as CLS_LSN;
pub type PCLS_LSN = *mut _CLS_LSN;
pub type PPCLS_LSN = *mut *mut _CLS_LSN;
pub use self::CLS_LSN as CLFS_LSN;
pub type PCLFS_LSN = *mut CLFS_LSN;
pub type PPCLFS_LSN = *mut *mut CLFS_LSN;
extern "C" {
    #[link_name = "CLFS_LSN_INVALID"]
    pub static CLFS_LSN_INVALID: CLFS_LSN;
}
extern "C" {
    #[link_name = "CLFS_LSN_NULL"]
    pub static CLFS_LSN_NULL: CLFS_LSN;
}
pub type CLS_RECORD_TYPE = UCHAR;
pub type PCLS_RECORD_TYPE = *mut UCHAR;
pub type PPCLS_RECORD_TYPE = *mut *mut UCHAR;
pub type CLFS_RECORD_TYPE = CLS_RECORD_TYPE;
pub type PCLFS_RECORD_TYPE = *mut CLS_RECORD_TYPE;
pub type PPCLFS_RECORD_TYPE = *mut *mut CLS_RECORD_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _CLS_CONTEXT_MODE {
    ClsContextNone = 0,
    ClsContextUndoNext = 1,
    ClsContextPrevious = 2,
    ClsContextForward = 3,
}
pub use self::_CLS_CONTEXT_MODE as CLS_CONTEXT_MODE;
pub type PCLS_CONTEXT_MODE = *mut _CLS_CONTEXT_MODE;
pub type PPCLS_CONTEXT_MODE = *mut *mut _CLS_CONTEXT_MODE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _CLFS_CONTEXT_MODE {
    ClfsContextNone = 0,
    ClfsContextUndoNext = 1,
    ClfsContextPrevious = 2,
    ClfsContextForward = 3,
}
pub use self::_CLFS_CONTEXT_MODE as CLFS_CONTEXT_MODE;
pub type PCLFS_CONTEXT_MODE = *mut _CLFS_CONTEXT_MODE;
pub type PPCLFS_CONTEXT_MODE = *mut *mut _CLFS_CONTEXT_MODE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CLFS_NODE_ID {
    pub cType: ULONG,
    pub cbNode: ULONG,
}
#[test]
fn bindgen_test_layout__CLFS_NODE_ID() {
    assert_eq!(::core::mem::size_of::<_CLFS_NODE_ID>() , 8usize);
    assert_eq!(::core::mem::align_of::<_CLFS_NODE_ID>() , 4usize);
}
impl Clone for _CLFS_NODE_ID {
    fn clone(&self) -> Self { *self }
}
pub use self::_CLFS_NODE_ID as CLFS_NODE_ID;
pub type PCLFS_NODE_ID = *mut _CLFS_NODE_ID;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CLS_WRITE_ENTRY {
    pub Buffer: PVOID,
    pub ByteLength: ULONG,
}
#[test]
fn bindgen_test_layout__CLS_WRITE_ENTRY() {
    assert_eq!(::core::mem::size_of::<_CLS_WRITE_ENTRY>() , 16usize);
    assert_eq!(::core::mem::align_of::<_CLS_WRITE_ENTRY>() , 8usize);
}
impl Clone for _CLS_WRITE_ENTRY {
    fn clone(&self) -> Self { *self }
}
pub use self::_CLS_WRITE_ENTRY as CLS_WRITE_ENTRY;
pub type PCLS_WRITE_ENTRY = *mut _CLS_WRITE_ENTRY;
pub type PPCLS_WRITE_ENTRY = *mut *mut _CLS_WRITE_ENTRY;
pub use self::CLS_WRITE_ENTRY as CLFS_WRITE_ENTRY;
pub type PCLFS_WRITE_ENTRY = *mut CLFS_WRITE_ENTRY;
pub type PPCLFS_WRITE_ENTRY = *mut *mut CLFS_WRITE_ENTRY;
pub use self::GUID as CLFS_LOG_ID;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CLS_INFORMATION {
    pub TotalAvailable: LONGLONG,
    pub CurrentAvailable: LONGLONG,
    pub TotalReservation: LONGLONG,
    pub BaseFileSize: ULONGLONG,
    pub ContainerSize: ULONGLONG,
    pub TotalContainers: ULONG,
    pub FreeContainers: ULONG,
    pub TotalClients: ULONG,
    pub Attributes: ULONG,
    pub FlushThreshold: ULONG,
    pub SectorSize: ULONG,
    pub MinArchiveTailLsn: CLS_LSN,
    pub BaseLsn: CLS_LSN,
    pub LastFlushedLsn: CLS_LSN,
    pub LastLsn: CLS_LSN,
    pub RestartLsn: CLS_LSN,
    pub Identity: GUID,
}
#[test]
fn bindgen_test_layout__CLS_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_CLS_INFORMATION>() , 120usize);
    assert_eq!(::core::mem::align_of::<_CLS_INFORMATION>() , 8usize);
}
impl Clone for _CLS_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_CLS_INFORMATION as CLS_INFORMATION;
pub type PCLS_INFORMATION = *mut _CLS_INFORMATION;
pub type PPCLS_INFORMATION = *mut _CLS_INFORMATION;
pub use self::CLS_INFORMATION as CLFS_INFORMATION;
pub type PCLFS_INFORMATION = *mut CLFS_INFORMATION;
pub type PPCLFS_INFORMATION = *mut CLFS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CLFS_LOG_NAME_INFORMATION {
    pub NameLengthInBytes: USHORT,
    pub Name: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__CLFS_LOG_NAME_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_CLFS_LOG_NAME_INFORMATION>() , 4usize);
    assert_eq!(::core::mem::align_of::<_CLFS_LOG_NAME_INFORMATION>() ,
               2usize);
}
impl Clone for _CLFS_LOG_NAME_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_CLFS_LOG_NAME_INFORMATION as CLFS_LOG_NAME_INFORMATION;
pub type PCLFS_LOG_NAME_INFORMATION = *mut _CLFS_LOG_NAME_INFORMATION;
pub type PPCLFS_LOG_NAME_INFORMATION = *mut *mut _CLFS_LOG_NAME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CLFS_STREAM_ID_INFORMATION {
    pub StreamIdentifier: UCHAR,
}
#[test]
fn bindgen_test_layout__CLFS_STREAM_ID_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_CLFS_STREAM_ID_INFORMATION>() ,
               1usize);
    assert_eq!(::core::mem::align_of::<_CLFS_STREAM_ID_INFORMATION>() ,
               1usize);
}
impl Clone for _CLFS_STREAM_ID_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_CLFS_STREAM_ID_INFORMATION as CLFS_STREAM_ID_INFORMATION;
pub type PCLFS_STREAM_ID_INFORMATION = *mut _CLFS_STREAM_ID_INFORMATION;
pub type PPCLFS_STREAM_ID_INFORMATION = *mut *mut _CLFS_STREAM_ID_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CLFS_PHYSICAL_LSN_INFORMATION {
    pub StreamIdentifier: UCHAR,
    pub VirtualLsn: CLFS_LSN,
    pub PhysicalLsn: CLFS_LSN,
}
impl Clone for _CLFS_PHYSICAL_LSN_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_CLFS_PHYSICAL_LSN_INFORMATION as CLFS_PHYSICAL_LSN_INFORMATION;
pub type PCLFS_PHYSICAL_LSN_INFORMATION = *mut _CLFS_PHYSICAL_LSN_INFORMATION;
pub type CLS_CONTAINER_STATE = UINT32;
pub type PCLS_CONTAINER_STATE = *mut UINT32;
pub type PPCLS_CONTAINER_STATE = *mut UINT32;
pub type CLFS_CONTAINER_STATE = CLS_CONTAINER_STATE;
pub type PCLFS_CONTAINER_STATE = *mut CLS_CONTAINER_STATE;
pub type PPCLFS_CONTAINER_STATE = *mut CLS_CONTAINER_STATE;
#[repr(C)]
pub struct _CLS_CONTAINER_INFORMATION {
    pub FileAttributes: ULONG,
    pub CreationTime: ULONGLONG,
    pub LastAccessTime: ULONGLONG,
    pub LastWriteTime: ULONGLONG,
    pub ContainerSize: LONGLONG,
    pub FileNameActualLength: ULONG,
    pub FileNameLength: ULONG,
    pub FileName: [WCHAR; 256usize],
    pub State: CLFS_CONTAINER_STATE,
    pub PhysicalContainerId: CLFS_CONTAINER_ID,
    pub LogicalContainerId: CLFS_CONTAINER_ID,
}
#[test]
fn bindgen_test_layout__CLS_CONTAINER_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_CLS_CONTAINER_INFORMATION>() ,
               576usize);
    assert_eq!(::core::mem::align_of::<_CLS_CONTAINER_INFORMATION>() ,
               8usize);
}
pub use self::_CLS_CONTAINER_INFORMATION as CLS_CONTAINER_INFORMATION;
pub type PCLS_CONTAINER_INFORMATION = *mut _CLS_CONTAINER_INFORMATION;
pub type PPCLS_CONTAINER_INFORMATION = *mut *mut _CLS_CONTAINER_INFORMATION;
pub use self::CLS_CONTAINER_INFORMATION as CLFS_CONTAINER_INFORMATION;
pub type PCLFS_CONTAINER_INFORMATION = *mut CLFS_CONTAINER_INFORMATION;
pub type PPCLFS_CONTAINER_INFORMATION = *mut *mut CLFS_CONTAINER_INFORMATION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _CLS_LOG_INFORMATION_CLASS {
    ClfsLogBasicInformation = 0,
    ClfsLogBasicInformationPhysical = 1,
    ClfsLogPhysicalNameInformation = 2,
    ClfsLogStreamIdentifierInformation = 3,
    ClfsLogSystemMarkingInformation = 4,
    ClfsLogPhysicalLsnInformation = 5,
}
pub use self::_CLS_LOG_INFORMATION_CLASS as CLS_LOG_INFORMATION_CLASS;
pub type PCLS_LOG_INFORMATION_CLASS = *mut _CLS_LOG_INFORMATION_CLASS;
pub type PPCLS_LOG_INFORMATION_CLASS = *mut *mut _CLS_LOG_INFORMATION_CLASS;
pub use self::CLS_LOG_INFORMATION_CLASS as CLFS_LOG_INFORMATION_CLASS;
pub type PCLFS_LOG_INFORMATION_CLASS = *mut CLFS_LOG_INFORMATION_CLASS;
pub type PPCLFS_LOG_INFORMATION_CLASS = *mut *mut CLFS_LOG_INFORMATION_CLASS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _CLS_IOSTATS_CLASS { ClsIoStatsDefault = 0, ClsIoStatsMax = 65535, }
pub use self::_CLS_IOSTATS_CLASS as CLS_IOSTATS_CLASS;
pub type PCLS_IOSTATS_CLASS = *mut _CLS_IOSTATS_CLASS;
pub type PPCLS_IOSTATS_CLASS = *mut *mut _CLS_IOSTATS_CLASS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _CLFS_IOSTATS_CLASS {
    ClfsIoStatsDefault = 0,
    ClfsIoStatsMax = 65535,
}
pub use self::_CLFS_IOSTATS_CLASS as CLFS_IOSTATS_CLASS;
pub type PCLFS_IOSTATS_CLASS = *mut _CLFS_IOSTATS_CLASS;
pub type PPCLFS_IOSTATS_CLASS = *mut *mut _CLFS_IOSTATS_CLASS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CLS_IO_STATISTICS_HEADER {
    pub ubMajorVersion: UCHAR,
    pub ubMinorVersion: UCHAR,
    pub eStatsClass: CLFS_IOSTATS_CLASS,
    pub cbLength: USHORT,
    pub coffData: ULONG,
}
#[test]
fn bindgen_test_layout__CLS_IO_STATISTICS_HEADER() {
    assert_eq!(::core::mem::size_of::<_CLS_IO_STATISTICS_HEADER>() , 16usize);
    assert_eq!(::core::mem::align_of::<_CLS_IO_STATISTICS_HEADER>() , 4usize);
}
impl Clone for _CLS_IO_STATISTICS_HEADER {
    fn clone(&self) -> Self { *self }
}
pub use self::_CLS_IO_STATISTICS_HEADER as CLS_IO_STATISTICS_HEADER;
pub type PCLS_IO_STATISTICS_HEADER = *mut _CLS_IO_STATISTICS_HEADER;
pub type PPCLS_IO_STATISTICS_HEADER = *mut *mut _CLS_IO_STATISTICS_HEADER;
pub use self::CLS_IO_STATISTICS_HEADER as CLFS_IO_STATISTICS_HEADER;
pub type PCLFS_IO_STATISTICS_HEADER = *mut CLFS_IO_STATISTICS_HEADER;
pub type PPCLFS_IO_STATISTICS_HEADER = *mut *mut CLFS_IO_STATISTICS_HEADER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CLS_IO_STATISTICS {
    pub hdrIoStats: CLS_IO_STATISTICS_HEADER,
    pub cFlush: ULONGLONG,
    pub cbFlush: ULONGLONG,
    pub cMetaFlush: ULONGLONG,
    pub cbMetaFlush: ULONGLONG,
}
#[test]
fn bindgen_test_layout__CLS_IO_STATISTICS() {
    assert_eq!(::core::mem::size_of::<_CLS_IO_STATISTICS>() , 48usize);
    assert_eq!(::core::mem::align_of::<_CLS_IO_STATISTICS>() , 8usize);
}
impl Clone for _CLS_IO_STATISTICS {
    fn clone(&self) -> Self { *self }
}
pub use self::_CLS_IO_STATISTICS as CLS_IO_STATISTICS;
pub type PCLS_IO_STATISTICS = *mut _CLS_IO_STATISTICS;
pub type PPCLS_IO_STATISTICS = *mut *mut _CLS_IO_STATISTICS;
pub use self::CLS_IO_STATISTICS as CLFS_IO_STATISTICS;
pub type PCLFS_IO_STATISTICS = *mut CLFS_IO_STATISTICS;
pub type PPCLFS_IO_STATISTICS = *mut *mut CLFS_IO_STATISTICS;
pub type CLFS_SCAN_MODE = UCHAR;
pub type PCLFS_SCAN_MODE = *mut UCHAR;
pub use self::FILE_OBJECT as LOG_FILE_OBJECT;
pub type PLOG_FILE_OBJECT = *mut FILE_OBJECT;
pub type PPLOG_FILE_OBJECT = *mut *mut FILE_OBJECT;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CLS_SCAN_CONTEXT {
    pub cidNode: CLFS_NODE_ID,
    pub plfoLog: PLOG_FILE_OBJECT,
    pub cIndex: ULONG,
    pub cContainers: ULONG,
    pub cContainersReturned: ULONG,
    pub eScanMode: CLFS_SCAN_MODE,
    pub pinfoContainer: PCLS_CONTAINER_INFORMATION,
}
impl Clone for _CLS_SCAN_CONTEXT {
    fn clone(&self) -> Self { *self }
}
pub use self::_CLS_SCAN_CONTEXT as CLS_SCAN_CONTEXT;
pub type PCLS_SCAN_CONTEXT = *mut _CLS_SCAN_CONTEXT;
pub type PPCLS_SCAN_CONTEXT = *mut *mut _CLS_SCAN_CONTEXT;
pub use self::CLS_SCAN_CONTEXT as CLFS_SCAN_CONTEXT;
pub type PCLFS_SCAN_CONTEXT = *mut CLFS_SCAN_CONTEXT;
pub type PPCLFS_SCAN_CONTEXT = *mut *mut CLFS_SCAN_CONTEXT;
#[repr(C)]
pub struct _CLS_ARCHIVE_DESCRIPTOR {
    pub coffLow: ULONGLONG,
    pub coffHigh: ULONGLONG,
    pub infoContainer: CLS_CONTAINER_INFORMATION,
}
#[test]
fn bindgen_test_layout__CLS_ARCHIVE_DESCRIPTOR() {
    assert_eq!(::core::mem::size_of::<_CLS_ARCHIVE_DESCRIPTOR>() , 592usize);
    assert_eq!(::core::mem::align_of::<_CLS_ARCHIVE_DESCRIPTOR>() , 8usize);
}
pub use self::_CLS_ARCHIVE_DESCRIPTOR as CLS_ARCHIVE_DESCRIPTOR;
pub type PCLS_ARCHIVE_DESCRIPTOR = *mut _CLS_ARCHIVE_DESCRIPTOR;
pub type PPCLS_ARCHIVE_DESCRIPTOR = *mut *mut _CLS_ARCHIVE_DESCRIPTOR;
pub use self::CLS_ARCHIVE_DESCRIPTOR as CLFS_ARCHIVE_DESCRIPTOR;
pub type PCLFS_ARCHIVE_DESCRIPTOR = *mut CLFS_ARCHIVE_DESCRIPTOR;
pub type PPCLFS_ARCHIVE_DESCRIPTOR = *mut *mut CLFS_ARCHIVE_DESCRIPTOR;
pub type CLFS_BLOCK_ALLOCATION =
    ::core::option::Option<unsafe extern "C" fn(cbBufferLength: ULONG,
                                                pvUserContext: PVOID)
                               -> *mut libc::c_void>;
pub type CLFS_BLOCK_DEALLOCATION =
    ::core::option::Option<unsafe extern "C" fn(pvBuffer: PVOID,
                                                pvUserContext: PVOID)>;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _CLFS_LOG_ARCHIVE_MODE {
    ClfsLogArchiveEnabled = 1,
    ClfsLogArchiveDisabled = 2,
}
pub use self::_CLFS_LOG_ARCHIVE_MODE as CLFS_LOG_ARCHIVE_MODE;
pub type PCLFS_LOG_ARCHIVE_MODE = *mut _CLFS_LOG_ARCHIVE_MODE;
extern "C" {
    pub fn ClfsLsnEqual(plsn1: *const CLFS_LSN, plsn2: *const CLFS_LSN)
     -> BOOLEAN;
}
extern "C" {
    pub fn ClfsLsnLess(plsn1: *const CLFS_LSN, plsn2: *const CLFS_LSN)
     -> BOOLEAN;
}
extern "C" {
    pub fn ClfsLsnGreater(plsn1: *const CLFS_LSN, plsn2: *const CLFS_LSN)
     -> BOOLEAN;
}
extern "C" {
    pub fn ClfsLsnNull(plsn: *const CLFS_LSN) -> BOOLEAN;
}
extern "C" {
    pub fn ClfsLsnContainer(plsn: *const CLFS_LSN) -> CLFS_CONTAINER_ID;
}
extern "C" {
    pub fn ClfsLsnCreate(cidContainer: CLFS_CONTAINER_ID, offBlock: ULONG,
                         cRecord: ULONG) -> CLFS_LSN;
}
extern "C" {
    pub fn ClfsLsnBlockOffset(plsn: *const CLFS_LSN) -> ULONG;
}
extern "C" {
    pub fn ClfsLsnRecordSequence(plsn: *const CLFS_LSN) -> ULONG;
}
extern "C" {
    pub fn ClfsLsnInvalid(plsn: *const CLFS_LSN) -> BOOLEAN;
}
extern "C" {
    pub fn ClfsLsnIncrement(plsn: PCLFS_LSN) -> CLFS_LSN;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _CLFS_MGMT_POLICY_TYPE {
    ClfsMgmtPolicyMaximumSize = 0,
    ClfsMgmtPolicyMinimumSize = 1,
    ClfsMgmtPolicyNewContainerSize = 2,
    ClfsMgmtPolicyGrowthRate = 3,
    ClfsMgmtPolicyLogTail = 4,
    ClfsMgmtPolicyAutoShrink = 5,
    ClfsMgmtPolicyAutoGrow = 6,
    ClfsMgmtPolicyNewContainerPrefix = 7,
    ClfsMgmtPolicyNewContainerSuffix = 8,
    ClfsMgmtPolicyNewContainerExtension = 9,
    ClfsMgmtPolicyInvalid = 10,
}
pub use self::_CLFS_MGMT_POLICY_TYPE as CLFS_MGMT_POLICY_TYPE;
pub type PCLFS_MGMT_POLICY_TYPE = *mut _CLFS_MGMT_POLICY_TYPE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CLFS_MGMT_POLICY {
    pub Version: ULONG,
    pub LengthInBytes: ULONG,
    pub PolicyFlags: ULONG,
    pub PolicyType: CLFS_MGMT_POLICY_TYPE,
    pub PolicyParameters: _CLFS_MGMT_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CLFS_MGMT_POLICY__bindgen_ty_1 {
    pub MaximumSize: __BindgenUnionField<_CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_1>,
    pub MinimumSize: __BindgenUnionField<_CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_2>,
    pub NewContainerSize: __BindgenUnionField<_CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_3>,
    pub GrowthRate: __BindgenUnionField<_CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_4>,
    pub LogTail: __BindgenUnionField<_CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_5>,
    pub AutoShrink: __BindgenUnionField<_CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_6>,
    pub AutoGrow: __BindgenUnionField<_CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_7>,
    pub NewContainerPrefix: __BindgenUnionField<_CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_8>,
    pub NewContainerSuffix: __BindgenUnionField<_CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_9>,
    pub NewContainerExtension: __BindgenUnionField<_CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_10>,
    pub bindgen_union_field: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub Containers: ULONG,
}
#[test]
fn bindgen_test_layout__CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_2 {
    pub Containers: ULONG,
}
#[test]
fn bindgen_test_layout__CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<_CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_2>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_2>()
               , 4usize);
}
impl Clone for _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_3 {
    pub SizeInBytes: ULONG,
}
#[test]
fn bindgen_test_layout__CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<_CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_3>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_3>()
               , 4usize);
}
impl Clone for _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_4 {
    pub AbsoluteGrowthInContainers: ULONG,
    pub RelativeGrowthPercentage: ULONG,
}
#[test]
fn bindgen_test_layout__CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(::core::mem::size_of::<_CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_4>()
               , 8usize);
    assert_eq!(::core::mem::align_of::<_CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_4>()
               , 4usize);
}
impl Clone for _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_5 {
    pub MinimumAvailablePercentage: ULONG,
    pub MinimumAvailableContainers: ULONG,
}
#[test]
fn bindgen_test_layout__CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(::core::mem::size_of::<_CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_5>()
               , 8usize);
    assert_eq!(::core::mem::align_of::<_CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_5>()
               , 4usize);
}
impl Clone for _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_6 {
    pub Percentage: ULONG,
}
#[test]
fn bindgen_test_layout__CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(::core::mem::size_of::<_CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_6>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_6>()
               , 4usize);
}
impl Clone for _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_6 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_7 {
    pub Enabled: ULONG,
}
#[test]
fn bindgen_test_layout__CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_7() {
    assert_eq!(::core::mem::size_of::<_CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_7>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_7>()
               , 4usize);
}
impl Clone for _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_7 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_8 {
    pub PrefixLengthInBytes: USHORT,
    pub PrefixString: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_8() {
    assert_eq!(::core::mem::size_of::<_CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_8>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_8>()
               , 2usize);
}
impl Clone for _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_8 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_9 {
    pub NextContainerSuffix: ULONGLONG,
}
#[test]
fn bindgen_test_layout__CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_9() {
    assert_eq!(::core::mem::size_of::<_CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_9>()
               , 8usize);
    assert_eq!(::core::mem::align_of::<_CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_9>()
               , 8usize);
}
impl Clone for _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_9 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_10 {
    pub ExtensionLengthInBytes: USHORT,
    pub ExtensionString: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_10() {
    assert_eq!(::core::mem::size_of::<_CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_10>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_10>()
               , 2usize);
}
impl Clone for _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_10 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__CLFS_MGMT_POLICY__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_CLFS_MGMT_POLICY__bindgen_ty_1>() ,
               8usize);
    assert_eq!(::core::mem::align_of::<_CLFS_MGMT_POLICY__bindgen_ty_1>() ,
               8usize);
}
impl Clone for _CLFS_MGMT_POLICY__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__CLFS_MGMT_POLICY() {
    assert_eq!(::core::mem::size_of::<_CLFS_MGMT_POLICY>() , 24usize);
    assert_eq!(::core::mem::align_of::<_CLFS_MGMT_POLICY>() , 8usize);
}
impl Clone for _CLFS_MGMT_POLICY {
    fn clone(&self) -> Self { *self }
}
pub use self::_CLFS_MGMT_POLICY as CLFS_MGMT_POLICY;
pub type PCLFS_MGMT_POLICY = *mut _CLFS_MGMT_POLICY;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _CLFS_MGMT_NOTIFICATION_TYPE {
    ClfsMgmtAdvanceTailNotification = 0,
    ClfsMgmtLogFullHandlerNotification = 1,
    ClfsMgmtLogUnpinnedNotification = 2,
    ClfsMgmtLogWriteNotification = 3,
}
pub use self::_CLFS_MGMT_NOTIFICATION_TYPE as CLFS_MGMT_NOTIFICATION_TYPE;
pub type PCLFS_MGMT_NOTIFICATION_TYPE = *mut _CLFS_MGMT_NOTIFICATION_TYPE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CLFS_MGMT_NOTIFICATION {
    pub Notification: CLFS_MGMT_NOTIFICATION_TYPE,
    pub Lsn: CLFS_LSN,
    pub LogIsPinned: USHORT,
}
#[test]
fn bindgen_test_layout__CLFS_MGMT_NOTIFICATION() {
    assert_eq!(::core::mem::size_of::<_CLFS_MGMT_NOTIFICATION>() , 24usize);
    assert_eq!(::core::mem::align_of::<_CLFS_MGMT_NOTIFICATION>() , 8usize);
}
impl Clone for _CLFS_MGMT_NOTIFICATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_CLFS_MGMT_NOTIFICATION as CLFS_MGMT_NOTIFICATION;
pub type PCLFS_MGMT_NOTIFICATION = *mut _CLFS_MGMT_NOTIFICATION;
pub type PCLFS_CLIENT_ADVANCE_TAIL_CALLBACK =
    ::core::option::Option<unsafe extern "C" fn(LogFile: PLOG_FILE_OBJECT,
                                                TargetLsn: PCLFS_LSN,
                                                ClientData: PVOID)
                               -> libc::c_long>;
pub type PCLFS_CLIENT_LFF_HANDLER_COMPLETE_CALLBACK =
    ::core::option::Option<unsafe extern "C" fn(LogFile: PLOG_FILE_OBJECT,
                                                OperationStatus: NTSTATUS,
                                                LogIsPinned: BOOLEAN,
                                                ClientData: PVOID)>;
pub type PCLFS_CLIENT_LOG_UNPINNED_CALLBACK =
    ::core::option::Option<unsafe extern "C" fn(LogFile: PLOG_FILE_OBJECT,
                                                ClientData: PVOID)>;
pub type PCLFS_SET_LOG_SIZE_COMPLETE_CALLBACK =
    ::core::option::Option<unsafe extern "C" fn(LogFile: PLOG_FILE_OBJECT,
                                                OperationStatus: NTSTATUS,
                                                ClientData: PVOID)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CLFS_MGMT_CLIENT_REGISTRATION {
    pub Version: ULONG,
    pub AdvanceTailCallback: PCLFS_CLIENT_ADVANCE_TAIL_CALLBACK,
    pub AdvanceTailCallbackData: PVOID,
    pub LogGrowthCompleteCallback: PCLFS_CLIENT_LFF_HANDLER_COMPLETE_CALLBACK,
    pub LogGrowthCompleteCallbackData: PVOID,
    pub LogUnpinnedCallback: PCLFS_CLIENT_LOG_UNPINNED_CALLBACK,
    pub LogUnpinnedCallbackData: PVOID,
}
#[test]
fn bindgen_test_layout__CLFS_MGMT_CLIENT_REGISTRATION() {
    assert_eq!(::core::mem::size_of::<_CLFS_MGMT_CLIENT_REGISTRATION>() ,
               56usize);
    assert_eq!(::core::mem::align_of::<_CLFS_MGMT_CLIENT_REGISTRATION>() ,
               8usize);
}
impl Clone for _CLFS_MGMT_CLIENT_REGISTRATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_CLFS_MGMT_CLIENT_REGISTRATION as CLFS_MGMT_CLIENT_REGISTRATION;
pub type PCLFS_MGMT_CLIENT_REGISTRATION = *mut _CLFS_MGMT_CLIENT_REGISTRATION;
pub type CLFS_MGMT_CLIENT = PVOID;
pub type PCLFS_MGMT_CLIENT = *mut PVOID;
extern "C" {
    pub fn ClfsMgmtRegisterManagedClient(LogFile: PLOG_FILE_OBJECT,
                                         RegistrationData:
                                             PCLFS_MGMT_CLIENT_REGISTRATION,
                                         ClientCookie: PCLFS_MGMT_CLIENT)
     -> NTSTATUS;
}
extern "C" {
    pub fn ClfsMgmtDeregisterManagedClient(ClientCookie: CLFS_MGMT_CLIENT)
     -> NTSTATUS;
}
extern "C" {
    pub fn ClfsMgmtTailAdvanceFailure(Client: CLFS_MGMT_CLIENT,
                                      Reason: NTSTATUS) -> NTSTATUS;
}
extern "C" {
    pub fn ClfsMgmtHandleLogFileFull(Client: CLFS_MGMT_CLIENT) -> NTSTATUS;
}
extern "C" {
    pub fn ClfsMgmtInstallPolicy(LogFile: PLOG_FILE_OBJECT,
                                 Policy: PCLFS_MGMT_POLICY,
                                 PolicyLength: ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn ClfsMgmtQueryPolicy(LogFile: PLOG_FILE_OBJECT,
                               PolicyType: CLFS_MGMT_POLICY_TYPE,
                               Policy: PCLFS_MGMT_POLICY,
                               PolicyLength: PULONG) -> NTSTATUS;
}
extern "C" {
    pub fn ClfsMgmtRemovePolicy(LogFile: PLOG_FILE_OBJECT,
                                PolicyType: CLFS_MGMT_POLICY_TYPE)
     -> NTSTATUS;
}
extern "C" {
    pub fn ClfsMgmtSetLogFileSize(LogFile: PLOG_FILE_OBJECT,
                                  NewSizeInContainers: PULONGLONG,
                                  ResultingSizeInContainers: PULONGLONG,
                                  CompletionRoutine:
                                      PCLFS_SET_LOG_SIZE_COMPLETE_CALLBACK,
                                  CompletionRoutineData: PVOID) -> NTSTATUS;
}
extern "C" {
    pub fn ClfsMgmtSetLogFileSizeAsClient(LogFile: PLOG_FILE_OBJECT,
                                          ClientCookie: PCLFS_MGMT_CLIENT,
                                          NewSizeInContainers: PULONGLONG,
                                          ResultingSizeInContainers:
                                              PULONGLONG,
                                          CompletionRoutine:
                                              PCLFS_SET_LOG_SIZE_COMPLETE_CALLBACK,
                                          CompletionRoutineData: PVOID)
     -> NTSTATUS;
}
extern "C" {
    pub fn ClfsInitialize() -> NTSTATUS;
}
extern "C" {
    pub fn ClfsFinalize();
}
extern "C" {
    pub fn ClfsCreateLogFile(pplfoLog: PPLOG_FILE_OBJECT,
                             puszLogFileName: PUNICODE_STRING,
                             fDesiredAccess: ACCESS_MASK, dwShareMode: ULONG,
                             psdLogFile: PSECURITY_DESCRIPTOR,
                             fCreateDisposition: ULONG, fCreateOptions: ULONG,
                             fFlagsAndAttributes: ULONG,
                             fLogOptionFlag: ULONG, pvContext: PVOID,
                             cbContext: ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn ClfsDeleteLogByPointer(plfoLog: PLOG_FILE_OBJECT) -> NTSTATUS;
}
extern "C" {
    pub fn ClfsDeleteLogFile(puszLogFileName: PUNICODE_STRING,
                             pvReserved: PVOID, fLogOptionFlag: ULONG,
                             pvContext: PVOID, cbContext: ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn ClfsAddLogContainer(plfoLog: PLOG_FILE_OBJECT,
                               pcbContainer: PULONGLONG,
                               puszContainerPath: PUNICODE_STRING)
     -> NTSTATUS;
}
extern "C" {
    pub fn ClfsAddLogContainerSet(plfoLog: PLOG_FILE_OBJECT,
                                  cContainers: USHORT,
                                  pcbContainer: PULONGLONG,
                                  rguszContainerPath: PUNICODE_STRING)
     -> NTSTATUS;
}
extern "C" {
    pub fn ClfsRemoveLogContainer(plfoLog: PLOG_FILE_OBJECT,
                                  puszContainerPath: PUNICODE_STRING,
                                  fForce: BOOLEAN) -> NTSTATUS;
}
extern "C" {
    pub fn ClfsRemoveLogContainerSet(plfoLog: PLOG_FILE_OBJECT,
                                     cContainers: USHORT,
                                     rgwszContainerPath: PUNICODE_STRING,
                                     fForce: BOOLEAN) -> NTSTATUS;
}
extern "C" {
    pub fn ClfsSetArchiveTail(plfoLog: PLOG_FILE_OBJECT,
                              plsnArchiveTail: PCLFS_LSN) -> NTSTATUS;
}
extern "C" {
    pub fn ClfsSetEndOfLog(plfoLog: PLOG_FILE_OBJECT, plsnEnd: PCLFS_LSN)
     -> NTSTATUS;
}
extern "C" {
    pub fn ClfsCreateScanContext(plfoLog: PLOG_FILE_OBJECT,
                                 cFromContainer: ULONG, cContainers: ULONG,
                                 eScanMode: CLFS_SCAN_MODE,
                                 pcxScan: PCLFS_SCAN_CONTEXT) -> NTSTATUS;
}
extern "C" {
    pub fn ClfsScanLogContainers(pcxScan: PCLFS_SCAN_CONTEXT,
                                 eScanMode: CLFS_SCAN_MODE) -> NTSTATUS;
}
extern "C" {
    pub fn ClfsGetContainerName(plfoLog: PLOG_FILE_OBJECT,
                                cidLogicalContainer: CLFS_CONTAINER_ID,
                                puszContainerName: PUNICODE_STRING,
                                pcActualLenContainerName: PULONG) -> NTSTATUS;
}
extern "C" {
    pub fn ClfsGetLogFileInformation(plfoLog: PLOG_FILE_OBJECT,
                                     pinfoBuffer: PCLFS_INFORMATION,
                                     pcbInfoBuffer: PULONG) -> NTSTATUS;
}
extern "C" {
    pub fn ClfsQueryLogFileInformation(plfoLog: PLOG_FILE_OBJECT,
                                       eInformationClass:
                                           CLFS_LOG_INFORMATION_CLASS,
                                       pinfoInputBuffer: PVOID,
                                       cbinfoInputBuffer: ULONG,
                                       pinfoBuffer: PVOID,
                                       pcbInfoBuffer: PULONG) -> NTSTATUS;
}
extern "C" {
    pub fn ClfsSetLogFileInformation(plfoLog: PLOG_FILE_OBJECT,
                                     eInformationClass:
                                         CLFS_LOG_INFORMATION_CLASS,
                                     pinfoBuffer: PVOID, cbBuffer: ULONG)
     -> NTSTATUS;
}
extern "C" {
    pub fn ClfsReadRestartArea(pvMarshalContext: PVOID,
                               ppvRestartBuffer: *mut PVOID,
                               pcbRestartBuffer: PULONG, plsn: PCLFS_LSN,
                               ppvReadContext: *mut PVOID) -> NTSTATUS;
}
extern "C" {
    pub fn ClfsReadPreviousRestartArea(pvReadContext: PVOID,
                                       ppvRestartBuffer: *mut PVOID,
                                       pcbRestartBuffer: PULONG,
                                       plsnRestart: PCLFS_LSN) -> NTSTATUS;
}
extern "C" {
    pub fn ClfsWriteRestartArea(pvMarshalContext: PVOID,
                                pvRestartBuffer: PVOID,
                                cbRestartBuffer: ULONG, plsnBase: PCLFS_LSN,
                                fFlags: ULONG, pcbWritten: PULONG,
                                plsnNext: PCLFS_LSN) -> NTSTATUS;
}
extern "C" {
    pub fn ClfsAdvanceLogBase(pvMarshalContext: PVOID, plsnBase: PCLFS_LSN,
                              fFlags: ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn ClfsCloseAndResetLogFile(plfoLog: PLOG_FILE_OBJECT) -> NTSTATUS;
}
extern "C" {
    pub fn ClfsCloseLogFileObject(plfoLog: PLOG_FILE_OBJECT) -> NTSTATUS;
}
extern "C" {
    pub fn ClfsCreateMarshallingArea(plfoLog: PLOG_FILE_OBJECT,
                                     ePoolType: POOL_TYPE,
                                     pfnAllocBuffer: PALLOCATE_FUNCTION,
                                     pfnFreeBuffer: PFREE_FUNCTION,
                                     cbMarshallingBuffer: ULONG,
                                     cMaxWriteBuffers: ULONG,
                                     cMaxReadBuffers: ULONG,
                                     ppvMarshalContext: *mut PVOID)
     -> NTSTATUS;
}
extern "C" {
    pub fn ClfsDeleteMarshallingArea(pvMarshalContext: PVOID) -> NTSTATUS;
}
extern "C" {
    pub fn ClfsReserveAndAppendLog(pvMarshalContext: PVOID,
                                   rgWriteEntries: PCLFS_WRITE_ENTRY,
                                   cWriteEntries: ULONG,
                                   plsnUndoNext: PCLFS_LSN,
                                   plsnPrevious: PCLFS_LSN,
                                   cReserveRecords: ULONG,
                                   rgcbReservation: PLONGLONG, fFlags: ULONG,
                                   plsn: PCLFS_LSN) -> NTSTATUS;
}
extern "C" {
    pub fn ClfsReserveAndAppendLogAligned(pvMarshalContext: PVOID,
                                          rgWriteEntries: PCLFS_WRITE_ENTRY,
                                          cWriteEntries: ULONG,
                                          cbEntryAlignment: ULONG,
                                          plsnUndoNext: PCLFS_LSN,
                                          plsnPrevious: PCLFS_LSN,
                                          cReserveRecords: ULONG,
                                          rgcbReservation: PLONGLONG,
                                          fFlags: ULONG, plsn: PCLFS_LSN)
     -> NTSTATUS;
}
extern "C" {
    pub fn ClfsAlignReservedLog(pvMarshalContext: PVOID, cRecords: ULONG,
                                rgcbReservation: *mut LONGLONG,
                                pcbAlignReservation: PLONGLONG) -> NTSTATUS;
}
extern "C" {
    pub fn ClfsAllocReservedLog(pvMarshalContext: PVOID, cRecords: ULONG,
                                pcbAdjustment: PLONGLONG) -> NTSTATUS;
}
extern "C" {
    pub fn ClfsFreeReservedLog(pvMarshalContext: PVOID, cRecords: ULONG,
                               pcbAdjustment: PLONGLONG) -> NTSTATUS;
}
extern "C" {
    pub fn ClfsFlushBuffers(pvMarshalContext: PVOID) -> NTSTATUS;
}
extern "C" {
    pub fn ClfsFlushToLsn(pvMarshalContext: PVOID, plsnFlush: PCLFS_LSN,
                          plsnLastFlushed: PCLFS_LSN) -> NTSTATUS;
}
extern "C" {
    pub fn ClfsReadLogRecord(pvMarshalContext: PVOID, plsnFirst: PCLFS_LSN,
                             peContextMode: CLFS_CONTEXT_MODE,
                             ppvReadBuffer: *mut PVOID, pcbReadBuffer: PULONG,
                             peRecordType: PCLFS_RECORD_TYPE,
                             plsnUndoNext: PCLFS_LSN, plsnPrevious: PCLFS_LSN,
                             ppvReadContext: *mut PVOID) -> NTSTATUS;
}
extern "C" {
    pub fn ClfsReadNextLogRecord(pvReadContext: PVOID, ppvBuffer: *mut PVOID,
                                 pcbBuffer: PULONG,
                                 peRecordType: PCLFS_RECORD_TYPE,
                                 plsnUser: PCLFS_LSN, plsnUndoNext: PCLFS_LSN,
                                 plsnPrevious: PCLFS_LSN,
                                 plsnRecord: PCLFS_LSN) -> NTSTATUS;
}
extern "C" {
    pub fn ClfsTerminateReadLog(pvCursorContext: PVOID) -> NTSTATUS;
}
extern "C" {
    pub fn ClfsGetLastLsn(plfoLog: PLOG_FILE_OBJECT, plsnLast: PCLFS_LSN)
     -> NTSTATUS;
}
extern "C" {
    pub fn ClfsGetIoStatistics(plfoLog: PLOG_FILE_OBJECT,
                               pvStatsBuffer: PVOID, cbStatsBuffer: ULONG,
                               eStatsClass: CLFS_IOSTATS_CLASS,
                               pcbStatsWritten: PULONG) -> NTSTATUS;
}
extern "C" {
    pub fn ClfsLaterLsn(plsn: PCLFS_LSN) -> CLFS_LSN;
}
extern "C" {
    pub fn ClfsEarlierLsn(plsn: PCLFS_LSN) -> CLFS_LSN;
}
extern "C" {
    pub fn ClfsLsnDifference(plsnStart: PCLFS_LSN, plsnFinish: PCLFS_LSN,
                             cbContainer: ULONG, cbMaxBlock: ULONG,
                             pcbDifference: PLONGLONG) -> NTSTATUS;
}
extern "C" {
    pub fn ClfsValidTopLevelContext(pirpTopLevelContext: PIRP) -> BOOLEAN;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KTRANSACTION {
    pub _address: u8,
}
impl Clone for _KTRANSACTION {
    fn clone(&self) -> Self { *self }
}
pub use self::_KTRANSACTION as KTRANSACTION;
pub type PKTRANSACTION = *mut _KTRANSACTION;
pub type PRKTRANSACTION = *mut _KTRANSACTION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KENLISTMENT {
    pub _address: u8,
}
impl Clone for _KENLISTMENT {
    fn clone(&self) -> Self { *self }
}
pub use self::_KENLISTMENT as KENLISTMENT;
pub type PKENLISTMENT = *mut _KENLISTMENT;
pub type PRKENLISTMENT = *mut _KENLISTMENT;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KRESOURCEMANAGER {
    pub _address: u8,
}
impl Clone for _KRESOURCEMANAGER {
    fn clone(&self) -> Self { *self }
}
pub use self::_KRESOURCEMANAGER as KRESOURCEMANAGER;
pub type PKRESOURCEMANAGER = *mut _KRESOURCEMANAGER;
pub type PRKRESOURCEMANAGER = *mut _KRESOURCEMANAGER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KTM {
    pub _address: u8,
}
impl Clone for _KTM {
    fn clone(&self) -> Self { *self }
}
pub use self::_KTM as KTM;
pub type PKTM = *mut _KTM;
pub type PRKTM = *mut _KTM;
pub type PGUID = *mut GUID;
pub type PTM_RM_NOTIFICATION =
    ::core::option::Option<unsafe extern "C" fn(EnlistmentObject:
                                                    PKENLISTMENT,
                                                RMContext: PVOID,
                                                TransactionContext: PVOID,
                                                TransactionNotification:
                                                    ULONG,
                                                TmVirtualClock:
                                                    PLARGE_INTEGER,
                                                ArgumentLength: ULONG,
                                                Argument: PVOID)
                               -> libc::c_long>;
pub use self::GUID as KCRM_PROTOCOL_ID;
pub type PKCRM_PROTOCOL_ID = *mut GUID;
pub type PTM_PROPAGATE_ROUTINE =
    ::core::option::Option<unsafe extern "C" fn(PropagationCookie: PVOID,
                                                CallbackData: PVOID,
                                                PropagationStatus: NTSTATUS,
                                                TransactionGuid: GUID)
                               -> libc::c_long>;
extern "C" {
    pub fn TmInitializeTransactionManager(TransactionManager: PRKTM,
                                          LogFileName: PCUNICODE_STRING,
                                          TmId: PGUID, CreateOptions: ULONG)
     -> NTSTATUS;
}
extern "C" {
    pub fn TmRenameTransactionManager(LogFileName: PUNICODE_STRING,
                                      ExistingTransactionManagerGuid: LPGUID)
     -> NTSTATUS;
}
extern "C" {
    pub fn TmRecoverTransactionManager(Tm: PKTM,
                                       TargetVirtualClock: PLARGE_INTEGER)
     -> NTSTATUS;
}
extern "C" {
    pub fn TmCommitTransaction(Transaction: PKTRANSACTION, Wait: BOOLEAN)
     -> NTSTATUS;
}
extern "C" {
    pub fn TmRollbackTransaction(Transaction: PKTRANSACTION, Wait: BOOLEAN)
     -> NTSTATUS;
}
extern "C" {
    pub fn TmCreateEnlistment(EnlistmentHandle: PHANDLE,
                              PreviousMode: KPROCESSOR_MODE,
                              DesiredAccess: ACCESS_MASK,
                              ObjectAttributes: POBJECT_ATTRIBUTES,
                              ResourceManager: PRKRESOURCEMANAGER,
                              Transaction: PKTRANSACTION,
                              CreateOptions: ULONG,
                              NotificationMask: NOTIFICATION_MASK,
                              EnlistmentKey: PVOID) -> NTSTATUS;
}
extern "C" {
    pub fn TmRecoverEnlistment(Enlistment: PKENLISTMENT, EnlistmentKey: PVOID)
     -> NTSTATUS;
}
extern "C" {
    pub fn TmPrePrepareEnlistment(Enlistment: PKENLISTMENT,
                                  TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
extern "C" {
    pub fn TmPrepareEnlistment(Enlistment: PKENLISTMENT,
                               TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
extern "C" {
    pub fn TmCommitEnlistment(Enlistment: PKENLISTMENT,
                              TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
extern "C" {
    pub fn TmRollbackEnlistment(Enlistment: PKENLISTMENT,
                                TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
extern "C" {
    pub fn TmPrePrepareComplete(Enlistment: PKENLISTMENT,
                                TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
extern "C" {
    pub fn TmPrepareComplete(Enlistment: PKENLISTMENT,
                             TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
extern "C" {
    pub fn TmReadOnlyEnlistment(Enlistment: PKENLISTMENT,
                                TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
extern "C" {
    pub fn TmCommitComplete(Enlistment: PKENLISTMENT,
                            TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
extern "C" {
    pub fn TmRollbackComplete(Enlistment: PKENLISTMENT,
                              TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
extern "C" {
    pub fn TmReferenceEnlistmentKey(Enlistment: PKENLISTMENT, Key: *mut PVOID)
     -> NTSTATUS;
}
extern "C" {
    pub fn TmDereferenceEnlistmentKey(Enlistment: PKENLISTMENT,
                                      LastReference: PBOOLEAN) -> NTSTATUS;
}
extern "C" {
    pub fn TmSinglePhaseReject(Enlistment: PKENLISTMENT,
                               TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
extern "C" {
    pub fn TmRequestOutcomeEnlistment(Enlistment: PKENLISTMENT,
                                      TmVirtualClock: PLARGE_INTEGER)
     -> NTSTATUS;
}
extern "C" {
    pub fn TmEnableCallbacks(ResourceManager: PKRESOURCEMANAGER,
                             CallbackRoutine: PTM_RM_NOTIFICATION,
                             RMKey: PVOID) -> NTSTATUS;
}
extern "C" {
    pub fn TmRecoverResourceManager(ResourceManager: PKRESOURCEMANAGER)
     -> NTSTATUS;
}
extern "C" {
    pub fn TmPropagationComplete(ResourceManager: PKRESOURCEMANAGER,
                                 RequestCookie: ULONG, BufferLength: ULONG,
                                 Buffer: PVOID) -> NTSTATUS;
}
extern "C" {
    pub fn TmPropagationFailed(ResourceManager: PKRESOURCEMANAGER,
                               RequestCookie: ULONG, Status: NTSTATUS)
     -> NTSTATUS;
}
extern "C" {
    pub fn TmGetTransactionId(Transaction: PKTRANSACTION,
                              TransactionId: PUOW);
}
extern "C" {
    pub fn TmIsTransactionActive(Transaction: PKTRANSACTION) -> BOOLEAN;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCW_INSTANCE {
    pub _address: u8,
}
impl Clone for _PCW_INSTANCE {
    fn clone(&self) -> Self { *self }
}
pub type PPCW_INSTANCE = *mut _PCW_INSTANCE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCW_REGISTRATION {
    pub _address: u8,
}
impl Clone for _PCW_REGISTRATION {
    fn clone(&self) -> Self { *self }
}
pub type PPCW_REGISTRATION = *mut _PCW_REGISTRATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCW_BUFFER {
    pub _address: u8,
}
impl Clone for _PCW_BUFFER {
    fn clone(&self) -> Self { *self }
}
pub type PPCW_BUFFER = *mut _PCW_BUFFER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCW_COUNTER_DESCRIPTOR {
    pub Id: USHORT,
    pub StructIndex: USHORT,
    pub Offset: USHORT,
    pub Size: USHORT,
}
#[test]
fn bindgen_test_layout__PCW_COUNTER_DESCRIPTOR() {
    assert_eq!(::core::mem::size_of::<_PCW_COUNTER_DESCRIPTOR>() , 8usize);
    assert_eq!(::core::mem::align_of::<_PCW_COUNTER_DESCRIPTOR>() , 2usize);
}
impl Clone for _PCW_COUNTER_DESCRIPTOR {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCW_COUNTER_DESCRIPTOR as PCW_COUNTER_DESCRIPTOR;
pub type PPCW_COUNTER_DESCRIPTOR = *mut _PCW_COUNTER_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCW_DATA {
    pub Data: *const libc::c_void,
    pub Size: ULONG,
}
#[test]
fn bindgen_test_layout__PCW_DATA() {
    assert_eq!(::core::mem::size_of::<_PCW_DATA>() , 16usize);
    assert_eq!(::core::mem::align_of::<_PCW_DATA>() , 8usize);
}
impl Clone for _PCW_DATA {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCW_DATA as PCW_DATA;
pub type PPCW_DATA = *mut _PCW_DATA;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCW_COUNTER_INFORMATION {
    pub CounterMask: ULONG64,
    pub InstanceMask: PCUNICODE_STRING,
}
#[test]
fn bindgen_test_layout__PCW_COUNTER_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_PCW_COUNTER_INFORMATION>() , 16usize);
    assert_eq!(::core::mem::align_of::<_PCW_COUNTER_INFORMATION>() , 8usize);
}
impl Clone for _PCW_COUNTER_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCW_COUNTER_INFORMATION as PCW_COUNTER_INFORMATION;
pub type PPCW_COUNTER_INFORMATION = *mut _PCW_COUNTER_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCW_MASK_INFORMATION {
    pub CounterMask: ULONG64,
    pub InstanceMask: PCUNICODE_STRING,
    pub InstanceId: ULONG,
    pub CollectMultiple: BOOLEAN,
    pub Buffer: PPCW_BUFFER,
    pub CancelEvent: PKEVENT,
}
#[test]
fn bindgen_test_layout__PCW_MASK_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_PCW_MASK_INFORMATION>() , 40usize);
    assert_eq!(::core::mem::align_of::<_PCW_MASK_INFORMATION>() , 8usize);
}
impl Clone for _PCW_MASK_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCW_MASK_INFORMATION as PCW_MASK_INFORMATION;
pub type PPCW_MASK_INFORMATION = *mut _PCW_MASK_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCW_CALLBACK_INFORMATION {
    pub AddCounter: __BindgenUnionField<PCW_COUNTER_INFORMATION>,
    pub RemoveCounter: __BindgenUnionField<PCW_COUNTER_INFORMATION>,
    pub EnumerateInstances: __BindgenUnionField<PCW_MASK_INFORMATION>,
    pub CollectData: __BindgenUnionField<PCW_MASK_INFORMATION>,
    pub bindgen_union_field: [u64; 5usize],
}
#[test]
fn bindgen_test_layout__PCW_CALLBACK_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_PCW_CALLBACK_INFORMATION>() , 40usize);
    assert_eq!(::core::mem::align_of::<_PCW_CALLBACK_INFORMATION>() , 8usize);
}
impl Clone for _PCW_CALLBACK_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCW_CALLBACK_INFORMATION as PCW_CALLBACK_INFORMATION;
pub type PPCW_CALLBACK_INFORMATION = *mut _PCW_CALLBACK_INFORMATION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _PCW_CALLBACK_TYPE {
    PcwCallbackAddCounter = 0,
    PcwCallbackRemoveCounter = 1,
    PcwCallbackEnumerateInstances = 2,
    PcwCallbackCollectData = 3,
}
pub use self::_PCW_CALLBACK_TYPE as PCW_CALLBACK_TYPE;
pub type PPCW_CALLBACK_TYPE = *mut _PCW_CALLBACK_TYPE;
pub type PPCW_CALLBACK =
    ::core::option::Option<unsafe extern "C" fn() -> NTSTATUS>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCW_REGISTRATION_INFORMATION {
    pub Version: ULONG,
    pub Name: PCUNICODE_STRING,
    pub CounterCount: ULONG,
    pub Counters: PPCW_COUNTER_DESCRIPTOR,
    pub Callback: PPCW_CALLBACK,
    pub CallbackContext: PVOID,
}
#[test]
fn bindgen_test_layout__PCW_REGISTRATION_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_PCW_REGISTRATION_INFORMATION>() ,
               48usize);
    assert_eq!(::core::mem::align_of::<_PCW_REGISTRATION_INFORMATION>() ,
               8usize);
}
impl Clone for _PCW_REGISTRATION_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCW_REGISTRATION_INFORMATION as PCW_REGISTRATION_INFORMATION;
pub type PPCW_REGISTRATION_INFORMATION = *mut _PCW_REGISTRATION_INFORMATION;
extern "C" {
    pub fn PcwRegister(Registration: *mut PPCW_REGISTRATION,
                       Info: PPCW_REGISTRATION_INFORMATION) -> NTSTATUS;
}
extern "C" {
    pub fn PcwUnregister(Registration: PPCW_REGISTRATION);
}
extern "C" {
    pub fn PcwCreateInstance(Instance: *mut PPCW_INSTANCE,
                             Registration: PPCW_REGISTRATION,
                             Name: PCUNICODE_STRING, Count: ULONG,
                             Data: PPCW_DATA) -> NTSTATUS;
}
extern "C" {
    pub fn PcwCloseInstance(Instance: PPCW_INSTANCE);
}
extern "C" {
    pub fn PcwAddInstance(Buffer: PPCW_BUFFER, Name: PCUNICODE_STRING,
                          Id: ULONG, Count: ULONG, Data: PPCW_DATA)
     -> NTSTATUS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _DRIVER_RUNTIME_INIT_FLAGS {
    DrvRtPoolNxOptIn = 1,
    LastDrvRtFlag = 2,
}
pub use self::_DRIVER_RUNTIME_INIT_FLAGS as DRIVER_RUNTIME_INIT_FLAGS;
pub type PDRIVER_RUNTIME_INIT_FLAGS = *mut _DRIVER_RUNTIME_INIT_FLAGS;
pub type PCDRIVER_RUNTIME_INIT_FLAGS = *const _DRIVER_RUNTIME_INIT_FLAGS;
extern "C" {
    #[link_name = "CmKeyObjectType"]
    pub static mut CmKeyObjectType: *mut POBJECT_TYPE;
}
extern "C" {
    #[link_name = "IoFileObjectType"]
    pub static mut IoFileObjectType: *mut POBJECT_TYPE;
}
extern "C" {
    #[link_name = "ExEventObjectType"]
    pub static mut ExEventObjectType: *mut POBJECT_TYPE;
}
extern "C" {
    #[link_name = "ExSemaphoreObjectType"]
    pub static mut ExSemaphoreObjectType: *mut POBJECT_TYPE;
}
extern "C" {
    #[link_name = "TmTransactionManagerObjectType"]
    pub static mut TmTransactionManagerObjectType: *mut POBJECT_TYPE;
}
extern "C" {
    #[link_name = "TmResourceManagerObjectType"]
    pub static mut TmResourceManagerObjectType: *mut POBJECT_TYPE;
}
extern "C" {
    #[link_name = "TmEnlistmentObjectType"]
    pub static mut TmEnlistmentObjectType: *mut POBJECT_TYPE;
}
extern "C" {
    #[link_name = "TmTransactionObjectType"]
    pub static mut TmTransactionObjectType: *mut POBJECT_TYPE;
}
extern "C" {
    #[link_name = "PsProcessType"]
    pub static mut PsProcessType: *mut POBJECT_TYPE;
}
extern "C" {
    #[link_name = "PsThreadType"]
    pub static mut PsThreadType: *mut POBJECT_TYPE;
}
extern "C" {
    #[link_name = "PsJobType"]
    pub static mut PsJobType: *mut POBJECT_TYPE;
}
extern "C" {
    #[link_name = "SeTokenObjectType"]
    pub static mut SeTokenObjectType: *mut POBJECT_TYPE;
}
extern "C" {
    #[link_name = "ExDesktopObjectType"]
    pub static mut ExDesktopObjectType: *mut POBJECT_TYPE;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _BUS_HANDLER {
    pub _address: u8,
}
impl Clone for _BUS_HANDLER {
    fn clone(&self) -> Self { *self }
}
pub type PBUS_HANDLER = *mut _BUS_HANDLER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DEVICE_HANDLER_OBJECT {
    pub _address: u8,
}
impl Clone for _DEVICE_HANDLER_OBJECT {
    fn clone(&self) -> Self { *self }
}
pub type PDEVICE_HANDLER_OBJECT = *mut _DEVICE_HANDLER_OBJECT;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _EJOB {
    pub _address: u8,
}
impl Clone for _EJOB {
    fn clone(&self) -> Self { *self }
}
pub type PEJOB = *mut _EJOB;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PEB {
    pub _address: u8,
}
impl Clone for _PEB {
    fn clone(&self) -> Self { *self }
}
pub type PPEB = *mut _PEB;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IMAGE_NT_HEADERS {
    pub _address: u8,
}
impl Clone for _IMAGE_NT_HEADERS {
    fn clone(&self) -> Self { *self }
}
pub type PIMAGE_NT_HEADERS32 = *mut _IMAGE_NT_HEADERS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IMAGE_NT_HEADERS64 {
    pub _address: u8,
}
impl Clone for _IMAGE_NT_HEADERS64 {
    fn clone(&self) -> Self { *self }
}
pub type PIMAGE_NT_HEADERS64 = *mut _IMAGE_NT_HEADERS64;
pub type PIMAGE_NT_HEADERS = PIMAGE_NT_HEADERS64;
#[repr(C)]
pub struct _FLOATING_SAVE_AREA {
    pub ControlWord: ULONG,
    pub StatusWord: ULONG,
    pub TagWord: ULONG,
    pub ErrorOffset: ULONG,
    pub ErrorSelector: ULONG,
    pub DataOffset: ULONG,
    pub DataSelector: ULONG,
    pub RegisterArea: [UCHAR; 80usize],
    pub Spare0: ULONG,
}
#[test]
fn bindgen_test_layout__FLOATING_SAVE_AREA() {
    assert_eq!(::core::mem::size_of::<_FLOATING_SAVE_AREA>() , 112usize);
    assert_eq!(::core::mem::align_of::<_FLOATING_SAVE_AREA>() , 4usize);
}
pub use self::_FLOATING_SAVE_AREA as FLOATING_SAVE_AREA;
pub type PFLOATING_SAVE_AREA = *mut FLOATING_SAVE_AREA;
pub use self::_CONTEXT as CONTEXT;
pub const WinNullSid: _bindgen_ty_19 = _bindgen_ty_19::WinNullSid;
pub const WinWorldSid: _bindgen_ty_19 = _bindgen_ty_19::WinWorldSid;
pub const WinLocalSid: _bindgen_ty_19 = _bindgen_ty_19::WinLocalSid;
pub const WinCreatorOwnerSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinCreatorOwnerSid;
pub const WinCreatorGroupSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinCreatorGroupSid;
pub const WinCreatorOwnerServerSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinCreatorOwnerServerSid;
pub const WinCreatorGroupServerSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinCreatorGroupServerSid;
pub const WinNtAuthoritySid: _bindgen_ty_19 =
    _bindgen_ty_19::WinNtAuthoritySid;
pub const WinDialupSid: _bindgen_ty_19 = _bindgen_ty_19::WinDialupSid;
pub const WinNetworkSid: _bindgen_ty_19 = _bindgen_ty_19::WinNetworkSid;
pub const WinBatchSid: _bindgen_ty_19 = _bindgen_ty_19::WinBatchSid;
pub const WinInteractiveSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinInteractiveSid;
pub const WinServiceSid: _bindgen_ty_19 = _bindgen_ty_19::WinServiceSid;
pub const WinAnonymousSid: _bindgen_ty_19 = _bindgen_ty_19::WinAnonymousSid;
pub const WinProxySid: _bindgen_ty_19 = _bindgen_ty_19::WinProxySid;
pub const WinEnterpriseControllersSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinEnterpriseControllersSid;
pub const WinSelfSid: _bindgen_ty_19 = _bindgen_ty_19::WinSelfSid;
pub const WinAuthenticatedUserSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinAuthenticatedUserSid;
pub const WinRestrictedCodeSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinRestrictedCodeSid;
pub const WinTerminalServerSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinTerminalServerSid;
pub const WinRemoteLogonIdSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinRemoteLogonIdSid;
pub const WinLogonIdsSid: _bindgen_ty_19 = _bindgen_ty_19::WinLogonIdsSid;
pub const WinLocalSystemSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinLocalSystemSid;
pub const WinLocalServiceSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinLocalServiceSid;
pub const WinNetworkServiceSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinNetworkServiceSid;
pub const WinBuiltinDomainSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinBuiltinDomainSid;
pub const WinBuiltinAdministratorsSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinBuiltinAdministratorsSid;
pub const WinBuiltinUsersSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinBuiltinUsersSid;
pub const WinBuiltinGuestsSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinBuiltinGuestsSid;
pub const WinBuiltinPowerUsersSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinBuiltinPowerUsersSid;
pub const WinBuiltinAccountOperatorsSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinBuiltinAccountOperatorsSid;
pub const WinBuiltinSystemOperatorsSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinBuiltinSystemOperatorsSid;
pub const WinBuiltinPrintOperatorsSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinBuiltinPrintOperatorsSid;
pub const WinBuiltinBackupOperatorsSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinBuiltinBackupOperatorsSid;
pub const WinBuiltinReplicatorSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinBuiltinReplicatorSid;
pub const WinBuiltinPreWindows2000CompatibleAccessSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinBuiltinPreWindows2000CompatibleAccessSid;
pub const WinBuiltinRemoteDesktopUsersSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinBuiltinRemoteDesktopUsersSid;
pub const WinBuiltinNetworkConfigurationOperatorsSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinBuiltinNetworkConfigurationOperatorsSid;
pub const WinAccountAdministratorSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinAccountAdministratorSid;
pub const WinAccountGuestSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinAccountGuestSid;
pub const WinAccountKrbtgtSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinAccountKrbtgtSid;
pub const WinAccountDomainAdminsSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinAccountDomainAdminsSid;
pub const WinAccountDomainUsersSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinAccountDomainUsersSid;
pub const WinAccountDomainGuestsSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinAccountDomainGuestsSid;
pub const WinAccountComputersSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinAccountComputersSid;
pub const WinAccountControllersSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinAccountControllersSid;
pub const WinAccountCertAdminsSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinAccountCertAdminsSid;
pub const WinAccountSchemaAdminsSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinAccountSchemaAdminsSid;
pub const WinAccountEnterpriseAdminsSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinAccountEnterpriseAdminsSid;
pub const WinAccountPolicyAdminsSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinAccountPolicyAdminsSid;
pub const WinAccountRasAndIasServersSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinAccountRasAndIasServersSid;
pub const WinNTLMAuthenticationSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinNTLMAuthenticationSid;
pub const WinDigestAuthenticationSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinDigestAuthenticationSid;
pub const WinSChannelAuthenticationSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinSChannelAuthenticationSid;
pub const WinThisOrganizationSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinThisOrganizationSid;
pub const WinOtherOrganizationSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinOtherOrganizationSid;
pub const WinBuiltinIncomingForestTrustBuildersSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinBuiltinIncomingForestTrustBuildersSid;
pub const WinBuiltinPerfMonitoringUsersSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinBuiltinPerfMonitoringUsersSid;
pub const WinBuiltinPerfLoggingUsersSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinBuiltinPerfLoggingUsersSid;
pub const WinBuiltinAuthorizationAccessSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinBuiltinAuthorizationAccessSid;
pub const WinBuiltinTerminalServerLicenseServersSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinBuiltinTerminalServerLicenseServersSid;
pub const WinBuiltinDCOMUsersSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinBuiltinDCOMUsersSid;
pub const WinBuiltinIUsersSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinBuiltinIUsersSid;
pub const WinIUserSid: _bindgen_ty_19 = _bindgen_ty_19::WinIUserSid;
pub const WinBuiltinCryptoOperatorsSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinBuiltinCryptoOperatorsSid;
pub const WinUntrustedLabelSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinUntrustedLabelSid;
pub const WinLowLabelSid: _bindgen_ty_19 = _bindgen_ty_19::WinLowLabelSid;
pub const WinMediumLabelSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinMediumLabelSid;
pub const WinHighLabelSid: _bindgen_ty_19 = _bindgen_ty_19::WinHighLabelSid;
pub const WinSystemLabelSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinSystemLabelSid;
pub const WinWriteRestrictedCodeSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinWriteRestrictedCodeSid;
pub const WinCreatorOwnerRightsSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinCreatorOwnerRightsSid;
pub const WinCacheablePrincipalsGroupSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinCacheablePrincipalsGroupSid;
pub const WinNonCacheablePrincipalsGroupSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinNonCacheablePrincipalsGroupSid;
pub const WinEnterpriseReadonlyControllersSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinEnterpriseReadonlyControllersSid;
pub const WinAccountReadonlyControllersSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinAccountReadonlyControllersSid;
pub const WinBuiltinEventLogReadersGroup: _bindgen_ty_19 =
    _bindgen_ty_19::WinBuiltinEventLogReadersGroup;
pub const WinNewEnterpriseReadonlyControllersSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinNewEnterpriseReadonlyControllersSid;
pub const WinBuiltinCertSvcDComAccessGroup: _bindgen_ty_19 =
    _bindgen_ty_19::WinBuiltinCertSvcDComAccessGroup;
pub const WinMediumPlusLabelSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinMediumPlusLabelSid;
pub const WinLocalLogonSid: _bindgen_ty_19 = _bindgen_ty_19::WinLocalLogonSid;
pub const WinConsoleLogonSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinConsoleLogonSid;
pub const WinThisOrganizationCertificateSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinThisOrganizationCertificateSid;
pub const WinApplicationPackageAuthoritySid: _bindgen_ty_19 =
    _bindgen_ty_19::WinApplicationPackageAuthoritySid;
pub const WinBuiltinAnyPackageSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinBuiltinAnyPackageSid;
pub const WinCapabilityInternetClientSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinCapabilityInternetClientSid;
pub const WinCapabilityInternetClientServerSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinCapabilityInternetClientServerSid;
pub const WinCapabilityPrivateNetworkClientServerSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinCapabilityPrivateNetworkClientServerSid;
pub const WinCapabilityPicturesLibrarySid: _bindgen_ty_19 =
    _bindgen_ty_19::WinCapabilityPicturesLibrarySid;
pub const WinCapabilityVideosLibrarySid: _bindgen_ty_19 =
    _bindgen_ty_19::WinCapabilityVideosLibrarySid;
pub const WinCapabilityMusicLibrarySid: _bindgen_ty_19 =
    _bindgen_ty_19::WinCapabilityMusicLibrarySid;
pub const WinCapabilityDocumentsLibrarySid: _bindgen_ty_19 =
    _bindgen_ty_19::WinCapabilityDocumentsLibrarySid;
pub const WinCapabilitySharedUserCertificatesSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinCapabilitySharedUserCertificatesSid;
pub const WinCapabilityEnterpriseAuthenticationSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinCapabilityEnterpriseAuthenticationSid;
pub const WinCapabilityRemovableStorageSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinCapabilityRemovableStorageSid;
pub const WinBuiltinRDSRemoteAccessServersSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinBuiltinRDSRemoteAccessServersSid;
pub const WinBuiltinRDSEndpointServersSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinBuiltinRDSEndpointServersSid;
pub const WinBuiltinRDSManagementServersSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinBuiltinRDSManagementServersSid;
pub const WinUserModeDriversSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinUserModeDriversSid;
pub const WinBuiltinHyperVAdminsSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinBuiltinHyperVAdminsSid;
pub const WinAccountCloneableControllersSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinAccountCloneableControllersSid;
pub const WinBuiltinAccessControlAssistanceOperatorsSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinBuiltinAccessControlAssistanceOperatorsSid;
pub const WinBuiltinRemoteManagementUsersSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinBuiltinRemoteManagementUsersSid;
pub const WinAuthenticationAuthorityAssertedSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinAuthenticationAuthorityAssertedSid;
pub const WinAuthenticationServiceAssertedSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinAuthenticationServiceAssertedSid;
pub const WinLocalAccountSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinLocalAccountSid;
pub const WinLocalAccountAndAdministratorSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinLocalAccountAndAdministratorSid;
pub const WinAccountProtectedUsersSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinAccountProtectedUsersSid;
pub const WinCapabilityAppointmentsSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinCapabilityAppointmentsSid;
pub const WinCapabilityContactsSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinCapabilityContactsSid;
pub const WinAccountDefaultSystemManagedSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinAccountDefaultSystemManagedSid;
pub const WinBuiltinDefaultSystemManagedGroupSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinBuiltinDefaultSystemManagedGroupSid;
pub const WinBuiltinStorageReplicaAdminsSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinBuiltinStorageReplicaAdminsSid;
pub const WinAccountKeyAdminsSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinAccountKeyAdminsSid;
pub const WinAccountEnterpriseKeyAdminsSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinAccountEnterpriseKeyAdminsSid;
pub const WinAuthenticationKeyTrustSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinAuthenticationKeyTrustSid;
pub const WinAuthenticationKeyPropertyMFASid: _bindgen_ty_19 =
    _bindgen_ty_19::WinAuthenticationKeyPropertyMFASid;
pub const WinAuthenticationKeyPropertyAttestationSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinAuthenticationKeyPropertyAttestationSid;
pub const WinAuthenticationFreshKeyAuthSid: _bindgen_ty_19 =
    _bindgen_ty_19::WinAuthenticationFreshKeyAuthSid;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_19 {
    WinNullSid = 0,
    WinWorldSid = 1,
    WinLocalSid = 2,
    WinCreatorOwnerSid = 3,
    WinCreatorGroupSid = 4,
    WinCreatorOwnerServerSid = 5,
    WinCreatorGroupServerSid = 6,
    WinNtAuthoritySid = 7,
    WinDialupSid = 8,
    WinNetworkSid = 9,
    WinBatchSid = 10,
    WinInteractiveSid = 11,
    WinServiceSid = 12,
    WinAnonymousSid = 13,
    WinProxySid = 14,
    WinEnterpriseControllersSid = 15,
    WinSelfSid = 16,
    WinAuthenticatedUserSid = 17,
    WinRestrictedCodeSid = 18,
    WinTerminalServerSid = 19,
    WinRemoteLogonIdSid = 20,
    WinLogonIdsSid = 21,
    WinLocalSystemSid = 22,
    WinLocalServiceSid = 23,
    WinNetworkServiceSid = 24,
    WinBuiltinDomainSid = 25,
    WinBuiltinAdministratorsSid = 26,
    WinBuiltinUsersSid = 27,
    WinBuiltinGuestsSid = 28,
    WinBuiltinPowerUsersSid = 29,
    WinBuiltinAccountOperatorsSid = 30,
    WinBuiltinSystemOperatorsSid = 31,
    WinBuiltinPrintOperatorsSid = 32,
    WinBuiltinBackupOperatorsSid = 33,
    WinBuiltinReplicatorSid = 34,
    WinBuiltinPreWindows2000CompatibleAccessSid = 35,
    WinBuiltinRemoteDesktopUsersSid = 36,
    WinBuiltinNetworkConfigurationOperatorsSid = 37,
    WinAccountAdministratorSid = 38,
    WinAccountGuestSid = 39,
    WinAccountKrbtgtSid = 40,
    WinAccountDomainAdminsSid = 41,
    WinAccountDomainUsersSid = 42,
    WinAccountDomainGuestsSid = 43,
    WinAccountComputersSid = 44,
    WinAccountControllersSid = 45,
    WinAccountCertAdminsSid = 46,
    WinAccountSchemaAdminsSid = 47,
    WinAccountEnterpriseAdminsSid = 48,
    WinAccountPolicyAdminsSid = 49,
    WinAccountRasAndIasServersSid = 50,
    WinNTLMAuthenticationSid = 51,
    WinDigestAuthenticationSid = 52,
    WinSChannelAuthenticationSid = 53,
    WinThisOrganizationSid = 54,
    WinOtherOrganizationSid = 55,
    WinBuiltinIncomingForestTrustBuildersSid = 56,
    WinBuiltinPerfMonitoringUsersSid = 57,
    WinBuiltinPerfLoggingUsersSid = 58,
    WinBuiltinAuthorizationAccessSid = 59,
    WinBuiltinTerminalServerLicenseServersSid = 60,
    WinBuiltinDCOMUsersSid = 61,
    WinBuiltinIUsersSid = 62,
    WinIUserSid = 63,
    WinBuiltinCryptoOperatorsSid = 64,
    WinUntrustedLabelSid = 65,
    WinLowLabelSid = 66,
    WinMediumLabelSid = 67,
    WinHighLabelSid = 68,
    WinSystemLabelSid = 69,
    WinWriteRestrictedCodeSid = 70,
    WinCreatorOwnerRightsSid = 71,
    WinCacheablePrincipalsGroupSid = 72,
    WinNonCacheablePrincipalsGroupSid = 73,
    WinEnterpriseReadonlyControllersSid = 74,
    WinAccountReadonlyControllersSid = 75,
    WinBuiltinEventLogReadersGroup = 76,
    WinNewEnterpriseReadonlyControllersSid = 77,
    WinBuiltinCertSvcDComAccessGroup = 78,
    WinMediumPlusLabelSid = 79,
    WinLocalLogonSid = 80,
    WinConsoleLogonSid = 81,
    WinThisOrganizationCertificateSid = 82,
    WinApplicationPackageAuthoritySid = 83,
    WinBuiltinAnyPackageSid = 84,
    WinCapabilityInternetClientSid = 85,
    WinCapabilityInternetClientServerSid = 86,
    WinCapabilityPrivateNetworkClientServerSid = 87,
    WinCapabilityPicturesLibrarySid = 88,
    WinCapabilityVideosLibrarySid = 89,
    WinCapabilityMusicLibrarySid = 90,
    WinCapabilityDocumentsLibrarySid = 91,
    WinCapabilitySharedUserCertificatesSid = 92,
    WinCapabilityEnterpriseAuthenticationSid = 93,
    WinCapabilityRemovableStorageSid = 94,
    WinBuiltinRDSRemoteAccessServersSid = 95,
    WinBuiltinRDSEndpointServersSid = 96,
    WinBuiltinRDSManagementServersSid = 97,
    WinUserModeDriversSid = 98,
    WinBuiltinHyperVAdminsSid = 99,
    WinAccountCloneableControllersSid = 100,
    WinBuiltinAccessControlAssistanceOperatorsSid = 101,
    WinBuiltinRemoteManagementUsersSid = 102,
    WinAuthenticationAuthorityAssertedSid = 103,
    WinAuthenticationServiceAssertedSid = 104,
    WinLocalAccountSid = 105,
    WinLocalAccountAndAdministratorSid = 106,
    WinAccountProtectedUsersSid = 107,
    WinCapabilityAppointmentsSid = 108,
    WinCapabilityContactsSid = 109,
    WinAccountDefaultSystemManagedSid = 110,
    WinBuiltinDefaultSystemManagedGroupSid = 111,
    WinBuiltinStorageReplicaAdminsSid = 112,
    WinAccountKeyAdminsSid = 113,
    WinAccountEnterpriseKeyAdminsSid = 114,
    WinAuthenticationKeyTrustSid = 115,
    WinAuthenticationKeyPropertyMFASid = 116,
    WinAuthenticationKeyPropertyAttestationSid = 117,
    WinAuthenticationFreshKeyAuthSid = 118,
}
pub use self::_bindgen_ty_19 as WELL_KNOWN_SID_TYPE;
pub type SE_SIGNING_LEVEL = UCHAR;
pub type PSE_SIGNING_LEVEL = *mut UCHAR;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _SE_IMAGE_SIGNATURE_TYPE {
    SeImageSignatureNone = 0,
    SeImageSignatureEmbedded = 1,
    SeImageSignatureCache = 2,
    SeImageSignatureCatalogCached = 3,
    SeImageSignatureCatalogNotCached = 4,
    SeImageSignatureCatalogHint = 5,
    SeImageSignaturePackageCatalog = 6,
}
pub use self::_SE_IMAGE_SIGNATURE_TYPE as SE_IMAGE_SIGNATURE_TYPE;
pub type PSE_IMAGE_SIGNATURE_TYPE = *mut _SE_IMAGE_SIGNATURE_TYPE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _RTL_RUN_ONCE {
    pub Ptr: __BindgenUnionField<PVOID>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__RTL_RUN_ONCE() {
    assert_eq!(::core::mem::size_of::<_RTL_RUN_ONCE>() , 8usize);
    assert_eq!(::core::mem::align_of::<_RTL_RUN_ONCE>() , 8usize);
}
impl Clone for _RTL_RUN_ONCE {
    fn clone(&self) -> Self { *self }
}
pub use self::_RTL_RUN_ONCE as RTL_RUN_ONCE;
pub type PRTL_RUN_ONCE = *mut _RTL_RUN_ONCE;
pub type PRTL_RUN_ONCE_INIT_FN =
    ::core::option::Option<unsafe extern "C" fn() -> ULONG>;
extern "C" {
    pub fn RtlRunOnceInitialize(RunOnce: PRTL_RUN_ONCE);
}
extern "C" {
    pub fn RtlRunOnceExecuteOnce(RunOnce: PRTL_RUN_ONCE,
                                 InitFn: PRTL_RUN_ONCE_INIT_FN,
                                 Parameter: PVOID, Context: *mut PVOID)
     -> NTSTATUS;
}
extern "C" {
    pub fn RtlRunOnceBeginInitialize(RunOnce: PRTL_RUN_ONCE, Flags: ULONG,
                                     Context: *mut PVOID) -> NTSTATUS;
}
extern "C" {
    pub fn RtlRunOnceComplete(RunOnce: PRTL_RUN_ONCE, Flags: ULONG,
                              Context: PVOID) -> NTSTATUS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _TABLE_SEARCH_RESULT {
    TableEmptyTree = 0,
    TableFoundNode = 1,
    TableInsertAsLeft = 2,
    TableInsertAsRight = 3,
}
pub use self::_TABLE_SEARCH_RESULT as TABLE_SEARCH_RESULT;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _RTL_GENERIC_COMPARE_RESULTS {
    GenericLessThan = 0,
    GenericGreaterThan = 1,
    GenericEqual = 2,
}
pub use self::_RTL_GENERIC_COMPARE_RESULTS as RTL_GENERIC_COMPARE_RESULTS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _RTL_AVL_TABLE {
    pub BalancedRoot: RTL_BALANCED_LINKS,
    pub OrderedPointer: PVOID,
    pub WhichOrderedElement: ULONG,
    pub NumberGenericTableElements: ULONG,
    pub DepthOfTree: ULONG,
    pub RestartKey: PRTL_BALANCED_LINKS,
    pub DeleteCount: ULONG,
    pub CompareRoutine: PRTL_AVL_COMPARE_ROUTINE,
    pub AllocateRoutine: PRTL_AVL_ALLOCATE_ROUTINE,
    pub FreeRoutine: PRTL_AVL_FREE_ROUTINE,
    pub TableContext: PVOID,
}
#[test]
fn bindgen_test_layout__RTL_AVL_TABLE() {
    assert_eq!(::core::mem::size_of::<_RTL_AVL_TABLE>() , 104usize);
    assert_eq!(::core::mem::align_of::<_RTL_AVL_TABLE>() , 8usize);
}
impl Clone for _RTL_AVL_TABLE {
    fn clone(&self) -> Self { *self }
}
pub type PRTL_AVL_COMPARE_ROUTINE =
    ::core::option::Option<unsafe extern "C" fn()
                               -> RTL_GENERIC_COMPARE_RESULTS>;
pub type PRTL_AVL_ALLOCATE_ROUTINE =
    ::core::option::Option<unsafe extern "C" fn() -> PVOID>;
pub type PRTL_AVL_FREE_ROUTINE =
    ::core::option::Option<unsafe extern "C" fn()>;
pub type PRTL_AVL_MATCH_FUNCTION =
    ::core::option::Option<unsafe extern "C" fn() -> NTSTATUS>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _RTL_BALANCED_LINKS {
    pub Parent: *mut _RTL_BALANCED_LINKS,
    pub LeftChild: *mut _RTL_BALANCED_LINKS,
    pub RightChild: *mut _RTL_BALANCED_LINKS,
    pub Balance: CHAR,
    pub Reserved: [UCHAR; 3usize],
}
#[test]
fn bindgen_test_layout__RTL_BALANCED_LINKS() {
    assert_eq!(::core::mem::size_of::<_RTL_BALANCED_LINKS>() , 32usize);
    assert_eq!(::core::mem::align_of::<_RTL_BALANCED_LINKS>() , 8usize);
}
impl Clone for _RTL_BALANCED_LINKS {
    fn clone(&self) -> Self { *self }
}
pub use self::_RTL_BALANCED_LINKS as RTL_BALANCED_LINKS;
pub type PRTL_BALANCED_LINKS = *mut RTL_BALANCED_LINKS;
pub use self::_RTL_AVL_TABLE as RTL_AVL_TABLE;
pub type PRTL_AVL_TABLE = *mut RTL_AVL_TABLE;
extern "C" {
    pub fn RtlInitializeGenericTableAvl(Table: PRTL_AVL_TABLE,
                                        CompareRoutine:
                                            PRTL_AVL_COMPARE_ROUTINE,
                                        AllocateRoutine:
                                            PRTL_AVL_ALLOCATE_ROUTINE,
                                        FreeRoutine: PRTL_AVL_FREE_ROUTINE,
                                        TableContext: PVOID);
}
extern "C" {
    pub fn RtlInsertElementGenericTableAvl(Table: PRTL_AVL_TABLE,
                                           Buffer: PVOID, BufferSize: CLONG,
                                           NewElement: PBOOLEAN) -> PVOID;
}
extern "C" {
    pub fn RtlInsertElementGenericTableFullAvl(Table: PRTL_AVL_TABLE,
                                               Buffer: PVOID,
                                               BufferSize: CLONG,
                                               NewElement: PBOOLEAN,
                                               NodeOrParent: PVOID,
                                               SearchResult:
                                                   TABLE_SEARCH_RESULT)
     -> PVOID;
}
extern "C" {
    pub fn RtlDeleteElementGenericTableAvl(Table: PRTL_AVL_TABLE,
                                           Buffer: PVOID) -> BOOLEAN;
}
extern "C" {
    pub fn RtlDeleteElementGenericTableAvlEx(Table: PRTL_AVL_TABLE,
                                             NodeOrParent: PVOID);
}
extern "C" {
    pub fn RtlLookupElementGenericTableAvl(Table: PRTL_AVL_TABLE,
                                           Buffer: PVOID) -> PVOID;
}
extern "C" {
    pub fn RtlLookupElementGenericTableFullAvl(Table: PRTL_AVL_TABLE,
                                               Buffer: PVOID,
                                               NodeOrParent: *mut PVOID,
                                               SearchResult:
                                                   *mut TABLE_SEARCH_RESULT)
     -> PVOID;
}
extern "C" {
    pub fn RtlEnumerateGenericTableAvl(Table: PRTL_AVL_TABLE,
                                       Restart: BOOLEAN) -> PVOID;
}
extern "C" {
    pub fn RtlEnumerateGenericTableWithoutSplayingAvl(Table: PRTL_AVL_TABLE,
                                                      RestartKey: *mut PVOID)
     -> PVOID;
}
extern "C" {
    pub fn RtlLookupFirstMatchingElementGenericTableAvl(Table: PRTL_AVL_TABLE,
                                                        Buffer: PVOID,
                                                        RestartKey:
                                                            *mut PVOID)
     -> PVOID;
}
extern "C" {
    pub fn RtlEnumerateGenericTableLikeADirectory(Table: PRTL_AVL_TABLE,
                                                  MatchFunction:
                                                      PRTL_AVL_MATCH_FUNCTION,
                                                  MatchData: PVOID,
                                                  NextFlag: ULONG,
                                                  RestartKey: *mut PVOID,
                                                  DeleteCount: PULONG,
                                                  Buffer: PVOID) -> PVOID;
}
extern "C" {
    pub fn RtlGetElementGenericTableAvl(Table: PRTL_AVL_TABLE, I: ULONG)
     -> PVOID;
}
extern "C" {
    pub fn RtlNumberGenericTableElementsAvl(Table: PRTL_AVL_TABLE) -> ULONG;
}
extern "C" {
    pub fn RtlIsGenericTableEmptyAvl(Table: PRTL_AVL_TABLE) -> BOOLEAN;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _RTL_SPLAY_LINKS {
    pub Parent: *mut _RTL_SPLAY_LINKS,
    pub LeftChild: *mut _RTL_SPLAY_LINKS,
    pub RightChild: *mut _RTL_SPLAY_LINKS,
}
#[test]
fn bindgen_test_layout__RTL_SPLAY_LINKS() {
    assert_eq!(::core::mem::size_of::<_RTL_SPLAY_LINKS>() , 24usize);
    assert_eq!(::core::mem::align_of::<_RTL_SPLAY_LINKS>() , 8usize);
}
impl Clone for _RTL_SPLAY_LINKS {
    fn clone(&self) -> Self { *self }
}
pub use self::_RTL_SPLAY_LINKS as RTL_SPLAY_LINKS;
pub type PRTL_SPLAY_LINKS = *mut RTL_SPLAY_LINKS;
extern "C" {
    pub fn RtlSplay(Links: PRTL_SPLAY_LINKS) -> PRTL_SPLAY_LINKS;
}
extern "C" {
    pub fn RtlDelete(Links: PRTL_SPLAY_LINKS) -> PRTL_SPLAY_LINKS;
}
extern "C" {
    pub fn RtlDeleteNoSplay(Links: PRTL_SPLAY_LINKS,
                            Root: *mut PRTL_SPLAY_LINKS);
}
extern "C" {
    pub fn RtlSubtreeSuccessor(Links: PRTL_SPLAY_LINKS) -> PRTL_SPLAY_LINKS;
}
extern "C" {
    pub fn RtlSubtreePredecessor(Links: PRTL_SPLAY_LINKS) -> PRTL_SPLAY_LINKS;
}
extern "C" {
    pub fn RtlRealSuccessor(Links: PRTL_SPLAY_LINKS) -> PRTL_SPLAY_LINKS;
}
extern "C" {
    pub fn RtlRealPredecessor(Links: PRTL_SPLAY_LINKS) -> PRTL_SPLAY_LINKS;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _RTL_GENERIC_TABLE {
    pub TableRoot: PRTL_SPLAY_LINKS,
    pub InsertOrderList: LIST_ENTRY,
    pub OrderedPointer: PLIST_ENTRY,
    pub WhichOrderedElement: ULONG,
    pub NumberGenericTableElements: ULONG,
    pub CompareRoutine: PRTL_GENERIC_COMPARE_ROUTINE,
    pub AllocateRoutine: PRTL_GENERIC_ALLOCATE_ROUTINE,
    pub FreeRoutine: PRTL_GENERIC_FREE_ROUTINE,
    pub TableContext: PVOID,
}
#[test]
fn bindgen_test_layout__RTL_GENERIC_TABLE() {
    assert_eq!(::core::mem::size_of::<_RTL_GENERIC_TABLE>() , 72usize);
    assert_eq!(::core::mem::align_of::<_RTL_GENERIC_TABLE>() , 8usize);
}
impl Clone for _RTL_GENERIC_TABLE {
    fn clone(&self) -> Self { *self }
}
pub type PRTL_GENERIC_COMPARE_ROUTINE =
    ::core::option::Option<unsafe extern "C" fn()
                               -> RTL_GENERIC_COMPARE_RESULTS>;
pub type PRTL_GENERIC_ALLOCATE_ROUTINE =
    ::core::option::Option<unsafe extern "C" fn() -> PVOID>;
pub type PRTL_GENERIC_FREE_ROUTINE =
    ::core::option::Option<unsafe extern "C" fn()>;
pub use self::_RTL_GENERIC_TABLE as RTL_GENERIC_TABLE;
pub type PRTL_GENERIC_TABLE = *mut RTL_GENERIC_TABLE;
extern "C" {
    pub fn RtlInitializeGenericTable(Table: PRTL_GENERIC_TABLE,
                                     CompareRoutine:
                                         PRTL_GENERIC_COMPARE_ROUTINE,
                                     AllocateRoutine:
                                         PRTL_GENERIC_ALLOCATE_ROUTINE,
                                     FreeRoutine: PRTL_GENERIC_FREE_ROUTINE,
                                     TableContext: PVOID);
}
extern "C" {
    pub fn RtlInsertElementGenericTable(Table: PRTL_GENERIC_TABLE,
                                        Buffer: PVOID, BufferSize: CLONG,
                                        NewElement: PBOOLEAN) -> PVOID;
}
extern "C" {
    pub fn RtlInsertElementGenericTableFull(Table: PRTL_GENERIC_TABLE,
                                            Buffer: PVOID, BufferSize: CLONG,
                                            NewElement: PBOOLEAN,
                                            NodeOrParent: PVOID,
                                            SearchResult: TABLE_SEARCH_RESULT)
     -> PVOID;
}
extern "C" {
    pub fn RtlDeleteElementGenericTable(Table: PRTL_GENERIC_TABLE,
                                        Buffer: PVOID) -> BOOLEAN;
}
extern "C" {
    pub fn RtlLookupElementGenericTable(Table: PRTL_GENERIC_TABLE,
                                        Buffer: PVOID) -> PVOID;
}
extern "C" {
    pub fn RtlLookupElementGenericTableFull(Table: PRTL_GENERIC_TABLE,
                                            Buffer: PVOID,
                                            NodeOrParent: *mut PVOID,
                                            SearchResult:
                                                *mut TABLE_SEARCH_RESULT)
     -> PVOID;
}
extern "C" {
    pub fn RtlEnumerateGenericTable(Table: PRTL_GENERIC_TABLE,
                                    Restart: BOOLEAN) -> PVOID;
}
extern "C" {
    pub fn RtlEnumerateGenericTableWithoutSplaying(Table: PRTL_GENERIC_TABLE,
                                                   RestartKey: *mut PVOID)
     -> PVOID;
}
extern "C" {
    pub fn RtlGetElementGenericTable(Table: PRTL_GENERIC_TABLE, I: ULONG)
     -> PVOID;
}
extern "C" {
    pub fn RtlNumberGenericTableElements(Table: PRTL_GENERIC_TABLE) -> ULONG;
}
extern "C" {
    pub fn RtlIsGenericTableEmpty(Table: PRTL_GENERIC_TABLE) -> BOOLEAN;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _RTL_DYNAMIC_HASH_TABLE_ENTRY {
    pub Linkage: LIST_ENTRY,
    pub Signature: ULONG_PTR,
}
#[test]
fn bindgen_test_layout__RTL_DYNAMIC_HASH_TABLE_ENTRY() {
    assert_eq!(::core::mem::size_of::<_RTL_DYNAMIC_HASH_TABLE_ENTRY>() ,
               24usize);
    assert_eq!(::core::mem::align_of::<_RTL_DYNAMIC_HASH_TABLE_ENTRY>() ,
               8usize);
}
impl Clone for _RTL_DYNAMIC_HASH_TABLE_ENTRY {
    fn clone(&self) -> Self { *self }
}
pub use self::_RTL_DYNAMIC_HASH_TABLE_ENTRY as RTL_DYNAMIC_HASH_TABLE_ENTRY;
pub type PRTL_DYNAMIC_HASH_TABLE_ENTRY = *mut _RTL_DYNAMIC_HASH_TABLE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _RTL_DYNAMIC_HASH_TABLE_CONTEXT {
    pub ChainHead: PLIST_ENTRY,
    pub PrevLinkage: PLIST_ENTRY,
    pub Signature: ULONG_PTR,
}
#[test]
fn bindgen_test_layout__RTL_DYNAMIC_HASH_TABLE_CONTEXT() {
    assert_eq!(::core::mem::size_of::<_RTL_DYNAMIC_HASH_TABLE_CONTEXT>() ,
               24usize);
    assert_eq!(::core::mem::align_of::<_RTL_DYNAMIC_HASH_TABLE_CONTEXT>() ,
               8usize);
}
impl Clone for _RTL_DYNAMIC_HASH_TABLE_CONTEXT {
    fn clone(&self) -> Self { *self }
}
pub use self::_RTL_DYNAMIC_HASH_TABLE_CONTEXT as
        RTL_DYNAMIC_HASH_TABLE_CONTEXT;
pub type PRTL_DYNAMIC_HASH_TABLE_CONTEXT =
    *mut _RTL_DYNAMIC_HASH_TABLE_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _RTL_DYNAMIC_HASH_TABLE_ENUMERATOR {
    pub __bindgen_anon_1: _RTL_DYNAMIC_HASH_TABLE_ENUMERATOR__bindgen_ty_1,
    pub ChainHead: PLIST_ENTRY,
    pub BucketIndex: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _RTL_DYNAMIC_HASH_TABLE_ENUMERATOR__bindgen_ty_1 {
    pub HashEntry: __BindgenUnionField<RTL_DYNAMIC_HASH_TABLE_ENTRY>,
    pub CurEntry: __BindgenUnionField<PLIST_ENTRY>,
    pub bindgen_union_field: [u64; 3usize],
}
#[test]
fn bindgen_test_layout__RTL_DYNAMIC_HASH_TABLE_ENUMERATOR__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_RTL_DYNAMIC_HASH_TABLE_ENUMERATOR__bindgen_ty_1>()
               , 24usize);
    assert_eq!(::core::mem::align_of::<_RTL_DYNAMIC_HASH_TABLE_ENUMERATOR__bindgen_ty_1>()
               , 8usize);
}
impl Clone for _RTL_DYNAMIC_HASH_TABLE_ENUMERATOR__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__RTL_DYNAMIC_HASH_TABLE_ENUMERATOR() {
    assert_eq!(::core::mem::size_of::<_RTL_DYNAMIC_HASH_TABLE_ENUMERATOR>() ,
               40usize);
    assert_eq!(::core::mem::align_of::<_RTL_DYNAMIC_HASH_TABLE_ENUMERATOR>() ,
               8usize);
}
impl Clone for _RTL_DYNAMIC_HASH_TABLE_ENUMERATOR {
    fn clone(&self) -> Self { *self }
}
pub use self::_RTL_DYNAMIC_HASH_TABLE_ENUMERATOR as
        RTL_DYNAMIC_HASH_TABLE_ENUMERATOR;
pub type PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR =
    *mut _RTL_DYNAMIC_HASH_TABLE_ENUMERATOR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _RTL_DYNAMIC_HASH_TABLE {
    pub Flags: ULONG,
    pub Shift: ULONG,
    pub TableSize: ULONG,
    pub Pivot: ULONG,
    pub DivisorMask: ULONG,
    pub NumEntries: ULONG,
    pub NonEmptyBuckets: ULONG,
    pub NumEnumerators: ULONG,
    pub Directory: PVOID,
}
#[test]
fn bindgen_test_layout__RTL_DYNAMIC_HASH_TABLE() {
    assert_eq!(::core::mem::size_of::<_RTL_DYNAMIC_HASH_TABLE>() , 40usize);
    assert_eq!(::core::mem::align_of::<_RTL_DYNAMIC_HASH_TABLE>() , 8usize);
}
impl Clone for _RTL_DYNAMIC_HASH_TABLE {
    fn clone(&self) -> Self { *self }
}
pub use self::_RTL_DYNAMIC_HASH_TABLE as RTL_DYNAMIC_HASH_TABLE;
pub type PRTL_DYNAMIC_HASH_TABLE = *mut _RTL_DYNAMIC_HASH_TABLE;
extern "C" {
    pub fn RtlCreateHashTable(HashTable: *mut PRTL_DYNAMIC_HASH_TABLE,
                              Shift: ULONG, Flags: ULONG) -> BOOLEAN;
}
extern "C" {
    pub fn RtlCreateHashTableEx(HashTable: *mut PRTL_DYNAMIC_HASH_TABLE,
                                InitialSize: ULONG, Shift: ULONG,
                                Flags: ULONG) -> BOOLEAN;
}
extern "C" {
    pub fn RtlDeleteHashTable(HashTable: PRTL_DYNAMIC_HASH_TABLE);
}
extern "C" {
    pub fn RtlInsertEntryHashTable(HashTable: PRTL_DYNAMIC_HASH_TABLE,
                                   Entry: PRTL_DYNAMIC_HASH_TABLE_ENTRY,
                                   Signature: ULONG_PTR,
                                   Context: PRTL_DYNAMIC_HASH_TABLE_CONTEXT)
     -> BOOLEAN;
}
extern "C" {
    pub fn RtlRemoveEntryHashTable(HashTable: PRTL_DYNAMIC_HASH_TABLE,
                                   Entry: PRTL_DYNAMIC_HASH_TABLE_ENTRY,
                                   Context: PRTL_DYNAMIC_HASH_TABLE_CONTEXT)
     -> BOOLEAN;
}
extern "C" {
    pub fn RtlLookupEntryHashTable(HashTable: PRTL_DYNAMIC_HASH_TABLE,
                                   Signature: ULONG_PTR,
                                   Context: PRTL_DYNAMIC_HASH_TABLE_CONTEXT)
     -> PRTL_DYNAMIC_HASH_TABLE_ENTRY;
}
extern "C" {
    pub fn RtlGetNextEntryHashTable(HashTable: PRTL_DYNAMIC_HASH_TABLE,
                                    Context: PRTL_DYNAMIC_HASH_TABLE_CONTEXT)
     -> PRTL_DYNAMIC_HASH_TABLE_ENTRY;
}
extern "C" {
    pub fn RtlInitEnumerationHashTable(HashTable: PRTL_DYNAMIC_HASH_TABLE,
                                       Enumerator:
                                           PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR)
     -> BOOLEAN;
}
extern "C" {
    pub fn RtlEnumerateEntryHashTable(HashTable: PRTL_DYNAMIC_HASH_TABLE,
                                      Enumerator:
                                          PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR)
     -> PRTL_DYNAMIC_HASH_TABLE_ENTRY;
}
extern "C" {
    pub fn RtlEndEnumerationHashTable(HashTable: PRTL_DYNAMIC_HASH_TABLE,
                                      Enumerator:
                                          PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR);
}
extern "C" {
    pub fn RtlInitWeakEnumerationHashTable(HashTable: PRTL_DYNAMIC_HASH_TABLE,
                                           Enumerator:
                                               PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR)
     -> BOOLEAN;
}
extern "C" {
    pub fn RtlWeaklyEnumerateEntryHashTable(HashTable:
                                                PRTL_DYNAMIC_HASH_TABLE,
                                            Enumerator:
                                                PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR)
     -> PRTL_DYNAMIC_HASH_TABLE_ENTRY;
}
extern "C" {
    pub fn RtlEndWeakEnumerationHashTable(HashTable: PRTL_DYNAMIC_HASH_TABLE,
                                          Enumerator:
                                              PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR);
}
extern "C" {
    pub fn RtlInitStrongEnumerationHashTable(HashTable:
                                                 PRTL_DYNAMIC_HASH_TABLE,
                                             Enumerator:
                                                 PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR)
     -> BOOLEAN;
}
extern "C" {
    pub fn RtlStronglyEnumerateEntryHashTable(HashTable:
                                                  PRTL_DYNAMIC_HASH_TABLE,
                                              Enumerator:
                                                  PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR)
     -> PRTL_DYNAMIC_HASH_TABLE_ENTRY;
}
extern "C" {
    pub fn RtlEndStrongEnumerationHashTable(HashTable:
                                                PRTL_DYNAMIC_HASH_TABLE,
                                            Enumerator:
                                                PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR);
}
extern "C" {
    pub fn RtlExpandHashTable(HashTable: PRTL_DYNAMIC_HASH_TABLE) -> BOOLEAN;
}
extern "C" {
    pub fn RtlContractHashTable(HashTable: PRTL_DYNAMIC_HASH_TABLE)
     -> BOOLEAN;
}
extern "C" {
    pub fn _ReturnAddress() -> PVOID;
}
extern "C" {
    pub fn RtlWalkFrameChain(Callers: *mut PVOID, Count: ULONG, Flags: ULONG)
     -> ULONG;
}
extern "C" {
    pub fn RtlGetEnabledExtendedFeatures(FeatureMask: ULONG64) -> ULONG64;
}
extern "C" {
    pub fn RtlCharToInteger(String: PCSZ, Base: ULONG, Value: PULONG)
     -> NTSTATUS;
}
extern "C" {
    pub fn RtlCopyString(DestinationString: PSTRING,
                         SourceString: *const STRING);
}
extern "C" {
    pub fn RtlUpperChar(Character: CHAR) -> CHAR;
}
extern "C" {
    pub fn RtlCompareString(String1: *const STRING, String2: *const STRING,
                            CaseInSensitive: BOOLEAN) -> LONG;
}
extern "C" {
    pub fn RtlEqualString(String1: *const STRING, String2: *const STRING,
                          CaseInSensitive: BOOLEAN) -> BOOLEAN;
}
extern "C" {
    pub fn RtlUpperString(DestinationString: PSTRING,
                          SourceString: *const STRING);
}
extern "C" {
    pub fn RtlPrefixUnicodeString(String1: PCUNICODE_STRING,
                                  String2: PCUNICODE_STRING,
                                  CaseInSensitive: BOOLEAN) -> BOOLEAN;
}
extern "C" {
    pub fn RtlSuffixUnicodeString(String1: PCUNICODE_STRING,
                                  String2: PCUNICODE_STRING,
                                  CaseInSensitive: BOOLEAN) -> BOOLEAN;
}
extern "C" {
    pub fn RtlUpcaseUnicodeString(DestinationString: PUNICODE_STRING,
                                  SourceString: PCUNICODE_STRING,
                                  AllocateDestinationString: BOOLEAN)
     -> NTSTATUS;
}
extern "C" {
    pub fn RtlLargeIntegerDivide(Dividend: LARGE_INTEGER,
                                 Divisor: LARGE_INTEGER,
                                 Remainder: PLARGE_INTEGER) -> LARGE_INTEGER;
}
extern "C" {
    pub fn RtlMapGenericMask(AccessMask: PACCESS_MASK,
                             GenericMapping: PGENERIC_MAPPING);
}
extern "C" {
    pub fn RtlVolumeDeviceToDosName(VolumeDeviceObject: PVOID,
                                    DosName: PUNICODE_STRING) -> NTSTATUS;
}
extern "C" {
    pub fn DbgPrompt(Prompt: PCCH, Response: PCH, Length: ULONG) -> ULONG;
}
extern "C" {
    pub fn RtlGetProductInfo(OSMajorVersion: ULONG, OSMinorVersion: ULONG,
                             SpMajorVersion: ULONG, SpMinorVersion: ULONG,
                             ReturnedProductType: PULONG) -> BOOLEAN;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _FILE_ALIGNMENT_INFORMATION {
    pub AlignmentRequirement: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_ALIGNMENT_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_FILE_ALIGNMENT_INFORMATION>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_FILE_ALIGNMENT_INFORMATION>() ,
               4usize);
}
impl Clone for _FILE_ALIGNMENT_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_FILE_ALIGNMENT_INFORMATION as FILE_ALIGNMENT_INFORMATION;
pub type PFILE_ALIGNMENT_INFORMATION = *mut _FILE_ALIGNMENT_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _FILE_NAME_INFORMATION {
    pub FileNameLength: ULONG,
    pub FileName: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_NAME_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_FILE_NAME_INFORMATION>() , 8usize);
    assert_eq!(::core::mem::align_of::<_FILE_NAME_INFORMATION>() , 4usize);
}
impl Clone for _FILE_NAME_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_FILE_NAME_INFORMATION as FILE_NAME_INFORMATION;
pub type PFILE_NAME_INFORMATION = *mut _FILE_NAME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _FILE_ATTRIBUTE_TAG_INFORMATION {
    pub FileAttributes: ULONG,
    pub ReparseTag: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_ATTRIBUTE_TAG_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_FILE_ATTRIBUTE_TAG_INFORMATION>() ,
               8usize);
    assert_eq!(::core::mem::align_of::<_FILE_ATTRIBUTE_TAG_INFORMATION>() ,
               4usize);
}
impl Clone for _FILE_ATTRIBUTE_TAG_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_FILE_ATTRIBUTE_TAG_INFORMATION as
        FILE_ATTRIBUTE_TAG_INFORMATION;
pub type PFILE_ATTRIBUTE_TAG_INFORMATION =
    *mut _FILE_ATTRIBUTE_TAG_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _FILE_DISPOSITION_INFORMATION {
    pub DeleteFile: BOOLEAN,
}
#[test]
fn bindgen_test_layout__FILE_DISPOSITION_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_FILE_DISPOSITION_INFORMATION>() ,
               1usize);
    assert_eq!(::core::mem::align_of::<_FILE_DISPOSITION_INFORMATION>() ,
               1usize);
}
impl Clone for _FILE_DISPOSITION_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_FILE_DISPOSITION_INFORMATION as FILE_DISPOSITION_INFORMATION;
pub type PFILE_DISPOSITION_INFORMATION = *mut _FILE_DISPOSITION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _FILE_DISPOSITION_INFORMATION_EX {
    pub Flags: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_DISPOSITION_INFORMATION_EX() {
    assert_eq!(::core::mem::size_of::<_FILE_DISPOSITION_INFORMATION_EX>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_FILE_DISPOSITION_INFORMATION_EX>() ,
               4usize);
}
impl Clone for _FILE_DISPOSITION_INFORMATION_EX {
    fn clone(&self) -> Self { *self }
}
pub use self::_FILE_DISPOSITION_INFORMATION_EX as
        FILE_DISPOSITION_INFORMATION_EX;
pub type PFILE_DISPOSITION_INFORMATION_EX =
    *mut _FILE_DISPOSITION_INFORMATION_EX;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _FILE_END_OF_FILE_INFORMATION {
    pub EndOfFile: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__FILE_END_OF_FILE_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_FILE_END_OF_FILE_INFORMATION>() ,
               8usize);
    assert_eq!(::core::mem::align_of::<_FILE_END_OF_FILE_INFORMATION>() ,
               8usize);
}
impl Clone for _FILE_END_OF_FILE_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_FILE_END_OF_FILE_INFORMATION as FILE_END_OF_FILE_INFORMATION;
pub type PFILE_END_OF_FILE_INFORMATION = *mut _FILE_END_OF_FILE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _FILE_VALID_DATA_LENGTH_INFORMATION {
    pub ValidDataLength: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__FILE_VALID_DATA_LENGTH_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_FILE_VALID_DATA_LENGTH_INFORMATION>() ,
               8usize);
    assert_eq!(::core::mem::align_of::<_FILE_VALID_DATA_LENGTH_INFORMATION>()
               , 8usize);
}
impl Clone for _FILE_VALID_DATA_LENGTH_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_FILE_VALID_DATA_LENGTH_INFORMATION as
        FILE_VALID_DATA_LENGTH_INFORMATION;
pub type PFILE_VALID_DATA_LENGTH_INFORMATION =
    *mut _FILE_VALID_DATA_LENGTH_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _FILE_FS_LABEL_INFORMATION {
    pub VolumeLabelLength: ULONG,
    pub VolumeLabel: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_FS_LABEL_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_FILE_FS_LABEL_INFORMATION>() , 8usize);
    assert_eq!(::core::mem::align_of::<_FILE_FS_LABEL_INFORMATION>() ,
               4usize);
}
impl Clone for _FILE_FS_LABEL_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_FILE_FS_LABEL_INFORMATION as FILE_FS_LABEL_INFORMATION;
pub type PFILE_FS_LABEL_INFORMATION = *mut _FILE_FS_LABEL_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _FILE_FS_VOLUME_INFORMATION {
    pub VolumeCreationTime: LARGE_INTEGER,
    pub VolumeSerialNumber: ULONG,
    pub VolumeLabelLength: ULONG,
    pub SupportsObjects: BOOLEAN,
    pub VolumeLabel: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_FS_VOLUME_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_FILE_FS_VOLUME_INFORMATION>() ,
               24usize);
    assert_eq!(::core::mem::align_of::<_FILE_FS_VOLUME_INFORMATION>() ,
               8usize);
}
impl Clone for _FILE_FS_VOLUME_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_FILE_FS_VOLUME_INFORMATION as FILE_FS_VOLUME_INFORMATION;
pub type PFILE_FS_VOLUME_INFORMATION = *mut _FILE_FS_VOLUME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _FILE_FS_SIZE_INFORMATION {
    pub TotalAllocationUnits: LARGE_INTEGER,
    pub AvailableAllocationUnits: LARGE_INTEGER,
    pub SectorsPerAllocationUnit: ULONG,
    pub BytesPerSector: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_FS_SIZE_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_FILE_FS_SIZE_INFORMATION>() , 24usize);
    assert_eq!(::core::mem::align_of::<_FILE_FS_SIZE_INFORMATION>() , 8usize);
}
impl Clone for _FILE_FS_SIZE_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_FILE_FS_SIZE_INFORMATION as FILE_FS_SIZE_INFORMATION;
pub type PFILE_FS_SIZE_INFORMATION = *mut _FILE_FS_SIZE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _FILE_FS_FULL_SIZE_INFORMATION {
    pub TotalAllocationUnits: LARGE_INTEGER,
    pub CallerAvailableAllocationUnits: LARGE_INTEGER,
    pub ActualAvailableAllocationUnits: LARGE_INTEGER,
    pub SectorsPerAllocationUnit: ULONG,
    pub BytesPerSector: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_FS_FULL_SIZE_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_FILE_FS_FULL_SIZE_INFORMATION>() ,
               32usize);
    assert_eq!(::core::mem::align_of::<_FILE_FS_FULL_SIZE_INFORMATION>() ,
               8usize);
}
impl Clone for _FILE_FS_FULL_SIZE_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_FILE_FS_FULL_SIZE_INFORMATION as FILE_FS_FULL_SIZE_INFORMATION;
pub type PFILE_FS_FULL_SIZE_INFORMATION = *mut _FILE_FS_FULL_SIZE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _FILE_FS_METADATA_SIZE_INFORMATION {
    pub TotalMetadataAllocationUnits: LARGE_INTEGER,
    pub SectorsPerAllocationUnit: ULONG,
    pub BytesPerSector: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_FS_METADATA_SIZE_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_FILE_FS_METADATA_SIZE_INFORMATION>() ,
               16usize);
    assert_eq!(::core::mem::align_of::<_FILE_FS_METADATA_SIZE_INFORMATION>() ,
               8usize);
}
impl Clone for _FILE_FS_METADATA_SIZE_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_FILE_FS_METADATA_SIZE_INFORMATION as
        FILE_FS_METADATA_SIZE_INFORMATION;
pub type PFILE_FS_METADATA_SIZE_INFORMATION =
    *mut _FILE_FS_METADATA_SIZE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _FILE_FS_SECTOR_SIZE_INFORMATION {
    pub LogicalBytesPerSector: ULONG,
    pub PhysicalBytesPerSectorForAtomicity: ULONG,
    pub PhysicalBytesPerSectorForPerformance: ULONG,
    pub FileSystemEffectivePhysicalBytesPerSectorForAtomicity: ULONG,
    pub Flags: ULONG,
    pub ByteOffsetForSectorAlignment: ULONG,
    pub ByteOffsetForPartitionAlignment: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_FS_SECTOR_SIZE_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_FILE_FS_SECTOR_SIZE_INFORMATION>() ,
               28usize);
    assert_eq!(::core::mem::align_of::<_FILE_FS_SECTOR_SIZE_INFORMATION>() ,
               4usize);
}
impl Clone for _FILE_FS_SECTOR_SIZE_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_FILE_FS_SECTOR_SIZE_INFORMATION as
        FILE_FS_SECTOR_SIZE_INFORMATION;
pub type PFILE_FS_SECTOR_SIZE_INFORMATION =
    *mut _FILE_FS_SECTOR_SIZE_INFORMATION;
#[repr(C)]
pub struct _FILE_FS_OBJECTID_INFORMATION {
    pub ObjectId: [UCHAR; 16usize],
    pub ExtendedInfo: [UCHAR; 48usize],
}
#[test]
fn bindgen_test_layout__FILE_FS_OBJECTID_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_FILE_FS_OBJECTID_INFORMATION>() ,
               64usize);
    assert_eq!(::core::mem::align_of::<_FILE_FS_OBJECTID_INFORMATION>() ,
               1usize);
}
pub use self::_FILE_FS_OBJECTID_INFORMATION as FILE_FS_OBJECTID_INFORMATION;
pub type PFILE_FS_OBJECTID_INFORMATION = *mut _FILE_FS_OBJECTID_INFORMATION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _BUS_DATA_TYPE {
    ConfigurationSpaceUndefined = -1,
    Cmos = 0,
    EisaConfiguration = 1,
    Pos = 2,
    CbusConfiguration = 3,
    PCIConfiguration = 4,
    VMEConfiguration = 5,
    NuBusConfiguration = 6,
    PCMCIAConfiguration = 7,
    MPIConfiguration = 8,
    MPSAConfiguration = 9,
    PNPISAConfiguration = 10,
    SgiInternalConfiguration = 11,
    MaximumBusDataType = 12,
}
pub use self::_BUS_DATA_TYPE as BUS_DATA_TYPE;
pub type PBUS_DATA_TYPE = *mut _BUS_DATA_TYPE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KEY_NAME_INFORMATION {
    pub NameLength: ULONG,
    pub Name: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__KEY_NAME_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_KEY_NAME_INFORMATION>() , 8usize);
    assert_eq!(::core::mem::align_of::<_KEY_NAME_INFORMATION>() , 4usize);
}
impl Clone for _KEY_NAME_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_KEY_NAME_INFORMATION as KEY_NAME_INFORMATION;
pub type PKEY_NAME_INFORMATION = *mut _KEY_NAME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KEY_CACHED_INFORMATION {
    pub LastWriteTime: LARGE_INTEGER,
    pub TitleIndex: ULONG,
    pub SubKeys: ULONG,
    pub MaxNameLen: ULONG,
    pub Values: ULONG,
    pub MaxValueNameLen: ULONG,
    pub MaxValueDataLen: ULONG,
    pub NameLength: ULONG,
}
#[test]
fn bindgen_test_layout__KEY_CACHED_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_KEY_CACHED_INFORMATION>() , 40usize);
    assert_eq!(::core::mem::align_of::<_KEY_CACHED_INFORMATION>() , 8usize);
}
impl Clone for _KEY_CACHED_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_KEY_CACHED_INFORMATION as KEY_CACHED_INFORMATION;
pub type PKEY_CACHED_INFORMATION = *mut _KEY_CACHED_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KEY_VIRTUALIZATION_INFORMATION {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__KEY_VIRTUALIZATION_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_KEY_VIRTUALIZATION_INFORMATION>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_KEY_VIRTUALIZATION_INFORMATION>() ,
               4usize);
}
impl Clone for _KEY_VIRTUALIZATION_INFORMATION {
    fn clone(&self) -> Self { *self }
}
impl _KEY_VIRTUALIZATION_INFORMATION {
    #[inline]
    pub fn VirtualizationCandidate(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_VirtualizationCandidate(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn VirtualizationEnabled(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_VirtualizationEnabled(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn VirtualTarget(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                        2u32) as u32)
        }
    }
    #[inline]
    pub fn set_VirtualTarget(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn VirtualStore(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u32)) >>
                                        3u32) as u32)
        }
    }
    #[inline]
    pub fn set_VirtualStore(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (8usize as u32);
    }
    #[inline]
    pub fn VirtualSource(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u32)) >>
                                        4u32) as u32)
        }
    }
    #[inline]
    pub fn set_VirtualSource(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (16usize as u32);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967264usize as u32)) >> 5u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967264usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 5u32) & (4294967264usize as u32);
    }
}
pub use self::_KEY_VIRTUALIZATION_INFORMATION as
        KEY_VIRTUALIZATION_INFORMATION;
pub type PKEY_VIRTUALIZATION_INFORMATION =
    *mut _KEY_VIRTUALIZATION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KEY_LAYER_INFORMATION {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__KEY_LAYER_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_KEY_LAYER_INFORMATION>() , 4usize);
    assert_eq!(::core::mem::align_of::<_KEY_LAYER_INFORMATION>() , 4usize);
}
impl Clone for _KEY_LAYER_INFORMATION {
    fn clone(&self) -> Self { *self }
}
impl _KEY_LAYER_INFORMATION {
    #[inline]
    pub fn IsTombstone(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_IsTombstone(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn IsSupersedeLocal(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_IsSupersedeLocal(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn IsSupersedeTree(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                        2u32) as u32)
        }
    }
    #[inline]
    pub fn set_IsSupersedeTree(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn ClassIsInherited(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u32)) >>
                                        3u32) as u32)
        }
    }
    #[inline]
    pub fn set_ClassIsInherited(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (8usize as u32);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967280usize as u32)) >> 4u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967280usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 4u32) & (4294967280usize as u32);
    }
}
pub use self::_KEY_LAYER_INFORMATION as KEY_LAYER_INFORMATION;
pub type PKEY_LAYER_INFORMATION = *mut _KEY_LAYER_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _EXCEPTION_REGISTRATION_RECORD {
    pub Next: *mut _EXCEPTION_REGISTRATION_RECORD,
    pub Handler: PEXCEPTION_ROUTINE,
}
#[test]
fn bindgen_test_layout__EXCEPTION_REGISTRATION_RECORD() {
    assert_eq!(::core::mem::size_of::<_EXCEPTION_REGISTRATION_RECORD>() ,
               16usize);
    assert_eq!(::core::mem::align_of::<_EXCEPTION_REGISTRATION_RECORD>() ,
               8usize);
}
impl Clone for _EXCEPTION_REGISTRATION_RECORD {
    fn clone(&self) -> Self { *self }
}
pub use self::_EXCEPTION_REGISTRATION_RECORD as EXCEPTION_REGISTRATION_RECORD;
pub type PEXCEPTION_REGISTRATION_RECORD = *mut EXCEPTION_REGISTRATION_RECORD;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _NT_TIB {
    pub ExceptionList: *mut _EXCEPTION_REGISTRATION_RECORD,
    pub StackBase: PVOID,
    pub StackLimit: PVOID,
    pub SubSystemTib: PVOID,
    pub __bindgen_anon_1: _NT_TIB__bindgen_ty_1,
    pub ArbitraryUserPointer: PVOID,
    pub Self_: *mut _NT_TIB,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _NT_TIB__bindgen_ty_1 {
    pub FiberData: __BindgenUnionField<PVOID>,
    pub Version: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__NT_TIB__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_NT_TIB__bindgen_ty_1>() , 8usize);
    assert_eq!(::core::mem::align_of::<_NT_TIB__bindgen_ty_1>() , 8usize);
}
impl Clone for _NT_TIB__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__NT_TIB() {
    assert_eq!(::core::mem::size_of::<_NT_TIB>() , 56usize);
    assert_eq!(::core::mem::align_of::<_NT_TIB>() , 8usize);
}
impl Clone for _NT_TIB {
    fn clone(&self) -> Self { *self }
}
pub use self::_NT_TIB as NT_TIB;
pub type PNT_TIB = *mut NT_TIB;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _NT_TIB32 {
    pub ExceptionList: ULONG,
    pub StackBase: ULONG,
    pub StackLimit: ULONG,
    pub SubSystemTib: ULONG,
    pub __bindgen_anon_1: _NT_TIB32__bindgen_ty_1,
    pub ArbitraryUserPointer: ULONG,
    pub Self_: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _NT_TIB32__bindgen_ty_1 {
    pub FiberData: __BindgenUnionField<ULONG>,
    pub Version: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout__NT_TIB32__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_NT_TIB32__bindgen_ty_1>() , 4usize);
    assert_eq!(::core::mem::align_of::<_NT_TIB32__bindgen_ty_1>() , 4usize);
}
impl Clone for _NT_TIB32__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__NT_TIB32() {
    assert_eq!(::core::mem::size_of::<_NT_TIB32>() , 28usize);
    assert_eq!(::core::mem::align_of::<_NT_TIB32>() , 4usize);
}
impl Clone for _NT_TIB32 {
    fn clone(&self) -> Self { *self }
}
pub use self::_NT_TIB32 as NT_TIB32;
pub type PNT_TIB32 = *mut _NT_TIB32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _NT_TIB64 {
    pub ExceptionList: ULONG64,
    pub StackBase: ULONG64,
    pub StackLimit: ULONG64,
    pub SubSystemTib: ULONG64,
    pub __bindgen_anon_1: _NT_TIB64__bindgen_ty_1,
    pub ArbitraryUserPointer: ULONG64,
    pub Self_: ULONG64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _NT_TIB64__bindgen_ty_1 {
    pub FiberData: __BindgenUnionField<ULONG64>,
    pub Version: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__NT_TIB64__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_NT_TIB64__bindgen_ty_1>() , 8usize);
    assert_eq!(::core::mem::align_of::<_NT_TIB64__bindgen_ty_1>() , 8usize);
}
impl Clone for _NT_TIB64__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__NT_TIB64() {
    assert_eq!(::core::mem::size_of::<_NT_TIB64>() , 56usize);
    assert_eq!(::core::mem::align_of::<_NT_TIB64>() , 8usize);
}
impl Clone for _NT_TIB64 {
    fn clone(&self) -> Self { *self }
}
pub use self::_NT_TIB64 as NT_TIB64;
pub type PNT_TIB64 = *mut _NT_TIB64;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _PROCESSINFOCLASS {
    ProcessBasicInformation = 0,
    ProcessQuotaLimits = 1,
    ProcessIoCounters = 2,
    ProcessVmCounters = 3,
    ProcessTimes = 4,
    ProcessBasePriority = 5,
    ProcessRaisePriority = 6,
    ProcessDebugPort = 7,
    ProcessExceptionPort = 8,
    ProcessAccessToken = 9,
    ProcessLdtInformation = 10,
    ProcessLdtSize = 11,
    ProcessDefaultHardErrorMode = 12,
    ProcessIoPortHandlers = 13,
    ProcessPooledUsageAndLimits = 14,
    ProcessWorkingSetWatch = 15,
    ProcessUserModeIOPL = 16,
    ProcessEnableAlignmentFaultFixup = 17,
    ProcessPriorityClass = 18,
    ProcessWx86Information = 19,
    ProcessHandleCount = 20,
    ProcessAffinityMask = 21,
    ProcessPriorityBoost = 22,
    ProcessDeviceMap = 23,
    ProcessSessionInformation = 24,
    ProcessForegroundInformation = 25,
    ProcessWow64Information = 26,
    ProcessImageFileName = 27,
    ProcessLUIDDeviceMapsEnabled = 28,
    ProcessBreakOnTermination = 29,
    ProcessDebugObjectHandle = 30,
    ProcessDebugFlags = 31,
    ProcessHandleTracing = 32,
    ProcessIoPriority = 33,
    ProcessExecuteFlags = 34,
    ProcessTlsInformation = 35,
    ProcessCookie = 36,
    ProcessImageInformation = 37,
    ProcessCycleTime = 38,
    ProcessPagePriority = 39,
    ProcessInstrumentationCallback = 40,
    ProcessThreadStackAllocation = 41,
    ProcessWorkingSetWatchEx = 42,
    ProcessImageFileNameWin32 = 43,
    ProcessImageFileMapping = 44,
    ProcessAffinityUpdateMode = 45,
    ProcessMemoryAllocationMode = 46,
    ProcessGroupInformation = 47,
    ProcessTokenVirtualizationEnabled = 48,
    ProcessOwnerInformation = 49,
    ProcessWindowInformation = 50,
    ProcessHandleInformation = 51,
    ProcessMitigationPolicy = 52,
    ProcessDynamicFunctionTableInformation = 53,
    ProcessHandleCheckingMode = 54,
    ProcessKeepAliveCount = 55,
    ProcessRevokeFileHandles = 56,
    ProcessWorkingSetControl = 57,
    ProcessHandleTable = 58,
    ProcessCheckStackExtentsMode = 59,
    ProcessCommandLineInformation = 60,
    ProcessProtectionInformation = 61,
    ProcessMemoryExhaustion = 62,
    ProcessFaultInformation = 63,
    ProcessTelemetryIdInformation = 64,
    ProcessCommitReleaseInformation = 65,
    ProcessReserved1Information = 66,
    ProcessReserved2Information = 67,
    ProcessSubsystemProcess = 68,
    ProcessInPrivate = 70,
    ProcessRaiseUMExceptionOnInvalidHandleClose = 71,
    MaxProcessInfoClass = 72,
}
pub use self::_PROCESSINFOCLASS as PROCESSINFOCLASS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _THREADINFOCLASS {
    ThreadBasicInformation = 0,
    ThreadTimes = 1,
    ThreadPriority = 2,
    ThreadBasePriority = 3,
    ThreadAffinityMask = 4,
    ThreadImpersonationToken = 5,
    ThreadDescriptorTableEntry = 6,
    ThreadEnableAlignmentFaultFixup = 7,
    ThreadEventPair_Reusable = 8,
    ThreadQuerySetWin32StartAddress = 9,
    ThreadZeroTlsCell = 10,
    ThreadPerformanceCount = 11,
    ThreadAmILastThread = 12,
    ThreadIdealProcessor = 13,
    ThreadPriorityBoost = 14,
    ThreadSetTlsArrayAddress = 15,
    ThreadIsIoPending = 16,
    ThreadHideFromDebugger = 17,
    ThreadBreakOnTermination = 18,
    ThreadSwitchLegacyState = 19,
    ThreadIsTerminated = 20,
    ThreadLastSystemCall = 21,
    ThreadIoPriority = 22,
    ThreadCycleTime = 23,
    ThreadPagePriority = 24,
    ThreadActualBasePriority = 25,
    ThreadTebInformation = 26,
    ThreadCSwitchMon = 27,
    ThreadCSwitchPmu = 28,
    ThreadWow64Context = 29,
    ThreadGroupInformation = 30,
    ThreadUmsInformation = 31,
    ThreadCounterProfiling = 32,
    ThreadIdealProcessorEx = 33,
    ThreadCpuAccountingInformation = 34,
    ThreadSuspendCount = 35,
    ThreadActualGroupAffinity = 41,
    ThreadDynamicCodePolicyInfo = 42,
    MaxThreadInfoClass = 45,
}
pub use self::_THREADINFOCLASS as THREADINFOCLASS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PAGE_PRIORITY_INFORMATION {
    pub PagePriority: ULONG,
}
#[test]
fn bindgen_test_layout__PAGE_PRIORITY_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_PAGE_PRIORITY_INFORMATION>() , 4usize);
    assert_eq!(::core::mem::align_of::<_PAGE_PRIORITY_INFORMATION>() ,
               4usize);
}
impl Clone for _PAGE_PRIORITY_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_PAGE_PRIORITY_INFORMATION as PAGE_PRIORITY_INFORMATION;
pub type PPAGE_PRIORITY_INFORMATION = *mut _PAGE_PRIORITY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_WS_WATCH_INFORMATION {
    pub FaultingPc: PVOID,
    pub FaultingVa: PVOID,
}
#[test]
fn bindgen_test_layout__PROCESS_WS_WATCH_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_PROCESS_WS_WATCH_INFORMATION>() ,
               16usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_WS_WATCH_INFORMATION>() ,
               8usize);
}
impl Clone for _PROCESS_WS_WATCH_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_PROCESS_WS_WATCH_INFORMATION as PROCESS_WS_WATCH_INFORMATION;
pub type PPROCESS_WS_WATCH_INFORMATION = *mut _PROCESS_WS_WATCH_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_BASIC_INFORMATION {
    pub ExitStatus: NTSTATUS,
    pub PebBaseAddress: PPEB,
    pub AffinityMask: ULONG_PTR,
    pub BasePriority: KPRIORITY,
    pub UniqueProcessId: ULONG_PTR,
    pub InheritedFromUniqueProcessId: ULONG_PTR,
}
#[test]
fn bindgen_test_layout__PROCESS_BASIC_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_PROCESS_BASIC_INFORMATION>() ,
               48usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_BASIC_INFORMATION>() ,
               8usize);
}
impl Clone for _PROCESS_BASIC_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_PROCESS_BASIC_INFORMATION as PROCESS_BASIC_INFORMATION;
pub type PPROCESS_BASIC_INFORMATION = *mut _PROCESS_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_EXTENDED_BASIC_INFORMATION {
    pub Size: SIZE_T,
    pub BasicInfo: PROCESS_BASIC_INFORMATION,
    pub __bindgen_anon_1: _PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_1 {
    pub Flags: __BindgenUnionField<ULONG>,
    pub __bindgen_anon_1: __BindgenUnionField<_PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_1__bindgen_ty_1
 {
    fn clone(&self) -> Self { *self }
}
impl _PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn IsProtectedProcess(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_IsProtectedProcess(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn IsWow64Process(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_IsWow64Process(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn IsProcessDeleting(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                        2u32) as u32)
        }
    }
    #[inline]
    pub fn set_IsProcessDeleting(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn IsCrossSessionCreate(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u32)) >>
                                        3u32) as u32)
        }
    }
    #[inline]
    pub fn set_IsCrossSessionCreate(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (8usize as u32);
    }
    #[inline]
    pub fn IsFrozen(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u32)) >>
                                        4u32) as u32)
        }
    }
    #[inline]
    pub fn set_IsFrozen(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (16usize as u32);
    }
    #[inline]
    pub fn IsBackground(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u32)) >>
                                        5u32) as u32)
        }
    }
    #[inline]
    pub fn set_IsBackground(&mut self, val: ULONG) {
        self._bitfield_1 &= !(32usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (32usize as u32);
    }
    #[inline]
    pub fn IsStronglyNamed(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u32)) >>
                                        6u32) as u32)
        }
    }
    #[inline]
    pub fn set_IsStronglyNamed(&mut self, val: ULONG) {
        self._bitfield_1 &= !(64usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 6u32) & (64usize as u32);
    }
    #[inline]
    pub fn IsSecureProcess(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (128usize as u32)) >>
                                        7u32) as u32)
        }
    }
    #[inline]
    pub fn set_IsSecureProcess(&mut self, val: ULONG) {
        self._bitfield_1 &= !(128usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 7u32) & (128usize as u32);
    }
    #[inline]
    pub fn IsPicoProcess(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (256usize as u32)) >>
                                        8u32) as u32)
        }
    }
    #[inline]
    pub fn set_IsPicoProcess(&mut self, val: ULONG) {
        self._bitfield_1 &= !(256usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 8u32) & (256usize as u32);
    }
    #[inline]
    pub fn SpareBits(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294966784usize as u32)) >> 9u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_SpareBits(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294966784usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 9u32) & (4294966784usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__PROCESS_EXTENDED_BASIC_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_PROCESS_EXTENDED_BASIC_INFORMATION>() ,
               64usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_EXTENDED_BASIC_INFORMATION>()
               , 8usize);
}
impl Clone for _PROCESS_EXTENDED_BASIC_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_PROCESS_EXTENDED_BASIC_INFORMATION as
        PROCESS_EXTENDED_BASIC_INFORMATION;
pub type PPROCESS_EXTENDED_BASIC_INFORMATION =
    *mut _PROCESS_EXTENDED_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_DEVICEMAP_INFORMATION {
    pub __bindgen_anon_1: _PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1 {
    pub Set: __BindgenUnionField<_PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1__bindgen_ty_1>,
    pub Query: __BindgenUnionField<_PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    pub DirectoryHandle: HANDLE,
}
#[test]
fn bindgen_test_layout__PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1__bindgen_ty_1>()
               , 8usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1__bindgen_ty_1>()
               , 8usize);
}
impl Clone for _PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1__bindgen_ty_2 {
    pub DriveMap: ULONG,
    pub DriveType: [UCHAR; 32usize],
}
#[test]
fn bindgen_test_layout__PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<_PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1__bindgen_ty_2>()
               , 36usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1__bindgen_ty_2>()
               , 4usize);
}
impl Clone for _PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1>()
               , 40usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1>()
               , 8usize);
}
impl Clone for _PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__PROCESS_DEVICEMAP_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_PROCESS_DEVICEMAP_INFORMATION>() ,
               40usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_DEVICEMAP_INFORMATION>() ,
               8usize);
}
impl Clone for _PROCESS_DEVICEMAP_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_PROCESS_DEVICEMAP_INFORMATION as PROCESS_DEVICEMAP_INFORMATION;
pub type PPROCESS_DEVICEMAP_INFORMATION = *mut _PROCESS_DEVICEMAP_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_DEVICEMAP_INFORMATION_EX {
    pub __bindgen_anon_1: _PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1,
    pub Flags: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1 {
    pub Set: __BindgenUnionField<_PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1__bindgen_ty_1>,
    pub Query: __BindgenUnionField<_PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1__bindgen_ty_1 {
    pub DirectoryHandle: HANDLE,
}
#[test]
fn bindgen_test_layout__PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1__bindgen_ty_1>()
               , 8usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1__bindgen_ty_1>()
               , 8usize);
}
impl Clone for _PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1__bindgen_ty_2 {
    pub DriveMap: ULONG,
    pub DriveType: [UCHAR; 32usize],
}
#[test]
fn bindgen_test_layout__PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<_PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1__bindgen_ty_2>()
               , 36usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1__bindgen_ty_2>()
               , 4usize);
}
impl Clone for _PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1>()
               , 40usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1>()
               , 8usize);
}
impl Clone for _PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__PROCESS_DEVICEMAP_INFORMATION_EX() {
    assert_eq!(::core::mem::size_of::<_PROCESS_DEVICEMAP_INFORMATION_EX>() ,
               48usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_DEVICEMAP_INFORMATION_EX>() ,
               8usize);
}
impl Clone for _PROCESS_DEVICEMAP_INFORMATION_EX {
    fn clone(&self) -> Self { *self }
}
pub use self::_PROCESS_DEVICEMAP_INFORMATION_EX as
        PROCESS_DEVICEMAP_INFORMATION_EX;
pub type PPROCESS_DEVICEMAP_INFORMATION_EX =
    *mut _PROCESS_DEVICEMAP_INFORMATION_EX;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_SESSION_INFORMATION {
    pub SessionId: ULONG,
}
#[test]
fn bindgen_test_layout__PROCESS_SESSION_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_PROCESS_SESSION_INFORMATION>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_SESSION_INFORMATION>() ,
               4usize);
}
impl Clone for _PROCESS_SESSION_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_PROCESS_SESSION_INFORMATION as PROCESS_SESSION_INFORMATION;
pub type PPROCESS_SESSION_INFORMATION = *mut _PROCESS_SESSION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_HANDLE_TRACING_ENABLE {
    pub Flags: ULONG,
}
#[test]
fn bindgen_test_layout__PROCESS_HANDLE_TRACING_ENABLE() {
    assert_eq!(::core::mem::size_of::<_PROCESS_HANDLE_TRACING_ENABLE>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_HANDLE_TRACING_ENABLE>() ,
               4usize);
}
impl Clone for _PROCESS_HANDLE_TRACING_ENABLE {
    fn clone(&self) -> Self { *self }
}
pub use self::_PROCESS_HANDLE_TRACING_ENABLE as PROCESS_HANDLE_TRACING_ENABLE;
pub type PPROCESS_HANDLE_TRACING_ENABLE = *mut _PROCESS_HANDLE_TRACING_ENABLE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_HANDLE_TRACING_ENABLE_EX {
    pub Flags: ULONG,
    pub TotalSlots: ULONG,
}
#[test]
fn bindgen_test_layout__PROCESS_HANDLE_TRACING_ENABLE_EX() {
    assert_eq!(::core::mem::size_of::<_PROCESS_HANDLE_TRACING_ENABLE_EX>() ,
               8usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_HANDLE_TRACING_ENABLE_EX>() ,
               4usize);
}
impl Clone for _PROCESS_HANDLE_TRACING_ENABLE_EX {
    fn clone(&self) -> Self { *self }
}
pub use self::_PROCESS_HANDLE_TRACING_ENABLE_EX as
        PROCESS_HANDLE_TRACING_ENABLE_EX;
pub type PPROCESS_HANDLE_TRACING_ENABLE_EX =
    *mut _PROCESS_HANDLE_TRACING_ENABLE_EX;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_HANDLE_TRACING_ENTRY {
    pub Handle: HANDLE,
    pub ClientId: CLIENT_ID,
    pub Type: ULONG,
    pub Stacks: [PVOID; 16usize],
}
#[test]
fn bindgen_test_layout__PROCESS_HANDLE_TRACING_ENTRY() {
    assert_eq!(::core::mem::size_of::<_PROCESS_HANDLE_TRACING_ENTRY>() ,
               160usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_HANDLE_TRACING_ENTRY>() ,
               8usize);
}
impl Clone for _PROCESS_HANDLE_TRACING_ENTRY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PROCESS_HANDLE_TRACING_ENTRY as PROCESS_HANDLE_TRACING_ENTRY;
pub type PPROCESS_HANDLE_TRACING_ENTRY = *mut _PROCESS_HANDLE_TRACING_ENTRY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_HANDLE_TRACING_QUERY {
    pub Handle: HANDLE,
    pub TotalTraces: ULONG,
    pub HandleTrace: [PROCESS_HANDLE_TRACING_ENTRY; 1usize],
}
#[test]
fn bindgen_test_layout__PROCESS_HANDLE_TRACING_QUERY() {
    assert_eq!(::core::mem::size_of::<_PROCESS_HANDLE_TRACING_QUERY>() ,
               176usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_HANDLE_TRACING_QUERY>() ,
               8usize);
}
impl Clone for _PROCESS_HANDLE_TRACING_QUERY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PROCESS_HANDLE_TRACING_QUERY as PROCESS_HANDLE_TRACING_QUERY;
pub type PPROCESS_HANDLE_TRACING_QUERY = *mut _PROCESS_HANDLE_TRACING_QUERY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _QUOTA_LIMITS {
    pub PagedPoolLimit: SIZE_T,
    pub NonPagedPoolLimit: SIZE_T,
    pub MinimumWorkingSetSize: SIZE_T,
    pub MaximumWorkingSetSize: SIZE_T,
    pub PagefileLimit: SIZE_T,
    pub TimeLimit: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__QUOTA_LIMITS() {
    assert_eq!(::core::mem::size_of::<_QUOTA_LIMITS>() , 48usize);
    assert_eq!(::core::mem::align_of::<_QUOTA_LIMITS>() , 8usize);
}
impl Clone for _QUOTA_LIMITS {
    fn clone(&self) -> Self { *self }
}
pub use self::_QUOTA_LIMITS as QUOTA_LIMITS;
pub type PQUOTA_LIMITS = *mut _QUOTA_LIMITS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _RATE_QUOTA_LIMIT {
    pub RateData: __BindgenUnionField<ULONG>,
    pub __bindgen_anon_1: __BindgenUnionField<_RATE_QUOTA_LIMIT__bindgen_ty_1>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _RATE_QUOTA_LIMIT__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__RATE_QUOTA_LIMIT__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_RATE_QUOTA_LIMIT__bindgen_ty_1>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_RATE_QUOTA_LIMIT__bindgen_ty_1>() ,
               4usize);
}
impl Clone for _RATE_QUOTA_LIMIT__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _RATE_QUOTA_LIMIT__bindgen_ty_1 {
    #[inline]
    pub fn RatePercent(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (127usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_RatePercent(&mut self, val: ULONG) {
        self._bitfield_1 &= !(127usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (127usize as u32);
    }
    #[inline]
    pub fn Reserved0(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967168usize as u32)) >> 7u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_Reserved0(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967168usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 7u32) & (4294967168usize as u32);
    }
}
#[test]
fn bindgen_test_layout__RATE_QUOTA_LIMIT() {
    assert_eq!(::core::mem::size_of::<_RATE_QUOTA_LIMIT>() , 4usize);
    assert_eq!(::core::mem::align_of::<_RATE_QUOTA_LIMIT>() , 4usize);
}
impl Clone for _RATE_QUOTA_LIMIT {
    fn clone(&self) -> Self { *self }
}
pub use self::_RATE_QUOTA_LIMIT as RATE_QUOTA_LIMIT;
pub type PRATE_QUOTA_LIMIT = *mut _RATE_QUOTA_LIMIT;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _QUOTA_LIMITS_EX {
    pub PagedPoolLimit: SIZE_T,
    pub NonPagedPoolLimit: SIZE_T,
    pub MinimumWorkingSetSize: SIZE_T,
    pub MaximumWorkingSetSize: SIZE_T,
    pub PagefileLimit: SIZE_T,
    pub TimeLimit: LARGE_INTEGER,
    pub WorkingSetLimit: SIZE_T,
    pub Reserved2: SIZE_T,
    pub Reserved3: SIZE_T,
    pub Reserved4: SIZE_T,
    pub Flags: ULONG,
    pub CpuRateLimit: RATE_QUOTA_LIMIT,
}
#[test]
fn bindgen_test_layout__QUOTA_LIMITS_EX() {
    assert_eq!(::core::mem::size_of::<_QUOTA_LIMITS_EX>() , 88usize);
    assert_eq!(::core::mem::align_of::<_QUOTA_LIMITS_EX>() , 8usize);
}
impl Clone for _QUOTA_LIMITS_EX {
    fn clone(&self) -> Self { *self }
}
pub use self::_QUOTA_LIMITS_EX as QUOTA_LIMITS_EX;
pub type PQUOTA_LIMITS_EX = *mut _QUOTA_LIMITS_EX;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_COUNTERS {
    pub ReadOperationCount: ULONGLONG,
    pub WriteOperationCount: ULONGLONG,
    pub OtherOperationCount: ULONGLONG,
    pub ReadTransferCount: ULONGLONG,
    pub WriteTransferCount: ULONGLONG,
    pub OtherTransferCount: ULONGLONG,
}
#[test]
fn bindgen_test_layout__IO_COUNTERS() {
    assert_eq!(::core::mem::size_of::<_IO_COUNTERS>() , 48usize);
    assert_eq!(::core::mem::align_of::<_IO_COUNTERS>() , 8usize);
}
impl Clone for _IO_COUNTERS {
    fn clone(&self) -> Self { *self }
}
pub use self::_IO_COUNTERS as IO_COUNTERS;
pub type PIO_COUNTERS = *mut IO_COUNTERS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VM_COUNTERS {
    pub PeakVirtualSize: SIZE_T,
    pub VirtualSize: SIZE_T,
    pub PageFaultCount: ULONG,
    pub PeakWorkingSetSize: SIZE_T,
    pub WorkingSetSize: SIZE_T,
    pub QuotaPeakPagedPoolUsage: SIZE_T,
    pub QuotaPagedPoolUsage: SIZE_T,
    pub QuotaPeakNonPagedPoolUsage: SIZE_T,
    pub QuotaNonPagedPoolUsage: SIZE_T,
    pub PagefileUsage: SIZE_T,
    pub PeakPagefileUsage: SIZE_T,
}
#[test]
fn bindgen_test_layout__VM_COUNTERS() {
    assert_eq!(::core::mem::size_of::<_VM_COUNTERS>() , 88usize);
    assert_eq!(::core::mem::align_of::<_VM_COUNTERS>() , 8usize);
}
impl Clone for _VM_COUNTERS {
    fn clone(&self) -> Self { *self }
}
pub use self::_VM_COUNTERS as VM_COUNTERS;
pub type PVM_COUNTERS = *mut VM_COUNTERS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VM_COUNTERS_EX {
    pub PeakVirtualSize: SIZE_T,
    pub VirtualSize: SIZE_T,
    pub PageFaultCount: ULONG,
    pub PeakWorkingSetSize: SIZE_T,
    pub WorkingSetSize: SIZE_T,
    pub QuotaPeakPagedPoolUsage: SIZE_T,
    pub QuotaPagedPoolUsage: SIZE_T,
    pub QuotaPeakNonPagedPoolUsage: SIZE_T,
    pub QuotaNonPagedPoolUsage: SIZE_T,
    pub PagefileUsage: SIZE_T,
    pub PeakPagefileUsage: SIZE_T,
    pub PrivateUsage: SIZE_T,
}
#[test]
fn bindgen_test_layout__VM_COUNTERS_EX() {
    assert_eq!(::core::mem::size_of::<_VM_COUNTERS_EX>() , 96usize);
    assert_eq!(::core::mem::align_of::<_VM_COUNTERS_EX>() , 8usize);
}
impl Clone for _VM_COUNTERS_EX {
    fn clone(&self) -> Self { *self }
}
pub use self::_VM_COUNTERS_EX as VM_COUNTERS_EX;
pub type PVM_COUNTERS_EX = *mut VM_COUNTERS_EX;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VM_COUNTERS_EX2 {
    pub CountersEx: VM_COUNTERS_EX,
    pub PrivateWorkingSetSize: SIZE_T,
    pub SharedCommitUsage: ULONGLONG,
}
#[test]
fn bindgen_test_layout__VM_COUNTERS_EX2() {
    assert_eq!(::core::mem::size_of::<_VM_COUNTERS_EX2>() , 112usize);
    assert_eq!(::core::mem::align_of::<_VM_COUNTERS_EX2>() , 8usize);
}
impl Clone for _VM_COUNTERS_EX2 {
    fn clone(&self) -> Self { *self }
}
pub use self::_VM_COUNTERS_EX2 as VM_COUNTERS_EX2;
pub type PVM_COUNTERS_EX2 = *mut _VM_COUNTERS_EX2;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _HARDWARE_COUNTER_TYPE {
    PMCCounter = 0,
    MaxHardwareCounterType = 1,
}
pub use self::_HARDWARE_COUNTER_TYPE as HARDWARE_COUNTER_TYPE;
pub type PHARDWARE_COUNTER_TYPE = *mut _HARDWARE_COUNTER_TYPE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _HARDWARE_COUNTER {
    pub Type: HARDWARE_COUNTER_TYPE,
    pub Reserved: ULONG,
    pub Index: ULONG64,
}
#[test]
fn bindgen_test_layout__HARDWARE_COUNTER() {
    assert_eq!(::core::mem::size_of::<_HARDWARE_COUNTER>() , 16usize);
    assert_eq!(::core::mem::align_of::<_HARDWARE_COUNTER>() , 8usize);
}
impl Clone for _HARDWARE_COUNTER {
    fn clone(&self) -> Self { *self }
}
pub use self::_HARDWARE_COUNTER as HARDWARE_COUNTER;
pub type PHARDWARE_COUNTER = *mut _HARDWARE_COUNTER;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _PROCESS_MITIGATION_POLICY {
    ProcessDEPPolicy = 0,
    ProcessASLRPolicy = 1,
    ProcessDynamicCodePolicy = 2,
    ProcessStrictHandleCheckPolicy = 3,
    ProcessSystemCallDisablePolicy = 4,
    ProcessMitigationOptionsMask = 5,
    ProcessExtensionPointDisablePolicy = 6,
    ProcessControlFlowGuardPolicy = 7,
    ProcessSignaturePolicy = 8,
    ProcessFontDisablePolicy = 9,
    ProcessImageLoadPolicy = 10,
    MaxProcessMitigationPolicy = 11,
}
pub use self::_PROCESS_MITIGATION_POLICY as PROCESS_MITIGATION_POLICY;
pub type PPROCESS_MITIGATION_POLICY = *mut _PROCESS_MITIGATION_POLICY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_MITIGATION_ASLR_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1 {
    pub Flags: __BindgenUnionField<ULONG>,
    pub __bindgen_anon_1: __BindgenUnionField<_PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn EnableBottomUpRandomization(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_EnableBottomUpRandomization(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn EnableForceRelocateImages(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_EnableForceRelocateImages(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn EnableHighEntropy(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                        2u32) as u32)
        }
    }
    #[inline]
    pub fn set_EnableHighEntropy(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn DisallowStrippedImages(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u32)) >>
                                        3u32) as u32)
        }
    }
    #[inline]
    pub fn set_DisallowStrippedImages(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (8usize as u32);
    }
    #[inline]
    pub fn ReservedFlags(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967280usize as u32)) >> 4u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967280usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 4u32) & (4294967280usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_ASLR_POLICY() {
    assert_eq!(::core::mem::size_of::<_PROCESS_MITIGATION_ASLR_POLICY>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_MITIGATION_ASLR_POLICY>() ,
               4usize);
}
impl Clone for _PROCESS_MITIGATION_ASLR_POLICY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PROCESS_MITIGATION_ASLR_POLICY as
        PROCESS_MITIGATION_ASLR_POLICY;
pub type PPROCESS_MITIGATION_ASLR_POLICY =
    *mut _PROCESS_MITIGATION_ASLR_POLICY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_MITIGATION_DEP_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1,
    pub Permanent: BOOLEAN,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1 {
    pub Flags: __BindgenUnionField<ULONG>,
    pub __bindgen_anon_1: __BindgenUnionField<_PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Enable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_Enable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn DisableAtlThunkEmulation(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_DisableAtlThunkEmulation(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn ReservedFlags(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967292usize as u32)) >> 2u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967292usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 2u32) & (4294967292usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_DEP_POLICY() {
    assert_eq!(::core::mem::size_of::<_PROCESS_MITIGATION_DEP_POLICY>() ,
               8usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_MITIGATION_DEP_POLICY>() ,
               4usize);
}
impl Clone for _PROCESS_MITIGATION_DEP_POLICY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PROCESS_MITIGATION_DEP_POLICY as PROCESS_MITIGATION_DEP_POLICY;
pub type PPROCESS_MITIGATION_DEP_POLICY = *mut _PROCESS_MITIGATION_DEP_POLICY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1 {
    pub Flags: __BindgenUnionField<ULONG>,
    pub __bindgen_anon_1: __BindgenUnionField<_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for
 _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1
 {
    #[inline]
    pub fn RaiseExceptionOnInvalidHandleReference(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_RaiseExceptionOnInvalidHandleReference(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn HandleExceptionsPermanentlyEnabled(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_HandleExceptionsPermanentlyEnabled(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn ReservedFlags(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967292usize as u32)) >> 2u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967292usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 2u32) & (4294967292usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY() {
    assert_eq!(::core::mem::size_of::<_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY>()
               , 4usize);
}
impl Clone for _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY as
        PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY;
pub type PPROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY =
    *mut _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1 {
    pub Flags: __BindgenUnionField<ULONG>,
    pub __bindgen_anon_1: __BindgenUnionField<_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for
 _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1
 {
    #[inline]
    pub fn DisallowWin32kSystemCalls(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_DisallowWin32kSystemCalls(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn ReservedFlags(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967294usize as u32)) >> 1u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967294usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 1u32) & (4294967294usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY() {
    assert_eq!(::core::mem::size_of::<_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY>()
               , 4usize);
}
impl Clone for _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY as
        PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY;
pub type PPROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY =
    *mut _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1 {
    pub Flags: __BindgenUnionField<ULONG>,
    pub __bindgen_anon_1: __BindgenUnionField<_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for
 _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1
 {
    fn clone(&self) -> Self { *self }
}
impl _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1
 {
    #[inline]
    pub fn DisableExtensionPoints(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_DisableExtensionPoints(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn ReservedFlags(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967294usize as u32)) >> 1u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967294usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 1u32) & (4294967294usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1>()
               , 4usize);
}
impl Clone for
 _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY() {
    assert_eq!(::core::mem::size_of::<_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY>()
               , 4usize);
}
impl Clone for _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY as
        PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY;
pub type PPROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY =
    *mut _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1 {
    pub Flags: __BindgenUnionField<ULONG>,
    pub __bindgen_anon_1: __BindgenUnionField<_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for
 _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn ProhibitDynamicCode(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_ProhibitDynamicCode(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn AllowThreadOptOut(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_AllowThreadOptOut(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn ReservedFlags(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967292usize as u32)) >> 2u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967292usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 2u32) & (4294967292usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_DYNAMIC_CODE_POLICY() {
    assert_eq!(::core::mem::size_of::<_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY>()
               , 4usize);
}
impl Clone for _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY as
        PROCESS_MITIGATION_DYNAMIC_CODE_POLICY;
pub type PPROCESS_MITIGATION_DYNAMIC_CODE_POLICY =
    *mut _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1 {
    pub Flags: __BindgenUnionField<ULONG>,
    pub __bindgen_anon_1: __BindgenUnionField<_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for
 _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1
 {
    #[inline]
    pub fn EnableControlFlowGuard(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_EnableControlFlowGuard(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn ReservedFlags(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967294usize as u32)) >> 1u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967294usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 1u32) & (4294967294usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY() {
    assert_eq!(::core::mem::size_of::<_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY>()
               , 4usize);
}
impl Clone for _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY as
        PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY;
pub type PPROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY =
    *mut _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1 {
    pub Flags: __BindgenUnionField<ULONG>,
    pub __bindgen_anon_1: __BindgenUnionField<_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for
 _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn MicrosoftSignedOnly(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_MicrosoftSignedOnly(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn StoreSignedOnly(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_StoreSignedOnly(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn MitigationOptIn(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                        2u32) as u32)
        }
    }
    #[inline]
    pub fn set_MitigationOptIn(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn ReservedFlags(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967288usize as u32)) >> 3u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967288usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 3u32) & (4294967288usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY() {
    assert_eq!(::core::mem::size_of::<_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY>()
               , 4usize);
}
impl Clone for _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY as
        PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY;
pub type PPROCESS_MITIGATION_BINARY_SIGNATURE_POLICY =
    *mut _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_MITIGATION_FONT_DISABLE_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1 {
    pub Flags: __BindgenUnionField<ULONG>,
    pub __bindgen_anon_1: __BindgenUnionField<_PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for
 _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn DisableNonSystemFonts(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_DisableNonSystemFonts(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn AuditNonSystemFontLoading(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_AuditNonSystemFontLoading(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn ReservedFlags(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967292usize as u32)) >> 2u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967292usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 2u32) & (4294967292usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_FONT_DISABLE_POLICY() {
    assert_eq!(::core::mem::size_of::<_PROCESS_MITIGATION_FONT_DISABLE_POLICY>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_MITIGATION_FONT_DISABLE_POLICY>()
               , 4usize);
}
impl Clone for _PROCESS_MITIGATION_FONT_DISABLE_POLICY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PROCESS_MITIGATION_FONT_DISABLE_POLICY as
        PROCESS_MITIGATION_FONT_DISABLE_POLICY;
pub type PPROCESS_MITIGATION_FONT_DISABLE_POLICY =
    *mut _PROCESS_MITIGATION_FONT_DISABLE_POLICY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_MITIGATION_IMAGE_LOAD_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1 {
    pub Flags: __BindgenUnionField<ULONG>,
    pub __bindgen_anon_1: __BindgenUnionField<_PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for
 _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn NoRemoteImages(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_NoRemoteImages(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn NoLowMandatoryLabelImages(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_NoLowMandatoryLabelImages(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn PreferSystem32Images(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                        2u32) as u32)
        }
    }
    #[inline]
    pub fn set_PreferSystem32Images(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn ReservedFlags(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967288usize as u32)) >> 3u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967288usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 3u32) & (4294967288usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_IMAGE_LOAD_POLICY() {
    assert_eq!(::core::mem::size_of::<_PROCESS_MITIGATION_IMAGE_LOAD_POLICY>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_MITIGATION_IMAGE_LOAD_POLICY>()
               , 4usize);
}
impl Clone for _PROCESS_MITIGATION_IMAGE_LOAD_POLICY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PROCESS_MITIGATION_IMAGE_LOAD_POLICY as
        PROCESS_MITIGATION_IMAGE_LOAD_POLICY;
pub type PPROCESS_MITIGATION_IMAGE_LOAD_POLICY =
    *mut _PROCESS_MITIGATION_IMAGE_LOAD_POLICY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_KEEPALIVE_COUNT_INFORMATION {
    pub WakeCount: ULONG,
    pub NoWakeCount: ULONG,
}
#[test]
fn bindgen_test_layout__PROCESS_KEEPALIVE_COUNT_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_PROCESS_KEEPALIVE_COUNT_INFORMATION>()
               , 8usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_KEEPALIVE_COUNT_INFORMATION>()
               , 4usize);
}
impl Clone for _PROCESS_KEEPALIVE_COUNT_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_PROCESS_KEEPALIVE_COUNT_INFORMATION as
        PROCESS_KEEPALIVE_COUNT_INFORMATION;
pub type PPROCESS_KEEPALIVE_COUNT_INFORMATION =
    *mut _PROCESS_KEEPALIVE_COUNT_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_REVOKE_FILE_HANDLES_INFORMATION {
    pub TargetDevicePath: UNICODE_STRING,
}
#[test]
fn bindgen_test_layout__PROCESS_REVOKE_FILE_HANDLES_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_PROCESS_REVOKE_FILE_HANDLES_INFORMATION>()
               , 16usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_REVOKE_FILE_HANDLES_INFORMATION>()
               , 8usize);
}
impl Clone for _PROCESS_REVOKE_FILE_HANDLES_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_PROCESS_REVOKE_FILE_HANDLES_INFORMATION as
        PROCESS_REVOKE_FILE_HANDLES_INFORMATION;
pub type PPROCESS_REVOKE_FILE_HANDLES_INFORMATION =
    *mut _PROCESS_REVOKE_FILE_HANDLES_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _POOLED_USAGE_AND_LIMITS {
    pub PeakPagedPoolUsage: SIZE_T,
    pub PagedPoolUsage: SIZE_T,
    pub PagedPoolLimit: SIZE_T,
    pub PeakNonPagedPoolUsage: SIZE_T,
    pub NonPagedPoolUsage: SIZE_T,
    pub NonPagedPoolLimit: SIZE_T,
    pub PeakPagefileUsage: SIZE_T,
    pub PagefileUsage: SIZE_T,
    pub PagefileLimit: SIZE_T,
}
#[test]
fn bindgen_test_layout__POOLED_USAGE_AND_LIMITS() {
    assert_eq!(::core::mem::size_of::<_POOLED_USAGE_AND_LIMITS>() , 72usize);
    assert_eq!(::core::mem::align_of::<_POOLED_USAGE_AND_LIMITS>() , 8usize);
}
impl Clone for _POOLED_USAGE_AND_LIMITS {
    fn clone(&self) -> Self { *self }
}
pub use self::_POOLED_USAGE_AND_LIMITS as POOLED_USAGE_AND_LIMITS;
pub type PPOOLED_USAGE_AND_LIMITS = *mut POOLED_USAGE_AND_LIMITS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_ACCESS_TOKEN {
    pub Token: HANDLE,
    pub Thread: HANDLE,
}
#[test]
fn bindgen_test_layout__PROCESS_ACCESS_TOKEN() {
    assert_eq!(::core::mem::size_of::<_PROCESS_ACCESS_TOKEN>() , 16usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_ACCESS_TOKEN>() , 8usize);
}
impl Clone for _PROCESS_ACCESS_TOKEN {
    fn clone(&self) -> Self { *self }
}
pub use self::_PROCESS_ACCESS_TOKEN as PROCESS_ACCESS_TOKEN;
pub type PPROCESS_ACCESS_TOKEN = *mut _PROCESS_ACCESS_TOKEN;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PROCESS_EXCEPTION_PORT {
    pub ExceptionPortHandle: HANDLE,
    pub StateFlags: ULONG,
}
#[test]
fn bindgen_test_layout__PROCESS_EXCEPTION_PORT() {
    assert_eq!(::core::mem::size_of::<_PROCESS_EXCEPTION_PORT>() , 16usize);
    assert_eq!(::core::mem::align_of::<_PROCESS_EXCEPTION_PORT>() , 8usize);
}
impl Clone for _PROCESS_EXCEPTION_PORT {
    fn clone(&self) -> Self { *self }
}
pub use self::_PROCESS_EXCEPTION_PORT as PROCESS_EXCEPTION_PORT;
pub type PPROCESS_EXCEPTION_PORT = *mut _PROCESS_EXCEPTION_PORT;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KERNEL_USER_TIMES {
    pub CreateTime: LARGE_INTEGER,
    pub ExitTime: LARGE_INTEGER,
    pub KernelTime: LARGE_INTEGER,
    pub UserTime: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__KERNEL_USER_TIMES() {
    assert_eq!(::core::mem::size_of::<_KERNEL_USER_TIMES>() , 32usize);
    assert_eq!(::core::mem::align_of::<_KERNEL_USER_TIMES>() , 8usize);
}
impl Clone for _KERNEL_USER_TIMES {
    fn clone(&self) -> Self { *self }
}
pub use self::_KERNEL_USER_TIMES as KERNEL_USER_TIMES;
pub type PKERNEL_USER_TIMES = *mut KERNEL_USER_TIMES;
extern "C" {
    pub fn NtOpenProcess(ProcessHandle: PHANDLE, DesiredAccess: ACCESS_MASK,
                         ObjectAttributes: POBJECT_ATTRIBUTES,
                         ClientId: PCLIENT_ID) -> NTSTATUS;
}
extern "C" {
    pub fn KeRaiseIrqlToSynchLevel() -> KIRQL;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KPCR {
    pub __bindgen_anon_1: _KPCR__bindgen_ty_1,
    pub SelfPcr: *mut _KPCR,
    pub Prcb: *mut _KPCR__KPRCB,
    pub Irql: KIRQL,
    pub IRR: ULONG,
    pub IrrActive: ULONG,
    pub IDR: ULONG,
    pub KdVersionBlock: PVOID,
    pub IDT: *mut _KPCR__KIDTENTRY,
    pub GDT: *mut _KPCR__KGDTENTRY,
    pub TSS: *mut _KPCR__KTSS,
    pub MajorVersion: USHORT,
    pub MinorVersion: USHORT,
    pub SetMember: KAFFINITY,
    pub StallScaleFactor: ULONG,
    pub SpareUnused: UCHAR,
    pub Number: UCHAR,
    pub Spare0: UCHAR,
    pub SecondLevelCacheAssociativity: UCHAR,
    pub VdmAlert: ULONG,
    pub KernelReserved: [ULONG; 14usize],
    pub SecondLevelCacheSize: ULONG,
    pub HalReserved: [ULONG; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KPCR__bindgen_ty_1 {
    pub NtTib: __BindgenUnionField<NT_TIB>,
    pub __bindgen_anon_1: __BindgenUnionField<_KPCR__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: [u64; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KPCR__bindgen_ty_1__bindgen_ty_1 {
    pub Used_ExceptionList: *mut _EXCEPTION_REGISTRATION_RECORD,
    pub Used_StackBase: PVOID,
    pub MxCsr: ULONG,
    pub TssCopy: PVOID,
    pub ContextSwitches: ULONG,
    pub SetMemberCopy: KAFFINITY,
    pub Used_Self: PVOID,
}
#[test]
fn bindgen_test_layout__KPCR__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_KPCR__bindgen_ty_1__bindgen_ty_1>() ,
               56usize);
    assert_eq!(::core::mem::align_of::<_KPCR__bindgen_ty_1__bindgen_ty_1>() ,
               8usize);
}
impl Clone for _KPCR__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__KPCR__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_KPCR__bindgen_ty_1>() , 56usize);
    assert_eq!(::core::mem::align_of::<_KPCR__bindgen_ty_1>() , 8usize);
}
impl Clone for _KPCR__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KPCR__KPRCB {
    pub _address: u8,
}
impl Clone for _KPCR__KPRCB {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KPCR__KIDTENTRY {
    pub _address: u8,
}
impl Clone for _KPCR__KIDTENTRY {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KPCR__KGDTENTRY {
    pub _address: u8,
}
impl Clone for _KPCR__KGDTENTRY {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KPCR__KTSS {
    pub _address: u8,
}
impl Clone for _KPCR__KTSS {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__KPCR() {
    assert_eq!(::core::mem::size_of::<_KPCR>() , 272usize);
    assert_eq!(::core::mem::align_of::<_KPCR>() , 8usize);
}
impl Clone for _KPCR {
    fn clone(&self) -> Self { *self }
}
pub use self::_KPCR as KPCR;
pub type PKPCR = *mut _KPCR;
extern "C" {
    #[link_name = "MmHighestUserAddress"]
    pub static mut MmHighestUserAddress: PVOID;
}
extern "C" {
    #[link_name = "MmSystemRangeStart"]
    pub static mut MmSystemRangeStart: PVOID;
}
extern "C" {
    #[link_name = "MmUserProbeAddress"]
    pub static mut MmUserProbeAddress: ULONG;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _INTERLOCKED_RESULT {
    ResultNegative = 32768,
    ResultZero = 16384,
    ResultPositive = 0,
}
pub use self::_INTERLOCKED_RESULT as INTERLOCKED_RESULT;
extern "C" {
    pub fn Exfi386InterlockedIncrementLong(Addend: *mut LONG)
     -> INTERLOCKED_RESULT;
}
extern "C" {
    pub fn Exfi386InterlockedDecrementLong(Addend: *mut LONG)
     -> INTERLOCKED_RESULT;
}
extern "C" {
    pub fn Exfi386InterlockedExchangeUlong(Target: *mut ULONG, Value: ULONG)
     -> ULONG;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _SYSTEM_FIRMWARE_TABLE_ACTION {
    SystemFirmwareTable_Enumerate = 0,
    SystemFirmwareTable_Get = 1,
}
pub use self::_SYSTEM_FIRMWARE_TABLE_ACTION as SYSTEM_FIRMWARE_TABLE_ACTION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SYSTEM_FIRMWARE_TABLE_INFORMATION {
    pub ProviderSignature: ULONG,
    pub Action: SYSTEM_FIRMWARE_TABLE_ACTION,
    pub TableID: ULONG,
    pub TableBufferLength: ULONG,
    pub TableBuffer: [UCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__SYSTEM_FIRMWARE_TABLE_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_SYSTEM_FIRMWARE_TABLE_INFORMATION>() ,
               20usize);
    assert_eq!(::core::mem::align_of::<_SYSTEM_FIRMWARE_TABLE_INFORMATION>() ,
               4usize);
}
impl Clone for _SYSTEM_FIRMWARE_TABLE_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_SYSTEM_FIRMWARE_TABLE_INFORMATION as
        SYSTEM_FIRMWARE_TABLE_INFORMATION;
pub type PSYSTEM_FIRMWARE_TABLE_INFORMATION =
    *mut _SYSTEM_FIRMWARE_TABLE_INFORMATION;
pub type PFNFTH =
    ::core::option::Option<unsafe extern "C" fn(SystemFirmwareTableInfo:
                                                    PSYSTEM_FIRMWARE_TABLE_INFORMATION)
                               -> libc::c_long>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SYSTEM_FIRMWARE_TABLE_HANDLER {
    pub ProviderSignature: ULONG,
    pub Register: BOOLEAN,
    pub FirmwareTableHandler: PFNFTH,
    pub DriverObject: PVOID,
}
#[test]
fn bindgen_test_layout__SYSTEM_FIRMWARE_TABLE_HANDLER() {
    assert_eq!(::core::mem::size_of::<_SYSTEM_FIRMWARE_TABLE_HANDLER>() ,
               24usize);
    assert_eq!(::core::mem::align_of::<_SYSTEM_FIRMWARE_TABLE_HANDLER>() ,
               8usize);
}
impl Clone for _SYSTEM_FIRMWARE_TABLE_HANDLER {
    fn clone(&self) -> Self { *self }
}
pub use self::_SYSTEM_FIRMWARE_TABLE_HANDLER as SYSTEM_FIRMWARE_TABLE_HANDLER;
pub type PSYSTEM_FIRMWARE_TABLE_HANDLER = *mut _SYSTEM_FIRMWARE_TABLE_HANDLER;
pub type PTIMER_APC_ROUTINE =
    ::core::option::Option<unsafe extern "C" fn(TimerContext: PVOID,
                                                TimerLowValue: ULONG,
                                                TimerHighValue: LONG)>;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _TIMER_SET_INFORMATION_CLASS {
    TimerSetCoalescableTimer = 0,
    MaxTimerInfoClass = 1,
}
pub use self::_TIMER_SET_INFORMATION_CLASS as TIMER_SET_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _TIMER_SET_COALESCABLE_TIMER_INFO {
    pub DueTime: LARGE_INTEGER,
    pub TimerApcRoutine: PTIMER_APC_ROUTINE,
    pub TimerContext: PVOID,
    pub WakeContext: *mut _COUNTED_REASON_CONTEXT,
    pub Period: ULONG,
    pub TolerableDelay: ULONG,
    pub PreviousState: PBOOLEAN,
}
#[test]
fn bindgen_test_layout__TIMER_SET_COALESCABLE_TIMER_INFO() {
    assert_eq!(::core::mem::size_of::<_TIMER_SET_COALESCABLE_TIMER_INFO>() ,
               48usize);
    assert_eq!(::core::mem::align_of::<_TIMER_SET_COALESCABLE_TIMER_INFO>() ,
               8usize);
}
impl Clone for _TIMER_SET_COALESCABLE_TIMER_INFO {
    fn clone(&self) -> Self { *self }
}
pub use self::_TIMER_SET_COALESCABLE_TIMER_INFO as
        TIMER_SET_COALESCABLE_TIMER_INFO;
pub type PTIMER_SET_COALESCABLE_TIMER_INFO =
    *mut _TIMER_SET_COALESCABLE_TIMER_INFO;
pub type PDRIVER_VERIFIER_THUNK_ROUTINE =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID)
                               -> libc::c_ulonglong>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DRIVER_VERIFIER_THUNK_PAIRS {
    pub PristineRoutine: PDRIVER_VERIFIER_THUNK_ROUTINE,
    pub NewRoutine: PDRIVER_VERIFIER_THUNK_ROUTINE,
}
#[test]
fn bindgen_test_layout__DRIVER_VERIFIER_THUNK_PAIRS() {
    assert_eq!(::core::mem::size_of::<_DRIVER_VERIFIER_THUNK_PAIRS>() ,
               16usize);
    assert_eq!(::core::mem::align_of::<_DRIVER_VERIFIER_THUNK_PAIRS>() ,
               8usize);
}
impl Clone for _DRIVER_VERIFIER_THUNK_PAIRS {
    fn clone(&self) -> Self { *self }
}
pub use self::_DRIVER_VERIFIER_THUNK_PAIRS as DRIVER_VERIFIER_THUNK_PAIRS;
pub type PDRIVER_VERIFIER_THUNK_PAIRS = *mut _DRIVER_VERIFIER_THUNK_PAIRS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _XSTATE_FEATURE {
    pub Offset: ULONG,
    pub Size: ULONG,
}
#[test]
fn bindgen_test_layout__XSTATE_FEATURE() {
    assert_eq!(::core::mem::size_of::<_XSTATE_FEATURE>() , 8usize);
    assert_eq!(::core::mem::align_of::<_XSTATE_FEATURE>() , 4usize);
}
impl Clone for _XSTATE_FEATURE {
    fn clone(&self) -> Self { *self }
}
pub use self::_XSTATE_FEATURE as XSTATE_FEATURE;
pub type PXSTATE_FEATURE = *mut _XSTATE_FEATURE;
#[repr(C)]
pub struct _XSTATE_CONFIGURATION {
    pub EnabledFeatures: ULONG64,
    pub EnabledVolatileFeatures: ULONG64,
    pub Size: ULONG,
    pub __bindgen_anon_1: _XSTATE_CONFIGURATION__bindgen_ty_1,
    pub Features: [XSTATE_FEATURE; 64usize],
    pub EnabledSupervisorFeatures: ULONG64,
    pub AlignedFeatures: ULONG64,
    pub AllFeatureSize: ULONG,
    pub AllFeatures: [ULONG; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _XSTATE_CONFIGURATION__bindgen_ty_1 {
    pub ControlFlags: __BindgenUnionField<ULONG>,
    pub __bindgen_anon_1: __BindgenUnionField<_XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u8,
}
#[test]
fn bindgen_test_layout__XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn OptimizedSave(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_OptimizedSave(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 0u32) & (1usize as u8);
    }
    #[inline]
    pub fn CompactionEnabled(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u8)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_CompactionEnabled(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 1u32) & (2usize as u8);
    }
}
#[test]
fn bindgen_test_layout__XSTATE_CONFIGURATION__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_XSTATE_CONFIGURATION__bindgen_ty_1>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_XSTATE_CONFIGURATION__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _XSTATE_CONFIGURATION__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__XSTATE_CONFIGURATION() {
    assert_eq!(::core::mem::size_of::<_XSTATE_CONFIGURATION>() , 816usize);
    assert_eq!(::core::mem::align_of::<_XSTATE_CONFIGURATION>() , 8usize);
}
pub use self::_XSTATE_CONFIGURATION as XSTATE_CONFIGURATION;
pub type PXSTATE_CONFIGURATION = *mut _XSTATE_CONFIGURATION;
#[repr(C)]
pub struct _KUSER_SHARED_DATA {
    pub TickCountLowDeprecated: ULONG,
    pub TickCountMultiplier: ULONG,
    pub InterruptTime: KSYSTEM_TIME,
    pub SystemTime: KSYSTEM_TIME,
    pub TimeZoneBias: KSYSTEM_TIME,
    pub ImageNumberLow: USHORT,
    pub ImageNumberHigh: USHORT,
    pub NtSystemRoot: [WCHAR; 260usize],
    pub MaxStackTraceDepth: ULONG,
    pub CryptoExponent: ULONG,
    pub TimeZoneId: ULONG,
    pub LargePageMinimum: ULONG,
    pub AitSamplingValue: ULONG,
    pub AppCompatFlag: ULONG,
    pub RNGSeedVersion: ULONGLONG,
    pub GlobalValidationRunlevel: ULONG,
    pub TimeZoneBiasStamp: LONG,
    pub NtBuildNumber: ULONG,
    pub NtProductType: NT_PRODUCT_TYPE,
    pub ProductTypeIsValid: BOOLEAN,
    pub Reserved0: [BOOLEAN; 1usize],
    pub NativeProcessorArchitecture: USHORT,
    pub NtMajorVersion: ULONG,
    pub NtMinorVersion: ULONG,
    pub ProcessorFeatures: [BOOLEAN; 64usize],
    pub Reserved1: ULONG,
    pub Reserved3: ULONG,
    pub TimeSlip: ULONG,
    pub AlternativeArchitecture: ALTERNATIVE_ARCHITECTURE_TYPE,
    pub BootId: ULONG,
    pub SystemExpirationDate: LARGE_INTEGER,
    pub SuiteMask: ULONG,
    pub KdDebuggerEnabled: BOOLEAN,
    pub __bindgen_anon_1: _KUSER_SHARED_DATA__bindgen_ty_1,
    pub Reserved6: [UCHAR; 2usize],
    pub ActiveConsoleId: ULONG,
    pub DismountCount: ULONG,
    pub ComPlusPackage: ULONG,
    pub LastSystemRITEventTickCount: ULONG,
    pub NumberOfPhysicalPages: ULONG,
    pub SafeBootMode: BOOLEAN,
    pub VirtualizationFlags: UCHAR,
    pub Reserved12: [UCHAR; 2usize],
    pub __bindgen_anon_2: _KUSER_SHARED_DATA__bindgen_ty_2,
    pub DataFlagsPad: [ULONG; 1usize],
    pub TestRetInstruction: ULONGLONG,
    pub QpcFrequency: LONGLONG,
    pub SystemCall: ULONG,
    pub SystemCallPad0: ULONG,
    pub SystemCallPad: [ULONGLONG; 2usize],
    pub __bindgen_anon_3: _KUSER_SHARED_DATA__bindgen_ty_3,
    pub Cookie: ULONG,
    pub CookiePad: [ULONG; 1usize],
    pub ConsoleSessionForegroundProcessId: LONGLONG,
    pub TimeUpdateLock: ULONGLONG,
    pub BaselineSystemTimeQpc: ULONGLONG,
    pub BaselineInterruptTimeQpc: ULONGLONG,
    pub QpcSystemTimeIncrement: ULONGLONG,
    pub QpcInterruptTimeIncrement: ULONGLONG,
    pub QpcSystemTimeIncrementShift: UCHAR,
    pub QpcInterruptTimeIncrementShift: UCHAR,
    pub UnparkedProcessorCount: USHORT,
    pub EnclaveFeatureMask: [ULONG; 4usize],
    pub Reserved8: ULONG,
    pub UserModeGlobalLogger: [USHORT; 16usize],
    pub ImageFileExecutionOptions: ULONG,
    pub LangGenerationCount: ULONG,
    pub Reserved4: ULONGLONG,
    pub InterruptTimeBias: ULONGLONG,
    pub QpcBias: ULONGLONG,
    pub ActiveProcessorCount: ULONG,
    pub ActiveGroupCount: UCHAR,
    pub Reserved9: UCHAR,
    pub __bindgen_anon_4: _KUSER_SHARED_DATA__bindgen_ty_4,
    pub TimeZoneBiasEffectiveStart: LARGE_INTEGER,
    pub TimeZoneBiasEffectiveEnd: LARGE_INTEGER,
    pub XState: XSTATE_CONFIGURATION,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KUSER_SHARED_DATA__bindgen_ty_1 {
    pub MitigationPolicies: __BindgenUnionField<UCHAR>,
    pub __bindgen_anon_1: __BindgenUnionField<_KUSER_SHARED_DATA__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KUSER_SHARED_DATA__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u8,
}
#[test]
fn bindgen_test_layout__KUSER_SHARED_DATA__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_KUSER_SHARED_DATA__bindgen_ty_1__bindgen_ty_1>()
               , 1usize);
    assert_eq!(::core::mem::align_of::<_KUSER_SHARED_DATA__bindgen_ty_1__bindgen_ty_1>()
               , 1usize);
}
impl Clone for _KUSER_SHARED_DATA__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _KUSER_SHARED_DATA__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn NXSupportPolicy(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (3usize as u8)) >>
                                        0u32) as u8)
        }
    }
    #[inline]
    pub fn set_NXSupportPolicy(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(3usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 0u32) & (3usize as u8);
    }
    #[inline]
    pub fn SEHValidationPolicy(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (12usize as u8)) >>
                                        2u32) as u8)
        }
    }
    #[inline]
    pub fn set_SEHValidationPolicy(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(12usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 2u32) & (12usize as u8);
    }
    #[inline]
    pub fn CurDirDevicesSkippedForDlls(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (48usize as u8)) >>
                                        4u32) as u8)
        }
    }
    #[inline]
    pub fn set_CurDirDevicesSkippedForDlls(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(48usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 4u32) & (48usize as u8);
    }
    #[inline]
    pub fn Reserved(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (192usize as u8)) >>
                                        6u32) as u8)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(192usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 6u32) & (192usize as u8);
    }
}
#[test]
fn bindgen_test_layout__KUSER_SHARED_DATA__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_KUSER_SHARED_DATA__bindgen_ty_1>() ,
               1usize);
    assert_eq!(::core::mem::align_of::<_KUSER_SHARED_DATA__bindgen_ty_1>() ,
               1usize);
}
impl Clone for _KUSER_SHARED_DATA__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KUSER_SHARED_DATA__bindgen_ty_2 {
    pub SharedDataFlags: __BindgenUnionField<ULONG>,
    pub __bindgen_anon_1: __BindgenUnionField<_KUSER_SHARED_DATA__bindgen_ty_2__bindgen_ty_1>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KUSER_SHARED_DATA__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__KUSER_SHARED_DATA__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_KUSER_SHARED_DATA__bindgen_ty_2__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_KUSER_SHARED_DATA__bindgen_ty_2__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _KUSER_SHARED_DATA__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _KUSER_SHARED_DATA__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn DbgErrorPortPresent(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_DbgErrorPortPresent(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn DbgElevationEnabled(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_DbgElevationEnabled(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn DbgVirtEnabled(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                        2u32) as u32)
        }
    }
    #[inline]
    pub fn set_DbgVirtEnabled(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn DbgInstallerDetectEnabled(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u32)) >>
                                        3u32) as u32)
        }
    }
    #[inline]
    pub fn set_DbgInstallerDetectEnabled(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (8usize as u32);
    }
    #[inline]
    pub fn DbgLkgEnabled(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u32)) >>
                                        4u32) as u32)
        }
    }
    #[inline]
    pub fn set_DbgLkgEnabled(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (16usize as u32);
    }
    #[inline]
    pub fn DbgDynProcessorEnabled(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u32)) >>
                                        5u32) as u32)
        }
    }
    #[inline]
    pub fn set_DbgDynProcessorEnabled(&mut self, val: ULONG) {
        self._bitfield_1 &= !(32usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (32usize as u32);
    }
    #[inline]
    pub fn DbgConsoleBrokerEnabled(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u32)) >>
                                        6u32) as u32)
        }
    }
    #[inline]
    pub fn set_DbgConsoleBrokerEnabled(&mut self, val: ULONG) {
        self._bitfield_1 &= !(64usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 6u32) & (64usize as u32);
    }
    #[inline]
    pub fn DbgSecureBootEnabled(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (128usize as u32)) >>
                                        7u32) as u32)
        }
    }
    #[inline]
    pub fn set_DbgSecureBootEnabled(&mut self, val: ULONG) {
        self._bitfield_1 &= !(128usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 7u32) & (128usize as u32);
    }
    #[inline]
    pub fn DbgMultiSessionSku(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (256usize as u32)) >>
                                        8u32) as u32)
        }
    }
    #[inline]
    pub fn set_DbgMultiSessionSku(&mut self, val: ULONG) {
        self._bitfield_1 &= !(256usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 8u32) & (256usize as u32);
    }
    #[inline]
    pub fn DbgMultiUsersInSessionSku(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (512usize as u32)) >>
                                        9u32) as u32)
        }
    }
    #[inline]
    pub fn set_DbgMultiUsersInSessionSku(&mut self, val: ULONG) {
        self._bitfield_1 &= !(512usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 9u32) & (512usize as u32);
    }
    #[inline]
    pub fn SpareBits(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294966272usize as u32)) >> 10u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_SpareBits(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294966272usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 10u32) & (4294966272usize as u32);
    }
}
#[test]
fn bindgen_test_layout__KUSER_SHARED_DATA__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<_KUSER_SHARED_DATA__bindgen_ty_2>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_KUSER_SHARED_DATA__bindgen_ty_2>() ,
               4usize);
}
impl Clone for _KUSER_SHARED_DATA__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KUSER_SHARED_DATA__bindgen_ty_3 {
    pub TickCount: __BindgenUnionField<KSYSTEM_TIME>,
    pub TickCountQuad: __BindgenUnionField<ULONG64>,
    pub __bindgen_anon_1: __BindgenUnionField<_KUSER_SHARED_DATA__bindgen_ty_3__bindgen_ty_1>,
    pub bindgen_union_field: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KUSER_SHARED_DATA__bindgen_ty_3__bindgen_ty_1 {
    pub ReservedTickCountOverlay: [ULONG; 3usize],
    pub TickCountPad: [ULONG; 1usize],
}
#[test]
fn bindgen_test_layout__KUSER_SHARED_DATA__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_KUSER_SHARED_DATA__bindgen_ty_3__bindgen_ty_1>()
               , 16usize);
    assert_eq!(::core::mem::align_of::<_KUSER_SHARED_DATA__bindgen_ty_3__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _KUSER_SHARED_DATA__bindgen_ty_3__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__KUSER_SHARED_DATA__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<_KUSER_SHARED_DATA__bindgen_ty_3>() ,
               16usize);
    assert_eq!(::core::mem::align_of::<_KUSER_SHARED_DATA__bindgen_ty_3>() ,
               8usize);
}
impl Clone for _KUSER_SHARED_DATA__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KUSER_SHARED_DATA__bindgen_ty_4 {
    pub QpcData: __BindgenUnionField<USHORT>,
    pub __bindgen_anon_1: __BindgenUnionField<_KUSER_SHARED_DATA__bindgen_ty_4__bindgen_ty_1>,
    pub bindgen_union_field: u16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _KUSER_SHARED_DATA__bindgen_ty_4__bindgen_ty_1 {
    pub QpcBypassEnabled: BOOLEAN,
    pub QpcShift: UCHAR,
}
#[test]
fn bindgen_test_layout__KUSER_SHARED_DATA__bindgen_ty_4__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_KUSER_SHARED_DATA__bindgen_ty_4__bindgen_ty_1>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_KUSER_SHARED_DATA__bindgen_ty_4__bindgen_ty_1>()
               , 1usize);
}
impl Clone for _KUSER_SHARED_DATA__bindgen_ty_4__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__KUSER_SHARED_DATA__bindgen_ty_4() {
    assert_eq!(::core::mem::size_of::<_KUSER_SHARED_DATA__bindgen_ty_4>() ,
               2usize);
    assert_eq!(::core::mem::align_of::<_KUSER_SHARED_DATA__bindgen_ty_4>() ,
               2usize);
}
impl Clone for _KUSER_SHARED_DATA__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__KUSER_SHARED_DATA() {
    assert_eq!(::core::mem::size_of::<_KUSER_SHARED_DATA>() , 1800usize);
    assert_eq!(::core::mem::align_of::<_KUSER_SHARED_DATA>() , 8usize);
}
pub use self::_KUSER_SHARED_DATA as KUSER_SHARED_DATA;
pub type PKUSER_SHARED_DATA = *mut _KUSER_SHARED_DATA;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SILO_USER_SHARED_DATA {
    pub ServiceSessionId: ULONG,
    pub ActiveConsoleId: ULONG,
    pub ConsoleSessionForegroundProcessId: LONGLONG,
    pub NtProductType: NT_PRODUCT_TYPE,
    pub SuiteMask: ULONG,
    pub IsMultiSessionSku: BOOLEAN,
}
#[test]
fn bindgen_test_layout__SILO_USER_SHARED_DATA() {
    assert_eq!(::core::mem::size_of::<_SILO_USER_SHARED_DATA>() , 32usize);
    assert_eq!(::core::mem::align_of::<_SILO_USER_SHARED_DATA>() , 8usize);
}
impl Clone for _SILO_USER_SHARED_DATA {
    fn clone(&self) -> Self { *self }
}
pub use self::_SILO_USER_SHARED_DATA as SILO_USER_SHARED_DATA;
pub type PSILO_USER_SHARED_DATA = *mut _SILO_USER_SHARED_DATA;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CM_PCCARD_DEVICE_DATA {
    pub Flags: UCHAR,
    pub ErrorCode: UCHAR,
    pub Reserved: USHORT,
    pub BusData: ULONG,
    pub DeviceId: ULONG,
    pub LegacyBaseAddress: ULONG,
    pub IRQMap: [UCHAR; 16usize],
}
#[test]
fn bindgen_test_layout__CM_PCCARD_DEVICE_DATA() {
    assert_eq!(::core::mem::size_of::<_CM_PCCARD_DEVICE_DATA>() , 32usize);
    assert_eq!(::core::mem::align_of::<_CM_PCCARD_DEVICE_DATA>() , 4usize);
}
impl Clone for _CM_PCCARD_DEVICE_DATA {
    fn clone(&self) -> Self { *self }
}
pub use self::_CM_PCCARD_DEVICE_DATA as CM_PCCARD_DEVICE_DATA;
pub type PCM_PCCARD_DEVICE_DATA = *mut _CM_PCCARD_DEVICE_DATA;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _CONFIGURATION_TYPE {
    ArcSystem = 0,
    CentralProcessor = 1,
    FloatingPointProcessor = 2,
    PrimaryIcache = 3,
    PrimaryDcache = 4,
    SecondaryIcache = 5,
    SecondaryDcache = 6,
    SecondaryCache = 7,
    EisaAdapter = 8,
    TcAdapter = 9,
    ScsiAdapter = 10,
    DtiAdapter = 11,
    MultiFunctionAdapter = 12,
    DiskController = 13,
    TapeController = 14,
    CdromController = 15,
    WormController = 16,
    SerialController = 17,
    NetworkController = 18,
    DisplayController = 19,
    ParallelController = 20,
    PointerController = 21,
    KeyboardController = 22,
    AudioController = 23,
    OtherController = 24,
    DiskPeripheral = 25,
    FloppyDiskPeripheral = 26,
    TapePeripheral = 27,
    ModemPeripheral = 28,
    MonitorPeripheral = 29,
    PrinterPeripheral = 30,
    PointerPeripheral = 31,
    KeyboardPeripheral = 32,
    TerminalPeripheral = 33,
    OtherPeripheral = 34,
    LinePeripheral = 35,
    NetworkPeripheral = 36,
    SystemMemory = 37,
    DockingInformation = 38,
    RealModeIrqRoutingTable = 39,
    RealModePCIEnumeration = 40,
    MaximumType = 41,
}
pub use self::_CONFIGURATION_TYPE as CONFIGURATION_TYPE;
pub type PCONFIGURATION_TYPE = *mut _CONFIGURATION_TYPE;
extern "C" {
    pub fn KePulseEvent(Event: PRKEVENT, Increment: KPRIORITY, Wait: BOOLEAN)
     -> LONG;
}
pub type PEXPAND_STACK_CALLOUT =
    ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn KeExpandKernelStackAndCallout(Callout: PEXPAND_STACK_CALLOUT,
                                         Parameter: PVOID, Size: SIZE_T)
     -> NTSTATUS;
}
extern "C" {
    pub fn KeExpandKernelStackAndCalloutEx(Callout: PEXPAND_STACK_CALLOUT,
                                           Parameter: PVOID, Size: SIZE_T,
                                           Wait: BOOLEAN, Context: PVOID)
     -> NTSTATUS;
}
extern "C" {
    pub fn KeSetBasePriorityThread(Thread: PKTHREAD, Increment: LONG) -> LONG;
}
extern "C" {
    pub fn KeBugCheck(BugCheckCode: ULONG);
}
extern "C" {
    pub fn KeInvalidateAllCaches() -> BOOLEAN;
}
extern "C" {
    pub fn KeInvalidateRangeAllCaches(BaseAddress: PVOID, Length: ULONG);
}
extern "C" {
    pub fn KeSetHardwareCounterConfiguration(CounterArray: PHARDWARE_COUNTER,
                                             Count: ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn KeQueryHardwareCounterConfiguration(CounterArray:
                                                   PHARDWARE_COUNTER,
                                               MaximumCount: ULONG,
                                               Count: PULONG) -> NTSTATUS;
}
extern "C" {
    pub fn ExRaiseDatatypeMisalignment();
}
extern "C" {
    pub fn ExRaiseAccessViolation();
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _ZONE_SEGMENT_HEADER {
    pub SegmentList: SINGLE_LIST_ENTRY,
    pub Reserved: PVOID,
}
#[test]
fn bindgen_test_layout__ZONE_SEGMENT_HEADER() {
    assert_eq!(::core::mem::size_of::<_ZONE_SEGMENT_HEADER>() , 16usize);
    assert_eq!(::core::mem::align_of::<_ZONE_SEGMENT_HEADER>() , 8usize);
}
impl Clone for _ZONE_SEGMENT_HEADER {
    fn clone(&self) -> Self { *self }
}
pub use self::_ZONE_SEGMENT_HEADER as ZONE_SEGMENT_HEADER;
pub type PZONE_SEGMENT_HEADER = *mut _ZONE_SEGMENT_HEADER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _ZONE_HEADER {
    pub FreeList: SINGLE_LIST_ENTRY,
    pub SegmentList: SINGLE_LIST_ENTRY,
    pub BlockSize: ULONG,
    pub TotalSegmentSize: ULONG,
}
#[test]
fn bindgen_test_layout__ZONE_HEADER() {
    assert_eq!(::core::mem::size_of::<_ZONE_HEADER>() , 24usize);
    assert_eq!(::core::mem::align_of::<_ZONE_HEADER>() , 8usize);
}
impl Clone for _ZONE_HEADER {
    fn clone(&self) -> Self { *self }
}
pub use self::_ZONE_HEADER as ZONE_HEADER;
pub type PZONE_HEADER = *mut _ZONE_HEADER;
extern "C" {
    pub fn ExInitializeZone(Zone: PZONE_HEADER, BlockSize: ULONG,
                            InitialSegment: PVOID, InitialSegmentSize: ULONG)
     -> NTSTATUS;
}
extern "C" {
    pub fn ExExtendZone(Zone: PZONE_HEADER, Segment: PVOID,
                        SegmentSize: ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn ExInterlockedExtendZone(Zone: PZONE_HEADER, Segment: PVOID,
                                   SegmentSize: ULONG, Lock: PKSPIN_LOCK)
     -> NTSTATUS;
}
pub use self::GUID as UUID;
extern "C" {
    pub fn ExUuidCreate(Uuid: *mut UUID) -> NTSTATUS;
}
extern "C" {
    pub fn MmIsThisAnNtAsSystem() -> BOOLEAN;
}
extern "C" {
    pub fn MmMapUserAddressesToPage(BaseAddress: PVOID, NumberOfBytes: SIZE_T,
                                    PageAddress: PVOID) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PHYSICAL_MEMORY_RANGE {
    pub BaseAddress: PHYSICAL_ADDRESS,
    pub NumberOfBytes: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__PHYSICAL_MEMORY_RANGE() {
    assert_eq!(::core::mem::size_of::<_PHYSICAL_MEMORY_RANGE>() , 16usize);
    assert_eq!(::core::mem::align_of::<_PHYSICAL_MEMORY_RANGE>() , 8usize);
}
impl Clone for _PHYSICAL_MEMORY_RANGE {
    fn clone(&self) -> Self { *self }
}
pub use self::_PHYSICAL_MEMORY_RANGE as PHYSICAL_MEMORY_RANGE;
pub type PPHYSICAL_MEMORY_RANGE = *mut _PHYSICAL_MEMORY_RANGE;
extern "C" {
    pub fn MmAddPhysicalMemory(StartAddress: PPHYSICAL_ADDRESS,
                               NumberOfBytes: PLARGE_INTEGER) -> NTSTATUS;
}
pub type PMM_ROTATE_COPY_CALLBACK_FUNCTION =
    ::core::option::Option<unsafe extern "C" fn(DestinationMdl: PMDL,
                                                SourceMdl: PMDL,
                                                Context: PVOID)
                               -> libc::c_long>;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _MM_ROTATE_DIRECTION {
    MmToFrameBuffer = 0,
    MmToFrameBufferNoCopy = 1,
    MmToRegularMemory = 2,
    MmToRegularMemoryNoCopy = 3,
    MmMaximumRotateDirection = 4,
}
pub use self::_MM_ROTATE_DIRECTION as MM_ROTATE_DIRECTION;
pub type PMM_ROTATE_DIRECTION = *mut _MM_ROTATE_DIRECTION;
extern "C" {
    pub fn MmRotatePhysicalView(VirtualAddress: PVOID, NumberOfBytes: PSIZE_T,
                                NewMdl: PMDL, Direction: MM_ROTATE_DIRECTION,
                                CopyFunction:
                                    PMM_ROTATE_COPY_CALLBACK_FUNCTION,
                                Context: PVOID) -> NTSTATUS;
}
extern "C" {
    pub fn MmRemovePhysicalMemory(StartAddress: PPHYSICAL_ADDRESS,
                                  NumberOfBytes: PLARGE_INTEGER) -> NTSTATUS;
}
extern "C" {
    pub fn MmGetPhysicalMemoryRanges() -> PPHYSICAL_MEMORY_RANGE;
}
extern "C" {
    pub fn MmMapVideoDisplay(PhysicalAddress: PHYSICAL_ADDRESS,
                             NumberOfBytes: SIZE_T,
                             CacheType: MEMORY_CACHING_TYPE) -> PVOID;
}
extern "C" {
    pub fn MmUnmapVideoDisplay(BaseAddress: PVOID, NumberOfBytes: SIZE_T);
}
extern "C" {
    pub fn MmGetPhysicalAddress(BaseAddress: PVOID) -> PHYSICAL_ADDRESS;
}
extern "C" {
    pub fn MmGetCacheAttribute(PhysicalAddress: PHYSICAL_ADDRESS,
                               CacheType: *mut MEMORY_CACHING_TYPE)
     -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _MM_COPY_ADDRESS {
    pub __bindgen_anon_1: _MM_COPY_ADDRESS__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _MM_COPY_ADDRESS__bindgen_ty_1 {
    pub VirtualAddress: __BindgenUnionField<PVOID>,
    pub PhysicalAddress: __BindgenUnionField<PHYSICAL_ADDRESS>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__MM_COPY_ADDRESS__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_MM_COPY_ADDRESS__bindgen_ty_1>() ,
               8usize);
    assert_eq!(::core::mem::align_of::<_MM_COPY_ADDRESS__bindgen_ty_1>() ,
               8usize);
}
impl Clone for _MM_COPY_ADDRESS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__MM_COPY_ADDRESS() {
    assert_eq!(::core::mem::size_of::<_MM_COPY_ADDRESS>() , 8usize);
    assert_eq!(::core::mem::align_of::<_MM_COPY_ADDRESS>() , 8usize);
}
impl Clone for _MM_COPY_ADDRESS {
    fn clone(&self) -> Self { *self }
}
pub use self::_MM_COPY_ADDRESS as MM_COPY_ADDRESS;
pub type PMMCOPY_ADDRESS = *mut _MM_COPY_ADDRESS;
extern "C" {
    pub fn MmCopyMemory(TargetAddress: PVOID, SourceAddress: MM_COPY_ADDRESS,
                        NumberOfBytes: SIZE_T, Flags: ULONG,
                        NumberOfBytesTransferred: PSIZE_T) -> NTSTATUS;
}
extern "C" {
    pub fn MmGetVirtualForPhysical(PhysicalAddress: PHYSICAL_ADDRESS)
     -> PVOID;
}
extern "C" {
    pub fn MmAllocateNonCachedMemory(NumberOfBytes: SIZE_T) -> PVOID;
}
extern "C" {
    pub fn MmFreeNonCachedMemory(BaseAddress: PVOID, NumberOfBytes: SIZE_T);
}
extern "C" {
    pub fn MmIsAddressValid(VirtualAddress: PVOID) -> BOOLEAN;
}
extern "C" {
    pub fn MmIsNonPagedSystemAddressValid(VirtualAddress: PVOID) -> BOOLEAN;
}
extern "C" {
    pub fn MmLockPagableSectionByHandle(ImageSectionHandle: PVOID);
}
extern "C" {
    pub fn MmSecureVirtualMemory(Address: PVOID, Size: SIZE_T,
                                 ProbeMode: ULONG) -> HANDLE;
}
extern "C" {
    pub fn MmUnsecureVirtualMemory(SecureHandle: HANDLE);
}
extern "C" {
    pub fn MmMapViewInSystemSpaceEx(Section: PVOID, MappedBase: *mut PVOID,
                                    ViewSize: PSIZE_T,
                                    SectionOffset: PLARGE_INTEGER,
                                    Flags: ULONG_PTR) -> NTSTATUS;
}
extern "C" {
    pub fn MmMapViewInSystemSpace(Section: PVOID, MappedBase: *mut PVOID,
                                  ViewSize: PSIZE_T) -> NTSTATUS;
}
extern "C" {
    pub fn MmUnmapViewInSystemSpace(MappedBase: PVOID) -> NTSTATUS;
}
extern "C" {
    pub fn MmMapViewInSessionSpaceEx(Section: PVOID, MappedBase: *mut PVOID,
                                     ViewSize: PSIZE_T,
                                     SectionOffset: PLARGE_INTEGER,
                                     Flags: ULONG_PTR) -> NTSTATUS;
}
extern "C" {
    pub fn MmMapViewInSessionSpace(Section: PVOID, MappedBase: *mut PVOID,
                                   ViewSize: PSIZE_T) -> NTSTATUS;
}
extern "C" {
    pub fn MmUnmapViewInSessionSpace(MappedBase: PVOID) -> NTSTATUS;
}
extern "C" {
    pub fn MmCreateMirror() -> NTSTATUS;
}
extern "C" {
    pub fn SeSinglePrivilegeCheck(PrivilegeValue: LUID,
                                  PreviousMode: KPROCESSOR_MODE) -> BOOLEAN;
}
extern "C" {
    #[link_name = "PsInitialSystemProcess"]
    pub static mut PsInitialSystemProcess: PEPROCESS;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PS_CREATE_NOTIFY_INFO {
    pub Size: SIZE_T,
    pub __bindgen_anon_1: _PS_CREATE_NOTIFY_INFO__bindgen_ty_1,
    pub ParentProcessId: HANDLE,
    pub CreatingThreadId: CLIENT_ID,
    pub FileObject: *mut _FILE_OBJECT,
    pub ImageFileName: PCUNICODE_STRING,
    pub CommandLine: PCUNICODE_STRING,
    pub CreationStatus: NTSTATUS,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PS_CREATE_NOTIFY_INFO__bindgen_ty_1 {
    pub Flags: __BindgenUnionField<ULONG>,
    pub __bindgen_anon_1: __BindgenUnionField<_PS_CREATE_NOTIFY_INFO__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PS_CREATE_NOTIFY_INFO__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PS_CREATE_NOTIFY_INFO__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PS_CREATE_NOTIFY_INFO__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PS_CREATE_NOTIFY_INFO__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PS_CREATE_NOTIFY_INFO__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PS_CREATE_NOTIFY_INFO__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn FileOpenNameAvailable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_FileOpenNameAvailable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967294usize as u32)) >> 1u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967294usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 1u32) & (4294967294usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PS_CREATE_NOTIFY_INFO__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PS_CREATE_NOTIFY_INFO__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PS_CREATE_NOTIFY_INFO__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PS_CREATE_NOTIFY_INFO__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__PS_CREATE_NOTIFY_INFO() {
    assert_eq!(::core::mem::size_of::<_PS_CREATE_NOTIFY_INFO>() , 72usize);
    assert_eq!(::core::mem::align_of::<_PS_CREATE_NOTIFY_INFO>() , 8usize);
}
impl Clone for _PS_CREATE_NOTIFY_INFO {
    fn clone(&self) -> Self { *self }
}
pub use self::_PS_CREATE_NOTIFY_INFO as PS_CREATE_NOTIFY_INFO;
pub type PPS_CREATE_NOTIFY_INFO = *mut _PS_CREATE_NOTIFY_INFO;
pub type PCREATE_PROCESS_NOTIFY_ROUTINE =
    ::core::option::Option<unsafe extern "C" fn(ParentId: HANDLE,
                                                ProcessId: HANDLE,
                                                Create: BOOLEAN)>;
extern "C" {
    pub fn PsSetCreateProcessNotifyRoutine(NotifyRoutine:
                                               PCREATE_PROCESS_NOTIFY_ROUTINE,
                                           Remove: BOOLEAN) -> NTSTATUS;
}
pub type PCREATE_PROCESS_NOTIFY_ROUTINE_EX =
    ::core::option::Option<unsafe extern "C" fn(Process: PEPROCESS,
                                                ProcessId: HANDLE,
                                                CreateInfo:
                                                    PPS_CREATE_NOTIFY_INFO)>;
extern "C" {
    pub fn PsSetCreateProcessNotifyRoutineEx(NotifyRoutine:
                                                 PCREATE_PROCESS_NOTIFY_ROUTINE_EX,
                                             Remove: BOOLEAN) -> NTSTATUS;
}
pub type PCREATE_THREAD_NOTIFY_ROUTINE =
    ::core::option::Option<unsafe extern "C" fn(ProcessId: HANDLE,
                                                ThreadId: HANDLE,
                                                Create: BOOLEAN)>;
extern "C" {
    pub fn PsSetCreateThreadNotifyRoutine(NotifyRoutine:
                                              PCREATE_THREAD_NOTIFY_ROUTINE)
     -> NTSTATUS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _PSCREATETHREADNOTIFYTYPE { PsCreateThreadNotifyNonSystem = 0, }
pub use self::_PSCREATETHREADNOTIFYTYPE as PSCREATETHREADNOTIFYTYPE;
extern "C" {
    pub fn PsSetCreateThreadNotifyRoutineEx(NotifyType:
                                                PSCREATETHREADNOTIFYTYPE,
                                            NotifyInformation: PVOID)
     -> NTSTATUS;
}
extern "C" {
    pub fn PsRemoveCreateThreadNotifyRoutine(NotifyRoutine:
                                                 PCREATE_THREAD_NOTIFY_ROUTINE)
     -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IMAGE_INFO {
    pub __bindgen_anon_1: _IMAGE_INFO__bindgen_ty_1,
    pub ImageBase: PVOID,
    pub ImageSelector: ULONG,
    pub ImageSize: SIZE_T,
    pub ImageSectionNumber: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IMAGE_INFO__bindgen_ty_1 {
    pub Properties: __BindgenUnionField<ULONG>,
    pub __bindgen_anon_1: __BindgenUnionField<_IMAGE_INFO__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IMAGE_INFO__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__IMAGE_INFO__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_IMAGE_INFO__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_IMAGE_INFO__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _IMAGE_INFO__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _IMAGE_INFO__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn ImageAddressingMode(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (255usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_ImageAddressingMode(&mut self, val: ULONG) {
        self._bitfield_1 &= !(255usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (255usize as u32);
    }
    #[inline]
    pub fn SystemModeImage(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (256usize as u32)) >>
                                        8u32) as u32)
        }
    }
    #[inline]
    pub fn set_SystemModeImage(&mut self, val: ULONG) {
        self._bitfield_1 &= !(256usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 8u32) & (256usize as u32);
    }
    #[inline]
    pub fn ImageMappedToAllPids(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (512usize as u32)) >>
                                        9u32) as u32)
        }
    }
    #[inline]
    pub fn set_ImageMappedToAllPids(&mut self, val: ULONG) {
        self._bitfield_1 &= !(512usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 9u32) & (512usize as u32);
    }
    #[inline]
    pub fn ExtendedInfoPresent(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1024usize as u32)) >>
                                        10u32) as u32)
        }
    }
    #[inline]
    pub fn set_ExtendedInfoPresent(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1024usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 10u32) & (1024usize as u32);
    }
    #[inline]
    pub fn MachineTypeMismatch(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2048usize as u32)) >>
                                        11u32) as u32)
        }
    }
    #[inline]
    pub fn set_MachineTypeMismatch(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2048usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 11u32) & (2048usize as u32);
    }
    #[inline]
    pub fn ImageSignatureLevel(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (61440usize as u32))
                                        >> 12u32) as u32)
        }
    }
    #[inline]
    pub fn set_ImageSignatureLevel(&mut self, val: ULONG) {
        self._bitfield_1 &= !(61440usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 12u32) & (61440usize as u32);
    }
    #[inline]
    pub fn ImageSignatureType(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (458752usize as u32))
                                        >> 16u32) as u32)
        }
    }
    #[inline]
    pub fn set_ImageSignatureType(&mut self, val: ULONG) {
        self._bitfield_1 &= !(458752usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (458752usize as u32);
    }
    #[inline]
    pub fn ImagePartialMap(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (524288usize as u32))
                                        >> 19u32) as u32)
        }
    }
    #[inline]
    pub fn set_ImagePartialMap(&mut self, val: ULONG) {
        self._bitfield_1 &= !(524288usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 19u32) & (524288usize as u32);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4293918720usize as u32)) >> 20u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4293918720usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 20u32) & (4293918720usize as u32);
    }
}
#[test]
fn bindgen_test_layout__IMAGE_INFO__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_IMAGE_INFO__bindgen_ty_1>() , 4usize);
    assert_eq!(::core::mem::align_of::<_IMAGE_INFO__bindgen_ty_1>() , 4usize);
}
impl Clone for _IMAGE_INFO__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__IMAGE_INFO() {
    assert_eq!(::core::mem::size_of::<_IMAGE_INFO>() , 40usize);
    assert_eq!(::core::mem::align_of::<_IMAGE_INFO>() , 8usize);
}
impl Clone for _IMAGE_INFO {
    fn clone(&self) -> Self { *self }
}
pub use self::_IMAGE_INFO as IMAGE_INFO;
pub type PIMAGE_INFO = *mut _IMAGE_INFO;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IMAGE_INFO_EX {
    pub Size: SIZE_T,
    pub ImageInfo: IMAGE_INFO,
    pub FileObject: *mut _FILE_OBJECT,
}
#[test]
fn bindgen_test_layout__IMAGE_INFO_EX() {
    assert_eq!(::core::mem::size_of::<_IMAGE_INFO_EX>() , 56usize);
    assert_eq!(::core::mem::align_of::<_IMAGE_INFO_EX>() , 8usize);
}
impl Clone for _IMAGE_INFO_EX {
    fn clone(&self) -> Self { *self }
}
pub use self::_IMAGE_INFO_EX as IMAGE_INFO_EX;
pub type PIMAGE_INFO_EX = *mut _IMAGE_INFO_EX;
pub type PLOAD_IMAGE_NOTIFY_ROUTINE =
    ::core::option::Option<unsafe extern "C" fn(FullImageName:
                                                    PUNICODE_STRING,
                                                ProcessId: HANDLE,
                                                ImageInfo: PIMAGE_INFO)>;
extern "C" {
    pub fn PsSetLoadImageNotifyRoutine(NotifyRoutine:
                                           PLOAD_IMAGE_NOTIFY_ROUTINE)
     -> NTSTATUS;
}
extern "C" {
    pub fn PsRemoveLoadImageNotifyRoutine(NotifyRoutine:
                                              PLOAD_IMAGE_NOTIFY_ROUTINE)
     -> NTSTATUS;
}
extern "C" {
    pub fn PsGetCurrentProcessId() -> HANDLE;
}
extern "C" {
    pub fn PsGetCurrentThreadId() -> HANDLE;
}
extern "C" {
    pub fn PsSetCurrentThreadPrefetching(Prefetching: BOOLEAN) -> BOOLEAN;
}
extern "C" {
    pub fn PsIsCurrentThreadPrefetching() -> BOOLEAN;
}
extern "C" {
    pub fn PsGetProcessCreateTimeQuadPart(Process: PEPROCESS) -> LONGLONG;
}
extern "C" {
    pub fn PsGetProcessExitStatus(Process: PEPROCESS) -> NTSTATUS;
}
extern "C" {
    pub fn PsGetThreadExitStatus(Thread: PETHREAD) -> NTSTATUS;
}
extern "C" {
    pub fn PsGetProcessId(Process: PEPROCESS) -> HANDLE;
}
extern "C" {
    pub fn PsGetThreadId(Thread: PETHREAD) -> HANDLE;
}
extern "C" {
    pub fn PsGetThreadProperty(Thread: PETHREAD, Key: ULONG_PTR, Flags: ULONG)
     -> PVOID;
}
extern "C" {
    pub fn PsGetThreadProcessId(Thread: PETHREAD) -> HANDLE;
}
extern "C" {
    pub fn PsGetThreadCreateTime(Thread: PETHREAD) -> LONGLONG;
}
extern "C" {
    pub fn PsGetCurrentThreadTeb() -> PVOID;
}
pub type PIO_QUERY_DEVICE_ROUTINE =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                PathName: PUNICODE_STRING,
                                                BusType: INTERFACE_TYPE,
                                                BusNumber: ULONG,
                                                BusInformation:
                                                    *mut PKEY_VALUE_FULL_INFORMATION,
                                                ControllerType:
                                                    CONFIGURATION_TYPE,
                                                ControllerNumber: ULONG,
                                                ControllerInformation:
                                                    *mut PKEY_VALUE_FULL_INFORMATION,
                                                PeripheralType:
                                                    CONFIGURATION_TYPE,
                                                PeripheralNumber: ULONG,
                                                PeripheralInformation:
                                                    *mut PKEY_VALUE_FULL_INFORMATION)
                               -> libc::c_long>;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _IO_QUERY_DEVICE_DATA_FORMAT {
    IoQueryDeviceIdentifier = 0,
    IoQueryDeviceConfigurationData = 1,
    IoQueryDeviceComponentInformation = 2,
    IoQueryDeviceMaxData = 3,
}
pub use self::_IO_QUERY_DEVICE_DATA_FORMAT as IO_QUERY_DEVICE_DATA_FORMAT;
pub type PIO_QUERY_DEVICE_DATA_FORMAT = *mut _IO_QUERY_DEVICE_DATA_FORMAT;
pub type DRIVER_REINITIALIZE =
    ::core::option::Option<unsafe extern "C" fn(DriverObject:
                                                    *mut _DRIVER_OBJECT,
                                                Context: PVOID,
                                                Count: ULONG)>;
pub type PDRIVER_REINITIALIZE = DRIVER_REINITIALIZE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CONTROLLER_OBJECT {
    pub Type: CSHORT,
    pub Size: CSHORT,
    pub ControllerExtension: PVOID,
    pub DeviceWaitQueue: KDEVICE_QUEUE,
    pub Spare1: ULONG,
    pub Spare2: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__CONTROLLER_OBJECT() {
    assert_eq!(::core::mem::size_of::<_CONTROLLER_OBJECT>() , 72usize);
    assert_eq!(::core::mem::align_of::<_CONTROLLER_OBJECT>() , 8usize);
}
impl Clone for _CONTROLLER_OBJECT {
    fn clone(&self) -> Self { *self }
}
pub use self::_CONTROLLER_OBJECT as CONTROLLER_OBJECT;
pub type PCONTROLLER_OBJECT = *mut _CONTROLLER_OBJECT;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CONFIGURATION_INFORMATION {
    pub DiskCount: ULONG,
    pub FloppyCount: ULONG,
    pub CdRomCount: ULONG,
    pub TapeCount: ULONG,
    pub ScsiPortCount: ULONG,
    pub SerialCount: ULONG,
    pub ParallelCount: ULONG,
    pub AtDiskPrimaryAddressClaimed: BOOLEAN,
    pub AtDiskSecondaryAddressClaimed: BOOLEAN,
    pub Version: ULONG,
    pub MediumChangerCount: ULONG,
}
#[test]
fn bindgen_test_layout__CONFIGURATION_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_CONFIGURATION_INFORMATION>() ,
               40usize);
    assert_eq!(::core::mem::align_of::<_CONFIGURATION_INFORMATION>() ,
               4usize);
}
impl Clone for _CONFIGURATION_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_CONFIGURATION_INFORMATION as CONFIGURATION_INFORMATION;
pub type PCONFIGURATION_INFORMATION = *mut _CONFIGURATION_INFORMATION;
extern "C" {
    pub fn IoAllocateController(ControllerObject: PCONTROLLER_OBJECT,
                                DeviceObject: PDEVICE_OBJECT,
                                ExecutionRoutine: PDRIVER_CONTROL,
                                Context: PVOID);
}
extern "C" {
    pub fn IoAssignResources(RegistryPath: PUNICODE_STRING,
                             DriverClassName: PUNICODE_STRING,
                             DriverObject: PDRIVER_OBJECT,
                             DeviceObject: PDEVICE_OBJECT,
                             RequestedResources:
                                 PIO_RESOURCE_REQUIREMENTS_LIST,
                             AllocatedResources: *mut PCM_RESOURCE_LIST)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoAttachDeviceByPointer(SourceDevice: PDEVICE_OBJECT,
                                   TargetDevice: PDEVICE_OBJECT) -> NTSTATUS;
}
extern "C" {
    pub fn IoCreateController(Size: ULONG) -> PCONTROLLER_OBJECT;
}
extern "C" {
    pub fn IoDeleteController(ControllerObject: PCONTROLLER_OBJECT);
}
extern "C" {
    pub fn IoFreeController(ControllerObject: PCONTROLLER_OBJECT);
}
extern "C" {
    pub fn IoGetConfigurationInformation() -> PCONFIGURATION_INFORMATION;
}
extern "C" {
    pub fn IoGetFileObjectGenericMapping() -> PGENERIC_MAPPING;
}
extern "C" {
    pub fn IoCancelFileOpen(DeviceObject: PDEVICE_OBJECT,
                            FileObject: PFILE_OBJECT);
}
extern "C" {
    pub fn IoMakeAssociatedIrp(Irp: PIRP, StackSize: CCHAR) -> PIRP;
}
extern "C" {
    pub fn IoMakeAssociatedIrpEx(Irp: PIRP, DeviceObject: PDEVICE_OBJECT,
                                 StackSize: CCHAR) -> PIRP;
}
extern "C" {
    pub fn IoQueryDeviceDescription(BusType: PINTERFACE_TYPE,
                                    BusNumber: PULONG,
                                    ControllerType: PCONFIGURATION_TYPE,
                                    ControllerNumber: PULONG,
                                    PeripheralType: PCONFIGURATION_TYPE,
                                    PeripheralNumber: PULONG,
                                    CalloutRoutine: PIO_QUERY_DEVICE_ROUTINE,
                                    Context: PVOID) -> NTSTATUS;
}
extern "C" {
    pub fn IoRaiseHardError(Irp: PIRP, Vpb: PVPB,
                            RealDeviceObject: PDEVICE_OBJECT);
}
extern "C" {
    pub fn IoRaiseInformationalHardError(ErrorStatus: NTSTATUS,
                                         String: PUNICODE_STRING,
                                         Thread: PKTHREAD) -> BOOLEAN;
}
extern "C" {
    pub fn IoSetThreadHardErrorMode(EnableHardErrors: BOOLEAN) -> BOOLEAN;
}
extern "C" {
    pub fn IoRegisterBootDriverReinitialization(DriverObject: PDRIVER_OBJECT,
                                                DriverReinitializationRoutine:
                                                    PDRIVER_REINITIALIZE,
                                                Context: PVOID);
}
extern "C" {
    pub fn IoRegisterDriverReinitialization(DriverObject: PDRIVER_OBJECT,
                                            DriverReinitializationRoutine:
                                                PDRIVER_REINITIALIZE,
                                            Context: PVOID);
}
extern "C" {
    pub fn IoReportResourceUsage(DriverClassName: PUNICODE_STRING,
                                 DriverObject: PDRIVER_OBJECT,
                                 DriverList: PCM_RESOURCE_LIST,
                                 DriverListSize: ULONG,
                                 DeviceObject: PDEVICE_OBJECT,
                                 DeviceList: PCM_RESOURCE_LIST,
                                 DeviceListSize: ULONG,
                                 OverrideConflict: BOOLEAN,
                                 ConflictDetected: PBOOLEAN) -> NTSTATUS;
}
extern "C" {
    pub fn IoTranslateBusAddress(InterfaceType: INTERFACE_TYPE,
                                 BusNumber: ULONG,
                                 BusAddress: PHYSICAL_ADDRESS,
                                 AddressSpace: PULONG,
                                 TranslatedAddress: PPHYSICAL_ADDRESS)
     -> BOOLEAN;
}
extern "C" {
    pub fn IoSetHardErrorOrVerifyDevice(Irp: PIRP,
                                        DeviceObject: PDEVICE_OBJECT);
}
extern "C" {
    pub fn HalExamineMBR(DeviceObject: PDEVICE_OBJECT, SectorSize: ULONG,
                         MBRTypeIdentifier: ULONG, Buffer: *mut PVOID);
}
extern "C" {
    pub fn IoReadPartitionTable(DeviceObject: PDEVICE_OBJECT,
                                SectorSize: ULONG,
                                ReturnRecognizedPartitions: BOOLEAN,
                                PartitionBuffer:
                                    *mut *mut _DRIVE_LAYOUT_INFORMATION)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoSetPartitionInformation(DeviceObject: PDEVICE_OBJECT,
                                     SectorSize: ULONG,
                                     PartitionNumber: ULONG,
                                     PartitionType: ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn IoWritePartitionTable(DeviceObject: PDEVICE_OBJECT,
                                 SectorSize: ULONG, SectorsPerTrack: ULONG,
                                 NumberOfHeads: ULONG,
                                 PartitionBuffer:
                                     *mut _DRIVE_LAYOUT_INFORMATION)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoCreateDisk(DeviceObject: PDEVICE_OBJECT, Disk: *mut _CREATE_DISK)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoReadPartitionTableEx(DeviceObject: PDEVICE_OBJECT,
                                  DriveLayout:
                                      *mut *mut _DRIVE_LAYOUT_INFORMATION_EX)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoWritePartitionTableEx(DeviceObject: PDEVICE_OBJECT,
                                   DriveLayout:
                                       *mut _DRIVE_LAYOUT_INFORMATION_EX)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoSetPartitionInformationEx(DeviceObject: PDEVICE_OBJECT,
                                       PartitionNumber: ULONG,
                                       PartitionInfo:
                                           *mut _SET_PARTITION_INFORMATION_EX)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoVerifyPartitionTable(DeviceObject: PDEVICE_OBJECT,
                                  FixErrors: BOOLEAN) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DISK_SIGNATURE {
    pub PartitionStyle: ULONG,
    pub __bindgen_anon_1: _DISK_SIGNATURE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DISK_SIGNATURE__bindgen_ty_1 {
    pub Mbr: __BindgenUnionField<_DISK_SIGNATURE__bindgen_ty_1__bindgen_ty_1>,
    pub Gpt: __BindgenUnionField<_DISK_SIGNATURE__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: [u32; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DISK_SIGNATURE__bindgen_ty_1__bindgen_ty_1 {
    pub Signature: ULONG,
    pub CheckSum: ULONG,
}
#[test]
fn bindgen_test_layout__DISK_SIGNATURE__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_DISK_SIGNATURE__bindgen_ty_1__bindgen_ty_1>()
               , 8usize);
    assert_eq!(::core::mem::align_of::<_DISK_SIGNATURE__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _DISK_SIGNATURE__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DISK_SIGNATURE__bindgen_ty_1__bindgen_ty_2 {
    pub DiskId: GUID,
}
#[test]
fn bindgen_test_layout__DISK_SIGNATURE__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<_DISK_SIGNATURE__bindgen_ty_1__bindgen_ty_2>()
               , 16usize);
    assert_eq!(::core::mem::align_of::<_DISK_SIGNATURE__bindgen_ty_1__bindgen_ty_2>()
               , 4usize);
}
impl Clone for _DISK_SIGNATURE__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__DISK_SIGNATURE__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_DISK_SIGNATURE__bindgen_ty_1>() ,
               16usize);
    assert_eq!(::core::mem::align_of::<_DISK_SIGNATURE__bindgen_ty_1>() ,
               4usize);
}
impl Clone for _DISK_SIGNATURE__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__DISK_SIGNATURE() {
    assert_eq!(::core::mem::size_of::<_DISK_SIGNATURE>() , 20usize);
    assert_eq!(::core::mem::align_of::<_DISK_SIGNATURE>() , 4usize);
}
impl Clone for _DISK_SIGNATURE {
    fn clone(&self) -> Self { *self }
}
pub use self::_DISK_SIGNATURE as DISK_SIGNATURE;
pub type PDISK_SIGNATURE = *mut _DISK_SIGNATURE;
extern "C" {
    pub fn IoReadDiskSignature(DeviceObject: PDEVICE_OBJECT,
                               BytesPerSector: ULONG,
                               Signature: PDISK_SIGNATURE) -> NTSTATUS;
}
extern "C" {
    pub fn IoVolumeDeviceToDosName(VolumeDeviceObject: PVOID,
                                   DosName: PUNICODE_STRING) -> NTSTATUS;
}
extern "C" {
    pub fn IoVolumeDeviceToGuidPath(VolumeDeviceObject: PVOID,
                                    GuidPath: PUNICODE_STRING) -> NTSTATUS;
}
extern "C" {
    pub fn IoVolumeDeviceToGuid(VolumeDeviceObject: PVOID, Guid: *mut GUID)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoVolumeDeviceNameToGuid(VolumeDeviceName: PUNICODE_STRING,
                                    Guid: *mut GUID) -> NTSTATUS;
}
extern "C" {
    pub fn IoVolumeDeviceNameToGuidPath(VolumeDeviceName: PUNICODE_STRING,
                                        GuidPath: PUNICODE_STRING)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoSetSystemPartition(VolumeNameString: PUNICODE_STRING)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoCreateFileSpecifyDeviceObjectHint(FileHandle: PHANDLE,
                                               DesiredAccess: ACCESS_MASK,
                                               ObjectAttributes:
                                                   POBJECT_ATTRIBUTES,
                                               IoStatusBlock:
                                                   PIO_STATUS_BLOCK,
                                               AllocationSize: PLARGE_INTEGER,
                                               FileAttributes: ULONG,
                                               ShareAccess: ULONG,
                                               Disposition: ULONG,
                                               CreateOptions: ULONG,
                                               EaBuffer: PVOID,
                                               EaLength: ULONG,
                                               CreateFileType:
                                                   CREATE_FILE_TYPE,
                                               InternalParameters: PVOID,
                                               Options: ULONG,
                                               DeviceObject: PVOID)
     -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _TXN_PARAMETER_BLOCK {
    pub Length: USHORT,
    pub TxFsContext: USHORT,
    pub TransactionObject: PVOID,
}
#[test]
fn bindgen_test_layout__TXN_PARAMETER_BLOCK() {
    assert_eq!(::core::mem::size_of::<_TXN_PARAMETER_BLOCK>() , 16usize);
    assert_eq!(::core::mem::align_of::<_TXN_PARAMETER_BLOCK>() , 8usize);
}
impl Clone for _TXN_PARAMETER_BLOCK {
    fn clone(&self) -> Self { *self }
}
pub use self::_TXN_PARAMETER_BLOCK as TXN_PARAMETER_BLOCK;
pub type PTXN_PARAMETER_BLOCK = *mut _TXN_PARAMETER_BLOCK;
extern "C" {
    pub fn IoGetTransactionParameterBlock(FileObject: PFILE_OBJECT)
     -> PTXN_PARAMETER_BLOCK;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CREATE_USER_PROCESS_ECP_CONTEXT {
    pub Size: USHORT,
    pub Reserved: USHORT,
    pub AccessToken: PACCESS_TOKEN,
}
#[test]
fn bindgen_test_layout__CREATE_USER_PROCESS_ECP_CONTEXT() {
    assert_eq!(::core::mem::size_of::<_CREATE_USER_PROCESS_ECP_CONTEXT>() ,
               16usize);
    assert_eq!(::core::mem::align_of::<_CREATE_USER_PROCESS_ECP_CONTEXT>() ,
               8usize);
}
impl Clone for _CREATE_USER_PROCESS_ECP_CONTEXT {
    fn clone(&self) -> Self { *self }
}
pub use self::_CREATE_USER_PROCESS_ECP_CONTEXT as
        CREATE_USER_PROCESS_ECP_CONTEXT;
pub type PCREATE_USER_PROCESS_ECP_CONTEXT =
    *mut _CREATE_USER_PROCESS_ECP_CONTEXT;
extern "C" {
    #[link_name = "GUID_ECP_CREATE_USER_PROCESS"]
    pub static GUID_ECP_CREATE_USER_PROCESS: GUID;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _OPLOCK_KEY_ECP_CONTEXT {
    pub _address: u8,
}
impl Clone for _OPLOCK_KEY_ECP_CONTEXT {
    fn clone(&self) -> Self { *self }
}
pub type POPLOCK_KEY_ECP_CONTEXT = *mut _OPLOCK_KEY_ECP_CONTEXT;
extern "C" {
    pub fn IoGetOplockKeyContext(FileObject: PFILE_OBJECT)
     -> POPLOCK_KEY_ECP_CONTEXT;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _OPLOCK_KEY_CONTEXT {
    pub Version: USHORT,
    pub Flags: USHORT,
    pub ParentOplockKey: GUID,
    pub TargetOplockKey: GUID,
    pub Reserved: ULONG,
}
#[test]
fn bindgen_test_layout__OPLOCK_KEY_CONTEXT() {
    assert_eq!(::core::mem::size_of::<_OPLOCK_KEY_CONTEXT>() , 40usize);
    assert_eq!(::core::mem::align_of::<_OPLOCK_KEY_CONTEXT>() , 4usize);
}
impl Clone for _OPLOCK_KEY_CONTEXT {
    fn clone(&self) -> Self { *self }
}
pub use self::_OPLOCK_KEY_CONTEXT as OPLOCK_KEY_CONTEXT;
pub type POPLOCK_KEY_CONTEXT = *mut _OPLOCK_KEY_CONTEXT;
extern "C" {
    pub fn IoGetOplockKeyContextEx(FileObject: PFILE_OBJECT)
     -> POPLOCK_KEY_CONTEXT;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_DRIVER_CREATE_CONTEXT {
    pub Size: CSHORT,
    pub ExtraCreateParameter: *mut _IO_DRIVER_CREATE_CONTEXT__ECP_LIST,
    pub DeviceObjectHint: PVOID,
    pub TxnParameters: PTXN_PARAMETER_BLOCK,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_DRIVER_CREATE_CONTEXT__ECP_LIST {
    pub _address: u8,
}
impl Clone for _IO_DRIVER_CREATE_CONTEXT__ECP_LIST {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__IO_DRIVER_CREATE_CONTEXT() {
    assert_eq!(::core::mem::size_of::<_IO_DRIVER_CREATE_CONTEXT>() , 32usize);
    assert_eq!(::core::mem::align_of::<_IO_DRIVER_CREATE_CONTEXT>() , 8usize);
}
impl Clone for _IO_DRIVER_CREATE_CONTEXT {
    fn clone(&self) -> Self { *self }
}
pub use self::_IO_DRIVER_CREATE_CONTEXT as IO_DRIVER_CREATE_CONTEXT;
pub type PIO_DRIVER_CREATE_CONTEXT = *mut _IO_DRIVER_CREATE_CONTEXT;
extern "C" {
    pub fn IoCreateFileEx(FileHandle: PHANDLE, DesiredAccess: ACCESS_MASK,
                          ObjectAttributes: POBJECT_ATTRIBUTES,
                          IoStatusBlock: PIO_STATUS_BLOCK,
                          AllocationSize: PLARGE_INTEGER,
                          FileAttributes: ULONG, ShareAccess: ULONG,
                          Disposition: ULONG, CreateOptions: ULONG,
                          EaBuffer: PVOID, EaLength: ULONG,
                          CreateFileType: CREATE_FILE_TYPE,
                          InternalParameters: PVOID, Options: ULONG,
                          DriverContext: PIO_DRIVER_CREATE_CONTEXT)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoSetIrpExtraCreateParameter(Irp: PIRP,
                                        ExtraCreateParameter:
                                            *mut _IO_DRIVER_CREATE_CONTEXT__ECP_LIST)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoClearIrpExtraCreateParameter(Irp: PIRP);
}
extern "C" {
    pub fn IoGetIrpExtraCreateParameter(Irp: PIRP,
                                        ExtraCreateParameter:
                                            *mut *mut _IO_DRIVER_CREATE_CONTEXT__ECP_LIST)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoAttachDeviceToDeviceStackSafe(SourceDevice: PDEVICE_OBJECT,
                                           TargetDevice: PDEVICE_OBJECT,
                                           AttachedToDeviceObject:
                                               *mut PDEVICE_OBJECT)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoIsFileOriginRemote(FileObject: PFILE_OBJECT) -> BOOLEAN;
}
extern "C" {
    pub fn IoSetFileOrigin(FileObject: PFILE_OBJECT, Remote: BOOLEAN)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoIsFileObjectIgnoringSharing(FileObject: PFILE_OBJECT) -> BOOLEAN;
}
extern "C" {
    pub fn IoSetFileObjectIgnoreSharing(FileObject: PFILE_OBJECT) -> NTSTATUS;
}
extern "C" {
    pub fn IoGetPagingIoPriority(Irp: PIRP) -> IO_PAGING_PRIORITY;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _BDCB_CALLBACK_TYPE {
    BdCbStatusUpdate = 0,
    BdCbInitializeImage = 1,
}
pub use self::_BDCB_CALLBACK_TYPE as BDCB_CALLBACK_TYPE;
pub type PBDCB_CALLBACK_TYPE = *mut _BDCB_CALLBACK_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _BDCB_CLASSIFICATION {
    BdCbClassificationUnknownImage = 0,
    BdCbClassificationKnownGoodImage = 1,
    BdCbClassificationKnownBadImage = 2,
    BdCbClassificationKnownBadImageBootCritical = 3,
    BdCbClassificationEnd = 4,
}
pub use self::_BDCB_CLASSIFICATION as BDCB_CLASSIFICATION;
pub type PBDCB_CLASSIFICATION = *mut _BDCB_CLASSIFICATION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _BDCB_STATUS_UPDATE_TYPE {
    BdCbStatusPrepareForDependencyLoad = 0,
    BdCbStatusPrepareForDriverLoad = 1,
    BdCbStatusPrepareForUnload = 2,
}
pub use self::_BDCB_STATUS_UPDATE_TYPE as BDCB_STATUS_UPDATE_TYPE;
pub type PBDCB_STATUS_UPDATE_TYPE = *mut _BDCB_STATUS_UPDATE_TYPE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _BDCB_STATUS_UPDATE_CONTEXT {
    pub StatusType: BDCB_STATUS_UPDATE_TYPE,
}
#[test]
fn bindgen_test_layout__BDCB_STATUS_UPDATE_CONTEXT() {
    assert_eq!(::core::mem::size_of::<_BDCB_STATUS_UPDATE_CONTEXT>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_BDCB_STATUS_UPDATE_CONTEXT>() ,
               4usize);
}
impl Clone for _BDCB_STATUS_UPDATE_CONTEXT {
    fn clone(&self) -> Self { *self }
}
pub use self::_BDCB_STATUS_UPDATE_CONTEXT as BDCB_STATUS_UPDATE_CONTEXT;
pub type PBDCB_STATUS_UPDATE_CONTEXT = *mut _BDCB_STATUS_UPDATE_CONTEXT;
pub use self::_BDCB_IMAGE_INFORMATION as BDCB_IMAGE_INFORMATION;
pub type BOOT_DRIVER_CALLBACK_FUNCTION =
    ::core::option::Option<unsafe extern "C" fn(CallbackContext: PVOID,
                                                Classification:
                                                    BDCB_CALLBACK_TYPE,
                                                ImageInformation:
                                                    PBDCB_IMAGE_INFORMATION)>;
pub type PBOOT_DRIVER_CALLBACK_FUNCTION = BOOT_DRIVER_CALLBACK_FUNCTION;
extern "C" {
    pub fn IoRegisterBootDriverCallback(CallbackFunction:
                                            PBOOT_DRIVER_CALLBACK_FUNCTION,
                                        CallbackContext: PVOID) -> PVOID;
}
extern "C" {
    pub fn IoUnregisterBootDriverCallback(CallbackHandle: PVOID);
}
extern "C" {
    pub fn IoGetActivityIdIrp(Irp: PIRP, Guid: LPGUID) -> NTSTATUS;
}
extern "C" {
    pub fn IoSetActivityIdIrp(Irp: PIRP, Guid: LPCGUID) -> NTSTATUS;
}
extern "C" {
    pub fn IoPropagateActivityIdToThread(Irp: PIRP, PropagatedId: LPGUID,
                                         OriginalId: *mut LPCGUID)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoSetActivityIdThread(ActivityId: LPCGUID) -> LPCGUID;
}
extern "C" {
    pub fn IoClearActivityIdThread(OriginalId: LPCGUID);
}
extern "C" {
    pub fn IoGetActivityIdThread() -> LPCGUID;
}
extern "C" {
    pub fn IoTransferActivityId(ActivityId: LPCGUID,
                                RelatedActivityId: LPCGUID);
}
extern "C" {
    pub fn IoGetFsZeroingOffset(Irp: PIRP, ZeroingOffset: PULONG) -> NTSTATUS;
}
extern "C" {
    pub fn IoSetFsZeroingOffsetRequired(Irp: PIRP) -> NTSTATUS;
}
extern "C" {
    pub fn IoSetFsZeroingOffset(Irp: PIRP, ZeroingOffset: ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn IoIsValidIrpStatus(Status: NTSTATUS) -> LOGICAL;
}
extern "C" {
    pub fn IoIncrementKeepAliveCount(FileObject: PFILE_OBJECT,
                                     Process: PEPROCESS) -> NTSTATUS;
}
extern "C" {
    pub fn IoDecrementKeepAliveCount(FileObject: PFILE_OBJECT,
                                     Process: PEPROCESS) -> NTSTATUS;
}
extern "C" {
    pub fn IoGetInitiatorProcess(FileObject: PFILE_OBJECT) -> PEPROCESS;
}
extern "C" {
    pub fn IoSetMasterIrpStatus(MasterIrp: PIRP, Status: NTSTATUS);
}
extern "C" {
    pub fn IoQueryFullDriverPath(DriverObject: PDRIVER_OBJECT,
                                 FullPath: PUNICODE_STRING) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _AGP_TARGET_BUS_INTERFACE_STANDARD {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub SetBusData: PGET_SET_DEVICE_DATA,
    pub GetBusData: PGET_SET_DEVICE_DATA,
    pub CapabilityID: UCHAR,
}
#[test]
fn bindgen_test_layout__AGP_TARGET_BUS_INTERFACE_STANDARD() {
    assert_eq!(::core::mem::size_of::<_AGP_TARGET_BUS_INTERFACE_STANDARD>() ,
               56usize);
    assert_eq!(::core::mem::align_of::<_AGP_TARGET_BUS_INTERFACE_STANDARD>() ,
               8usize);
}
impl Clone for _AGP_TARGET_BUS_INTERFACE_STANDARD {
    fn clone(&self) -> Self { *self }
}
pub use self::_AGP_TARGET_BUS_INTERFACE_STANDARD as
        AGP_TARGET_BUS_INTERFACE_STANDARD;
pub type PAGP_TARGET_BUS_INTERFACE_STANDARD =
    *mut _AGP_TARGET_BUS_INTERFACE_STANDARD;
extern "C" {
    pub fn IoReportDetectedDevice(DriverObject: PDRIVER_OBJECT,
                                  LegacyBusType: INTERFACE_TYPE,
                                  BusNumber: ULONG, SlotNumber: ULONG,
                                  ResourceList: PCM_RESOURCE_LIST,
                                  ResourceRequirements:
                                      PIO_RESOURCE_REQUIREMENTS_LIST,
                                  ResourceAssigned: BOOLEAN,
                                  DeviceObject: *mut PDEVICE_OBJECT)
     -> NTSTATUS;
}
extern "C" {
    pub fn IoReportRootDevice(DriverObject: PDRIVER_OBJECT) -> NTSTATUS;
}
pub type PGET_LOCATION_STRING =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                LocationStrings: *mut PZZWSTR)
                               -> libc::c_long>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PNP_LOCATION_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub GetLocationString: PGET_LOCATION_STRING,
}
#[test]
fn bindgen_test_layout__PNP_LOCATION_INTERFACE() {
    assert_eq!(::core::mem::size_of::<_PNP_LOCATION_INTERFACE>() , 40usize);
    assert_eq!(::core::mem::align_of::<_PNP_LOCATION_INTERFACE>() , 8usize);
}
impl Clone for _PNP_LOCATION_INTERFACE {
    fn clone(&self) -> Self { *self }
}
pub use self::_PNP_LOCATION_INTERFACE as PNP_LOCATION_INTERFACE;
pub type PPNP_LOCATION_INTERFACE = *mut _PNP_LOCATION_INTERFACE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ARBITER_ACTION {
    ArbiterActionTestAllocation = 0,
    ArbiterActionRetestAllocation = 1,
    ArbiterActionCommitAllocation = 2,
    ArbiterActionRollbackAllocation = 3,
    ArbiterActionQueryAllocatedResources = 4,
    ArbiterActionWriteReservedResources = 5,
    ArbiterActionQueryConflict = 6,
    ArbiterActionQueryArbitrate = 7,
    ArbiterActionAddReserved = 8,
    ArbiterActionBootAllocation = 9,
}
pub use self::_ARBITER_ACTION as ARBITER_ACTION;
pub type PARBITER_ACTION = *mut _ARBITER_ACTION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _ARBITER_CONFLICT_INFO {
    pub OwningObject: PDEVICE_OBJECT,
    pub Start: ULONGLONG,
    pub End: ULONGLONG,
}
#[test]
fn bindgen_test_layout__ARBITER_CONFLICT_INFO() {
    assert_eq!(::core::mem::size_of::<_ARBITER_CONFLICT_INFO>() , 24usize);
    assert_eq!(::core::mem::align_of::<_ARBITER_CONFLICT_INFO>() , 8usize);
}
impl Clone for _ARBITER_CONFLICT_INFO {
    fn clone(&self) -> Self { *self }
}
pub use self::_ARBITER_CONFLICT_INFO as ARBITER_CONFLICT_INFO;
pub type PARBITER_CONFLICT_INFO = *mut _ARBITER_CONFLICT_INFO;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _ARBITER_TEST_ALLOCATION_PARAMETERS {
    pub ArbitrationList: PLIST_ENTRY,
    pub AllocateFromCount: ULONG,
    pub AllocateFrom: PCM_PARTIAL_RESOURCE_DESCRIPTOR,
}
#[test]
fn bindgen_test_layout__ARBITER_TEST_ALLOCATION_PARAMETERS() {
    assert_eq!(::core::mem::size_of::<_ARBITER_TEST_ALLOCATION_PARAMETERS>() ,
               24usize);
    assert_eq!(::core::mem::align_of::<_ARBITER_TEST_ALLOCATION_PARAMETERS>()
               , 8usize);
}
impl Clone for _ARBITER_TEST_ALLOCATION_PARAMETERS {
    fn clone(&self) -> Self { *self }
}
pub use self::_ARBITER_TEST_ALLOCATION_PARAMETERS as
        ARBITER_TEST_ALLOCATION_PARAMETERS;
pub type PARBITER_TEST_ALLOCATION_PARAMETERS =
    *mut _ARBITER_TEST_ALLOCATION_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _ARBITER_RETEST_ALLOCATION_PARAMETERS {
    pub ArbitrationList: PLIST_ENTRY,
    pub AllocateFromCount: ULONG,
    pub AllocateFrom: PCM_PARTIAL_RESOURCE_DESCRIPTOR,
}
#[test]
fn bindgen_test_layout__ARBITER_RETEST_ALLOCATION_PARAMETERS() {
    assert_eq!(::core::mem::size_of::<_ARBITER_RETEST_ALLOCATION_PARAMETERS>()
               , 24usize);
    assert_eq!(::core::mem::align_of::<_ARBITER_RETEST_ALLOCATION_PARAMETERS>()
               , 8usize);
}
impl Clone for _ARBITER_RETEST_ALLOCATION_PARAMETERS {
    fn clone(&self) -> Self { *self }
}
pub use self::_ARBITER_RETEST_ALLOCATION_PARAMETERS as
        ARBITER_RETEST_ALLOCATION_PARAMETERS;
pub type PARBITER_RETEST_ALLOCATION_PARAMETERS =
    *mut _ARBITER_RETEST_ALLOCATION_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _ARBITER_BOOT_ALLOCATION_PARAMETERS {
    pub ArbitrationList: PLIST_ENTRY,
}
#[test]
fn bindgen_test_layout__ARBITER_BOOT_ALLOCATION_PARAMETERS() {
    assert_eq!(::core::mem::size_of::<_ARBITER_BOOT_ALLOCATION_PARAMETERS>() ,
               8usize);
    assert_eq!(::core::mem::align_of::<_ARBITER_BOOT_ALLOCATION_PARAMETERS>()
               , 8usize);
}
impl Clone for _ARBITER_BOOT_ALLOCATION_PARAMETERS {
    fn clone(&self) -> Self { *self }
}
pub use self::_ARBITER_BOOT_ALLOCATION_PARAMETERS as
        ARBITER_BOOT_ALLOCATION_PARAMETERS;
pub type PARBITER_BOOT_ALLOCATION_PARAMETERS =
    *mut _ARBITER_BOOT_ALLOCATION_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS {
    pub AllocatedResources: *mut PCM_PARTIAL_RESOURCE_LIST,
}
#[test]
fn bindgen_test_layout__ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS() {
    assert_eq!(::core::mem::size_of::<_ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS>()
               , 8usize);
    assert_eq!(::core::mem::align_of::<_ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS>()
               , 8usize);
}
impl Clone for _ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS {
    fn clone(&self) -> Self { *self }
}
pub use self::_ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS as
        ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS;
pub type PARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS =
    *mut _ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _ARBITER_QUERY_CONFLICT_PARAMETERS {
    pub PhysicalDeviceObject: PDEVICE_OBJECT,
    pub ConflictingResource: PIO_RESOURCE_DESCRIPTOR,
    pub ConflictCount: PULONG,
    pub Conflicts: *mut PARBITER_CONFLICT_INFO,
}
#[test]
fn bindgen_test_layout__ARBITER_QUERY_CONFLICT_PARAMETERS() {
    assert_eq!(::core::mem::size_of::<_ARBITER_QUERY_CONFLICT_PARAMETERS>() ,
               32usize);
    assert_eq!(::core::mem::align_of::<_ARBITER_QUERY_CONFLICT_PARAMETERS>() ,
               8usize);
}
impl Clone for _ARBITER_QUERY_CONFLICT_PARAMETERS {
    fn clone(&self) -> Self { *self }
}
pub use self::_ARBITER_QUERY_CONFLICT_PARAMETERS as
        ARBITER_QUERY_CONFLICT_PARAMETERS;
pub type PARBITER_QUERY_CONFLICT_PARAMETERS =
    *mut _ARBITER_QUERY_CONFLICT_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _ARBITER_QUERY_ARBITRATE_PARAMETERS {
    pub ArbitrationList: PLIST_ENTRY,
}
#[test]
fn bindgen_test_layout__ARBITER_QUERY_ARBITRATE_PARAMETERS() {
    assert_eq!(::core::mem::size_of::<_ARBITER_QUERY_ARBITRATE_PARAMETERS>() ,
               8usize);
    assert_eq!(::core::mem::align_of::<_ARBITER_QUERY_ARBITRATE_PARAMETERS>()
               , 8usize);
}
impl Clone for _ARBITER_QUERY_ARBITRATE_PARAMETERS {
    fn clone(&self) -> Self { *self }
}
pub use self::_ARBITER_QUERY_ARBITRATE_PARAMETERS as
        ARBITER_QUERY_ARBITRATE_PARAMETERS;
pub type PARBITER_QUERY_ARBITRATE_PARAMETERS =
    *mut _ARBITER_QUERY_ARBITRATE_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _ARBITER_ADD_RESERVED_PARAMETERS {
    pub ReserveDevice: PDEVICE_OBJECT,
}
#[test]
fn bindgen_test_layout__ARBITER_ADD_RESERVED_PARAMETERS() {
    assert_eq!(::core::mem::size_of::<_ARBITER_ADD_RESERVED_PARAMETERS>() ,
               8usize);
    assert_eq!(::core::mem::align_of::<_ARBITER_ADD_RESERVED_PARAMETERS>() ,
               8usize);
}
impl Clone for _ARBITER_ADD_RESERVED_PARAMETERS {
    fn clone(&self) -> Self { *self }
}
pub use self::_ARBITER_ADD_RESERVED_PARAMETERS as
        ARBITER_ADD_RESERVED_PARAMETERS;
pub type PARBITER_ADD_RESERVED_PARAMETERS =
    *mut _ARBITER_ADD_RESERVED_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _ARBITER_PARAMETERS {
    pub Parameters: _ARBITER_PARAMETERS__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _ARBITER_PARAMETERS__bindgen_ty_1 {
    pub TestAllocation: __BindgenUnionField<ARBITER_TEST_ALLOCATION_PARAMETERS>,
    pub RetestAllocation: __BindgenUnionField<ARBITER_RETEST_ALLOCATION_PARAMETERS>,
    pub BootAllocation: __BindgenUnionField<ARBITER_BOOT_ALLOCATION_PARAMETERS>,
    pub QueryAllocatedResources: __BindgenUnionField<ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS>,
    pub QueryConflict: __BindgenUnionField<ARBITER_QUERY_CONFLICT_PARAMETERS>,
    pub QueryArbitrate: __BindgenUnionField<ARBITER_QUERY_ARBITRATE_PARAMETERS>,
    pub AddReserved: __BindgenUnionField<ARBITER_ADD_RESERVED_PARAMETERS>,
    pub bindgen_union_field: [u64; 4usize],
}
#[test]
fn bindgen_test_layout__ARBITER_PARAMETERS__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_ARBITER_PARAMETERS__bindgen_ty_1>() ,
               32usize);
    assert_eq!(::core::mem::align_of::<_ARBITER_PARAMETERS__bindgen_ty_1>() ,
               8usize);
}
impl Clone for _ARBITER_PARAMETERS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__ARBITER_PARAMETERS() {
    assert_eq!(::core::mem::size_of::<_ARBITER_PARAMETERS>() , 32usize);
    assert_eq!(::core::mem::align_of::<_ARBITER_PARAMETERS>() , 8usize);
}
impl Clone for _ARBITER_PARAMETERS {
    fn clone(&self) -> Self { *self }
}
pub use self::_ARBITER_PARAMETERS as ARBITER_PARAMETERS;
pub type PARBITER_PARAMETERS = *mut _ARBITER_PARAMETERS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ARBITER_REQUEST_SOURCE {
    ArbiterRequestUndefined = -1,
    ArbiterRequestLegacyReported = 0,
    ArbiterRequestHalReported = 1,
    ArbiterRequestLegacyAssigned = 2,
    ArbiterRequestPnpDetected = 3,
    ArbiterRequestPnpEnumerated = 4,
}
pub use self::_ARBITER_REQUEST_SOURCE as ARBITER_REQUEST_SOURCE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ARBITER_RESULT {
    ArbiterResultUndefined = -1,
    ArbiterResultSuccess = 0,
    ArbiterResultExternalConflict = 1,
    ArbiterResultNullRequest = 2,
}
pub use self::_ARBITER_RESULT as ARBITER_RESULT;
extern "C" {
    pub fn IoReportResourceForDetection(DriverObject: PDRIVER_OBJECT,
                                        DriverList: PCM_RESOURCE_LIST,
                                        DriverListSize: ULONG,
                                        DeviceObject: PDEVICE_OBJECT,
                                        DeviceList: PCM_RESOURCE_LIST,
                                        DeviceListSize: ULONG,
                                        ConflictDetected: PBOOLEAN)
     -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _ARBITER_LIST_ENTRY {
    pub ListEntry: LIST_ENTRY,
    pub AlternativeCount: ULONG,
    pub Alternatives: PIO_RESOURCE_DESCRIPTOR,
    pub PhysicalDeviceObject: PDEVICE_OBJECT,
    pub RequestSource: ARBITER_REQUEST_SOURCE,
    pub Flags: ULONG,
    pub WorkSpace: LONG_PTR,
    pub InterfaceType: INTERFACE_TYPE,
    pub SlotNumber: ULONG,
    pub BusNumber: ULONG,
    pub Assignment: PCM_PARTIAL_RESOURCE_DESCRIPTOR,
    pub SelectedAlternative: PIO_RESOURCE_DESCRIPTOR,
    pub Result: ARBITER_RESULT,
}
#[test]
fn bindgen_test_layout__ARBITER_LIST_ENTRY() {
    assert_eq!(::core::mem::size_of::<_ARBITER_LIST_ENTRY>() , 96usize);
    assert_eq!(::core::mem::align_of::<_ARBITER_LIST_ENTRY>() , 8usize);
}
impl Clone for _ARBITER_LIST_ENTRY {
    fn clone(&self) -> Self { *self }
}
pub use self::_ARBITER_LIST_ENTRY as ARBITER_LIST_ENTRY;
pub type PARBITER_LIST_ENTRY = *mut _ARBITER_LIST_ENTRY;
pub type PARBITER_HANDLER =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                Action: ARBITER_ACTION,
                                                Parameters:
                                                    PARBITER_PARAMETERS)
                               -> libc::c_long>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _ARBITER_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub ArbiterHandler: PARBITER_HANDLER,
    pub Flags: ULONG,
}
#[test]
fn bindgen_test_layout__ARBITER_INTERFACE() {
    assert_eq!(::core::mem::size_of::<_ARBITER_INTERFACE>() , 48usize);
    assert_eq!(::core::mem::align_of::<_ARBITER_INTERFACE>() , 8usize);
}
impl Clone for _ARBITER_INTERFACE {
    fn clone(&self) -> Self { *self }
}
pub use self::_ARBITER_INTERFACE as ARBITER_INTERFACE;
pub type PARBITER_INTERFACE = *mut _ARBITER_INTERFACE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _RESOURCE_TRANSLATION_DIRECTION {
    TranslateChildToParent = 0,
    TranslateParentToChild = 1,
}
pub use self::_RESOURCE_TRANSLATION_DIRECTION as
        RESOURCE_TRANSLATION_DIRECTION;
pub type PTRANSLATE_RESOURCE_HANDLER =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                Source:
                                                    PCM_PARTIAL_RESOURCE_DESCRIPTOR,
                                                Direction:
                                                    RESOURCE_TRANSLATION_DIRECTION,
                                                AlternativesCount: ULONG,
                                                Alternatives:
                                                    *mut IO_RESOURCE_DESCRIPTOR,
                                                PhysicalDeviceObject:
                                                    PDEVICE_OBJECT,
                                                Target:
                                                    PCM_PARTIAL_RESOURCE_DESCRIPTOR)
                               -> libc::c_long>;
pub type PTRANSLATE_RESOURCE_REQUIREMENTS_HANDLER =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                Source:
                                                    PIO_RESOURCE_DESCRIPTOR,
                                                PhysicalDeviceObject:
                                                    PDEVICE_OBJECT,
                                                TargetCount: PULONG,
                                                Target:
                                                    *mut PIO_RESOURCE_DESCRIPTOR)
                               -> libc::c_long>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _TRANSLATOR_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub TranslateResources: PTRANSLATE_RESOURCE_HANDLER,
    pub TranslateResourceRequirements: PTRANSLATE_RESOURCE_REQUIREMENTS_HANDLER,
}
#[test]
fn bindgen_test_layout__TRANSLATOR_INTERFACE() {
    assert_eq!(::core::mem::size_of::<_TRANSLATOR_INTERFACE>() , 48usize);
    assert_eq!(::core::mem::align_of::<_TRANSLATOR_INTERFACE>() , 8usize);
}
impl Clone for _TRANSLATOR_INTERFACE {
    fn clone(&self) -> Self { *self }
}
pub use self::_TRANSLATOR_INTERFACE as TRANSLATOR_INTERFACE;
pub type PTRANSLATOR_INTERFACE = *mut _TRANSLATOR_INTERFACE;
pub type PHAL_RESET_DISPLAY_PARAMETERS =
    ::core::option::Option<unsafe extern "C" fn(Columns: ULONG, Rows: ULONG)
                               -> libc::c_uchar>;
extern "C" {
    pub fn HalAcquireDisplayOwnership(ResetDisplayParameters:
                                          PHAL_RESET_DISPLAY_PARAMETERS);
}
extern "C" {
    pub fn HalSetBusDataByOffset(BusDataType: BUS_DATA_TYPE, BusNumber: ULONG,
                                 SlotNumber: ULONG, Buffer: PVOID,
                                 Offset: ULONG, Length: ULONG) -> ULONG;
}
extern "C" {
    pub fn HalTranslateBusAddress(InterfaceType: INTERFACE_TYPE,
                                  BusNumber: ULONG,
                                  BusAddress: PHYSICAL_ADDRESS,
                                  AddressSpace: PULONG,
                                  TranslatedAddress: PPHYSICAL_ADDRESS)
     -> BOOLEAN;
}
extern "C" {
    pub fn HalAllocateCrashDumpRegisters(AdapterObject: PADAPTER_OBJECT,
                                         NumberOfMapRegisters: PULONG)
     -> PVOID;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _HAL_DMA_CRASH_DUMP_REGISTER_TYPE {
    HalDmaCrashDumpRegisterSet1 = 0,
    HalDmaCrashDumpRegisterSet2 = 1,
    HalDmaCrashDumpRegisterSetMax = 2,
}
pub use self::_HAL_DMA_CRASH_DUMP_REGISTER_TYPE as
        HAL_DMA_CRASH_DUMP_REGISTER_TYPE;
pub type PHAL_DMA_CRASH_DUMP_REGISTER_TYPE =
    *mut _HAL_DMA_CRASH_DUMP_REGISTER_TYPE;
extern "C" {
    pub fn HalDmaAllocateCrashDumpRegistersEx(Adapter: PADAPTER_OBJECT,
                                              NumberOfMapRegisters: ULONG,
                                              Type:
                                                  HAL_DMA_CRASH_DUMP_REGISTER_TYPE,
                                              MapRegisterBase: *mut PVOID,
                                              MapRegistersAvailable: PULONG)
     -> NTSTATUS;
}
extern "C" {
    pub fn HalDmaFreeCrashDumpRegistersEx(Adapter: PADAPTER_OBJECT,
                                          Type:
                                              HAL_DMA_CRASH_DUMP_REGISTER_TYPE)
     -> NTSTATUS;
}
extern "C" {
    pub fn HalGetBusDataByOffset(BusDataType: BUS_DATA_TYPE, BusNumber: ULONG,
                                 SlotNumber: ULONG, Buffer: PVOID,
                                 Offset: ULONG, Length: ULONG) -> ULONG;
}
extern "C" {
    pub fn HalGetAdapter(DeviceDescription: PDEVICE_DESCRIPTION,
                         NumberOfMapRegisters: PULONG) -> PADAPTER_OBJECT;
}
pub type pHalHandlerForBus =
    ::core::option::Option<unsafe extern "C" fn(InterfaceType: INTERFACE_TYPE,
                                                BusNumber: ULONG)
                               -> *mut _BUS_HANDLER>;
pub type pHalReferenceBusHandler =
    ::core::option::Option<unsafe extern "C" fn(BusHandler: PBUS_HANDLER)>;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _HAL_QUERY_INFORMATION_CLASS {
    HalInstalledBusInformation = 0,
    HalProfileSourceInformation = 1,
    HalInformationClassUnused1 = 2,
    HalPowerInformation = 3,
    HalProcessorSpeedInformation = 4,
    HalCallbackInformation = 5,
    HalMapRegisterInformation = 6,
    HalMcaLogInformation = 7,
    HalFrameBufferCachingInformation = 8,
    HalDisplayBiosInformation = 9,
    HalProcessorFeatureInformation = 10,
    HalNumaTopologyInterface = 11,
    HalErrorInformation = 12,
    HalCmcLogInformation = 13,
    HalCpeLogInformation = 14,
    HalQueryMcaInterface = 15,
    HalQueryAMLIIllegalIOPortAddresses = 16,
    HalQueryMaxHotPlugMemoryAddress = 17,
    HalPartitionIpiInterface = 18,
    HalPlatformInformation = 19,
    HalQueryProfileSourceList = 20,
    HalInitLogInformation = 21,
    HalFrequencyInformation = 22,
    HalProcessorBrandString = 23,
    HalHypervisorInformation = 24,
    HalPlatformTimerInformation = 25,
    HalAcpiAuditInformation = 26,
    HalIrtInformation = 27,
    HalSecondaryInterruptInformation = 28,
    HalParkingPageInformation = 29,
    HalNumaRangeTableInformation = 30,
    HalChannelTopologyInformation = 31,
    HalExternalCacheInformation = 32,
    HalQueryDebuggerInformation = 33,
    HalFwBootPerformanceInformation = 34,
    HalFwS3PerformanceInformation = 35,
    HalGetChannelPowerInformation = 36,
    HalQueryStateElementInformation = 37,
    HalPsciInformation = 38,
    HalInterruptControllerInformation = 39,
    HalQueryIommuReservedRegionInformation = 40,
    HalQueryArmErrataInformation = 41,
    HalQueryProcessorEfficiencyInformation = 42,
    HalQueryAcpiWakeAlarmSystemPowerStateInformation = 43,
    HalQueryProfileNumberOfCounters = 44,
}
pub use self::_HAL_QUERY_INFORMATION_CLASS as HAL_QUERY_INFORMATION_CLASS;
pub type PHAL_QUERY_INFORMATION_CLASS = *mut _HAL_QUERY_INFORMATION_CLASS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _HAL_SET_INFORMATION_CLASS {
    HalProfileSourceInterval = 0,
    HalProfileSourceInterruptHandler = 1,
    HalMcaRegisterDriver = 2,
    HalKernelErrorHandler = 3,
    HalCmcRegisterDriver = 4,
    HalCpeRegisterDriver = 5,
    HalMcaLog = 6,
    HalCmcLog = 7,
    HalCpeLog = 8,
    HalGenerateCmcInterrupt = 9,
    HalProfileSourceTimerHandler = 10,
    HalEnlightenment = 11,
    HalProfileDpgoSourceInterruptHandler = 12,
    HalRegisterSecondaryInterruptInterface = 13,
    HalSetChannelPowerInformation = 14,
    HalI386ExceptionChainTerminatorInformation = 15,
    HalSetResetParkDisposition = 16,
}
pub use self::_HAL_SET_INFORMATION_CLASS as HAL_SET_INFORMATION_CLASS;
pub type PHAL_SET_INFORMATION_CLASS = *mut _HAL_SET_INFORMATION_CLASS;
pub type pHalQuerySystemInformation =
    ::core::option::Option<unsafe extern "C" fn(InformationClass:
                                                    HAL_QUERY_INFORMATION_CLASS,
                                                BufferSize: ULONG,
                                                Buffer: PVOID,
                                                ReturnedLength: PULONG)
                               -> libc::c_long>;
pub type pHalSetSystemInformation =
    ::core::option::Option<unsafe extern "C" fn(InformationClass:
                                                    HAL_SET_INFORMATION_CLASS,
                                                BufferSize: ULONG,
                                                Buffer: PVOID)
                               -> libc::c_long>;
pub type pHalExamineMBR =
    ::core::option::Option<unsafe extern "C" fn(DeviceObject: PDEVICE_OBJECT,
                                                SectorSize: ULONG,
                                                MBRTypeIdentifier: ULONG,
                                                Buffer: *mut PVOID)>;
pub type pHalIoReadPartitionTable =
    ::core::option::Option<unsafe extern "C" fn(DeviceObject: PDEVICE_OBJECT,
                                                SectorSize: ULONG,
                                                ReturnRecognizedPartitions:
                                                    BOOLEAN,
                                                PartitionBuffer:
                                                    *mut *mut _DRIVE_LAYOUT_INFORMATION)
                               -> libc::c_long>;
pub type pHalIoSetPartitionInformation =
    ::core::option::Option<unsafe extern "C" fn(DeviceObject: PDEVICE_OBJECT,
                                                SectorSize: ULONG,
                                                PartitionNumber: ULONG,
                                                PartitionType: ULONG)
                               -> libc::c_long>;
pub type pHalIoWritePartitionTable =
    ::core::option::Option<unsafe extern "C" fn(DeviceObject: PDEVICE_OBJECT,
                                                SectorSize: ULONG,
                                                SectorsPerTrack: ULONG,
                                                NumberOfHeads: ULONG,
                                                PartitionBuffer:
                                                    *mut _DRIVE_LAYOUT_INFORMATION)
                               -> libc::c_long>;
pub type pHalQueryBusSlots =
    ::core::option::Option<unsafe extern "C" fn(BusHandler: PBUS_HANDLER,
                                                BufferSize: ULONG,
                                                SlotNumbers: PULONG,
                                                ReturnedLength: PULONG)
                               -> libc::c_long>;
pub type pHalInitPnpDriver =
    ::core::option::Option<unsafe extern "C" fn() -> libc::c_long>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PM_DISPATCH_TABLE {
    pub Signature: ULONG,
    pub Version: ULONG,
    pub Function: [PVOID; 1usize],
}
#[test]
fn bindgen_test_layout__PM_DISPATCH_TABLE() {
    assert_eq!(::core::mem::size_of::<_PM_DISPATCH_TABLE>() , 16usize);
    assert_eq!(::core::mem::align_of::<_PM_DISPATCH_TABLE>() , 8usize);
}
impl Clone for _PM_DISPATCH_TABLE {
    fn clone(&self) -> Self { *self }
}
pub use self::_PM_DISPATCH_TABLE as PM_DISPATCH_TABLE;
pub type PPM_DISPATCH_TABLE = *mut _PM_DISPATCH_TABLE;
pub type pHalInitPowerManagement =
    ::core::option::Option<unsafe extern "C" fn(PmDriverDispatchTable:
                                                    PPM_DISPATCH_TABLE,
                                                PmHalDispatchTable:
                                                    *mut PPM_DISPATCH_TABLE)
                               -> libc::c_long>;
pub type pHalGetDmaAdapter =
    ::core::option::Option<unsafe extern "C" fn(PhysicalDeviceObject: PVOID,
                                                DeviceDescriptor:
                                                    *mut _DEVICE_DESCRIPTION,
                                                NumberOfMapRegisters: PULONG)
                               -> *mut _DMA_ADAPTER>;
pub type pHalGetInterruptTranslator =
    ::core::option::Option<unsafe extern "C" fn(ParentInterfaceType:
                                                    INTERFACE_TYPE,
                                                ParentBusNumber: ULONG,
                                                BridgeInterfaceType:
                                                    INTERFACE_TYPE,
                                                Size: USHORT, Version: USHORT,
                                                Translator:
                                                    PTRANSLATOR_INTERFACE,
                                                BridgeBusNumber: PULONG)
                               -> libc::c_long>;
pub type pHalTranslateBusAddress =
    ::core::option::Option<unsafe extern "C" fn(InterfaceType: INTERFACE_TYPE,
                                                BusNumber: ULONG,
                                                BusAddress: PHYSICAL_ADDRESS,
                                                AddressSpace: PULONG,
                                                TranslatedAddress:
                                                    PPHYSICAL_ADDRESS)
                               -> libc::c_uchar>;
pub type pHalAssignSlotResources =
    ::core::option::Option<unsafe extern "C" fn(RegistryPath: PUNICODE_STRING,
                                                DriverClassName:
                                                    PUNICODE_STRING,
                                                DriverObject: PDRIVER_OBJECT,
                                                DeviceObject: PDEVICE_OBJECT,
                                                BusType: INTERFACE_TYPE,
                                                BusNumber: ULONG,
                                                SlotNumber: ULONG,
                                                AllocatedResources:
                                                    *mut PCM_RESOURCE_LIST)
                               -> libc::c_long>;
pub type pHalHaltSystem = ::core::option::Option<unsafe extern "C" fn()>;
pub type pHalResetDisplay =
    ::core::option::Option<unsafe extern "C" fn() -> libc::c_uchar>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _MAP_REGISTER_ENTRY {
    pub MapRegister: PVOID,
    pub WriteToDevice: BOOLEAN,
}
#[test]
fn bindgen_test_layout__MAP_REGISTER_ENTRY() {
    assert_eq!(::core::mem::size_of::<_MAP_REGISTER_ENTRY>() , 16usize);
    assert_eq!(::core::mem::align_of::<_MAP_REGISTER_ENTRY>() , 8usize);
}
impl Clone for _MAP_REGISTER_ENTRY {
    fn clone(&self) -> Self { *self }
}
pub use self::_MAP_REGISTER_ENTRY as MAP_REGISTER_ENTRY;
pub type PMAP_REGISTER_ENTRY = *mut _MAP_REGISTER_ENTRY;
pub type pHalVectorToIDTEntry =
    ::core::option::Option<unsafe extern "C" fn(Vector: ULONG)
                               -> libc::c_uchar>;
pub type pHalFindBusAddressTranslation =
    ::core::option::Option<unsafe extern "C" fn(BusAddress: PHYSICAL_ADDRESS,
                                                AddressSpace: PULONG,
                                                TranslatedAddress:
                                                    PPHYSICAL_ADDRESS,
                                                Context: PULONG_PTR,
                                                NextBus: BOOLEAN)
                               -> libc::c_uchar>;
pub type pHalStartMirroring =
    ::core::option::Option<unsafe extern "C" fn() -> libc::c_long>;
pub type pHalEndMirroring =
    ::core::option::Option<unsafe extern "C" fn(PassNumber: ULONG)
                               -> libc::c_long>;
pub type pHalMirrorPhysicalMemory =
    ::core::option::Option<unsafe extern "C" fn(PhysicalAddress:
                                                    PHYSICAL_ADDRESS,
                                                NumberOfBytes: LARGE_INTEGER)
                               -> libc::c_long>;
pub type pHalMirrorVerify =
    ::core::option::Option<unsafe extern "C" fn(PhysicalAddress:
                                                    PHYSICAL_ADDRESS,
                                                NumberOfBytes: LARGE_INTEGER)
                               -> libc::c_long>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_20 {
    pub Type: UCHAR,
    pub Valid: BOOLEAN,
    pub Reserved: [UCHAR; 2usize],
    pub TranslatedAddress: PUCHAR,
    pub Length: ULONG,
}
#[test]
fn bindgen_test_layout__bindgen_ty_20() {
    assert_eq!(::core::mem::size_of::<_bindgen_ty_20>() , 24usize);
    assert_eq!(::core::mem::align_of::<_bindgen_ty_20>() , 8usize);
}
impl Clone for _bindgen_ty_20 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_20 as DEBUG_DEVICE_ADDRESS;
pub type PDEBUG_DEVICE_ADDRESS = *mut _bindgen_ty_20;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_21 {
    pub Start: PHYSICAL_ADDRESS,
    pub MaxEnd: PHYSICAL_ADDRESS,
    pub VirtualAddress: PVOID,
    pub Length: ULONG,
    pub Cached: BOOLEAN,
    pub Aligned: BOOLEAN,
}
#[test]
fn bindgen_test_layout__bindgen_ty_21() {
    assert_eq!(::core::mem::size_of::<_bindgen_ty_21>() , 32usize);
    assert_eq!(::core::mem::align_of::<_bindgen_ty_21>() , 8usize);
}
impl Clone for _bindgen_ty_21 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_21 as DEBUG_MEMORY_REQUIREMENTS;
pub type PDEBUG_MEMORY_REQUIREMENTS = *mut _bindgen_ty_21;
pub const KdNameSpacePCI: _bindgen_ty_22 = _bindgen_ty_22::KdNameSpacePCI;
pub const KdNameSpaceACPI: _bindgen_ty_22 = _bindgen_ty_22::KdNameSpaceACPI;
pub const KdNameSpaceAny: _bindgen_ty_22 = _bindgen_ty_22::KdNameSpaceAny;
pub const KdNameSpaceNone: _bindgen_ty_22 = _bindgen_ty_22::KdNameSpaceNone;
pub const KdNameSpaceMax: _bindgen_ty_22 = _bindgen_ty_22::KdNameSpaceMax;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_22 {
    KdNameSpacePCI = 0,
    KdNameSpaceACPI = 1,
    KdNameSpaceAny = 2,
    KdNameSpaceNone = 3,
    KdNameSpaceMax = 4,
}
pub use self::_bindgen_ty_22 as KD_NAMESPACE_ENUM;
pub type PKD_NAMESPACE_ENUM = *mut _bindgen_ty_22;
pub const KdConfigureDeviceAndContinue: _bindgen_ty_23 =
    _bindgen_ty_23::KdConfigureDeviceAndContinue;
pub const KdSkipDeviceAndContinue: _bindgen_ty_23 =
    _bindgen_ty_23::KdSkipDeviceAndContinue;
pub const KdConfigureDeviceAndStop: _bindgen_ty_23 =
    _bindgen_ty_23::KdConfigureDeviceAndStop;
pub const KdSkipDeviceAndStop: _bindgen_ty_23 =
    _bindgen_ty_23::KdSkipDeviceAndStop;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_23 {
    KdConfigureDeviceAndContinue = 0,
    KdSkipDeviceAndContinue = 1,
    KdConfigureDeviceAndStop = 2,
    KdSkipDeviceAndStop = 3,
}
pub use self::_bindgen_ty_23 as KD_CALLBACK_ACTION;
pub type PKD_CALLBACK_ACTION = *mut _bindgen_ty_23;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DEBUG_TRANSPORT_DATA {
    pub HwContextSize: ULONG,
    pub UseSerialFraming: BOOLEAN,
}
#[test]
fn bindgen_test_layout__DEBUG_TRANSPORT_DATA() {
    assert_eq!(::core::mem::size_of::<_DEBUG_TRANSPORT_DATA>() , 8usize);
    assert_eq!(::core::mem::align_of::<_DEBUG_TRANSPORT_DATA>() , 4usize);
}
impl Clone for _DEBUG_TRANSPORT_DATA {
    fn clone(&self) -> Self { *self }
}
pub use self::_DEBUG_TRANSPORT_DATA as DEBUG_TRANSPORT_DATA;
pub type PDEBUG_TRANSPORT_DATA = *mut _DEBUG_TRANSPORT_DATA;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DEBUG_DEVICE_DESCRIPTOR {
    pub Bus: ULONG,
    pub Slot: ULONG,
    pub Segment: USHORT,
    pub VendorID: USHORT,
    pub DeviceID: USHORT,
    pub BaseClass: UCHAR,
    pub SubClass: UCHAR,
    pub ProgIf: UCHAR,
    pub __bindgen_anon_1: _DEBUG_DEVICE_DESCRIPTOR__bindgen_ty_1,
    pub Initialized: BOOLEAN,
    pub Configured: BOOLEAN,
    pub BaseAddress: [DEBUG_DEVICE_ADDRESS; 6usize],
    pub Memory: DEBUG_MEMORY_REQUIREMENTS,
    pub PortType: USHORT,
    pub PortSubtype: USHORT,
    pub OemData: PVOID,
    pub OemDataLength: ULONG,
    pub NameSpace: KD_NAMESPACE_ENUM,
    pub NameSpacePath: PWCHAR,
    pub NameSpacePathLength: ULONG,
    pub TransportType: ULONG,
    pub TransportData: DEBUG_TRANSPORT_DATA,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DEBUG_DEVICE_DESCRIPTOR__bindgen_ty_1 {
    pub Flags: __BindgenUnionField<UCHAR>,
    pub __bindgen_anon_1: __BindgenUnionField<_DEBUG_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DEBUG_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u8,
}
#[test]
fn bindgen_test_layout__DEBUG_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_DEBUG_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>()
               , 1usize);
    assert_eq!(::core::mem::align_of::<_DEBUG_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>()
               , 1usize);
}
impl Clone for _DEBUG_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _DEBUG_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn DbgHalScratchAllocated(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                        0u32) as u8)
        }
    }
    #[inline]
    pub fn set_DbgHalScratchAllocated(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 0u32) & (1usize as u8);
    }
    #[inline]
    pub fn DbgBarsMapped(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u8)) >>
                                        1u32) as u8)
        }
    }
    #[inline]
    pub fn set_DbgBarsMapped(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(2usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 1u32) & (2usize as u8);
    }
    #[inline]
    pub fn DbgScratchAllocated(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u8)) >>
                                        2u32) as u8)
        }
    }
    #[inline]
    pub fn set_DbgScratchAllocated(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(4usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 2u32) & (4usize as u8);
    }
}
#[test]
fn bindgen_test_layout__DEBUG_DEVICE_DESCRIPTOR__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_DEBUG_DEVICE_DESCRIPTOR__bindgen_ty_1>()
               , 1usize);
    assert_eq!(::core::mem::align_of::<_DEBUG_DEVICE_DESCRIPTOR__bindgen_ty_1>()
               , 1usize);
}
impl Clone for _DEBUG_DEVICE_DESCRIPTOR__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__DEBUG_DEVICE_DESCRIPTOR() {
    assert_eq!(::core::mem::size_of::<_DEBUG_DEVICE_DESCRIPTOR>() , 248usize);
    assert_eq!(::core::mem::align_of::<_DEBUG_DEVICE_DESCRIPTOR>() , 8usize);
}
impl Clone for _DEBUG_DEVICE_DESCRIPTOR {
    fn clone(&self) -> Self { *self }
}
pub use self::_DEBUG_DEVICE_DESCRIPTOR as DEBUG_DEVICE_DESCRIPTOR;
pub type PDEBUG_DEVICE_DESCRIPTOR = *mut _DEBUG_DEVICE_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_DEBUGGING_DEVICE_IN_USE {
    pub Segment: USHORT,
    pub Bus: ULONG,
    pub Slot: ULONG,
}
#[test]
fn bindgen_test_layout__PCI_DEBUGGING_DEVICE_IN_USE() {
    assert_eq!(::core::mem::size_of::<_PCI_DEBUGGING_DEVICE_IN_USE>() ,
               12usize);
    assert_eq!(::core::mem::align_of::<_PCI_DEBUGGING_DEVICE_IN_USE>() ,
               4usize);
}
impl Clone for _PCI_DEBUGGING_DEVICE_IN_USE {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_DEBUGGING_DEVICE_IN_USE as PCI_DEBUGGING_DEVICE_IN_USE;
pub type PPCI_DEBUGGING_DEVICE_IN_USE = *mut _PCI_DEBUGGING_DEVICE_IN_USE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _ACPI_DEBUGGING_DEVICE_IN_USE {
    pub NameSpacePathLength: ULONG,
    pub NameSpacePath: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__ACPI_DEBUGGING_DEVICE_IN_USE() {
    assert_eq!(::core::mem::size_of::<_ACPI_DEBUGGING_DEVICE_IN_USE>() ,
               8usize);
    assert_eq!(::core::mem::align_of::<_ACPI_DEBUGGING_DEVICE_IN_USE>() ,
               4usize);
}
impl Clone for _ACPI_DEBUGGING_DEVICE_IN_USE {
    fn clone(&self) -> Self { *self }
}
pub use self::_ACPI_DEBUGGING_DEVICE_IN_USE as ACPI_DEBUGGING_DEVICE_IN_USE;
pub type PACPI_DEBUGGING_DEVICE_IN_USE = *mut _ACPI_DEBUGGING_DEVICE_IN_USE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DEBUGGING_DEVICE_IN_USE {
    pub NameSpace: KD_NAMESPACE_ENUM,
    pub StructureLength: ULONG,
    pub __bindgen_anon_1: _DEBUGGING_DEVICE_IN_USE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DEBUGGING_DEVICE_IN_USE__bindgen_ty_1 {
    pub AcpiDevice: __BindgenUnionField<ACPI_DEBUGGING_DEVICE_IN_USE>,
    pub PciDevice: __BindgenUnionField<PCI_DEBUGGING_DEVICE_IN_USE>,
    pub bindgen_union_field: [u32; 3usize],
}
#[test]
fn bindgen_test_layout__DEBUGGING_DEVICE_IN_USE__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_DEBUGGING_DEVICE_IN_USE__bindgen_ty_1>()
               , 12usize);
    assert_eq!(::core::mem::align_of::<_DEBUGGING_DEVICE_IN_USE__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _DEBUGGING_DEVICE_IN_USE__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__DEBUGGING_DEVICE_IN_USE() {
    assert_eq!(::core::mem::size_of::<_DEBUGGING_DEVICE_IN_USE>() , 20usize);
    assert_eq!(::core::mem::align_of::<_DEBUGGING_DEVICE_IN_USE>() , 4usize);
}
impl Clone for _DEBUGGING_DEVICE_IN_USE {
    fn clone(&self) -> Self { *self }
}
pub use self::_DEBUGGING_DEVICE_IN_USE as DEBUGGING_DEVICE_IN_USE;
pub type PDEBUGGING_DEVICE_IN_USE = *mut _DEBUGGING_DEVICE_IN_USE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DEBUGGING_DEVICE_IN_USE_INFORMATION {
    pub DeviceCount: ULONG,
    pub Device: [DEBUGGING_DEVICE_IN_USE; 1usize],
}
#[test]
fn bindgen_test_layout__DEBUGGING_DEVICE_IN_USE_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_DEBUGGING_DEVICE_IN_USE_INFORMATION>()
               , 24usize);
    assert_eq!(::core::mem::align_of::<_DEBUGGING_DEVICE_IN_USE_INFORMATION>()
               , 4usize);
}
impl Clone for _DEBUGGING_DEVICE_IN_USE_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_DEBUGGING_DEVICE_IN_USE_INFORMATION as
        DEBUGGING_DEVICE_IN_USE_INFORMATION;
pub type PDEBUGGING_DEVICE_IN_USE_INFORMATION =
    *mut _DEBUGGING_DEVICE_IN_USE_INFORMATION;
pub type PDEBUG_DEVICE_FOUND_FUNCTION =
    ::core::option::Option<unsafe extern "C" fn(Device:
                                                    PDEBUG_DEVICE_DESCRIPTOR)
                               -> _bindgen_ty_23>;
pub type pKdEnumerateDebuggingDevices =
    ::core::option::Option<unsafe extern "C" fn(LoaderBlock: PVOID,
                                                Device:
                                                    PDEBUG_DEVICE_DESCRIPTOR,
                                                Callback:
                                                    PDEBUG_DEVICE_FOUND_FUNCTION)
                               -> libc::c_long>;
pub type pKdSetupPciDeviceForDebugging =
    ::core::option::Option<unsafe extern "C" fn(LoaderBlock: PVOID,
                                                PciDevice:
                                                    PDEBUG_DEVICE_DESCRIPTOR)
                               -> libc::c_long>;
pub type pKdReleasePciDeviceForDebugging =
    ::core::option::Option<unsafe extern "C" fn(PciDevice:
                                                    PDEBUG_DEVICE_DESCRIPTOR)
                               -> libc::c_long>;
pub type pKdSetupIntegratedDeviceForDebugging =
    ::core::option::Option<unsafe extern "C" fn(LoaderBlock: PVOID,
                                                IntegratedDevice:
                                                    PDEBUG_DEVICE_DESCRIPTOR)
                               -> libc::c_long>;
pub type pKdReleaseIntegratedDeviceForDebugging =
    ::core::option::Option<unsafe extern "C" fn(IntegratedDevice:
                                                    PDEBUG_DEVICE_DESCRIPTOR)
                               -> libc::c_long>;
pub type pKdGetAcpiTablePhase0 =
    ::core::option::Option<unsafe extern "C" fn(LoaderBlock:
                                                    *mut _LOADER_PARAMETER_BLOCK,
                                                Signature: ULONG)
                               -> *mut libc::c_void>;
pub type pKdCheckPowerButton = ::core::option::Option<unsafe extern "C" fn()>;
pub type pHalEndOfBoot = ::core::option::Option<unsafe extern "C" fn()>;
pub type pKdMapPhysicalMemory64 =
    ::core::option::Option<unsafe extern "C" fn(PhysicalAddress:
                                                    PHYSICAL_ADDRESS,
                                                NumberPages: ULONG,
                                                FlushCurrentTLB: BOOLEAN)
                               -> *mut libc::c_void>;
pub type pKdUnmapVirtualAddress =
    ::core::option::Option<unsafe extern "C" fn(VirtualAddress: PVOID,
                                                NumberPages: ULONG,
                                                FlushCurrentTLB: BOOLEAN)>;
pub type pKdGetPciDataByOffset =
    ::core::option::Option<unsafe extern "C" fn(BusNumber: ULONG,
                                                SlotNumber: ULONG,
                                                Buffer: PVOID, Offset: ULONG,
                                                Length: ULONG)
                               -> libc::c_ulong>;
pub type pKdSetPciDataByOffset =
    ::core::option::Option<unsafe extern "C" fn(BusNumber: ULONG,
                                                SlotNumber: ULONG,
                                                Buffer: PVOID, Offset: ULONG,
                                                Length: ULONG)
                               -> libc::c_ulong>;
pub type pHalGetAcpiTable =
    ::core::option::Option<unsafe extern "C" fn(Signature: ULONG,
                                                OemId: PCSTR,
                                                OemTableId: PCSTR)
                               -> *mut libc::c_void>;
pub type PCI_ERROR_HANDLER_CALLBACK =
    ::core::option::Option<unsafe extern "C" fn()>;
pub type pHalSetPciErrorHandlerCallback =
    ::core::option::Option<unsafe extern "C" fn(Callback:
                                                    PCI_ERROR_HANDLER_CALLBACK)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_24 {
    pub Version: ULONG,
    pub HalQuerySystemInformation: pHalQuerySystemInformation,
    pub HalSetSystemInformation: pHalSetSystemInformation,
    pub HalQueryBusSlots: pHalQueryBusSlots,
    pub Spare1: ULONG,
    pub HalExamineMBR: pHalExamineMBR,
    pub HalIoReadPartitionTable: pHalIoReadPartitionTable,
    pub HalIoSetPartitionInformation: pHalIoSetPartitionInformation,
    pub HalIoWritePartitionTable: pHalIoWritePartitionTable,
    pub HalReferenceHandlerForBus: pHalHandlerForBus,
    pub HalReferenceBusHandler: pHalReferenceBusHandler,
    pub HalDereferenceBusHandler: pHalReferenceBusHandler,
    pub HalInitPnpDriver: pHalInitPnpDriver,
    pub HalInitPowerManagement: pHalInitPowerManagement,
    pub HalGetDmaAdapter: pHalGetDmaAdapter,
    pub HalGetInterruptTranslator: pHalGetInterruptTranslator,
    pub HalStartMirroring: pHalStartMirroring,
    pub HalEndMirroring: pHalEndMirroring,
    pub HalMirrorPhysicalMemory: pHalMirrorPhysicalMemory,
    pub HalEndOfBoot: pHalEndOfBoot,
    pub HalMirrorVerify: pHalMirrorVerify,
    pub HalGetCachedAcpiTable: pHalGetAcpiTable,
    pub HalSetPciErrorHandlerCallback: pHalSetPciErrorHandlerCallback,
}
#[test]
fn bindgen_test_layout__bindgen_ty_24() {
    assert_eq!(::core::mem::size_of::<_bindgen_ty_24>() , 184usize);
    assert_eq!(::core::mem::align_of::<_bindgen_ty_24>() , 8usize);
}
impl Clone for _bindgen_ty_24 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_24 as HAL_DISPATCH;
pub type PHAL_DISPATCH = *mut _bindgen_ty_24;
extern "C" {
    #[link_name = "HalDispatchTable"]
    pub static mut HalDispatchTable: PHAL_DISPATCH;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _HAL_BUS_INFORMATION {
    pub BusType: INTERFACE_TYPE,
    pub ConfigurationType: BUS_DATA_TYPE,
    pub BusNumber: ULONG,
    pub Reserved: ULONG,
}
#[test]
fn bindgen_test_layout__HAL_BUS_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_HAL_BUS_INFORMATION>() , 16usize);
    assert_eq!(::core::mem::align_of::<_HAL_BUS_INFORMATION>() , 4usize);
}
impl Clone for _HAL_BUS_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_HAL_BUS_INFORMATION as HAL_BUS_INFORMATION;
pub type PHAL_BUS_INFORMATION = *mut _HAL_BUS_INFORMATION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _HAL_DISPLAY_BIOS_INFORMATION {
    HalDisplayInt10Bios = 0,
    HalDisplayEmulatedBios = 1,
    HalDisplayNoBios = 2,
}
pub use self::_HAL_DISPLAY_BIOS_INFORMATION as HAL_DISPLAY_BIOS_INFORMATION;
pub type PHAL_DISPLAY_BIOS_INFORMATION = *mut _HAL_DISPLAY_BIOS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _HAL_POWER_INFORMATION {
    pub TBD: ULONG,
}
#[test]
fn bindgen_test_layout__HAL_POWER_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_HAL_POWER_INFORMATION>() , 4usize);
    assert_eq!(::core::mem::align_of::<_HAL_POWER_INFORMATION>() , 4usize);
}
impl Clone for _HAL_POWER_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_HAL_POWER_INFORMATION as HAL_POWER_INFORMATION;
pub type PHAL_POWER_INFORMATION = *mut _HAL_POWER_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _HAL_PROCESSOR_SPEED_INFO {
    pub ProcessorSpeed: ULONG,
}
#[test]
fn bindgen_test_layout__HAL_PROCESSOR_SPEED_INFO() {
    assert_eq!(::core::mem::size_of::<_HAL_PROCESSOR_SPEED_INFO>() , 4usize);
    assert_eq!(::core::mem::align_of::<_HAL_PROCESSOR_SPEED_INFO>() , 4usize);
}
impl Clone for _HAL_PROCESSOR_SPEED_INFO {
    fn clone(&self) -> Self { *self }
}
pub use self::_HAL_PROCESSOR_SPEED_INFO as HAL_PROCESSOR_SPEED_INFORMATION;
pub type PHAL_PROCESSOR_SPEED_INFORMATION = *mut _HAL_PROCESSOR_SPEED_INFO;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _HAL_CALLBACKS {
    pub SetSystemInformation: PCALLBACK_OBJECT,
    pub BusCheck: PCALLBACK_OBJECT,
}
#[test]
fn bindgen_test_layout__HAL_CALLBACKS() {
    assert_eq!(::core::mem::size_of::<_HAL_CALLBACKS>() , 16usize);
    assert_eq!(::core::mem::align_of::<_HAL_CALLBACKS>() , 8usize);
}
impl Clone for _HAL_CALLBACKS {
    fn clone(&self) -> Self { *self }
}
pub use self::_HAL_CALLBACKS as HAL_CALLBACKS;
pub type PHAL_CALLBACKS = *mut _HAL_CALLBACKS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _HAL_PROCESSOR_FEATURE {
    pub UsableFeatureBits: ULONG,
}
#[test]
fn bindgen_test_layout__HAL_PROCESSOR_FEATURE() {
    assert_eq!(::core::mem::size_of::<_HAL_PROCESSOR_FEATURE>() , 4usize);
    assert_eq!(::core::mem::align_of::<_HAL_PROCESSOR_FEATURE>() , 4usize);
}
impl Clone for _HAL_PROCESSOR_FEATURE {
    fn clone(&self) -> Self { *self }
}
pub use self::_HAL_PROCESSOR_FEATURE as HAL_PROCESSOR_FEATURE;
pub type PHALIOREADWRITEHANDLER =
    ::core::option::Option<unsafe extern "C" fn(fRead: BOOLEAN, dwAddr: ULONG,
                                                dwSize: ULONG,
                                                pdwData: PULONG)
                               -> libc::c_long>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _HAL_AMLI_BAD_IO_ADDRESS_LIST {
    pub BadAddrBegin: ULONG,
    pub BadAddrSize: ULONG,
    pub OSVersionTrigger: ULONG,
    pub IOHandler: PHALIOREADWRITEHANDLER,
}
#[test]
fn bindgen_test_layout__HAL_AMLI_BAD_IO_ADDRESS_LIST() {
    assert_eq!(::core::mem::size_of::<_HAL_AMLI_BAD_IO_ADDRESS_LIST>() ,
               24usize);
    assert_eq!(::core::mem::align_of::<_HAL_AMLI_BAD_IO_ADDRESS_LIST>() ,
               8usize);
}
impl Clone for _HAL_AMLI_BAD_IO_ADDRESS_LIST {
    fn clone(&self) -> Self { *self }
}
pub use self::_HAL_AMLI_BAD_IO_ADDRESS_LIST as HAL_AMLI_BAD_IO_ADDRESS_LIST;
pub type PHAL_AMLI_BAD_IO_ADDRESS_LIST = *mut _HAL_AMLI_BAD_IO_ADDRESS_LIST;
pub type PHALMCAINTERFACELOCK =
    ::core::option::Option<unsafe extern "C" fn()>;
pub type PHALMCAINTERFACEUNLOCK =
    ::core::option::Option<unsafe extern "C" fn()>;
pub type PHALMCAINTERFACEREADREGISTER =
    ::core::option::Option<unsafe extern "C" fn(BankNumber: UCHAR,
                                                Exception: PVOID)
                               -> libc::c_long>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _HAL_MCA_INTERFACE {
    pub Lock: PHALMCAINTERFACELOCK,
    pub Unlock: PHALMCAINTERFACEUNLOCK,
    pub ReadRegister: PHALMCAINTERFACEREADREGISTER,
}
#[test]
fn bindgen_test_layout__HAL_MCA_INTERFACE() {
    assert_eq!(::core::mem::size_of::<_HAL_MCA_INTERFACE>() , 24usize);
    assert_eq!(::core::mem::align_of::<_HAL_MCA_INTERFACE>() , 8usize);
}
impl Clone for _HAL_MCA_INTERFACE {
    fn clone(&self) -> Self { *self }
}
pub use self::_HAL_MCA_INTERFACE as HAL_MCA_INTERFACE;
pub const ApicDestinationModePhysical: _bindgen_ty_25 =
    _bindgen_ty_25::ApicDestinationModePhysical;
pub const ApicDestinationModeLogicalFlat: _bindgen_ty_25 =
    _bindgen_ty_25::ApicDestinationModeLogicalFlat;
pub const ApicDestinationModeLogicalClustered: _bindgen_ty_25 =
    _bindgen_ty_25::ApicDestinationModeLogicalClustered;
pub const ApicDestinationModeUnknown: _bindgen_ty_25 =
    _bindgen_ty_25::ApicDestinationModeUnknown;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_25 {
    ApicDestinationModePhysical = 1,
    ApicDestinationModeLogicalFlat = 2,
    ApicDestinationModeLogicalClustered = 3,
    ApicDestinationModeUnknown = 4,
}
pub use self::_bindgen_ty_25 as HAL_APIC_DESTINATION_MODE;
pub type PHAL_APIC_DESTINATION_MODE = *mut _bindgen_ty_25;
pub type PDRIVER_EXCPTN_CALLBACK =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                BankLog: PMCA_EXCEPTION)>;
pub type PDRIVER_MCA_EXCEPTION_CALLBACK = PDRIVER_EXCPTN_CALLBACK;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _MCA_DRIVER_INFO {
    pub ExceptionCallback: PDRIVER_MCA_EXCEPTION_CALLBACK,
    pub DpcCallback: PKDEFERRED_ROUTINE,
    pub DeviceContext: PVOID,
}
#[test]
fn bindgen_test_layout__MCA_DRIVER_INFO() {
    assert_eq!(::core::mem::size_of::<_MCA_DRIVER_INFO>() , 24usize);
    assert_eq!(::core::mem::align_of::<_MCA_DRIVER_INFO>() , 8usize);
}
impl Clone for _MCA_DRIVER_INFO {
    fn clone(&self) -> Self { *self }
}
pub use self::_MCA_DRIVER_INFO as MCA_DRIVER_INFO;
pub type PMCA_DRIVER_INFO = *mut _MCA_DRIVER_INFO;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _HAL_ERROR_INFO {
    pub Version: ULONG,
    pub InitMaxSize: ULONG,
    pub McaMaxSize: ULONG,
    pub McaPreviousEventsCount: ULONG,
    pub McaCorrectedEventsCount: ULONG,
    pub McaKernelDeliveryFails: ULONG,
    pub McaDriverDpcQueueFails: ULONG,
    pub McaReserved: ULONG,
    pub CmcMaxSize: ULONG,
    pub CmcPollingInterval: ULONG,
    pub CmcInterruptsCount: ULONG,
    pub CmcKernelDeliveryFails: ULONG,
    pub CmcDriverDpcQueueFails: ULONG,
    pub CmcGetStateFails: ULONG,
    pub CmcClearStateFails: ULONG,
    pub CmcReserved: ULONG,
    pub CmcLogId: ULONGLONG,
    pub CpeMaxSize: ULONG,
    pub CpePollingInterval: ULONG,
    pub CpeInterruptsCount: ULONG,
    pub CpeKernelDeliveryFails: ULONG,
    pub CpeDriverDpcQueueFails: ULONG,
    pub CpeGetStateFails: ULONG,
    pub CpeClearStateFails: ULONG,
    pub CpeInterruptSources: ULONG,
    pub CpeLogId: ULONGLONG,
    pub KernelReserved: [ULONGLONG; 4usize],
}
#[test]
fn bindgen_test_layout__HAL_ERROR_INFO() {
    assert_eq!(::core::mem::size_of::<_HAL_ERROR_INFO>() , 144usize);
    assert_eq!(::core::mem::align_of::<_HAL_ERROR_INFO>() , 8usize);
}
impl Clone for _HAL_ERROR_INFO {
    fn clone(&self) -> Self { *self }
}
pub use self::_HAL_ERROR_INFO as HAL_ERROR_INFO;
pub type PHAL_ERROR_INFO = *mut _HAL_ERROR_INFO;
pub type PDRIVER_CMC_EXCEPTION_CALLBACK =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                CmcLog: PCMC_EXCEPTION)>;
pub type PDRIVER_CPE_EXCEPTION_CALLBACK =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                CmcLog: PCPE_EXCEPTION)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CMC_DRIVER_INFO {
    pub ExceptionCallback: PDRIVER_CMC_EXCEPTION_CALLBACK,
    pub DpcCallback: PKDEFERRED_ROUTINE,
    pub DeviceContext: PVOID,
}
#[test]
fn bindgen_test_layout__CMC_DRIVER_INFO() {
    assert_eq!(::core::mem::size_of::<_CMC_DRIVER_INFO>() , 24usize);
    assert_eq!(::core::mem::align_of::<_CMC_DRIVER_INFO>() , 8usize);
}
impl Clone for _CMC_DRIVER_INFO {
    fn clone(&self) -> Self { *self }
}
pub use self::_CMC_DRIVER_INFO as CMC_DRIVER_INFO;
pub type PCMC_DRIVER_INFO = *mut _CMC_DRIVER_INFO;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CPE_DRIVER_INFO {
    pub ExceptionCallback: PDRIVER_CPE_EXCEPTION_CALLBACK,
    pub DpcCallback: PKDEFERRED_ROUTINE,
    pub DeviceContext: PVOID,
}
#[test]
fn bindgen_test_layout__CPE_DRIVER_INFO() {
    assert_eq!(::core::mem::size_of::<_CPE_DRIVER_INFO>() , 24usize);
    assert_eq!(::core::mem::align_of::<_CPE_DRIVER_INFO>() , 8usize);
}
impl Clone for _CPE_DRIVER_INFO {
    fn clone(&self) -> Self { *self }
}
pub use self::_CPE_DRIVER_INFO as CPE_DRIVER_INFO;
pub type PCPE_DRIVER_INFO = *mut _CPE_DRIVER_INFO;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _HAL_PLATFORM_INFORMATION {
    pub PlatformFlags: ULONG,
}
#[test]
fn bindgen_test_layout__HAL_PLATFORM_INFORMATION() {
    assert_eq!(::core::mem::size_of::<_HAL_PLATFORM_INFORMATION>() , 4usize);
    assert_eq!(::core::mem::align_of::<_HAL_PLATFORM_INFORMATION>() , 4usize);
}
impl Clone for _HAL_PLATFORM_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_HAL_PLATFORM_INFORMATION as HAL_PLATFORM_INFORMATION;
pub type PHAL_PLATFORM_INFORMATION = *mut _HAL_PLATFORM_INFORMATION;
extern "C" {
    pub fn HalGetScatterGatherList(DmaAdapter: PADAPTER_OBJECT,
                                   DeviceObject: PDEVICE_OBJECT, Mdl: PMDL,
                                   CurrentVa: PVOID, Length: ULONG,
                                   ExecutionRoutine: PDRIVER_LIST_CONTROL,
                                   Context: PVOID, WriteToDevice: BOOLEAN)
     -> NTSTATUS;
}
extern "C" {
    pub fn HalPutScatterGatherList(DmaAdapter: PADAPTER_OBJECT,
                                   ScatterGather: PSCATTER_GATHER_LIST,
                                   WriteToDevice: BOOLEAN);
}
extern "C" {
    pub fn HalPutDmaAdapter(DmaAdapter: PADAPTER_OBJECT);
}
#[repr(C)]
#[derive(Copy)]
pub struct _WHEA_ERROR_SOURCE_DESCRIPTOR {
    pub Length: ULONG,
    pub Version: ULONG,
    pub Type: WHEA_ERROR_SOURCE_TYPE,
    pub State: WHEA_ERROR_SOURCE_STATE,
    pub MaxRawDataLength: ULONG,
    pub NumRecordsToPreallocate: ULONG,
    pub MaxSectionsPerRecord: ULONG,
    pub ErrorSourceId: ULONG,
    pub PlatformErrorSourceId: ULONG,
    pub Flags: ULONG,
    pub Info: _WHEA_ERROR_SOURCE_DESCRIPTOR__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub struct _WHEA_ERROR_SOURCE_DESCRIPTOR__bindgen_ty_1 {
    pub XpfMceDescriptor: __BindgenUnionField<WHEA_XPF_MCE_DESCRIPTOR>,
    pub XpfCmcDescriptor: __BindgenUnionField<WHEA_XPF_CMC_DESCRIPTOR>,
    pub XpfNmiDescriptor: __BindgenUnionField<WHEA_XPF_NMI_DESCRIPTOR>,
    pub IpfMcaDescriptor: __BindgenUnionField<WHEA_IPF_MCA_DESCRIPTOR>,
    pub IpfCmcDescriptor: __BindgenUnionField<WHEA_IPF_CMC_DESCRIPTOR>,
    pub IpfCpeDescriptor: __BindgenUnionField<WHEA_IPF_CPE_DESCRIPTOR>,
    pub AerRootportDescriptor: __BindgenUnionField<WHEA_AER_ROOTPORT_DESCRIPTOR>,
    pub AerEndpointDescriptor: __BindgenUnionField<WHEA_AER_ENDPOINT_DESCRIPTOR>,
    pub AerBridgeDescriptor: __BindgenUnionField<WHEA_AER_BRIDGE_DESCRIPTOR>,
    pub GenErrDescriptor: __BindgenUnionField<WHEA_GENERIC_ERROR_DESCRIPTOR>,
    pub GenErrDescriptorV2: __BindgenUnionField<WHEA_GENERIC_ERROR_DESCRIPTOR_V2>,
    pub bindgen_union_field: [u8; 932usize],
}
impl Clone for _WHEA_ERROR_SOURCE_DESCRIPTOR__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Clone for _WHEA_ERROR_SOURCE_DESCRIPTOR {
    fn clone(&self) -> Self { *self }
}
pub type PWHEA_ERROR_SOURCE_DESCRIPTOR = *mut _WHEA_ERROR_SOURCE_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ERROR_RECORD {
    pub Header: WHEA_ERROR_RECORD_HEADER,
    pub SectionDescriptor: [WHEA_ERROR_RECORD_SECTION_DESCRIPTOR; 1usize],
}
impl Clone for _WHEA_ERROR_RECORD {
    fn clone(&self) -> Self { *self }
}
pub type PWHEA_ERROR_RECORD = *mut _WHEA_ERROR_RECORD;
extern "C" {
    pub fn HalBugCheckSystem(ErrorSource: PWHEA_ERROR_SOURCE_DESCRIPTOR,
                             ErrorRecord: PWHEA_ERROR_RECORD);
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE {
    ResourceTypeSingle = 0,
    ResourceTypeRange = 1,
    ResourceTypeExtendedCounterConfiguration = 2,
    ResourceTypeOverflow = 3,
    ResourceTypeMax = 4,
}
pub use self::_PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE as
        PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR {
    pub Type: PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE,
    pub Flags: ULONG,
    pub u: _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR__bindgen_ty_1 {
    pub CounterIndex: __BindgenUnionField<ULONG>,
    pub ExtendedRegisterAddress: __BindgenUnionField<ULONG>,
    pub Range: __BindgenUnionField<_PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    pub Begin: ULONG,
    pub End: ULONG,
}
#[test]
fn bindgen_test_layout__PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>()
               , 8usize);
    assert_eq!(::core::mem::align_of::<_PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for
 _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR__bindgen_ty_1>()
               , 8usize);
    assert_eq!(::core::mem::align_of::<_PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR() {
    assert_eq!(::core::mem::size_of::<_PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR>()
               , 16usize);
    assert_eq!(::core::mem::align_of::<_PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR>()
               , 4usize);
}
impl Clone for _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR {
    fn clone(&self) -> Self { *self }
}
pub use self::_PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR as
        PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR;
pub type PPHYSICAL_COUNTER_RESOURCE_DESCRIPTOR =
    *mut _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PHYSICAL_COUNTER_RESOURCE_LIST {
    pub Count: ULONG,
    pub Descriptors: [PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR; 1usize],
}
#[test]
fn bindgen_test_layout__PHYSICAL_COUNTER_RESOURCE_LIST() {
    assert_eq!(::core::mem::size_of::<_PHYSICAL_COUNTER_RESOURCE_LIST>() ,
               20usize);
    assert_eq!(::core::mem::align_of::<_PHYSICAL_COUNTER_RESOURCE_LIST>() ,
               4usize);
}
impl Clone for _PHYSICAL_COUNTER_RESOURCE_LIST {
    fn clone(&self) -> Self { *self }
}
pub use self::_PHYSICAL_COUNTER_RESOURCE_LIST as
        PHYSICAL_COUNTER_RESOURCE_LIST;
pub type PPHYSICAL_COUNTER_RESOURCE_LIST =
    *mut _PHYSICAL_COUNTER_RESOURCE_LIST;
extern "C" {
    pub fn HalAllocateHardwareCounters(GroupAffinty: PGROUP_AFFINITY,
                                       GroupCount: ULONG,
                                       ResourceList:
                                           PPHYSICAL_COUNTER_RESOURCE_LIST,
                                       CounterSetHandle: PHANDLE) -> NTSTATUS;
}
extern "C" {
    pub fn HalFreeHardwareCounters(CounterSetHandle: HANDLE) -> NTSTATUS;
}
extern "C" {
    pub fn FsRtlIsTotalDeviceFailure(Status: NTSTATUS) -> BOOLEAN;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_AGP_CAPABILITY {
    pub Header: PCI_CAPABILITIES_HEADER,
    pub _bitfield_1: u16,
    pub AGPStatus: _PCI_AGP_CAPABILITY__PCI_AGP_STATUS,
    pub AGPCommand: _PCI_AGP_CAPABILITY__PCI_AGP_COMMAND,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_AGP_CAPABILITY__PCI_AGP_STATUS {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCI_AGP_CAPABILITY__PCI_AGP_STATUS() {
    assert_eq!(::core::mem::size_of::<_PCI_AGP_CAPABILITY__PCI_AGP_STATUS>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_PCI_AGP_CAPABILITY__PCI_AGP_STATUS>()
               , 4usize);
}
impl Clone for _PCI_AGP_CAPABILITY__PCI_AGP_STATUS {
    fn clone(&self) -> Self { *self }
}
impl _PCI_AGP_CAPABILITY__PCI_AGP_STATUS {
    #[inline]
    pub fn Rate(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (7usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_Rate(&mut self, val: ULONG) {
        self._bitfield_1 &= !(7usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (7usize as u32);
    }
    #[inline]
    pub fn Agp3Mode(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u32)) >>
                                        3u32) as u32)
        }
    }
    #[inline]
    pub fn set_Agp3Mode(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (8usize as u32);
    }
    #[inline]
    pub fn FastWrite(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u32)) >>
                                        4u32) as u32)
        }
    }
    #[inline]
    pub fn set_FastWrite(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (16usize as u32);
    }
    #[inline]
    pub fn FourGB(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u32)) >>
                                        5u32) as u32)
        }
    }
    #[inline]
    pub fn set_FourGB(&mut self, val: ULONG) {
        self._bitfield_1 &= !(32usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (32usize as u32);
    }
    #[inline]
    pub fn HostTransDisable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u32)) >>
                                        6u32) as u32)
        }
    }
    #[inline]
    pub fn set_HostTransDisable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(64usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 6u32) & (64usize as u32);
    }
    #[inline]
    pub fn Gart64(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (128usize as u32)) >>
                                        7u32) as u32)
        }
    }
    #[inline]
    pub fn set_Gart64(&mut self, val: ULONG) {
        self._bitfield_1 &= !(128usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 7u32) & (128usize as u32);
    }
    #[inline]
    pub fn ITA_Coherent(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (256usize as u32)) >>
                                        8u32) as u32)
        }
    }
    #[inline]
    pub fn set_ITA_Coherent(&mut self, val: ULONG) {
        self._bitfield_1 &= !(256usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 8u32) & (256usize as u32);
    }
    #[inline]
    pub fn SideBandAddressing(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (512usize as u32)) >>
                                        9u32) as u32)
        }
    }
    #[inline]
    pub fn set_SideBandAddressing(&mut self, val: ULONG) {
        self._bitfield_1 &= !(512usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 9u32) & (512usize as u32);
    }
    #[inline]
    pub fn CalibrationCycle(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (7168usize as u32)) >>
                                        10u32) as u32)
        }
    }
    #[inline]
    pub fn set_CalibrationCycle(&mut self, val: ULONG) {
        self._bitfield_1 &= !(7168usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 10u32) & (7168usize as u32);
    }
    #[inline]
    pub fn AsyncRequestSize(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (57344usize as u32))
                                        >> 13u32) as u32)
        }
    }
    #[inline]
    pub fn set_AsyncRequestSize(&mut self, val: ULONG) {
        self._bitfield_1 &= !(57344usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 13u32) & (57344usize as u32);
    }
    #[inline]
    pub fn Rsvd1(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65536usize as u32))
                                        >> 16u32) as u32)
        }
    }
    #[inline]
    pub fn set_Rsvd1(&mut self, val: ULONG) {
        self._bitfield_1 &= !(65536usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (65536usize as u32);
    }
    #[inline]
    pub fn Isoch(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (131072usize as u32))
                                        >> 17u32) as u32)
        }
    }
    #[inline]
    pub fn set_Isoch(&mut self, val: ULONG) {
        self._bitfield_1 &= !(131072usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 17u32) & (131072usize as u32);
    }
    #[inline]
    pub fn Rsvd2(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (16515072usize as u32)) >> 18u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16515072usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 18u32) & (16515072usize as u32);
    }
    #[inline]
    pub fn RequestQueueDepthMaximum(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4278190080usize as u32)) >> 24u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_RequestQueueDepthMaximum(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4278190080usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 24u32) & (4278190080usize as u32);
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_AGP_CAPABILITY__PCI_AGP_COMMAND {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCI_AGP_CAPABILITY__PCI_AGP_COMMAND() {
    assert_eq!(::core::mem::size_of::<_PCI_AGP_CAPABILITY__PCI_AGP_COMMAND>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_AGP_CAPABILITY__PCI_AGP_COMMAND>()
               , 4usize);
}
impl Clone for _PCI_AGP_CAPABILITY__PCI_AGP_COMMAND {
    fn clone(&self) -> Self { *self }
}
impl _PCI_AGP_CAPABILITY__PCI_AGP_COMMAND {
    #[inline]
    pub fn Rate(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (7usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_Rate(&mut self, val: ULONG) {
        self._bitfield_1 &= !(7usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (7usize as u32);
    }
    #[inline]
    pub fn Rsvd1(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u32)) >>
                                        3u32) as u32)
        }
    }
    #[inline]
    pub fn set_Rsvd1(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (8usize as u32);
    }
    #[inline]
    pub fn FastWriteEnable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u32)) >>
                                        4u32) as u32)
        }
    }
    #[inline]
    pub fn set_FastWriteEnable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (16usize as u32);
    }
    #[inline]
    pub fn FourGBEnable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u32)) >>
                                        5u32) as u32)
        }
    }
    #[inline]
    pub fn set_FourGBEnable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(32usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (32usize as u32);
    }
    #[inline]
    pub fn Rsvd2(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u32)) >>
                                        6u32) as u32)
        }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: ULONG) {
        self._bitfield_1 &= !(64usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 6u32) & (64usize as u32);
    }
    #[inline]
    pub fn Gart64(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (128usize as u32)) >>
                                        7u32) as u32)
        }
    }
    #[inline]
    pub fn set_Gart64(&mut self, val: ULONG) {
        self._bitfield_1 &= !(128usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 7u32) & (128usize as u32);
    }
    #[inline]
    pub fn AGPEnable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (256usize as u32)) >>
                                        8u32) as u32)
        }
    }
    #[inline]
    pub fn set_AGPEnable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(256usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 8u32) & (256usize as u32);
    }
    #[inline]
    pub fn SBAEnable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (512usize as u32)) >>
                                        9u32) as u32)
        }
    }
    #[inline]
    pub fn set_SBAEnable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(512usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 9u32) & (512usize as u32);
    }
    #[inline]
    pub fn CalibrationCycle(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (7168usize as u32)) >>
                                        10u32) as u32)
        }
    }
    #[inline]
    pub fn set_CalibrationCycle(&mut self, val: ULONG) {
        self._bitfield_1 &= !(7168usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 10u32) & (7168usize as u32);
    }
    #[inline]
    pub fn AsyncReqSize(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (57344usize as u32))
                                        >> 13u32) as u32)
        }
    }
    #[inline]
    pub fn set_AsyncReqSize(&mut self, val: ULONG) {
        self._bitfield_1 &= !(57344usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 13u32) & (57344usize as u32);
    }
    #[inline]
    pub fn Rsvd3(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (16711680usize as u32)) >> 16u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_Rsvd3(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16711680usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (16711680usize as u32);
    }
    #[inline]
    pub fn RequestQueueDepth(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4278190080usize as u32)) >> 24u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_RequestQueueDepth(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4278190080usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 24u32) & (4278190080usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PCI_AGP_CAPABILITY() {
    assert_eq!(::core::mem::size_of::<_PCI_AGP_CAPABILITY>() , 12usize);
    assert_eq!(::core::mem::align_of::<_PCI_AGP_CAPABILITY>() , 4usize);
}
impl Clone for _PCI_AGP_CAPABILITY {
    fn clone(&self) -> Self { *self }
}
impl _PCI_AGP_CAPABILITY {
    #[inline]
    pub fn Minor(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (15usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_Minor(&mut self, val: USHORT) {
        self._bitfield_1 &= !(15usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (15usize as u16);
    }
    #[inline]
    pub fn Major(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (240usize as u16)) >>
                                        4u32) as u16)
        }
    }
    #[inline]
    pub fn set_Major(&mut self, val: USHORT) {
        self._bitfield_1 &= !(240usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 4u32) & (240usize as u16);
    }
    #[inline]
    pub fn Rsvd1(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65280usize as u16))
                                        >> 8u32) as u16)
        }
    }
    #[inline]
    pub fn set_Rsvd1(&mut self, val: USHORT) {
        self._bitfield_1 &= !(65280usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 8u32) & (65280usize as u16);
    }
}
pub use self::_PCI_AGP_CAPABILITY as PCI_AGP_CAPABILITY;
pub type PPCI_AGP_CAPABILITY = *mut _PCI_AGP_CAPABILITY;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _EXTENDED_AGP_REGISTER {
    IsochStatus = 0,
    AgpControl = 1,
    ApertureSize = 2,
    AperturePageSize = 3,
    GartLow = 4,
    GartHigh = 5,
    IsochCommand = 6,
}
pub use self::_EXTENDED_AGP_REGISTER as EXTENDED_AGP_REGISTER;
pub type PEXTENDED_AGP_REGISTER = *mut _EXTENDED_AGP_REGISTER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_AGP_ISOCH_STATUS {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCI_AGP_ISOCH_STATUS() {
    assert_eq!(::core::mem::size_of::<_PCI_AGP_ISOCH_STATUS>() , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_AGP_ISOCH_STATUS>() , 4usize);
}
impl Clone for _PCI_AGP_ISOCH_STATUS {
    fn clone(&self) -> Self { *self }
}
impl _PCI_AGP_ISOCH_STATUS {
    #[inline]
    pub fn ErrorCode(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (3usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_ErrorCode(&mut self, val: ULONG) {
        self._bitfield_1 &= !(3usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (3usize as u32);
    }
    #[inline]
    pub fn Rsvd1(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                        2u32) as u32)
        }
    }
    #[inline]
    pub fn set_Rsvd1(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn Isoch_L(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (56usize as u32)) >>
                                        3u32) as u32)
        }
    }
    #[inline]
    pub fn set_Isoch_L(&mut self, val: ULONG) {
        self._bitfield_1 &= !(56usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (56usize as u32);
    }
    #[inline]
    pub fn Isoch_Y(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (192usize as u32)) >>
                                        6u32) as u32)
        }
    }
    #[inline]
    pub fn set_Isoch_Y(&mut self, val: ULONG) {
        self._bitfield_1 &= !(192usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 6u32) & (192usize as u32);
    }
    #[inline]
    pub fn Isoch_N(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65280usize as u32))
                                        >> 8u32) as u32)
        }
    }
    #[inline]
    pub fn set_Isoch_N(&mut self, val: ULONG) {
        self._bitfield_1 &= !(65280usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 8u32) & (65280usize as u32);
    }
    #[inline]
    pub fn Rsvd2(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294901760usize as u32)) >> 16u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294901760usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (4294901760usize as u32);
    }
}
pub use self::_PCI_AGP_ISOCH_STATUS as PCI_AGP_ISOCH_STATUS;
pub type PPCI_AGP_ISOCH_STATUS = *mut _PCI_AGP_ISOCH_STATUS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_AGP_CONTROL {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCI_AGP_CONTROL() {
    assert_eq!(::core::mem::size_of::<_PCI_AGP_CONTROL>() , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_AGP_CONTROL>() , 4usize);
}
impl Clone for _PCI_AGP_CONTROL {
    fn clone(&self) -> Self { *self }
}
impl _PCI_AGP_CONTROL {
    #[inline]
    pub fn Rsvd1(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (127usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_Rsvd1(&mut self, val: ULONG) {
        self._bitfield_1 &= !(127usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (127usize as u32);
    }
    #[inline]
    pub fn GTLB_Enable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (128usize as u32)) >>
                                        7u32) as u32)
        }
    }
    #[inline]
    pub fn set_GTLB_Enable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(128usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 7u32) & (128usize as u32);
    }
    #[inline]
    pub fn AP_Enable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (256usize as u32)) >>
                                        8u32) as u32)
        }
    }
    #[inline]
    pub fn set_AP_Enable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(256usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 8u32) & (256usize as u32);
    }
    #[inline]
    pub fn CAL_Disable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (512usize as u32)) >>
                                        9u32) as u32)
        }
    }
    #[inline]
    pub fn set_CAL_Disable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(512usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 9u32) & (512usize as u32);
    }
    #[inline]
    pub fn Rsvd2(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294966272usize as u32)) >> 10u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294966272usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 10u32) & (4294966272usize as u32);
    }
}
pub use self::_PCI_AGP_CONTROL as PCI_AGP_CONTROL;
pub type PPCI_AGP_CONTROL = *mut _PCI_AGP_CONTROL;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_AGP_APERTURE_PAGE_SIZE {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__PCI_AGP_APERTURE_PAGE_SIZE() {
    assert_eq!(::core::mem::size_of::<_PCI_AGP_APERTURE_PAGE_SIZE>() ,
               2usize);
    assert_eq!(::core::mem::align_of::<_PCI_AGP_APERTURE_PAGE_SIZE>() ,
               2usize);
}
impl Clone for _PCI_AGP_APERTURE_PAGE_SIZE {
    fn clone(&self) -> Self { *self }
}
impl _PCI_AGP_APERTURE_PAGE_SIZE {
    #[inline]
    pub fn PageSizeMask(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2047usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_PageSizeMask(&mut self, val: USHORT) {
        self._bitfield_1 &= !(2047usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 0u32) & (2047usize as u16);
    }
    #[inline]
    pub fn Rsvd1(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2048usize as u16)) >>
                                        11u32) as u16)
        }
    }
    #[inline]
    pub fn set_Rsvd1(&mut self, val: USHORT) {
        self._bitfield_1 &= !(2048usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 11u32) & (2048usize as u16);
    }
    #[inline]
    pub fn PageSizeSelect(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (61440usize as u16))
                                        >> 12u32) as u16)
        }
    }
    #[inline]
    pub fn set_PageSizeSelect(&mut self, val: USHORT) {
        self._bitfield_1 &= !(61440usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 12u32) & (61440usize as u16);
    }
}
pub use self::_PCI_AGP_APERTURE_PAGE_SIZE as PCI_AGP_APERTURE_PAGE_SIZE;
pub type PPCI_AGP_APERTURE_PAGE_SIZE = *mut _PCI_AGP_APERTURE_PAGE_SIZE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_AGP_ISOCH_COMMAND {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__PCI_AGP_ISOCH_COMMAND() {
    assert_eq!(::core::mem::size_of::<_PCI_AGP_ISOCH_COMMAND>() , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_AGP_ISOCH_COMMAND>() , 2usize);
}
impl Clone for _PCI_AGP_ISOCH_COMMAND {
    fn clone(&self) -> Self { *self }
}
impl _PCI_AGP_ISOCH_COMMAND {
    #[inline]
    pub fn Rsvd1(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (63usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_Rsvd1(&mut self, val: USHORT) {
        self._bitfield_1 &= !(63usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (63usize as u16);
    }
    #[inline]
    pub fn Isoch_Y(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (192usize as u16)) >>
                                        6u32) as u16)
        }
    }
    #[inline]
    pub fn set_Isoch_Y(&mut self, val: USHORT) {
        self._bitfield_1 &= !(192usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 6u32) & (192usize as u16);
    }
    #[inline]
    pub fn Isoch_N(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65280usize as u16))
                                        >> 8u32) as u16)
        }
    }
    #[inline]
    pub fn set_Isoch_N(&mut self, val: USHORT) {
        self._bitfield_1 &= !(65280usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 8u32) & (65280usize as u16);
    }
}
pub use self::_PCI_AGP_ISOCH_COMMAND as PCI_AGP_ISOCH_COMMAND;
pub type PPCI_AGP_ISOCH_COMMAND = *mut _PCI_AGP_ISOCH_COMMAND;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PCI_AGP_EXTENDED_CAPABILITY {
    pub IsochStatus: PCI_AGP_ISOCH_STATUS,
    pub AgpControl: PCI_AGP_CONTROL,
    pub ApertureSize: USHORT,
    pub AperturePageSize: PCI_AGP_APERTURE_PAGE_SIZE,
    pub GartLow: ULONG,
    pub GartHigh: ULONG,
    pub IsochCommand: PCI_AGP_ISOCH_COMMAND,
}
#[test]
fn bindgen_test_layout_PCI_AGP_EXTENDED_CAPABILITY() {
    assert_eq!(::core::mem::size_of::<PCI_AGP_EXTENDED_CAPABILITY>() ,
               24usize);
    assert_eq!(::core::mem::align_of::<PCI_AGP_EXTENDED_CAPABILITY>() ,
               4usize);
}
impl Clone for PCI_AGP_EXTENDED_CAPABILITY {
    fn clone(&self) -> Self { *self }
}
pub type PPCI_AGP_EXTENDED_CAPABILITY = *mut PCI_AGP_EXTENDED_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCIX_BRIDGE_CAPABILITY {
    pub Header: PCI_CAPABILITIES_HEADER,
    pub SecondaryStatus: _PCIX_BRIDGE_CAPABILITY__bindgen_ty_1,
    pub BridgeStatus: _PCIX_BRIDGE_CAPABILITY__bindgen_ty_2,
    pub UpstreamSplitTransactionCapacity: USHORT,
    pub UpstreamSplitTransactionLimit: USHORT,
    pub DownstreamSplitTransactionCapacity: USHORT,
    pub DownstreamSplitTransactionLimit: USHORT,
    pub EccControlStatus: _PCIX_BRIDGE_CAPABILITY__bindgen_ty_3,
    pub EccFirstAddress: ULONG,
    pub EccSecondAddress: ULONG,
    pub EccAttribute: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCIX_BRIDGE_CAPABILITY__bindgen_ty_1 {
    pub __bindgen_anon_1: __BindgenUnionField<_PCIX_BRIDGE_CAPABILITY__bindgen_ty_1__bindgen_ty_1>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: u16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCIX_BRIDGE_CAPABILITY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__PCIX_BRIDGE_CAPABILITY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCIX_BRIDGE_CAPABILITY__bindgen_ty_1__bindgen_ty_1>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_PCIX_BRIDGE_CAPABILITY__bindgen_ty_1__bindgen_ty_1>()
               , 2usize);
}
impl Clone for _PCIX_BRIDGE_CAPABILITY__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCIX_BRIDGE_CAPABILITY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Bus64Bit(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_Bus64Bit(&mut self, val: USHORT) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn Bus133MHzCapable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u16)) >>
                                        1u32) as u16)
        }
    }
    #[inline]
    pub fn set_Bus133MHzCapable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(2usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 1u32) & (2usize as u16);
    }
    #[inline]
    pub fn SplitCompletionDiscarded(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u16)) >>
                                        2u32) as u16)
        }
    }
    #[inline]
    pub fn set_SplitCompletionDiscarded(&mut self, val: USHORT) {
        self._bitfield_1 &= !(4usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 2u32) & (4usize as u16);
    }
    #[inline]
    pub fn UnexpectedSplitCompletion(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u16)) >>
                                        3u32) as u16)
        }
    }
    #[inline]
    pub fn set_UnexpectedSplitCompletion(&mut self, val: USHORT) {
        self._bitfield_1 &= !(8usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 3u32) & (8usize as u16);
    }
    #[inline]
    pub fn SplitCompletionOverrun(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u16)) >>
                                        4u32) as u16)
        }
    }
    #[inline]
    pub fn set_SplitCompletionOverrun(&mut self, val: USHORT) {
        self._bitfield_1 &= !(16usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 4u32) & (16usize as u16);
    }
    #[inline]
    pub fn SplitRequestDelayed(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u16)) >>
                                        5u32) as u16)
        }
    }
    #[inline]
    pub fn set_SplitRequestDelayed(&mut self, val: USHORT) {
        self._bitfield_1 &= !(32usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 5u32) & (32usize as u16);
    }
    #[inline]
    pub fn BusModeFrequency(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (960usize as u16)) >>
                                        6u32) as u16)
        }
    }
    #[inline]
    pub fn set_BusModeFrequency(&mut self, val: USHORT) {
        self._bitfield_1 &= !(960usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 6u32) & (960usize as u16);
    }
    #[inline]
    pub fn Rsvd(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (3072usize as u16)) >>
                                        10u32) as u16)
        }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: USHORT) {
        self._bitfield_1 &= !(3072usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 10u32) & (3072usize as u16);
    }
    #[inline]
    pub fn Version(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (12288usize as u16))
                                        >> 12u32) as u16)
        }
    }
    #[inline]
    pub fn set_Version(&mut self, val: USHORT) {
        self._bitfield_1 &= !(12288usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 12u32) & (12288usize as u16);
    }
    #[inline]
    pub fn Bus266MHzCapable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16384usize as u16))
                                        >> 14u32) as u16)
        }
    }
    #[inline]
    pub fn set_Bus266MHzCapable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(16384usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 14u32) & (16384usize as u16);
    }
    #[inline]
    pub fn Bus533MHzCapable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32768usize as u16))
                                        >> 15u32) as u16)
        }
    }
    #[inline]
    pub fn set_Bus533MHzCapable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(32768usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 15u32) & (32768usize as u16);
    }
}
#[test]
fn bindgen_test_layout__PCIX_BRIDGE_CAPABILITY__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCIX_BRIDGE_CAPABILITY__bindgen_ty_1>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_PCIX_BRIDGE_CAPABILITY__bindgen_ty_1>()
               , 2usize);
}
impl Clone for _PCIX_BRIDGE_CAPABILITY__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCIX_BRIDGE_CAPABILITY__bindgen_ty_2 {
    pub __bindgen_anon_1: __BindgenUnionField<_PCIX_BRIDGE_CAPABILITY__bindgen_ty_2__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCIX_BRIDGE_CAPABILITY__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCIX_BRIDGE_CAPABILITY__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCIX_BRIDGE_CAPABILITY__bindgen_ty_2__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCIX_BRIDGE_CAPABILITY__bindgen_ty_2__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PCIX_BRIDGE_CAPABILITY__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCIX_BRIDGE_CAPABILITY__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn FunctionNumber(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (7usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_FunctionNumber(&mut self, val: ULONG) {
        self._bitfield_1 &= !(7usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (7usize as u32);
    }
    #[inline]
    pub fn DeviceNumber(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (248usize as u32)) >>
                                        3u32) as u32)
        }
    }
    #[inline]
    pub fn set_DeviceNumber(&mut self, val: ULONG) {
        self._bitfield_1 &= !(248usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (248usize as u32);
    }
    #[inline]
    pub fn BusNumber(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65280usize as u32))
                                        >> 8u32) as u32)
        }
    }
    #[inline]
    pub fn set_BusNumber(&mut self, val: ULONG) {
        self._bitfield_1 &= !(65280usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 8u32) & (65280usize as u32);
    }
    #[inline]
    pub fn Device64Bit(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65536usize as u32))
                                        >> 16u32) as u32)
        }
    }
    #[inline]
    pub fn set_Device64Bit(&mut self, val: ULONG) {
        self._bitfield_1 &= !(65536usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (65536usize as u32);
    }
    #[inline]
    pub fn Device133MHzCapable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (131072usize as u32))
                                        >> 17u32) as u32)
        }
    }
    #[inline]
    pub fn set_Device133MHzCapable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(131072usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 17u32) & (131072usize as u32);
    }
    #[inline]
    pub fn SplitCompletionDiscarded(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (262144usize as u32))
                                        >> 18u32) as u32)
        }
    }
    #[inline]
    pub fn set_SplitCompletionDiscarded(&mut self, val: ULONG) {
        self._bitfield_1 &= !(262144usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 18u32) & (262144usize as u32);
    }
    #[inline]
    pub fn UnexpectedSplitCompletion(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (524288usize as u32))
                                        >> 19u32) as u32)
        }
    }
    #[inline]
    pub fn set_UnexpectedSplitCompletion(&mut self, val: ULONG) {
        self._bitfield_1 &= !(524288usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 19u32) & (524288usize as u32);
    }
    #[inline]
    pub fn SplitCompletionOverrun(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1048576usize as u32))
                                        >> 20u32) as u32)
        }
    }
    #[inline]
    pub fn set_SplitCompletionOverrun(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1048576usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 20u32) & (1048576usize as u32);
    }
    #[inline]
    pub fn SplitRequestDelayed(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2097152usize as u32))
                                        >> 21u32) as u32)
        }
    }
    #[inline]
    pub fn set_SplitRequestDelayed(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2097152usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 21u32) & (2097152usize as u32);
    }
    #[inline]
    pub fn Rsvd(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (532676608usize as u32)) >> 22u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: ULONG) {
        self._bitfield_1 &= !(532676608usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 22u32) & (532676608usize as u32);
    }
    #[inline]
    pub fn DIMCapable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (536870912usize as u32)) >> 29u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_DIMCapable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(536870912usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 29u32) & (536870912usize as u32);
    }
    #[inline]
    pub fn Device266MHzCapable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (1073741824usize as u32)) >> 30u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_Device266MHzCapable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1073741824usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 30u32) & (1073741824usize as u32);
    }
    #[inline]
    pub fn Device533MHzCapable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (2147483648usize as u32)) >> 31u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_Device533MHzCapable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2147483648usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 31u32) & (2147483648usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PCIX_BRIDGE_CAPABILITY__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<_PCIX_BRIDGE_CAPABILITY__bindgen_ty_2>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCIX_BRIDGE_CAPABILITY__bindgen_ty_2>()
               , 4usize);
}
impl Clone for _PCIX_BRIDGE_CAPABILITY__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCIX_BRIDGE_CAPABILITY__bindgen_ty_3 {
    pub __bindgen_anon_1: __BindgenUnionField<_PCIX_BRIDGE_CAPABILITY__bindgen_ty_3__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCIX_BRIDGE_CAPABILITY__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCIX_BRIDGE_CAPABILITY__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCIX_BRIDGE_CAPABILITY__bindgen_ty_3__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCIX_BRIDGE_CAPABILITY__bindgen_ty_3__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PCIX_BRIDGE_CAPABILITY__bindgen_ty_3__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCIX_BRIDGE_CAPABILITY__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn SelectSecondaryRegisters(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_SelectSecondaryRegisters(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn ErrorPresentInOtherBank(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_ErrorPresentInOtherBank(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn AdditionalCorrectableError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                        2u32) as u32)
        }
    }
    #[inline]
    pub fn set_AdditionalCorrectableError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn AdditionalUncorrectableError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u32)) >>
                                        3u32) as u32)
        }
    }
    #[inline]
    pub fn set_AdditionalUncorrectableError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (8usize as u32);
    }
    #[inline]
    pub fn ErrorPhase(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (112usize as u32)) >>
                                        4u32) as u32)
        }
    }
    #[inline]
    pub fn set_ErrorPhase(&mut self, val: ULONG) {
        self._bitfield_1 &= !(112usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (112usize as u32);
    }
    #[inline]
    pub fn ErrorCorrected(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (128usize as u32)) >>
                                        7u32) as u32)
        }
    }
    #[inline]
    pub fn set_ErrorCorrected(&mut self, val: ULONG) {
        self._bitfield_1 &= !(128usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 7u32) & (128usize as u32);
    }
    #[inline]
    pub fn Syndrome(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65280usize as u32))
                                        >> 8u32) as u32)
        }
    }
    #[inline]
    pub fn set_Syndrome(&mut self, val: ULONG) {
        self._bitfield_1 &= !(65280usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 8u32) & (65280usize as u32);
    }
    #[inline]
    pub fn ErrorFirstCommand(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (983040usize as u32))
                                        >> 16u32) as u32)
        }
    }
    #[inline]
    pub fn set_ErrorFirstCommand(&mut self, val: ULONG) {
        self._bitfield_1 &= !(983040usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (983040usize as u32);
    }
    #[inline]
    pub fn ErrorSecondCommand(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (15728640usize as u32)) >> 20u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_ErrorSecondCommand(&mut self, val: ULONG) {
        self._bitfield_1 &= !(15728640usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 20u32) & (15728640usize as u32);
    }
    #[inline]
    pub fn ErrorUpperAttributes(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (251658240usize as u32)) >> 24u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_ErrorUpperAttributes(&mut self, val: ULONG) {
        self._bitfield_1 &= !(251658240usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 24u32) & (251658240usize as u32);
    }
    #[inline]
    pub fn ControlUpdateEnable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (268435456usize as u32)) >> 28u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_ControlUpdateEnable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(268435456usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 28u32) & (268435456usize as u32);
    }
    #[inline]
    pub fn Rsvd(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (536870912usize as u32)) >> 29u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: ULONG) {
        self._bitfield_1 &= !(536870912usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 29u32) & (536870912usize as u32);
    }
    #[inline]
    pub fn DisableSingleBitCorrection(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (1073741824usize as u32)) >> 30u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_DisableSingleBitCorrection(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1073741824usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 30u32) & (1073741824usize as u32);
    }
    #[inline]
    pub fn EccMode(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (2147483648usize as u32)) >> 31u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_EccMode(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2147483648usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 31u32) & (2147483648usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PCIX_BRIDGE_CAPABILITY__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<_PCIX_BRIDGE_CAPABILITY__bindgen_ty_3>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCIX_BRIDGE_CAPABILITY__bindgen_ty_3>()
               , 4usize);
}
impl Clone for _PCIX_BRIDGE_CAPABILITY__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__PCIX_BRIDGE_CAPABILITY() {
    assert_eq!(::core::mem::size_of::<_PCIX_BRIDGE_CAPABILITY>() , 32usize);
    assert_eq!(::core::mem::align_of::<_PCIX_BRIDGE_CAPABILITY>() , 4usize);
}
impl Clone for _PCIX_BRIDGE_CAPABILITY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCIX_BRIDGE_CAPABILITY as PCIX_BRIDGE_CAPABILITY;
pub type PPCIX_BRIDGE_CAPABILITY = *mut _PCIX_BRIDGE_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_SUBSYSTEM_IDS_CAPABILITY {
    pub Header: PCI_CAPABILITIES_HEADER,
    pub Reserved: USHORT,
    pub SubVendorID: USHORT,
    pub SubSystemID: USHORT,
}
#[test]
fn bindgen_test_layout__PCI_SUBSYSTEM_IDS_CAPABILITY() {
    assert_eq!(::core::mem::size_of::<_PCI_SUBSYSTEM_IDS_CAPABILITY>() ,
               8usize);
    assert_eq!(::core::mem::align_of::<_PCI_SUBSYSTEM_IDS_CAPABILITY>() ,
               2usize);
}
impl Clone for _PCI_SUBSYSTEM_IDS_CAPABILITY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_SUBSYSTEM_IDS_CAPABILITY as PCI_SUBSYSTEM_IDS_CAPABILITY;
pub type PPCI_SUBSYSTEM_IDS_CAPABILITY = *mut _PCI_SUBSYSTEM_IDS_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_ADVANCED_FEATURES_CAPABILITY {
    pub Header: PCI_CAPABILITIES_HEADER,
    pub Length: UCHAR,
    pub Capabilities: _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_1,
    pub Control: _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_2,
    pub Status: _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_1 {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_1__bindgen_ty_1>,
    pub AsUCHAR: __BindgenUnionField<UCHAR>,
    pub bindgen_union_field: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u8,
}
#[test]
fn bindgen_test_layout__PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_1__bindgen_ty_1>()
               , 1usize);
    assert_eq!(::core::mem::align_of::<_PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_1__bindgen_ty_1>()
               , 1usize);
}
impl Clone for _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn FunctionLevelResetSupported(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                        0u32) as u8)
        }
    }
    #[inline]
    pub fn set_FunctionLevelResetSupported(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 0u32) & (1usize as u8);
    }
    #[inline]
    pub fn TransactionsPendingSupported(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u8)) >>
                                        1u32) as u8)
        }
    }
    #[inline]
    pub fn set_TransactionsPendingSupported(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(2usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 1u32) & (2usize as u8);
    }
    #[inline]
    pub fn Rsvd(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (252usize as u8)) >>
                                        2u32) as u8)
        }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(252usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 2u32) & (252usize as u8);
    }
}
#[test]
fn bindgen_test_layout__PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_1>()
               , 1usize);
    assert_eq!(::core::mem::align_of::<_PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_1>()
               , 1usize);
}
impl Clone for _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_2 {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_2__bindgen_ty_1>,
    pub AsUCHAR: __BindgenUnionField<UCHAR>,
    pub bindgen_union_field: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: u8,
}
#[test]
fn bindgen_test_layout__PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_2__bindgen_ty_1>()
               , 1usize);
    assert_eq!(::core::mem::align_of::<_PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_2__bindgen_ty_1>()
               , 1usize);
}
impl Clone for _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn InitiateFunctionLevelReset(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                        0u32) as u8)
        }
    }
    #[inline]
    pub fn set_InitiateFunctionLevelReset(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 0u32) & (1usize as u8);
    }
    #[inline]
    pub fn Rsvd(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (254usize as u8)) >>
                                        1u32) as u8)
        }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(254usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 1u32) & (254usize as u8);
    }
}
#[test]
fn bindgen_test_layout__PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<_PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_2>()
               , 1usize);
    assert_eq!(::core::mem::align_of::<_PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_2>()
               , 1usize);
}
impl Clone for _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_3 {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_3__bindgen_ty_1>,
    pub AsUCHAR: __BindgenUnionField<UCHAR>,
    pub bindgen_union_field: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_1: u8,
}
#[test]
fn bindgen_test_layout__PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_3__bindgen_ty_1>()
               , 1usize);
    assert_eq!(::core::mem::align_of::<_PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_3__bindgen_ty_1>()
               , 1usize);
}
impl Clone for _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_3__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn TransactionsPending(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                        0u32) as u8)
        }
    }
    #[inline]
    pub fn set_TransactionsPending(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 0u32) & (1usize as u8);
    }
    #[inline]
    pub fn Rsvd(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (254usize as u8)) >>
                                        1u32) as u8)
        }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(254usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 1u32) & (254usize as u8);
    }
}
#[test]
fn bindgen_test_layout__PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<_PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_3>()
               , 1usize);
    assert_eq!(::core::mem::align_of::<_PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_3>()
               , 1usize);
}
impl Clone for _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__PCI_ADVANCED_FEATURES_CAPABILITY() {
    assert_eq!(::core::mem::size_of::<_PCI_ADVANCED_FEATURES_CAPABILITY>() ,
               6usize);
    assert_eq!(::core::mem::align_of::<_PCI_ADVANCED_FEATURES_CAPABILITY>() ,
               1usize);
}
impl Clone for _PCI_ADVANCED_FEATURES_CAPABILITY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_ADVANCED_FEATURES_CAPABILITY as
        PCI_ADVANCED_FEATURES_CAPABILITY;
pub type PPCI_ADVANCED_FEATURES_CAPABILITY =
    *mut _PCI_ADVANCED_FEATURES_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_ROOT_BUS_OSC_SUPPORT_FIELD {
    pub u: _PCI_ROOT_BUS_OSC_SUPPORT_FIELD__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_ROOT_BUS_OSC_SUPPORT_FIELD__bindgen_ty_1 {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_ROOT_BUS_OSC_SUPPORT_FIELD__bindgen_ty_1__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_ROOT_BUS_OSC_SUPPORT_FIELD__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCI_ROOT_BUS_OSC_SUPPORT_FIELD__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_ROOT_BUS_OSC_SUPPORT_FIELD__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_ROOT_BUS_OSC_SUPPORT_FIELD__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PCI_ROOT_BUS_OSC_SUPPORT_FIELD__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_ROOT_BUS_OSC_SUPPORT_FIELD__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn ExtendedConfigOpRegions(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_ExtendedConfigOpRegions(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn ActiveStatePowerManagement(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_ActiveStatePowerManagement(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn ClockPowerManagement(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                        2u32) as u32)
        }
    }
    #[inline]
    pub fn set_ClockPowerManagement(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn SegmentGroups(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u32)) >>
                                        3u32) as u32)
        }
    }
    #[inline]
    pub fn set_SegmentGroups(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (8usize as u32);
    }
    #[inline]
    pub fn MessageSignaledInterrupts(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u32)) >>
                                        4u32) as u32)
        }
    }
    #[inline]
    pub fn set_MessageSignaledInterrupts(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (16usize as u32);
    }
    #[inline]
    pub fn OptimizedBufferFlushAndFill(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u32)) >>
                                        5u32) as u32)
        }
    }
    #[inline]
    pub fn set_OptimizedBufferFlushAndFill(&mut self, val: ULONG) {
        self._bitfield_1 &= !(32usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (32usize as u32);
    }
    #[inline]
    pub fn AspmOptionality(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u32)) >>
                                        6u32) as u32)
        }
    }
    #[inline]
    pub fn set_AspmOptionality(&mut self, val: ULONG) {
        self._bitfield_1 &= !(64usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 6u32) & (64usize as u32);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967168usize as u32)) >> 7u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967168usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 7u32) & (4294967168usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PCI_ROOT_BUS_OSC_SUPPORT_FIELD__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_ROOT_BUS_OSC_SUPPORT_FIELD__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_ROOT_BUS_OSC_SUPPORT_FIELD__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PCI_ROOT_BUS_OSC_SUPPORT_FIELD__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__PCI_ROOT_BUS_OSC_SUPPORT_FIELD() {
    assert_eq!(::core::mem::size_of::<_PCI_ROOT_BUS_OSC_SUPPORT_FIELD>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_PCI_ROOT_BUS_OSC_SUPPORT_FIELD>() ,
               4usize);
}
impl Clone for _PCI_ROOT_BUS_OSC_SUPPORT_FIELD {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_ROOT_BUS_OSC_SUPPORT_FIELD as
        PCI_ROOT_BUS_OSC_SUPPORT_FIELD;
pub type PPCI_ROOT_BUS_OSC_SUPPORT_FIELD =
    *mut _PCI_ROOT_BUS_OSC_SUPPORT_FIELD;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_ROOT_BUS_OSC_CONTROL_FIELD {
    pub u: _PCI_ROOT_BUS_OSC_CONTROL_FIELD__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_ROOT_BUS_OSC_CONTROL_FIELD__bindgen_ty_1 {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_ROOT_BUS_OSC_CONTROL_FIELD__bindgen_ty_1__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_ROOT_BUS_OSC_CONTROL_FIELD__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCI_ROOT_BUS_OSC_CONTROL_FIELD__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_ROOT_BUS_OSC_CONTROL_FIELD__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_ROOT_BUS_OSC_CONTROL_FIELD__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PCI_ROOT_BUS_OSC_CONTROL_FIELD__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_ROOT_BUS_OSC_CONTROL_FIELD__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn ExpressNativeHotPlug(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_ExpressNativeHotPlug(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn ShpcNativeHotPlug(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_ShpcNativeHotPlug(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn ExpressNativePME(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                        2u32) as u32)
        }
    }
    #[inline]
    pub fn set_ExpressNativePME(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn ExpressAdvancedErrorReporting(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u32)) >>
                                        3u32) as u32)
        }
    }
    #[inline]
    pub fn set_ExpressAdvancedErrorReporting(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (8usize as u32);
    }
    #[inline]
    pub fn ExpressCapabilityStructure(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u32)) >>
                                        4u32) as u32)
        }
    }
    #[inline]
    pub fn set_ExpressCapabilityStructure(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (16usize as u32);
    }
    #[inline]
    pub fn LatencyToleranceReporting(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u32)) >>
                                        5u32) as u32)
        }
    }
    #[inline]
    pub fn set_LatencyToleranceReporting(&mut self, val: ULONG) {
        self._bitfield_1 &= !(32usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (32usize as u32);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967232usize as u32)) >> 6u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967232usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 6u32) & (4294967232usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PCI_ROOT_BUS_OSC_CONTROL_FIELD__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_ROOT_BUS_OSC_CONTROL_FIELD__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_ROOT_BUS_OSC_CONTROL_FIELD__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PCI_ROOT_BUS_OSC_CONTROL_FIELD__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__PCI_ROOT_BUS_OSC_CONTROL_FIELD() {
    assert_eq!(::core::mem::size_of::<_PCI_ROOT_BUS_OSC_CONTROL_FIELD>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_PCI_ROOT_BUS_OSC_CONTROL_FIELD>() ,
               4usize);
}
impl Clone for _PCI_ROOT_BUS_OSC_CONTROL_FIELD {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_ROOT_BUS_OSC_CONTROL_FIELD as
        PCI_ROOT_BUS_OSC_CONTROL_FIELD;
pub type PPCI_ROOT_BUS_OSC_CONTROL_FIELD =
    *mut _PCI_ROOT_BUS_OSC_CONTROL_FIELD;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_FIRMWARE_BUS_CAPS {
    pub Type: USHORT,
    pub Length: USHORT,
    pub __bindgen_anon_1: _PCI_FIRMWARE_BUS_CAPS__bindgen_ty_1,
    pub CurrentSpeedAndMode: UCHAR,
    pub SupportedSpeedsAndModesLowByte: UCHAR,
    pub SupportedSpeedsAndModesHighByte: UCHAR,
    pub Voltage: UCHAR,
    pub Reserved2: [UCHAR; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_FIRMWARE_BUS_CAPS__bindgen_ty_1 {
    pub _bitfield_1: u8,
}
#[test]
fn bindgen_test_layout__PCI_FIRMWARE_BUS_CAPS__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_FIRMWARE_BUS_CAPS__bindgen_ty_1>()
               , 1usize);
    assert_eq!(::core::mem::align_of::<_PCI_FIRMWARE_BUS_CAPS__bindgen_ty_1>()
               , 1usize);
}
impl Clone for _PCI_FIRMWARE_BUS_CAPS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_FIRMWARE_BUS_CAPS__bindgen_ty_1 {
    #[inline]
    pub fn SixtyFourBitDevice(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                        0u32) as u8)
        }
    }
    #[inline]
    pub fn set_SixtyFourBitDevice(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 0u32) & (1usize as u8);
    }
    #[inline]
    pub fn PciXMode1EccCapable(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u8)) >>
                                        1u32) as u8)
        }
    }
    #[inline]
    pub fn set_PciXMode1EccCapable(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(2usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 1u32) & (2usize as u8);
    }
    #[inline]
    pub fn DeviceIdMessagingCapable(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u8)) >>
                                        2u32) as u8)
        }
    }
    #[inline]
    pub fn set_DeviceIdMessagingCapable(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(4usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 2u32) & (4usize as u8);
    }
    #[inline]
    pub fn ObffWakeSignalCapable(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u8)) >>
                                        3u32) as u8)
        }
    }
    #[inline]
    pub fn set_ObffWakeSignalCapable(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(8usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 3u32) & (8usize as u8);
    }
    #[inline]
    pub fn Reserved1(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (240usize as u8)) >>
                                        4u32) as u8)
        }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(240usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 4u32) & (240usize as u8);
    }
}
#[test]
fn bindgen_test_layout__PCI_FIRMWARE_BUS_CAPS() {
    assert_eq!(::core::mem::size_of::<_PCI_FIRMWARE_BUS_CAPS>() , 16usize);
    assert_eq!(::core::mem::align_of::<_PCI_FIRMWARE_BUS_CAPS>() , 2usize);
}
impl Clone for _PCI_FIRMWARE_BUS_CAPS {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_FIRMWARE_BUS_CAPS as PCI_FIRMWARE_BUS_CAPS;
pub type PPCI_FIRMWARE_BUS_CAPS = *mut _PCI_FIRMWARE_BUS_CAPS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_FIRMWARE_BUS_CAPS_RETURN_BUFFER {
    pub Version: USHORT,
    pub Status: USHORT,
    pub Length: ULONG,
    pub Caps: PCI_FIRMWARE_BUS_CAPS,
}
#[test]
fn bindgen_test_layout__PCI_FIRMWARE_BUS_CAPS_RETURN_BUFFER() {
    assert_eq!(::core::mem::size_of::<_PCI_FIRMWARE_BUS_CAPS_RETURN_BUFFER>()
               , 24usize);
    assert_eq!(::core::mem::align_of::<_PCI_FIRMWARE_BUS_CAPS_RETURN_BUFFER>()
               , 4usize);
}
impl Clone for _PCI_FIRMWARE_BUS_CAPS_RETURN_BUFFER {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_FIRMWARE_BUS_CAPS_RETURN_BUFFER as
        PCI_FIRMWARE_BUS_CAPS_RETURN_BUFFER;
pub type PPCI_FIRMWARE_BUS_CAPS_RETURN_BUFFER =
    *mut _PCI_FIRMWARE_BUS_CAPS_RETURN_BUFFER;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _PCI_HARDWARE_INTERFACE {
    PciConventional = 0,
    PciXMode1 = 1,
    PciXMode2 = 2,
    PciExpress = 3,
}
pub use self::_PCI_HARDWARE_INTERFACE as PCI_HARDWARE_INTERFACE;
pub type PPCI_HARDWARE_INTERFACE = *mut _PCI_HARDWARE_INTERFACE;
pub const BusWidth32Bits: _bindgen_ty_26 = _bindgen_ty_26::BusWidth32Bits;
pub const BusWidth64Bits: _bindgen_ty_26 = _bindgen_ty_26::BusWidth64Bits;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_26 { BusWidth32Bits = 0, BusWidth64Bits = 1, }
pub use self::_bindgen_ty_26 as PCI_BUS_WIDTH;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_ROOT_BUS_HARDWARE_CAPABILITY {
    pub SecondaryInterface: PCI_HARDWARE_INTERFACE,
    pub __bindgen_anon_1: _PCI_ROOT_BUS_HARDWARE_CAPABILITY__bindgen_ty_1,
    pub OscFeatureSupport: PCI_ROOT_BUS_OSC_SUPPORT_FIELD,
    pub OscControlRequest: PCI_ROOT_BUS_OSC_CONTROL_FIELD,
    pub OscControlGranted: PCI_ROOT_BUS_OSC_CONTROL_FIELD,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_ROOT_BUS_HARDWARE_CAPABILITY__bindgen_ty_1 {
    pub BusCapabilitiesFound: BOOLEAN,
    pub CurrentSpeedAndMode: ULONG,
    pub SupportedSpeedsAndModes: ULONG,
    pub DeviceIDMessagingCapable: BOOLEAN,
    pub SecondaryBusWidth: PCI_BUS_WIDTH,
}
#[test]
fn bindgen_test_layout__PCI_ROOT_BUS_HARDWARE_CAPABILITY__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_ROOT_BUS_HARDWARE_CAPABILITY__bindgen_ty_1>()
               , 20usize);
    assert_eq!(::core::mem::align_of::<_PCI_ROOT_BUS_HARDWARE_CAPABILITY__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PCI_ROOT_BUS_HARDWARE_CAPABILITY__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__PCI_ROOT_BUS_HARDWARE_CAPABILITY() {
    assert_eq!(::core::mem::size_of::<_PCI_ROOT_BUS_HARDWARE_CAPABILITY>() ,
               36usize);
    assert_eq!(::core::mem::align_of::<_PCI_ROOT_BUS_HARDWARE_CAPABILITY>() ,
               4usize);
}
impl Clone for _PCI_ROOT_BUS_HARDWARE_CAPABILITY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_ROOT_BUS_HARDWARE_CAPABILITY as
        PCI_ROOT_BUS_HARDWARE_CAPABILITY;
pub type PPCI_ROOT_BUS_HARDWARE_CAPABILITY =
    *mut _PCI_ROOT_BUS_HARDWARE_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_CAPABILITIES_REGISTER {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_CAPABILITIES_REGISTER__bindgen_ty_1>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: u16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_CAPABILITIES_REGISTER__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_CAPABILITIES_REGISTER__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_CAPABILITIES_REGISTER__bindgen_ty_1>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_CAPABILITIES_REGISTER__bindgen_ty_1>()
               , 2usize);
}
impl Clone for _PCI_EXPRESS_CAPABILITIES_REGISTER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_CAPABILITIES_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn CapabilityVersion(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (15usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_CapabilityVersion(&mut self, val: USHORT) {
        self._bitfield_1 &= !(15usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (15usize as u16);
    }
    #[inline]
    pub fn DeviceType(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (240usize as u16)) >>
                                        4u32) as u16)
        }
    }
    #[inline]
    pub fn set_DeviceType(&mut self, val: USHORT) {
        self._bitfield_1 &= !(240usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 4u32) & (240usize as u16);
    }
    #[inline]
    pub fn SlotImplemented(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (256usize as u16)) >>
                                        8u32) as u16)
        }
    }
    #[inline]
    pub fn set_SlotImplemented(&mut self, val: USHORT) {
        self._bitfield_1 &= !(256usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 8u32) & (256usize as u16);
    }
    #[inline]
    pub fn InterruptMessageNumber(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (15872usize as u16))
                                        >> 9u32) as u16)
        }
    }
    #[inline]
    pub fn set_InterruptMessageNumber(&mut self, val: USHORT) {
        self._bitfield_1 &= !(15872usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 9u32) & (15872usize as u16);
    }
    #[inline]
    pub fn Rsvd(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (49152usize as u16))
                                        >> 14u32) as u16)
        }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: USHORT) {
        self._bitfield_1 &= !(49152usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 14u32) & (49152usize as u16);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_CAPABILITIES_REGISTER() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_CAPABILITIES_REGISTER>() ,
               2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_CAPABILITIES_REGISTER>() ,
               2usize);
}
impl Clone for _PCI_EXPRESS_CAPABILITIES_REGISTER {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_CAPABILITIES_REGISTER as
        PCI_EXPRESS_CAPABILITIES_REGISTER;
pub type PPCI_EXPRESS_CAPABILITIES_REGISTER =
    *mut _PCI_EXPRESS_CAPABILITIES_REGISTER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn MaxPayloadSizeSupported(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (7usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_MaxPayloadSizeSupported(&mut self, val: ULONG) {
        self._bitfield_1 &= !(7usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (7usize as u32);
    }
    #[inline]
    pub fn PhantomFunctionsSupported(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (24usize as u32)) >>
                                        3u32) as u32)
        }
    }
    #[inline]
    pub fn set_PhantomFunctionsSupported(&mut self, val: ULONG) {
        self._bitfield_1 &= !(24usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (24usize as u32);
    }
    #[inline]
    pub fn ExtendedTagSupported(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u32)) >>
                                        5u32) as u32)
        }
    }
    #[inline]
    pub fn set_ExtendedTagSupported(&mut self, val: ULONG) {
        self._bitfield_1 &= !(32usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (32usize as u32);
    }
    #[inline]
    pub fn L0sAcceptableLatency(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (448usize as u32)) >>
                                        6u32) as u32)
        }
    }
    #[inline]
    pub fn set_L0sAcceptableLatency(&mut self, val: ULONG) {
        self._bitfield_1 &= !(448usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 6u32) & (448usize as u32);
    }
    #[inline]
    pub fn L1AcceptableLatency(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (3584usize as u32)) >>
                                        9u32) as u32)
        }
    }
    #[inline]
    pub fn set_L1AcceptableLatency(&mut self, val: ULONG) {
        self._bitfield_1 &= !(3584usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 9u32) & (3584usize as u32);
    }
    #[inline]
    pub fn Undefined(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (28672usize as u32))
                                        >> 12u32) as u32)
        }
    }
    #[inline]
    pub fn set_Undefined(&mut self, val: ULONG) {
        self._bitfield_1 &= !(28672usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 12u32) & (28672usize as u32);
    }
    #[inline]
    pub fn RoleBasedErrorReporting(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32768usize as u32))
                                        >> 15u32) as u32)
        }
    }
    #[inline]
    pub fn set_RoleBasedErrorReporting(&mut self, val: ULONG) {
        self._bitfield_1 &= !(32768usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 15u32) & (32768usize as u32);
    }
    #[inline]
    pub fn Rsvd1(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (196608usize as u32))
                                        >> 16u32) as u32)
        }
    }
    #[inline]
    pub fn set_Rsvd1(&mut self, val: ULONG) {
        self._bitfield_1 &= !(196608usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (196608usize as u32);
    }
    #[inline]
    pub fn CapturedSlotPowerLimit(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (66846720usize as u32)) >> 18u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_CapturedSlotPowerLimit(&mut self, val: ULONG) {
        self._bitfield_1 &= !(66846720usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 18u32) & (66846720usize as u32);
    }
    #[inline]
    pub fn CapturedSlotPowerLimitScale(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (201326592usize as u32)) >> 26u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_CapturedSlotPowerLimitScale(&mut self, val: ULONG) {
        self._bitfield_1 &= !(201326592usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 26u32) & (201326592usize as u32);
    }
    #[inline]
    pub fn FunctionLevelResetCapability(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (268435456usize as u32)) >> 28u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_FunctionLevelResetCapability(&mut self, val: ULONG) {
        self._bitfield_1 &= !(268435456usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 28u32) & (268435456usize as u32);
    }
    #[inline]
    pub fn Rsvd2(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (3758096384usize as u32)) >> 29u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: ULONG) {
        self._bitfield_1 &= !(3758096384usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 29u32) & (3758096384usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER as
        PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER;
pub type PPCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER =
    *mut _PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_DEVICE_CONTROL_REGISTER {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_DEVICE_CONTROL_REGISTER__bindgen_ty_1>,
    pub __bindgen_anon_2: __BindgenUnionField<_PCI_EXPRESS_DEVICE_CONTROL_REGISTER__bindgen_ty_2>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: u16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_DEVICE_CONTROL_REGISTER__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_DEVICE_CONTROL_REGISTER__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_DEVICE_CONTROL_REGISTER__bindgen_ty_1>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_DEVICE_CONTROL_REGISTER__bindgen_ty_1>()
               , 2usize);
}
impl Clone for _PCI_EXPRESS_DEVICE_CONTROL_REGISTER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_DEVICE_CONTROL_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn CorrectableErrorEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_CorrectableErrorEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn NonFatalErrorEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u16)) >>
                                        1u32) as u16)
        }
    }
    #[inline]
    pub fn set_NonFatalErrorEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(2usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 1u32) & (2usize as u16);
    }
    #[inline]
    pub fn FatalErrorEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u16)) >>
                                        2u32) as u16)
        }
    }
    #[inline]
    pub fn set_FatalErrorEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(4usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 2u32) & (4usize as u16);
    }
    #[inline]
    pub fn UnsupportedRequestErrorEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u16)) >>
                                        3u32) as u16)
        }
    }
    #[inline]
    pub fn set_UnsupportedRequestErrorEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(8usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 3u32) & (8usize as u16);
    }
    #[inline]
    pub fn EnableRelaxedOrder(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u16)) >>
                                        4u32) as u16)
        }
    }
    #[inline]
    pub fn set_EnableRelaxedOrder(&mut self, val: USHORT) {
        self._bitfield_1 &= !(16usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 4u32) & (16usize as u16);
    }
    #[inline]
    pub fn MaxPayloadSize(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (224usize as u16)) >>
                                        5u32) as u16)
        }
    }
    #[inline]
    pub fn set_MaxPayloadSize(&mut self, val: USHORT) {
        self._bitfield_1 &= !(224usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 5u32) & (224usize as u16);
    }
    #[inline]
    pub fn ExtendedTagEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (256usize as u16)) >>
                                        8u32) as u16)
        }
    }
    #[inline]
    pub fn set_ExtendedTagEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(256usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 8u32) & (256usize as u16);
    }
    #[inline]
    pub fn PhantomFunctionsEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (512usize as u16)) >>
                                        9u32) as u16)
        }
    }
    #[inline]
    pub fn set_PhantomFunctionsEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(512usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 9u32) & (512usize as u16);
    }
    #[inline]
    pub fn AuxPowerEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1024usize as u16)) >>
                                        10u32) as u16)
        }
    }
    #[inline]
    pub fn set_AuxPowerEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(1024usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 10u32) & (1024usize as u16);
    }
    #[inline]
    pub fn NoSnoopEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2048usize as u16)) >>
                                        11u32) as u16)
        }
    }
    #[inline]
    pub fn set_NoSnoopEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(2048usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 11u32) & (2048usize as u16);
    }
    #[inline]
    pub fn MaxReadRequestSize(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (28672usize as u16))
                                        >> 12u32) as u16)
        }
    }
    #[inline]
    pub fn set_MaxReadRequestSize(&mut self, val: USHORT) {
        self._bitfield_1 &= !(28672usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 12u32) & (28672usize as u16);
    }
    #[inline]
    pub fn BridgeConfigRetryEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32768usize as u16))
                                        >> 15u32) as u16)
        }
    }
    #[inline]
    pub fn set_BridgeConfigRetryEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(32768usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 15u32) & (32768usize as u16);
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_DEVICE_CONTROL_REGISTER__bindgen_ty_2 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_DEVICE_CONTROL_REGISTER__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_DEVICE_CONTROL_REGISTER__bindgen_ty_2>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_DEVICE_CONTROL_REGISTER__bindgen_ty_2>()
               , 2usize);
}
impl Clone for _PCI_EXPRESS_DEVICE_CONTROL_REGISTER__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_DEVICE_CONTROL_REGISTER__bindgen_ty_2 {
    #[inline]
    pub fn at_offset_0(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32767usize as u16))
                                        >> 0u32) as u16)
        }
    }
    #[inline]
    pub fn set_at_offset_0(&mut self, val: USHORT) {
        self._bitfield_1 &= !(32767usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 0u32) & (32767usize as u16);
    }
    #[inline]
    pub fn InitiateFunctionLevelReset(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32768usize as u16))
                                        >> 15u32) as u16)
        }
    }
    #[inline]
    pub fn set_InitiateFunctionLevelReset(&mut self, val: USHORT) {
        self._bitfield_1 &= !(32768usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 15u32) & (32768usize as u16);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_DEVICE_CONTROL_REGISTER() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_DEVICE_CONTROL_REGISTER>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_DEVICE_CONTROL_REGISTER>()
               , 2usize);
}
impl Clone for _PCI_EXPRESS_DEVICE_CONTROL_REGISTER {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_DEVICE_CONTROL_REGISTER as
        PCI_EXPRESS_DEVICE_CONTROL_REGISTER;
pub type PPCI_EXPRESS_DEVICE_CONTROL_REGISTER =
    *mut _PCI_EXPRESS_DEVICE_CONTROL_REGISTER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_DEVICE_STATUS_REGISTER {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_DEVICE_STATUS_REGISTER__bindgen_ty_1>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: u16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_DEVICE_STATUS_REGISTER__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_DEVICE_STATUS_REGISTER__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_DEVICE_STATUS_REGISTER__bindgen_ty_1>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_DEVICE_STATUS_REGISTER__bindgen_ty_1>()
               , 2usize);
}
impl Clone for _PCI_EXPRESS_DEVICE_STATUS_REGISTER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_DEVICE_STATUS_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn CorrectableErrorDetected(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_CorrectableErrorDetected(&mut self, val: USHORT) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn NonFatalErrorDetected(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u16)) >>
                                        1u32) as u16)
        }
    }
    #[inline]
    pub fn set_NonFatalErrorDetected(&mut self, val: USHORT) {
        self._bitfield_1 &= !(2usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 1u32) & (2usize as u16);
    }
    #[inline]
    pub fn FatalErrorDetected(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u16)) >>
                                        2u32) as u16)
        }
    }
    #[inline]
    pub fn set_FatalErrorDetected(&mut self, val: USHORT) {
        self._bitfield_1 &= !(4usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 2u32) & (4usize as u16);
    }
    #[inline]
    pub fn UnsupportedRequestDetected(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u16)) >>
                                        3u32) as u16)
        }
    }
    #[inline]
    pub fn set_UnsupportedRequestDetected(&mut self, val: USHORT) {
        self._bitfield_1 &= !(8usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 3u32) & (8usize as u16);
    }
    #[inline]
    pub fn AuxPowerDetected(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u16)) >>
                                        4u32) as u16)
        }
    }
    #[inline]
    pub fn set_AuxPowerDetected(&mut self, val: USHORT) {
        self._bitfield_1 &= !(16usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 4u32) & (16usize as u16);
    }
    #[inline]
    pub fn TransactionsPending(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u16)) >>
                                        5u32) as u16)
        }
    }
    #[inline]
    pub fn set_TransactionsPending(&mut self, val: USHORT) {
        self._bitfield_1 &= !(32usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 5u32) & (32usize as u16);
    }
    #[inline]
    pub fn Rsvd(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65472usize as u16))
                                        >> 6u32) as u16)
        }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: USHORT) {
        self._bitfield_1 &= !(65472usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 6u32) & (65472usize as u16);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_DEVICE_STATUS_REGISTER() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_DEVICE_STATUS_REGISTER>() ,
               2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_DEVICE_STATUS_REGISTER>()
               , 2usize);
}
impl Clone for _PCI_EXPRESS_DEVICE_STATUS_REGISTER {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_DEVICE_STATUS_REGISTER as
        PCI_EXPRESS_DEVICE_STATUS_REGISTER;
pub type PPCI_EXPRESS_DEVICE_STATUS_REGISTER =
    *mut _PCI_EXPRESS_DEVICE_STATUS_REGISTER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_LINK_CAPABILITIES_REGISTER {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_LINK_CAPABILITIES_REGISTER__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_LINK_CAPABILITIES_REGISTER__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_LINK_CAPABILITIES_REGISTER__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_LINK_CAPABILITIES_REGISTER__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_LINK_CAPABILITIES_REGISTER__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_LINK_CAPABILITIES_REGISTER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_LINK_CAPABILITIES_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn MaximumLinkSpeed(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (15usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_MaximumLinkSpeed(&mut self, val: ULONG) {
        self._bitfield_1 &= !(15usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (15usize as u32);
    }
    #[inline]
    pub fn MaximumLinkWidth(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1008usize as u32)) >>
                                        4u32) as u32)
        }
    }
    #[inline]
    pub fn set_MaximumLinkWidth(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1008usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 4u32) & (1008usize as u32);
    }
    #[inline]
    pub fn ActiveStatePMSupport(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (3072usize as u32)) >>
                                        10u32) as u32)
        }
    }
    #[inline]
    pub fn set_ActiveStatePMSupport(&mut self, val: ULONG) {
        self._bitfield_1 &= !(3072usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 10u32) & (3072usize as u32);
    }
    #[inline]
    pub fn L0sExitLatency(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (28672usize as u32))
                                        >> 12u32) as u32)
        }
    }
    #[inline]
    pub fn set_L0sExitLatency(&mut self, val: ULONG) {
        self._bitfield_1 &= !(28672usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 12u32) & (28672usize as u32);
    }
    #[inline]
    pub fn L1ExitLatency(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (229376usize as u32))
                                        >> 15u32) as u32)
        }
    }
    #[inline]
    pub fn set_L1ExitLatency(&mut self, val: ULONG) {
        self._bitfield_1 &= !(229376usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 15u32) & (229376usize as u32);
    }
    #[inline]
    pub fn ClockPowerManagement(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (262144usize as u32))
                                        >> 18u32) as u32)
        }
    }
    #[inline]
    pub fn set_ClockPowerManagement(&mut self, val: ULONG) {
        self._bitfield_1 &= !(262144usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 18u32) & (262144usize as u32);
    }
    #[inline]
    pub fn SurpriseDownErrorReportingCapable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (524288usize as u32))
                                        >> 19u32) as u32)
        }
    }
    #[inline]
    pub fn set_SurpriseDownErrorReportingCapable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(524288usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 19u32) & (524288usize as u32);
    }
    #[inline]
    pub fn DataLinkLayerActiveReportingCapable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1048576usize as u32))
                                        >> 20u32) as u32)
        }
    }
    #[inline]
    pub fn set_DataLinkLayerActiveReportingCapable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1048576usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 20u32) & (1048576usize as u32);
    }
    #[inline]
    pub fn LinkBandwidthNotificationCapability(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2097152usize as u32))
                                        >> 21u32) as u32)
        }
    }
    #[inline]
    pub fn set_LinkBandwidthNotificationCapability(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2097152usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 21u32) & (2097152usize as u32);
    }
    #[inline]
    pub fn AspmOptionalityCompliance(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4194304usize as u32))
                                        >> 22u32) as u32)
        }
    }
    #[inline]
    pub fn set_AspmOptionalityCompliance(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4194304usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 22u32) & (4194304usize as u32);
    }
    #[inline]
    pub fn Rsvd(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8388608usize as u32))
                                        >> 23u32) as u32)
        }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8388608usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 23u32) & (8388608usize as u32);
    }
    #[inline]
    pub fn PortNumber(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4278190080usize as u32)) >> 24u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_PortNumber(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4278190080usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 24u32) & (4278190080usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_LINK_CAPABILITIES_REGISTER() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_LINK_CAPABILITIES_REGISTER>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_LINK_CAPABILITIES_REGISTER>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_LINK_CAPABILITIES_REGISTER {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_LINK_CAPABILITIES_REGISTER as
        PCI_EXPRESS_LINK_CAPABILITIES_REGISTER;
pub type PPCI_EXPRESS_LINK_CAPABILITIES_REGISTER =
    *mut _PCI_EXPRESS_LINK_CAPABILITIES_REGISTER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_LINK_CONTROL_REGISTER {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_LINK_CONTROL_REGISTER__bindgen_ty_1>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: u16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_LINK_CONTROL_REGISTER__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_LINK_CONTROL_REGISTER__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_LINK_CONTROL_REGISTER__bindgen_ty_1>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_LINK_CONTROL_REGISTER__bindgen_ty_1>()
               , 2usize);
}
impl Clone for _PCI_EXPRESS_LINK_CONTROL_REGISTER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_LINK_CONTROL_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn ActiveStatePMControl(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (3usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_ActiveStatePMControl(&mut self, val: USHORT) {
        self._bitfield_1 &= !(3usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (3usize as u16);
    }
    #[inline]
    pub fn Rsvd1(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u16)) >>
                                        2u32) as u16)
        }
    }
    #[inline]
    pub fn set_Rsvd1(&mut self, val: USHORT) {
        self._bitfield_1 &= !(4usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 2u32) & (4usize as u16);
    }
    #[inline]
    pub fn ReadCompletionBoundary(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u16)) >>
                                        3u32) as u16)
        }
    }
    #[inline]
    pub fn set_ReadCompletionBoundary(&mut self, val: USHORT) {
        self._bitfield_1 &= !(8usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 3u32) & (8usize as u16);
    }
    #[inline]
    pub fn LinkDisable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u16)) >>
                                        4u32) as u16)
        }
    }
    #[inline]
    pub fn set_LinkDisable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(16usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 4u32) & (16usize as u16);
    }
    #[inline]
    pub fn RetrainLink(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u16)) >>
                                        5u32) as u16)
        }
    }
    #[inline]
    pub fn set_RetrainLink(&mut self, val: USHORT) {
        self._bitfield_1 &= !(32usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 5u32) & (32usize as u16);
    }
    #[inline]
    pub fn CommonClockConfig(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u16)) >>
                                        6u32) as u16)
        }
    }
    #[inline]
    pub fn set_CommonClockConfig(&mut self, val: USHORT) {
        self._bitfield_1 &= !(64usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 6u32) & (64usize as u16);
    }
    #[inline]
    pub fn ExtendedSynch(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (128usize as u16)) >>
                                        7u32) as u16)
        }
    }
    #[inline]
    pub fn set_ExtendedSynch(&mut self, val: USHORT) {
        self._bitfield_1 &= !(128usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 7u32) & (128usize as u16);
    }
    #[inline]
    pub fn EnableClockPowerManagement(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (256usize as u16)) >>
                                        8u32) as u16)
        }
    }
    #[inline]
    pub fn set_EnableClockPowerManagement(&mut self, val: USHORT) {
        self._bitfield_1 &= !(256usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 8u32) & (256usize as u16);
    }
    #[inline]
    pub fn Rsvd2(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65024usize as u16))
                                        >> 9u32) as u16)
        }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: USHORT) {
        self._bitfield_1 &= !(65024usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 9u32) & (65024usize as u16);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_LINK_CONTROL_REGISTER() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_LINK_CONTROL_REGISTER>() ,
               2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_LINK_CONTROL_REGISTER>() ,
               2usize);
}
impl Clone for _PCI_EXPRESS_LINK_CONTROL_REGISTER {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_LINK_CONTROL_REGISTER as
        PCI_EXPRESS_LINK_CONTROL_REGISTER;
pub type PPCI_EXPRESS_LINK_CONTROL_REGISTER =
    *mut _PCI_EXPRESS_LINK_CONTROL_REGISTER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_LINK_STATUS_REGISTER {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_LINK_STATUS_REGISTER__bindgen_ty_1>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: u16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_LINK_STATUS_REGISTER__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_LINK_STATUS_REGISTER__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_LINK_STATUS_REGISTER__bindgen_ty_1>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_LINK_STATUS_REGISTER__bindgen_ty_1>()
               , 2usize);
}
impl Clone for _PCI_EXPRESS_LINK_STATUS_REGISTER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_LINK_STATUS_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn LinkSpeed(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (15usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_LinkSpeed(&mut self, val: USHORT) {
        self._bitfield_1 &= !(15usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (15usize as u16);
    }
    #[inline]
    pub fn LinkWidth(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1008usize as u16)) >>
                                        4u32) as u16)
        }
    }
    #[inline]
    pub fn set_LinkWidth(&mut self, val: USHORT) {
        self._bitfield_1 &= !(1008usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 4u32) & (1008usize as u16);
    }
    #[inline]
    pub fn Undefined(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1024usize as u16)) >>
                                        10u32) as u16)
        }
    }
    #[inline]
    pub fn set_Undefined(&mut self, val: USHORT) {
        self._bitfield_1 &= !(1024usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 10u32) & (1024usize as u16);
    }
    #[inline]
    pub fn LinkTraining(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2048usize as u16)) >>
                                        11u32) as u16)
        }
    }
    #[inline]
    pub fn set_LinkTraining(&mut self, val: USHORT) {
        self._bitfield_1 &= !(2048usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 11u32) & (2048usize as u16);
    }
    #[inline]
    pub fn SlotClockConfig(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4096usize as u16)) >>
                                        12u32) as u16)
        }
    }
    #[inline]
    pub fn set_SlotClockConfig(&mut self, val: USHORT) {
        self._bitfield_1 &= !(4096usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 12u32) & (4096usize as u16);
    }
    #[inline]
    pub fn DataLinkLayerActive(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8192usize as u16)) >>
                                        13u32) as u16)
        }
    }
    #[inline]
    pub fn set_DataLinkLayerActive(&mut self, val: USHORT) {
        self._bitfield_1 &= !(8192usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 13u32) & (8192usize as u16);
    }
    #[inline]
    pub fn Rsvd(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (49152usize as u16))
                                        >> 14u32) as u16)
        }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: USHORT) {
        self._bitfield_1 &= !(49152usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 14u32) & (49152usize as u16);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_LINK_STATUS_REGISTER() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_LINK_STATUS_REGISTER>() ,
               2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_LINK_STATUS_REGISTER>() ,
               2usize);
}
impl Clone for _PCI_EXPRESS_LINK_STATUS_REGISTER {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_LINK_STATUS_REGISTER as
        PCI_EXPRESS_LINK_STATUS_REGISTER;
pub type PPCI_EXPRESS_LINK_STATUS_REGISTER =
    *mut _PCI_EXPRESS_LINK_STATUS_REGISTER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn AttentionButtonPresent(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_AttentionButtonPresent(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn PowerControllerPresent(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_PowerControllerPresent(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn MRLSensorPresent(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                        2u32) as u32)
        }
    }
    #[inline]
    pub fn set_MRLSensorPresent(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn AttentionIndicatorPresent(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u32)) >>
                                        3u32) as u32)
        }
    }
    #[inline]
    pub fn set_AttentionIndicatorPresent(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (8usize as u32);
    }
    #[inline]
    pub fn PowerIndicatorPresent(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u32)) >>
                                        4u32) as u32)
        }
    }
    #[inline]
    pub fn set_PowerIndicatorPresent(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (16usize as u32);
    }
    #[inline]
    pub fn HotPlugSurprise(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u32)) >>
                                        5u32) as u32)
        }
    }
    #[inline]
    pub fn set_HotPlugSurprise(&mut self, val: ULONG) {
        self._bitfield_1 &= !(32usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (32usize as u32);
    }
    #[inline]
    pub fn HotPlugCapable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u32)) >>
                                        6u32) as u32)
        }
    }
    #[inline]
    pub fn set_HotPlugCapable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(64usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 6u32) & (64usize as u32);
    }
    #[inline]
    pub fn SlotPowerLimit(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32640usize as u32))
                                        >> 7u32) as u32)
        }
    }
    #[inline]
    pub fn set_SlotPowerLimit(&mut self, val: ULONG) {
        self._bitfield_1 &= !(32640usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 7u32) & (32640usize as u32);
    }
    #[inline]
    pub fn SlotPowerLimitScale(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (98304usize as u32))
                                        >> 15u32) as u32)
        }
    }
    #[inline]
    pub fn set_SlotPowerLimitScale(&mut self, val: ULONG) {
        self._bitfield_1 &= !(98304usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 15u32) & (98304usize as u32);
    }
    #[inline]
    pub fn ElectromechanicalLockPresent(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (131072usize as u32))
                                        >> 17u32) as u32)
        }
    }
    #[inline]
    pub fn set_ElectromechanicalLockPresent(&mut self, val: ULONG) {
        self._bitfield_1 &= !(131072usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 17u32) & (131072usize as u32);
    }
    #[inline]
    pub fn NoCommandCompletedSupport(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (262144usize as u32))
                                        >> 18u32) as u32)
        }
    }
    #[inline]
    pub fn set_NoCommandCompletedSupport(&mut self, val: ULONG) {
        self._bitfield_1 &= !(262144usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 18u32) & (262144usize as u32);
    }
    #[inline]
    pub fn PhysicalSlotNumber(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294443008usize as u32)) >> 19u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_PhysicalSlotNumber(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294443008usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 19u32) & (4294443008usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER as
        PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER;
pub type PPCI_EXPRESS_SLOT_CAPABILITIES_REGISTER =
    *mut _PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_SLOT_CONTROL_REGISTER {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_SLOT_CONTROL_REGISTER__bindgen_ty_1>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: u16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_SLOT_CONTROL_REGISTER__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_SLOT_CONTROL_REGISTER__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_SLOT_CONTROL_REGISTER__bindgen_ty_1>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_SLOT_CONTROL_REGISTER__bindgen_ty_1>()
               , 2usize);
}
impl Clone for _PCI_EXPRESS_SLOT_CONTROL_REGISTER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_SLOT_CONTROL_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn AttentionButtonEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_AttentionButtonEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn PowerFaultDetectEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u16)) >>
                                        1u32) as u16)
        }
    }
    #[inline]
    pub fn set_PowerFaultDetectEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(2usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 1u32) & (2usize as u16);
    }
    #[inline]
    pub fn MRLSensorEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u16)) >>
                                        2u32) as u16)
        }
    }
    #[inline]
    pub fn set_MRLSensorEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(4usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 2u32) & (4usize as u16);
    }
    #[inline]
    pub fn PresenceDetectEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u16)) >>
                                        3u32) as u16)
        }
    }
    #[inline]
    pub fn set_PresenceDetectEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(8usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 3u32) & (8usize as u16);
    }
    #[inline]
    pub fn CommandCompletedEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u16)) >>
                                        4u32) as u16)
        }
    }
    #[inline]
    pub fn set_CommandCompletedEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(16usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 4u32) & (16usize as u16);
    }
    #[inline]
    pub fn HotPlugInterruptEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u16)) >>
                                        5u32) as u16)
        }
    }
    #[inline]
    pub fn set_HotPlugInterruptEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(32usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 5u32) & (32usize as u16);
    }
    #[inline]
    pub fn AttentionIndicatorControl(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (192usize as u16)) >>
                                        6u32) as u16)
        }
    }
    #[inline]
    pub fn set_AttentionIndicatorControl(&mut self, val: USHORT) {
        self._bitfield_1 &= !(192usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 6u32) & (192usize as u16);
    }
    #[inline]
    pub fn PowerIndicatorControl(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (768usize as u16)) >>
                                        8u32) as u16)
        }
    }
    #[inline]
    pub fn set_PowerIndicatorControl(&mut self, val: USHORT) {
        self._bitfield_1 &= !(768usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 8u32) & (768usize as u16);
    }
    #[inline]
    pub fn PowerControllerControl(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1024usize as u16)) >>
                                        10u32) as u16)
        }
    }
    #[inline]
    pub fn set_PowerControllerControl(&mut self, val: USHORT) {
        self._bitfield_1 &= !(1024usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 10u32) & (1024usize as u16);
    }
    #[inline]
    pub fn ElectromechanicalLockControl(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2048usize as u16)) >>
                                        11u32) as u16)
        }
    }
    #[inline]
    pub fn set_ElectromechanicalLockControl(&mut self, val: USHORT) {
        self._bitfield_1 &= !(2048usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 11u32) & (2048usize as u16);
    }
    #[inline]
    pub fn DataLinkStateChangeEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4096usize as u16)) >>
                                        12u32) as u16)
        }
    }
    #[inline]
    pub fn set_DataLinkStateChangeEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(4096usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 12u32) & (4096usize as u16);
    }
    #[inline]
    pub fn Rsvd(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (57344usize as u16))
                                        >> 13u32) as u16)
        }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: USHORT) {
        self._bitfield_1 &= !(57344usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 13u32) & (57344usize as u16);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_SLOT_CONTROL_REGISTER() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_SLOT_CONTROL_REGISTER>() ,
               2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_SLOT_CONTROL_REGISTER>() ,
               2usize);
}
impl Clone for _PCI_EXPRESS_SLOT_CONTROL_REGISTER {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_SLOT_CONTROL_REGISTER as
        PCI_EXPRESS_SLOT_CONTROL_REGISTER;
pub type PPCI_EXPRESS_SLOT_CONTROL_REGISTER =
    *mut _PCI_EXPRESS_SLOT_CONTROL_REGISTER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_SLOT_STATUS_REGISTER {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_SLOT_STATUS_REGISTER__bindgen_ty_1>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: u16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_SLOT_STATUS_REGISTER__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_SLOT_STATUS_REGISTER__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_SLOT_STATUS_REGISTER__bindgen_ty_1>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_SLOT_STATUS_REGISTER__bindgen_ty_1>()
               , 2usize);
}
impl Clone for _PCI_EXPRESS_SLOT_STATUS_REGISTER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_SLOT_STATUS_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn AttentionButtonPressed(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_AttentionButtonPressed(&mut self, val: USHORT) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn PowerFaultDetected(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u16)) >>
                                        1u32) as u16)
        }
    }
    #[inline]
    pub fn set_PowerFaultDetected(&mut self, val: USHORT) {
        self._bitfield_1 &= !(2usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 1u32) & (2usize as u16);
    }
    #[inline]
    pub fn MRLSensorChanged(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u16)) >>
                                        2u32) as u16)
        }
    }
    #[inline]
    pub fn set_MRLSensorChanged(&mut self, val: USHORT) {
        self._bitfield_1 &= !(4usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 2u32) & (4usize as u16);
    }
    #[inline]
    pub fn PresenceDetectChanged(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u16)) >>
                                        3u32) as u16)
        }
    }
    #[inline]
    pub fn set_PresenceDetectChanged(&mut self, val: USHORT) {
        self._bitfield_1 &= !(8usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 3u32) & (8usize as u16);
    }
    #[inline]
    pub fn CommandCompleted(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u16)) >>
                                        4u32) as u16)
        }
    }
    #[inline]
    pub fn set_CommandCompleted(&mut self, val: USHORT) {
        self._bitfield_1 &= !(16usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 4u32) & (16usize as u16);
    }
    #[inline]
    pub fn MRLSensorState(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u16)) >>
                                        5u32) as u16)
        }
    }
    #[inline]
    pub fn set_MRLSensorState(&mut self, val: USHORT) {
        self._bitfield_1 &= !(32usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 5u32) & (32usize as u16);
    }
    #[inline]
    pub fn PresenceDetectState(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u16)) >>
                                        6u32) as u16)
        }
    }
    #[inline]
    pub fn set_PresenceDetectState(&mut self, val: USHORT) {
        self._bitfield_1 &= !(64usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 6u32) & (64usize as u16);
    }
    #[inline]
    pub fn ElectromechanicalLockEngaged(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (128usize as u16)) >>
                                        7u32) as u16)
        }
    }
    #[inline]
    pub fn set_ElectromechanicalLockEngaged(&mut self, val: USHORT) {
        self._bitfield_1 &= !(128usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 7u32) & (128usize as u16);
    }
    #[inline]
    pub fn DataLinkStateChanged(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (256usize as u16)) >>
                                        8u32) as u16)
        }
    }
    #[inline]
    pub fn set_DataLinkStateChanged(&mut self, val: USHORT) {
        self._bitfield_1 &= !(256usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 8u32) & (256usize as u16);
    }
    #[inline]
    pub fn Rsvd(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65024usize as u16))
                                        >> 9u32) as u16)
        }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: USHORT) {
        self._bitfield_1 &= !(65024usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 9u32) & (65024usize as u16);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_SLOT_STATUS_REGISTER() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_SLOT_STATUS_REGISTER>() ,
               2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_SLOT_STATUS_REGISTER>() ,
               2usize);
}
impl Clone for _PCI_EXPRESS_SLOT_STATUS_REGISTER {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_SLOT_STATUS_REGISTER as
        PCI_EXPRESS_SLOT_STATUS_REGISTER;
pub type PPCI_EXPRESS_SLOT_STATUS_REGISTER =
    *mut _PCI_EXPRESS_SLOT_STATUS_REGISTER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_ROOT_CONTROL_REGISTER {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_ROOT_CONTROL_REGISTER__bindgen_ty_1>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: u16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_ROOT_CONTROL_REGISTER__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_ROOT_CONTROL_REGISTER__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_ROOT_CONTROL_REGISTER__bindgen_ty_1>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_ROOT_CONTROL_REGISTER__bindgen_ty_1>()
               , 2usize);
}
impl Clone for _PCI_EXPRESS_ROOT_CONTROL_REGISTER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_ROOT_CONTROL_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn CorrectableSerrEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_CorrectableSerrEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn NonFatalSerrEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u16)) >>
                                        1u32) as u16)
        }
    }
    #[inline]
    pub fn set_NonFatalSerrEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(2usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 1u32) & (2usize as u16);
    }
    #[inline]
    pub fn FatalSerrEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u16)) >>
                                        2u32) as u16)
        }
    }
    #[inline]
    pub fn set_FatalSerrEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(4usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 2u32) & (4usize as u16);
    }
    #[inline]
    pub fn PMEInterruptEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u16)) >>
                                        3u32) as u16)
        }
    }
    #[inline]
    pub fn set_PMEInterruptEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(8usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 3u32) & (8usize as u16);
    }
    #[inline]
    pub fn CRSSoftwareVisibilityEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u16)) >>
                                        4u32) as u16)
        }
    }
    #[inline]
    pub fn set_CRSSoftwareVisibilityEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(16usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 4u32) & (16usize as u16);
    }
    #[inline]
    pub fn Rsvd(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65504usize as u16))
                                        >> 5u32) as u16)
        }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: USHORT) {
        self._bitfield_1 &= !(65504usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 5u32) & (65504usize as u16);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_ROOT_CONTROL_REGISTER() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_ROOT_CONTROL_REGISTER>() ,
               2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_ROOT_CONTROL_REGISTER>() ,
               2usize);
}
impl Clone for _PCI_EXPRESS_ROOT_CONTROL_REGISTER {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_ROOT_CONTROL_REGISTER as
        PCI_EXPRESS_ROOT_CONTROL_REGISTER;
pub type PPCI_EXPRESS_ROOT_CONTROL_REGISTER =
    *mut _PCI_EXPRESS_ROOT_CONTROL_REGISTER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER__bindgen_ty_1>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: u16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER__bindgen_ty_1>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER__bindgen_ty_1>()
               , 2usize);
}
impl Clone for _PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn CRSSoftwareVisibility(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_CRSSoftwareVisibility(&mut self, val: USHORT) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn Rsvd(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65534usize as u16))
                                        >> 1u32) as u16)
        }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: USHORT) {
        self._bitfield_1 &= !(65534usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 1u32) & (65534usize as u16);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER>()
               , 2usize);
}
impl Clone for _PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER as
        PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER;
pub type PPCI_EXPRESS_ROOT_CAPABILITIES_REGISTER =
    *mut _PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_ROOT_STATUS_REGISTER {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_ROOT_STATUS_REGISTER__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_ROOT_STATUS_REGISTER__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_ROOT_STATUS_REGISTER__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_ROOT_STATUS_REGISTER__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_ROOT_STATUS_REGISTER__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_ROOT_STATUS_REGISTER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_ROOT_STATUS_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn PMERequestorId(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65535usize as u32))
                                        >> 0u32) as u32)
        }
    }
    #[inline]
    pub fn set_PMERequestorId(&mut self, val: ULONG) {
        self._bitfield_1 &= !(65535usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 0u32) & (65535usize as u32);
    }
    #[inline]
    pub fn PMEStatus(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65536usize as u32))
                                        >> 16u32) as u32)
        }
    }
    #[inline]
    pub fn set_PMEStatus(&mut self, val: ULONG) {
        self._bitfield_1 &= !(65536usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (65536usize as u32);
    }
    #[inline]
    pub fn PMEPending(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (131072usize as u32))
                                        >> 17u32) as u32)
        }
    }
    #[inline]
    pub fn set_PMEPending(&mut self, val: ULONG) {
        self._bitfield_1 &= !(131072usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 17u32) & (131072usize as u32);
    }
    #[inline]
    pub fn Rsvd(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294705152usize as u32)) >> 18u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294705152usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 18u32) & (4294705152usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_ROOT_STATUS_REGISTER() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_ROOT_STATUS_REGISTER>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_ROOT_STATUS_REGISTER>() ,
               4usize);
}
impl Clone for _PCI_EXPRESS_ROOT_STATUS_REGISTER {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_ROOT_STATUS_REGISTER as
        PCI_EXPRESS_ROOT_STATUS_REGISTER;
pub type PPCI_EXPRESS_ROOT_STATUS_REGISTER =
    *mut _PCI_EXPRESS_ROOT_STATUS_REGISTER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn CompletionTimeoutRangesSupported(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (15usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_CompletionTimeoutRangesSupported(&mut self, val: ULONG) {
        self._bitfield_1 &= !(15usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (15usize as u32);
    }
    #[inline]
    pub fn CompletionTimeoutDisableSupported(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u32)) >>
                                        4u32) as u32)
        }
    }
    #[inline]
    pub fn set_CompletionTimeoutDisableSupported(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (16usize as u32);
    }
    #[inline]
    pub fn AriForwardingSupported(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u32)) >>
                                        5u32) as u32)
        }
    }
    #[inline]
    pub fn set_AriForwardingSupported(&mut self, val: ULONG) {
        self._bitfield_1 &= !(32usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (32usize as u32);
    }
    #[inline]
    pub fn AtomicOpRoutingSupported(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u32)) >>
                                        6u32) as u32)
        }
    }
    #[inline]
    pub fn set_AtomicOpRoutingSupported(&mut self, val: ULONG) {
        self._bitfield_1 &= !(64usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 6u32) & (64usize as u32);
    }
    #[inline]
    pub fn AtomicOpCompleterSupported32Bit(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (128usize as u32)) >>
                                        7u32) as u32)
        }
    }
    #[inline]
    pub fn set_AtomicOpCompleterSupported32Bit(&mut self, val: ULONG) {
        self._bitfield_1 &= !(128usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 7u32) & (128usize as u32);
    }
    #[inline]
    pub fn AtomicOpCompleterSupported64Bit(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (256usize as u32)) >>
                                        8u32) as u32)
        }
    }
    #[inline]
    pub fn set_AtomicOpCompleterSupported64Bit(&mut self, val: ULONG) {
        self._bitfield_1 &= !(256usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 8u32) & (256usize as u32);
    }
    #[inline]
    pub fn CASCompleterSupported128Bit(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (512usize as u32)) >>
                                        9u32) as u32)
        }
    }
    #[inline]
    pub fn set_CASCompleterSupported128Bit(&mut self, val: ULONG) {
        self._bitfield_1 &= !(512usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 9u32) & (512usize as u32);
    }
    #[inline]
    pub fn NoROEnabledPRPRPassing(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1024usize as u32)) >>
                                        10u32) as u32)
        }
    }
    #[inline]
    pub fn set_NoROEnabledPRPRPassing(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1024usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 10u32) & (1024usize as u32);
    }
    #[inline]
    pub fn LTRMechanismSupported(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2048usize as u32)) >>
                                        11u32) as u32)
        }
    }
    #[inline]
    pub fn set_LTRMechanismSupported(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2048usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 11u32) & (2048usize as u32);
    }
    #[inline]
    pub fn TPHCompleterSupported(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (12288usize as u32))
                                        >> 12u32) as u32)
        }
    }
    #[inline]
    pub fn set_TPHCompleterSupported(&mut self, val: ULONG) {
        self._bitfield_1 &= !(12288usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 12u32) & (12288usize as u32);
    }
    #[inline]
    pub fn Rsvd(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (245760usize as u32))
                                        >> 14u32) as u32)
        }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: ULONG) {
        self._bitfield_1 &= !(245760usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 14u32) & (245760usize as u32);
    }
    #[inline]
    pub fn OBFFSupported(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (786432usize as u32))
                                        >> 18u32) as u32)
        }
    }
    #[inline]
    pub fn set_OBFFSupported(&mut self, val: ULONG) {
        self._bitfield_1 &= !(786432usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 18u32) & (786432usize as u32);
    }
    #[inline]
    pub fn ExtendedFmtFieldSuported(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1048576usize as u32))
                                        >> 20u32) as u32)
        }
    }
    #[inline]
    pub fn set_ExtendedFmtFieldSuported(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1048576usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 20u32) & (1048576usize as u32);
    }
    #[inline]
    pub fn EndEndTLPPrefixSupported(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2097152usize as u32))
                                        >> 21u32) as u32)
        }
    }
    #[inline]
    pub fn set_EndEndTLPPrefixSupported(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2097152usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 21u32) & (2097152usize as u32);
    }
    #[inline]
    pub fn MaxEndEndTLPPrefixes(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (12582912usize as u32)) >> 22u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_MaxEndEndTLPPrefixes(&mut self, val: ULONG) {
        self._bitfield_1 &= !(12582912usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 22u32) & (12582912usize as u32);
    }
    #[inline]
    pub fn Rsvd2(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4278190080usize as u32)) >> 24u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4278190080usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 24u32) & (4278190080usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER as
        PCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER;
pub type PPCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER =
    *mut _PCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_DEVICE_CONTROL_2_REGISTER {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_DEVICE_CONTROL_2_REGISTER__bindgen_ty_1>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: u16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_DEVICE_CONTROL_2_REGISTER__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_DEVICE_CONTROL_2_REGISTER__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_DEVICE_CONTROL_2_REGISTER__bindgen_ty_1>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_DEVICE_CONTROL_2_REGISTER__bindgen_ty_1>()
               , 2usize);
}
impl Clone for _PCI_EXPRESS_DEVICE_CONTROL_2_REGISTER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_DEVICE_CONTROL_2_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn CompletionTimeoutValue(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (15usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_CompletionTimeoutValue(&mut self, val: USHORT) {
        self._bitfield_1 &= !(15usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (15usize as u16);
    }
    #[inline]
    pub fn CompletionTimeoutDisable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u16)) >>
                                        4u32) as u16)
        }
    }
    #[inline]
    pub fn set_CompletionTimeoutDisable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(16usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 4u32) & (16usize as u16);
    }
    #[inline]
    pub fn AriForwardingEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u16)) >>
                                        5u32) as u16)
        }
    }
    #[inline]
    pub fn set_AriForwardingEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(32usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 5u32) & (32usize as u16);
    }
    #[inline]
    pub fn AtomicOpRequesterEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u16)) >>
                                        6u32) as u16)
        }
    }
    #[inline]
    pub fn set_AtomicOpRequesterEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(64usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 6u32) & (64usize as u16);
    }
    #[inline]
    pub fn AtomicOpEgresBlocking(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (128usize as u16)) >>
                                        7u32) as u16)
        }
    }
    #[inline]
    pub fn set_AtomicOpEgresBlocking(&mut self, val: USHORT) {
        self._bitfield_1 &= !(128usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 7u32) & (128usize as u16);
    }
    #[inline]
    pub fn IDORequestEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (256usize as u16)) >>
                                        8u32) as u16)
        }
    }
    #[inline]
    pub fn set_IDORequestEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(256usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 8u32) & (256usize as u16);
    }
    #[inline]
    pub fn IDOCompletionEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (512usize as u16)) >>
                                        9u32) as u16)
        }
    }
    #[inline]
    pub fn set_IDOCompletionEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(512usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 9u32) & (512usize as u16);
    }
    #[inline]
    pub fn LTRMechanismEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1024usize as u16)) >>
                                        10u32) as u16)
        }
    }
    #[inline]
    pub fn set_LTRMechanismEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(1024usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 10u32) & (1024usize as u16);
    }
    #[inline]
    pub fn Rsvd(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (6144usize as u16)) >>
                                        11u32) as u16)
        }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: USHORT) {
        self._bitfield_1 &= !(6144usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 11u32) & (6144usize as u16);
    }
    #[inline]
    pub fn OBFFEnable(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (24576usize as u16))
                                        >> 13u32) as u16)
        }
    }
    #[inline]
    pub fn set_OBFFEnable(&mut self, val: USHORT) {
        self._bitfield_1 &= !(24576usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 13u32) & (24576usize as u16);
    }
    #[inline]
    pub fn EndEndTLPPrefixBlocking(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32768usize as u16))
                                        >> 15u32) as u16)
        }
    }
    #[inline]
    pub fn set_EndEndTLPPrefixBlocking(&mut self, val: USHORT) {
        self._bitfield_1 &= !(32768usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 15u32) & (32768usize as u16);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_DEVICE_CONTROL_2_REGISTER() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_DEVICE_CONTROL_2_REGISTER>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_DEVICE_CONTROL_2_REGISTER>()
               , 2usize);
}
impl Clone for _PCI_EXPRESS_DEVICE_CONTROL_2_REGISTER {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_DEVICE_CONTROL_2_REGISTER as
        PCI_EXPRESS_DEVICE_CONTROL_2_REGISTER;
pub type PPCI_EXPRESS_DEVICE_CONTROL_2_REGISTER =
    *mut _PCI_EXPRESS_DEVICE_CONTROL_2_REGISTER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_DEVICE_STATUS_2_REGISTER {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_DEVICE_STATUS_2_REGISTER__bindgen_ty_1>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: u16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_DEVICE_STATUS_2_REGISTER__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_DEVICE_STATUS_2_REGISTER__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_DEVICE_STATUS_2_REGISTER__bindgen_ty_1>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_DEVICE_STATUS_2_REGISTER__bindgen_ty_1>()
               , 2usize);
}
impl Clone for _PCI_EXPRESS_DEVICE_STATUS_2_REGISTER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_DEVICE_STATUS_2_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn Rsvd(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65535usize as u16))
                                        >> 0u32) as u16)
        }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: USHORT) {
        self._bitfield_1 &= !(65535usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 0u32) & (65535usize as u16);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_DEVICE_STATUS_2_REGISTER() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_DEVICE_STATUS_2_REGISTER>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_DEVICE_STATUS_2_REGISTER>()
               , 2usize);
}
impl Clone for _PCI_EXPRESS_DEVICE_STATUS_2_REGISTER {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_DEVICE_STATUS_2_REGISTER as
        PCI_EXPRESS_DEVICE_STATUS_2_REGISTER;
pub type PPCI_EXPRESS_DEVICE_STATUS_2_REGISTER =
    *mut _PCI_EXPRESS_DEVICE_STATUS_2_REGISTER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_CAPABILITY {
    pub Header: PCI_CAPABILITIES_HEADER,
    pub ExpressCapabilities: PCI_EXPRESS_CAPABILITIES_REGISTER,
    pub DeviceCapabilities: PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER,
    pub DeviceControl: PCI_EXPRESS_DEVICE_CONTROL_REGISTER,
    pub DeviceStatus: PCI_EXPRESS_DEVICE_STATUS_REGISTER,
    pub LinkCapabilities: PCI_EXPRESS_LINK_CAPABILITIES_REGISTER,
    pub LinkControl: PCI_EXPRESS_LINK_CONTROL_REGISTER,
    pub LinkStatus: PCI_EXPRESS_LINK_STATUS_REGISTER,
    pub SlotCapabilities: PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER,
    pub SlotControl: PCI_EXPRESS_SLOT_CONTROL_REGISTER,
    pub SlotStatus: PCI_EXPRESS_SLOT_STATUS_REGISTER,
    pub RootControl: PCI_EXPRESS_ROOT_CONTROL_REGISTER,
    pub RootCapabilities: PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER,
    pub RootStatus: PCI_EXPRESS_ROOT_STATUS_REGISTER,
    pub DeviceCapabilities2: PCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER,
    pub DeviceControl2: PCI_EXPRESS_DEVICE_CONTROL_2_REGISTER,
    pub DeviceStatus2: PCI_EXPRESS_DEVICE_STATUS_2_REGISTER,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_CAPABILITY() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_CAPABILITY>() , 44usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_CAPABILITY>() , 4usize);
}
impl Clone for _PCI_EXPRESS_CAPABILITY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_CAPABILITY as PCI_EXPRESS_CAPABILITY;
pub type PPCI_EXPRESS_CAPABILITY = *mut _PCI_EXPRESS_CAPABILITY;
pub const MRLClosed: _bindgen_ty_27 = _bindgen_ty_27::MRLClosed;
pub const MRLOpen: _bindgen_ty_27 = _bindgen_ty_27::MRLOpen;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_27 { MRLClosed = 0, MRLOpen = 1, }
pub use self::_bindgen_ty_27 as PCI_EXPRESS_MRL_STATE;
pub const SlotEmpty: _bindgen_ty_28 = _bindgen_ty_28::SlotEmpty;
pub const CardPresent: _bindgen_ty_28 = _bindgen_ty_28::CardPresent;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_28 { SlotEmpty = 0, CardPresent = 1, }
pub use self::_bindgen_ty_28 as PCI_EXPRESS_CARD_PRESENCE;
pub const IndicatorOn: _bindgen_ty_29 = _bindgen_ty_29::IndicatorOn;
pub const IndicatorBlink: _bindgen_ty_29 = _bindgen_ty_29::IndicatorBlink;
pub const IndicatorOff: _bindgen_ty_29 = _bindgen_ty_29::IndicatorOff;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_29 {
    IndicatorOn = 1,
    IndicatorBlink = 2,
    IndicatorOff = 3,
}
pub use self::_bindgen_ty_29 as PCI_EXPRESS_INDICATOR_STATE;
pub const PowerOn: _bindgen_ty_30 = _bindgen_ty_30::PowerOn;
pub const PowerOff: _bindgen_ty_30 = _bindgen_ty_30::PowerOff;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_30 { PowerOn = 0, PowerOff = 1, }
pub use self::_bindgen_ty_30 as PCI_EXPRESS_POWER_STATE;
pub const NoAspmSupport: _bindgen_ty_31 = _bindgen_ty_31::NoAspmSupport;
pub const L0sEntrySupport: _bindgen_ty_31 = _bindgen_ty_31::L0sEntrySupport;
pub const L1EntrySupport: _bindgen_ty_31 = _bindgen_ty_31::L1EntrySupport;
pub const L0sAndL1EntrySupport: _bindgen_ty_31 =
    _bindgen_ty_31::L0sAndL1EntrySupport;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_31 {
    NoAspmSupport = 0,
    L0sEntrySupport = 1,
    L1EntrySupport = 2,
    L0sAndL1EntrySupport = 3,
}
pub use self::_bindgen_ty_31 as PCI_EXPRESS_ASPM_SUPPORT;
pub const L0sAndL1EntryDisabled: _bindgen_ty_32 =
    _bindgen_ty_32::L0sAndL1EntryDisabled;
pub const L0sEntryEnabled: _bindgen_ty_32 = _bindgen_ty_32::L0sEntryEnabled;
pub const L1EntryEnabled: _bindgen_ty_32 = _bindgen_ty_32::L1EntryEnabled;
pub const L0sAndL1EntryEnabled: _bindgen_ty_32 =
    _bindgen_ty_32::L0sAndL1EntryEnabled;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_32 {
    L0sAndL1EntryDisabled = 0,
    L0sEntryEnabled = 1,
    L1EntryEnabled = 2,
    L0sAndL1EntryEnabled = 3,
}
pub use self::_bindgen_ty_32 as PCI_EXPRESS_ASPM_CONTROL;
pub const L0s_Below64ns: _bindgen_ty_33 = _bindgen_ty_33::L0s_Below64ns;
pub const L0s_64ns_128ns: _bindgen_ty_33 = _bindgen_ty_33::L0s_64ns_128ns;
pub const L0s_128ns_256ns: _bindgen_ty_33 = _bindgen_ty_33::L0s_128ns_256ns;
pub const L0s_256ns_512ns: _bindgen_ty_33 = _bindgen_ty_33::L0s_256ns_512ns;
pub const L0s_512ns_1us: _bindgen_ty_33 = _bindgen_ty_33::L0s_512ns_1us;
pub const L0s_1us_2us: _bindgen_ty_33 = _bindgen_ty_33::L0s_1us_2us;
pub const L0s_2us_4us: _bindgen_ty_33 = _bindgen_ty_33::L0s_2us_4us;
pub const L0s_Above4us: _bindgen_ty_33 = _bindgen_ty_33::L0s_Above4us;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_33 {
    L0s_Below64ns = 0,
    L0s_64ns_128ns = 1,
    L0s_128ns_256ns = 2,
    L0s_256ns_512ns = 3,
    L0s_512ns_1us = 4,
    L0s_1us_2us = 5,
    L0s_2us_4us = 6,
    L0s_Above4us = 7,
}
pub use self::_bindgen_ty_33 as PCI_EXPRESS_L0s_EXIT_LATENCY;
pub const L1_Below1us: _bindgen_ty_34 = _bindgen_ty_34::L1_Below1us;
pub const L1_1us_2us: _bindgen_ty_34 = _bindgen_ty_34::L1_1us_2us;
pub const L1_2us_4us: _bindgen_ty_34 = _bindgen_ty_34::L1_2us_4us;
pub const L1_4us_8us: _bindgen_ty_34 = _bindgen_ty_34::L1_4us_8us;
pub const L1_8us_16us: _bindgen_ty_34 = _bindgen_ty_34::L1_8us_16us;
pub const L1_16us_32us: _bindgen_ty_34 = _bindgen_ty_34::L1_16us_32us;
pub const L1_32us_64us: _bindgen_ty_34 = _bindgen_ty_34::L1_32us_64us;
pub const L1_Above64us: _bindgen_ty_34 = _bindgen_ty_34::L1_Above64us;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_34 {
    L1_Below1us = 0,
    L1_1us_2us = 1,
    L1_2us_4us = 2,
    L1_4us_8us = 3,
    L1_8us_16us = 4,
    L1_16us_32us = 5,
    L1_32us_64us = 6,
    L1_Above64us = 7,
}
pub use self::_bindgen_ty_34 as PCI_EXPRESS_L1_EXIT_LATENCY;
pub const PciExpressEndpoint: _bindgen_ty_35 =
    _bindgen_ty_35::PciExpressEndpoint;
pub const PciExpressLegacyEndpoint: _bindgen_ty_35 =
    _bindgen_ty_35::PciExpressLegacyEndpoint;
pub const PciExpressRootPort: _bindgen_ty_35 =
    _bindgen_ty_35::PciExpressRootPort;
pub const PciExpressUpstreamSwitchPort: _bindgen_ty_35 =
    _bindgen_ty_35::PciExpressUpstreamSwitchPort;
pub const PciExpressDownstreamSwitchPort: _bindgen_ty_35 =
    _bindgen_ty_35::PciExpressDownstreamSwitchPort;
pub const PciExpressToPciXBridge: _bindgen_ty_35 =
    _bindgen_ty_35::PciExpressToPciXBridge;
pub const PciXToExpressBridge: _bindgen_ty_35 =
    _bindgen_ty_35::PciXToExpressBridge;
pub const PciExpressRootComplexIntegratedEndpoint: _bindgen_ty_35 =
    _bindgen_ty_35::PciExpressRootComplexIntegratedEndpoint;
pub const PciExpressRootComplexEventCollector: _bindgen_ty_35 =
    _bindgen_ty_35::PciExpressRootComplexEventCollector;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_35 {
    PciExpressEndpoint = 0,
    PciExpressLegacyEndpoint = 1,
    PciExpressRootPort = 4,
    PciExpressUpstreamSwitchPort = 5,
    PciExpressDownstreamSwitchPort = 6,
    PciExpressToPciXBridge = 7,
    PciXToExpressBridge = 8,
    PciExpressRootComplexIntegratedEndpoint = 9,
    PciExpressRootComplexEventCollector = 10,
}
pub use self::_bindgen_ty_35 as PCI_EXPRESS_DEVICE_TYPE;
pub const MaxPayload128Bytes: _bindgen_ty_36 =
    _bindgen_ty_36::MaxPayload128Bytes;
pub const MaxPayload256Bytes: _bindgen_ty_36 =
    _bindgen_ty_36::MaxPayload256Bytes;
pub const MaxPayload512Bytes: _bindgen_ty_36 =
    _bindgen_ty_36::MaxPayload512Bytes;
pub const MaxPayload1024Bytes: _bindgen_ty_36 =
    _bindgen_ty_36::MaxPayload1024Bytes;
pub const MaxPayload2048Bytes: _bindgen_ty_36 =
    _bindgen_ty_36::MaxPayload2048Bytes;
pub const MaxPayload4096Bytes: _bindgen_ty_36 =
    _bindgen_ty_36::MaxPayload4096Bytes;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_36 {
    MaxPayload128Bytes = 0,
    MaxPayload256Bytes = 1,
    MaxPayload512Bytes = 2,
    MaxPayload1024Bytes = 3,
    MaxPayload2048Bytes = 4,
    MaxPayload4096Bytes = 5,
}
pub use self::_bindgen_ty_36 as PCI_EXPRESS_MAX_PAYLOAD_SIZE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_PME_REQUESTOR_ID {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_PME_REQUESTOR_ID__bindgen_ty_1>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: u16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_PME_REQUESTOR_ID__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_PME_REQUESTOR_ID__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_PME_REQUESTOR_ID__bindgen_ty_1>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_PME_REQUESTOR_ID__bindgen_ty_1>()
               , 2usize);
}
impl Clone for _PCI_EXPRESS_PME_REQUESTOR_ID__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_PME_REQUESTOR_ID__bindgen_ty_1 {
    #[inline]
    pub fn FunctionNumber(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (7usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_FunctionNumber(&mut self, val: USHORT) {
        self._bitfield_1 &= !(7usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (7usize as u16);
    }
    #[inline]
    pub fn DeviceNumber(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (248usize as u16)) >>
                                        3u32) as u16)
        }
    }
    #[inline]
    pub fn set_DeviceNumber(&mut self, val: USHORT) {
        self._bitfield_1 &= !(248usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 3u32) & (248usize as u16);
    }
    #[inline]
    pub fn BusNumber(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65280usize as u16))
                                        >> 8u32) as u16)
        }
    }
    #[inline]
    pub fn set_BusNumber(&mut self, val: USHORT) {
        self._bitfield_1 &= !(65280usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 8u32) & (65280usize as u16);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_PME_REQUESTOR_ID() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_PME_REQUESTOR_ID>() ,
               2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_PME_REQUESTOR_ID>() ,
               2usize);
}
impl Clone for _PCI_EXPRESS_PME_REQUESTOR_ID {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_PME_REQUESTOR_ID as PCI_EXPRESS_PME_REQUESTOR_ID;
pub type PPCI_EXPRESS_PME_REQUESTOR_ID = *mut _PCI_EXPRESS_PME_REQUESTOR_ID;
pub type PciPin2Line =
    ::core::option::Option<unsafe extern "C" fn(BusHandler: *mut _BUS_HANDLER,
                                                RootHandler:
                                                    *mut _BUS_HANDLER,
                                                SlotNumber: PCI_SLOT_NUMBER,
                                                PciData: PPCI_COMMON_CONFIG)>;
pub type PciLine2Pin =
    ::core::option::Option<unsafe extern "C" fn(BusHandler: *mut _BUS_HANDLER,
                                                RootHandler:
                                                    *mut _BUS_HANDLER,
                                                SlotNumber: PCI_SLOT_NUMBER,
                                                PciNewData:
                                                    PPCI_COMMON_CONFIG,
                                                PciOldData:
                                                    PPCI_COMMON_CONFIG)>;
pub type PciReadWriteConfig =
    ::core::option::Option<unsafe extern "C" fn(BusHandler: *mut _BUS_HANDLER,
                                                Slot: PCI_SLOT_NUMBER,
                                                Buffer: PVOID, Offset: ULONG,
                                                Length: ULONG)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCIBUSDATA {
    pub Tag: ULONG,
    pub Version: ULONG,
    pub ReadConfig: PciReadWriteConfig,
    pub WriteConfig: PciReadWriteConfig,
    pub Pin2Line: PciPin2Line,
    pub Line2Pin: PciLine2Pin,
    pub ParentSlot: PCI_SLOT_NUMBER,
    pub Reserved: [PVOID; 4usize],
}
#[test]
fn bindgen_test_layout__PCIBUSDATA() {
    assert_eq!(::core::mem::size_of::<_PCIBUSDATA>() , 80usize);
    assert_eq!(::core::mem::align_of::<_PCIBUSDATA>() , 8usize);
}
impl Clone for _PCIBUSDATA {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCIBUSDATA as PCIBUSDATA;
pub type PPCIBUSDATA = *mut _PCIBUSDATA;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_LTR_MAX_LATENCY_REGISTER {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_LTR_MAX_LATENCY_REGISTER__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_LTR_MAX_LATENCY_REGISTER__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_LTR_MAX_LATENCY_REGISTER__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_LTR_MAX_LATENCY_REGISTER__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_LTR_MAX_LATENCY_REGISTER__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_LTR_MAX_LATENCY_REGISTER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_LTR_MAX_LATENCY_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn MaxSnoopLatencyValue(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1023usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_MaxSnoopLatencyValue(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1023usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 0u32) & (1023usize as u32);
    }
    #[inline]
    pub fn MaxSnoopLatencyScale(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (7168usize as u32)) >>
                                        10u32) as u32)
        }
    }
    #[inline]
    pub fn set_MaxSnoopLatencyScale(&mut self, val: ULONG) {
        self._bitfield_1 &= !(7168usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 10u32) & (7168usize as u32);
    }
    #[inline]
    pub fn Rsvd(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (24576usize as u32))
                                        >> 13u32) as u32)
        }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: ULONG) {
        self._bitfield_1 &= !(24576usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 13u32) & (24576usize as u32);
    }
    #[inline]
    pub fn MaxSnoopRequirement(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32768usize as u32))
                                        >> 15u32) as u32)
        }
    }
    #[inline]
    pub fn set_MaxSnoopRequirement(&mut self, val: ULONG) {
        self._bitfield_1 &= !(32768usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 15u32) & (32768usize as u32);
    }
    #[inline]
    pub fn MaxNoSnoopLatencyValue(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (67043328usize as u32)) >> 16u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_MaxNoSnoopLatencyValue(&mut self, val: ULONG) {
        self._bitfield_1 &= !(67043328usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (67043328usize as u32);
    }
    #[inline]
    pub fn MaxNoSnoopLatencyScale(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (469762048usize as u32)) >> 26u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_MaxNoSnoopLatencyScale(&mut self, val: ULONG) {
        self._bitfield_1 &= !(469762048usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 26u32) & (469762048usize as u32);
    }
    #[inline]
    pub fn Rsvd2(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (1610612736usize as u32)) >> 29u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1610612736usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 29u32) & (1610612736usize as u32);
    }
    #[inline]
    pub fn MaxNoSnoopRequirement(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (2147483648usize as u32)) >> 31u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_MaxNoSnoopRequirement(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2147483648usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 31u32) & (2147483648usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_LTR_MAX_LATENCY_REGISTER() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_LTR_MAX_LATENCY_REGISTER>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_LTR_MAX_LATENCY_REGISTER>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_LTR_MAX_LATENCY_REGISTER {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_LTR_MAX_LATENCY_REGISTER as
        PCI_EXPRESS_LTR_MAX_LATENCY_REGISTER;
pub type PPCI_EXPRESS_LTR_MAX_LATENCY_REGISTER =
    *mut _PCI_EXPRESS_LTR_MAX_LATENCY_REGISTER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_LTR_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub Latency: PCI_EXPRESS_LTR_MAX_LATENCY_REGISTER,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_LTR_CAPABILITY() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_LTR_CAPABILITY>() ,
               8usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_LTR_CAPABILITY>() ,
               4usize);
}
impl Clone for _PCI_EXPRESS_LTR_CAPABILITY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_LTR_CAPABILITY as PCI_EXPRESS_LTR_CAPABILITY;
pub type PPCI_EXPRESS_LTR_CAPABILITY = *mut _PCI_EXPRESS_LTR_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn NoStModeSupported(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_NoStModeSupported(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn InteruptVectorModeSupported(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_InteruptVectorModeSupported(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn DeviceSpecificModeSupported(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                        2u32) as u32)
        }
    }
    #[inline]
    pub fn set_DeviceSpecificModeSupported(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn Rsvd(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (248usize as u32)) >>
                                        3u32) as u32)
        }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: ULONG) {
        self._bitfield_1 &= !(248usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (248usize as u32);
    }
    #[inline]
    pub fn ExtendedTPHRequesterSupported(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (256usize as u32)) >>
                                        8u32) as u32)
        }
    }
    #[inline]
    pub fn set_ExtendedTPHRequesterSupported(&mut self, val: ULONG) {
        self._bitfield_1 &= !(256usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 8u32) & (256usize as u32);
    }
    #[inline]
    pub fn StTableLocation(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1536usize as u32)) >>
                                        9u32) as u32)
        }
    }
    #[inline]
    pub fn set_StTableLocation(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1536usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 9u32) & (1536usize as u32);
    }
    #[inline]
    pub fn Rsvd2(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (63488usize as u32))
                                        >> 11u32) as u32)
        }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: ULONG) {
        self._bitfield_1 &= !(63488usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 11u32) & (63488usize as u32);
    }
    #[inline]
    pub fn StTableSize(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (134152192usize as u32)) >> 16u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_StTableSize(&mut self, val: ULONG) {
        self._bitfield_1 &= !(134152192usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (134152192usize as u32);
    }
    #[inline]
    pub fn Rsvd3(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4160749568usize as u32)) >> 27u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_Rsvd3(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4160749568usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 27u32) & (4160749568usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER as
        PCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER;
pub type PPCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER =
    *mut _PCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn StModeSelect(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (7usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_StModeSelect(&mut self, val: ULONG) {
        self._bitfield_1 &= !(7usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (7usize as u32);
    }
    #[inline]
    pub fn Rsvd(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (248usize as u32)) >>
                                        3u32) as u32)
        }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: ULONG) {
        self._bitfield_1 &= !(248usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (248usize as u32);
    }
    #[inline]
    pub fn TphRequesterEnable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (768usize as u32)) >>
                                        8u32) as u32)
        }
    }
    #[inline]
    pub fn set_TphRequesterEnable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(768usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 8u32) & (768usize as u32);
    }
    #[inline]
    pub fn Rsvd2(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294966272usize as u32)) >> 10u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294966272usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 10u32) & (4294966272usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER as
        PCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER;
pub type PPCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER =
    *mut _PCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_TPH_ST_TABLE_ENTRY {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_TPH_ST_TABLE_ENTRY__bindgen_ty_1>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: u16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_TPH_ST_TABLE_ENTRY__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_TPH_ST_TABLE_ENTRY__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_TPH_ST_TABLE_ENTRY__bindgen_ty_1>()
               , 2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_TPH_ST_TABLE_ENTRY__bindgen_ty_1>()
               , 2usize);
}
impl Clone for _PCI_EXPRESS_TPH_ST_TABLE_ENTRY__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_TPH_ST_TABLE_ENTRY__bindgen_ty_1 {
    #[inline]
    pub fn LowerEntry(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (255usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_LowerEntry(&mut self, val: USHORT) {
        self._bitfield_1 &= !(255usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (255usize as u16);
    }
    #[inline]
    pub fn UpperEntry(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65280usize as u16))
                                        >> 8u32) as u16)
        }
    }
    #[inline]
    pub fn set_UpperEntry(&mut self, val: USHORT) {
        self._bitfield_1 &= !(65280usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 8u32) & (65280usize as u16);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_TPH_ST_TABLE_ENTRY() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_TPH_ST_TABLE_ENTRY>() ,
               2usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_TPH_ST_TABLE_ENTRY>() ,
               2usize);
}
impl Clone for _PCI_EXPRESS_TPH_ST_TABLE_ENTRY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_TPH_ST_TABLE_ENTRY as
        PCI_EXPRESS_TPH_ST_TABLE_ENTRY;
pub type PPCI_EXPRESS_TPH_ST_TABLE_ENTRY =
    *mut _PCI_EXPRESS_TPH_ST_TABLE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_TPH_REQUESTER_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub RequesterCapability: PCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER,
    pub RequesterControl: PCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_TPH_REQUESTER_CAPABILITY() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_TPH_REQUESTER_CAPABILITY>()
               , 12usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_TPH_REQUESTER_CAPABILITY>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_TPH_REQUESTER_CAPABILITY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_TPH_REQUESTER_CAPABILITY as
        PCI_EXPRESS_TPH_REQUESTER_CAPABILITY;
pub type PPCI_EXPRESS_TPH_REQUESTER_CAPABILITY =
    *mut _PCI_EXPRESS_TPH_REQUESTER_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn PciPmL12Supported(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_PciPmL12Supported(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn PciPmL11Supported(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_PciPmL11Supported(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn AspmL12Supported(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                        2u32) as u32)
        }
    }
    #[inline]
    pub fn set_AspmL12Supported(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn AspmL11Supported(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u32)) >>
                                        3u32) as u32)
        }
    }
    #[inline]
    pub fn set_AspmL11Supported(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (8usize as u32);
    }
    #[inline]
    pub fn L1PmSsSupported(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u32)) >>
                                        4u32) as u32)
        }
    }
    #[inline]
    pub fn set_L1PmSsSupported(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (16usize as u32);
    }
    #[inline]
    pub fn Rsvd(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (224usize as u32)) >>
                                        5u32) as u32)
        }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: ULONG) {
        self._bitfield_1 &= !(224usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (224usize as u32);
    }
    #[inline]
    pub fn PortCommonModeRestoreTime(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65280usize as u32))
                                        >> 8u32) as u32)
        }
    }
    #[inline]
    pub fn set_PortCommonModeRestoreTime(&mut self, val: ULONG) {
        self._bitfield_1 &= !(65280usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 8u32) & (65280usize as u32);
    }
    #[inline]
    pub fn PortTPowerOnScale(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (196608usize as u32))
                                        >> 16u32) as u32)
        }
    }
    #[inline]
    pub fn set_PortTPowerOnScale(&mut self, val: ULONG) {
        self._bitfield_1 &= !(196608usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (196608usize as u32);
    }
    #[inline]
    pub fn Rsvd2(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (262144usize as u32))
                                        >> 18u32) as u32)
        }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: ULONG) {
        self._bitfield_1 &= !(262144usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 18u32) & (262144usize as u32);
    }
    #[inline]
    pub fn PortTPowerOnValue(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (16252928usize as u32)) >> 19u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_PortTPowerOnValue(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16252928usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 19u32) & (16252928usize as u32);
    }
    #[inline]
    pub fn Rsvd3(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4278190080usize as u32)) >> 24u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_Rsvd3(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4278190080usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 24u32) & (4278190080usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER as
        PCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER;
pub type PPCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER =
    *mut _PCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn PciPmL12Enabled(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_PciPmL12Enabled(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn PciPmL11Enabled(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_PciPmL11Enabled(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn AspmL12Enabled(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                        2u32) as u32)
        }
    }
    #[inline]
    pub fn set_AspmL12Enabled(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn AspmL11Enabled(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u32)) >>
                                        3u32) as u32)
        }
    }
    #[inline]
    pub fn set_AspmL11Enabled(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (8usize as u32);
    }
    #[inline]
    pub fn Rsvd(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (240usize as u32)) >>
                                        4u32) as u32)
        }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: ULONG) {
        self._bitfield_1 &= !(240usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (240usize as u32);
    }
    #[inline]
    pub fn CommonModeRestoreTime(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65280usize as u32))
                                        >> 8u32) as u32)
        }
    }
    #[inline]
    pub fn set_CommonModeRestoreTime(&mut self, val: ULONG) {
        self._bitfield_1 &= !(65280usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 8u32) & (65280usize as u32);
    }
    #[inline]
    pub fn LtrL12ThresholdValue(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (67043328usize as u32)) >> 16u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_LtrL12ThresholdValue(&mut self, val: ULONG) {
        self._bitfield_1 &= !(67043328usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (67043328usize as u32);
    }
    #[inline]
    pub fn Rsvd2(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (469762048usize as u32)) >> 26u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: ULONG) {
        self._bitfield_1 &= !(469762048usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 26u32) & (469762048usize as u32);
    }
    #[inline]
    pub fn LtrL12ThresholdScale(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (3758096384usize as u32)) >> 29u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_LtrL12ThresholdScale(&mut self, val: ULONG) {
        self._bitfield_1 &= !(3758096384usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 29u32) & (3758096384usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER as
        PCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER;
pub type PPCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER =
    *mut _PCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn TPowerOnScale(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (3usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_TPowerOnScale(&mut self, val: ULONG) {
        self._bitfield_1 &= !(3usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (3usize as u32);
    }
    #[inline]
    pub fn Rsvd(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                        2u32) as u32)
        }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn TPowerOnValue(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (248usize as u32)) >>
                                        3u32) as u32)
        }
    }
    #[inline]
    pub fn set_TPowerOnValue(&mut self, val: ULONG) {
        self._bitfield_1 &= !(248usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (248usize as u32);
    }
    #[inline]
    pub fn Rsvd2(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967040usize as u32)) >> 8u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967040usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 8u32) & (4294967040usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER as
        PCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER;
pub type PPCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER =
    *mut _PCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_L1_PM_SS_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub L1PmSsCapabilities: PCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER,
    pub L1PmSsControl1: PCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER,
    pub L1PmSsControl2: PCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_L1_PM_SS_CAPABILITY() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_L1_PM_SS_CAPABILITY>() ,
               16usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_L1_PM_SS_CAPABILITY>() ,
               4usize);
}
impl Clone for _PCI_EXPRESS_L1_PM_SS_CAPABILITY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_L1_PM_SS_CAPABILITY as
        PCI_EXPRESS_L1_PM_SS_CAPABILITY;
pub type PPCI_EXPRESS_L1_PM_SS_CAPABILITY =
    *mut _PCI_EXPRESS_L1_PM_SS_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn Rsvd(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (15usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: ULONG) {
        self._bitfield_1 &= !(15usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (15usize as u32);
    }
    #[inline]
    pub fn SizesSupported(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (16777200usize as u32)) >> 4u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_SizesSupported(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16777200usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 4u32) & (16777200usize as u32);
    }
    #[inline]
    pub fn Rsvd2(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4278190080usize as u32)) >> 24u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4278190080usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 24u32) & (4278190080usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER as
        PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER;
pub type PPCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER =
    *mut _PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER {
    pub __bindgen_anon_1: __BindgenUnionField<_PCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _PCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn BarIndex(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (7usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_BarIndex(&mut self, val: ULONG) {
        self._bitfield_1 &= !(7usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (7usize as u32);
    }
    #[inline]
    pub fn Rsvd(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (24usize as u32)) >>
                                        3u32) as u32)
        }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: ULONG) {
        self._bitfield_1 &= !(24usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (24usize as u32);
    }
    #[inline]
    pub fn NumberOfResizableBars(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (224usize as u32)) >>
                                        5u32) as u32)
        }
    }
    #[inline]
    pub fn set_NumberOfResizableBars(&mut self, val: ULONG) {
        self._bitfield_1 &= !(224usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (224usize as u32);
    }
    #[inline]
    pub fn BarSize(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (7936usize as u32)) >>
                                        8u32) as u32)
        }
    }
    #[inline]
    pub fn set_BarSize(&mut self, val: ULONG) {
        self._bitfield_1 &= !(7936usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 8u32) & (7936usize as u32);
    }
    #[inline]
    pub fn Rsvd2(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294959104usize as u32)) >> 13u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294959104usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 13u32) & (4294959104usize as u32);
    }
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER as
        PCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER;
pub type PPCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER =
    *mut _PCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_RESIZABLE_BAR_ENTRY {
    pub Capability: PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER,
    pub Control: PCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER,
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_RESIZABLE_BAR_ENTRY() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_RESIZABLE_BAR_ENTRY>() ,
               8usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_RESIZABLE_BAR_ENTRY>() ,
               4usize);
}
impl Clone for _PCI_EXPRESS_RESIZABLE_BAR_ENTRY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_RESIZABLE_BAR_ENTRY as
        PCI_EXPRESS_RESIZABLE_BAR_ENTRY;
pub type PPCI_EXPRESS_RESIZABLE_BAR_ENTRY =
    *mut _PCI_EXPRESS_RESIZABLE_BAR_ENTRY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub Entry: [PCI_EXPRESS_RESIZABLE_BAR_ENTRY; 6usize],
}
#[test]
fn bindgen_test_layout__PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY() {
    assert_eq!(::core::mem::size_of::<_PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY>()
               , 52usize);
    assert_eq!(::core::mem::align_of::<_PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY>()
               , 4usize);
}
impl Clone for _PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY as
        PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY;
pub type PPCI_EXPRESS_RESIZABLE_BAR_CAPABILITY =
    *mut _PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY;
pub type PCI_READ_WRITE_CONFIG =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                BusOffset: ULONG, Slot: ULONG,
                                                Buffer: PVOID, Offset: ULONG,
                                                Length: ULONG) -> ULONG>;
pub type PPCI_READ_WRITE_CONFIG = PCI_READ_WRITE_CONFIG;
pub type PCI_PIN_TO_LINE =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                PciData: PPCI_COMMON_CONFIG)>;
pub type PPCI_PIN_TO_LINE = PCI_PIN_TO_LINE;
pub type PCI_LINE_TO_PIN =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                PciNewData:
                                                    PPCI_COMMON_CONFIG,
                                                PciOldData:
                                                    PPCI_COMMON_CONFIG)>;
pub type PPCI_LINE_TO_PIN = PCI_LINE_TO_PIN;
pub type PCI_ROOT_BUS_CAPABILITY =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                HardwareCapability:
                                                    PPCI_ROOT_BUS_HARDWARE_CAPABILITY)>;
pub type PPCI_ROOT_BUS_CAPABILITY = PCI_ROOT_BUS_CAPABILITY;
pub type PCI_EXPRESS_WAKE_CONTROL =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID,
                                                EnableWake: BOOLEAN)>;
pub type PPCI_EXPRESS_WAKE_CONTROL = PCI_EXPRESS_WAKE_CONTROL;
pub type PCI_PREPARE_MULTISTAGE_RESUME =
    ::core::option::Option<unsafe extern "C" fn(Context: PVOID)>;
pub type PPCI_PREPARE_MULTISTAGE_RESUME = PCI_PREPARE_MULTISTAGE_RESUME;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PCI_BUS_INTERFACE_STANDARD {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub ReadConfig: PPCI_READ_WRITE_CONFIG,
    pub WriteConfig: PPCI_READ_WRITE_CONFIG,
    pub PinToLine: PPCI_PIN_TO_LINE,
    pub LineToPin: PPCI_LINE_TO_PIN,
    pub RootBusCapability: PPCI_ROOT_BUS_CAPABILITY,
    pub ExpressWakeControl: PPCI_EXPRESS_WAKE_CONTROL,
    pub PrepareMultistageResume: PPCI_PREPARE_MULTISTAGE_RESUME,
}
#[test]
fn bindgen_test_layout__PCI_BUS_INTERFACE_STANDARD() {
    assert_eq!(::core::mem::size_of::<_PCI_BUS_INTERFACE_STANDARD>() ,
               88usize);
    assert_eq!(::core::mem::align_of::<_PCI_BUS_INTERFACE_STANDARD>() ,
               8usize);
}
impl Clone for _PCI_BUS_INTERFACE_STANDARD {
    fn clone(&self) -> Self { *self }
}
pub use self::_PCI_BUS_INTERFACE_STANDARD as PCI_BUS_INTERFACE_STANDARD;
pub type PPCI_BUS_INTERFACE_STANDARD = *mut _PCI_BUS_INTERFACE_STANDARD;
extern "C" {
    pub fn ZwSetInformationThread(ThreadHandle: HANDLE,
                                  ThreadInformationClass: THREADINFOCLASS,
                                  ThreadInformation: PVOID,
                                  ThreadInformationLength: ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn ZwCreateTimer(TimerHandle: PHANDLE, DesiredAccess: ACCESS_MASK,
                         ObjectAttributes: POBJECT_ATTRIBUTES,
                         TimerType: TIMER_TYPE) -> NTSTATUS;
}
extern "C" {
    pub fn ZwOpenTimer(TimerHandle: PHANDLE, DesiredAccess: ACCESS_MASK,
                       ObjectAttributes: POBJECT_ATTRIBUTES) -> NTSTATUS;
}
extern "C" {
    pub fn ZwCancelTimer(TimerHandle: HANDLE, CurrentState: PBOOLEAN)
     -> NTSTATUS;
}
extern "C" {
    pub fn ZwSetTimer(TimerHandle: HANDLE, DueTime: PLARGE_INTEGER,
                      TimerApcRoutine: PTIMER_APC_ROUTINE,
                      TimerContext: PVOID, ResumeTimer: BOOLEAN, Period: LONG,
                      PreviousState: PBOOLEAN) -> NTSTATUS;
}
extern "C" {
    pub fn ZwSetTimerEx(TimerHandle: HANDLE,
                        TimerSetInformationClass: TIMER_SET_INFORMATION_CLASS,
                        TimerSetInformation: PVOID,
                        TimerSetInformationLength: ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn ZwQueryVolumeInformationFile(FileHandle: HANDLE,
                                        IoStatusBlock: PIO_STATUS_BLOCK,
                                        FsInformation: PVOID, Length: ULONG,
                                        FsInformationClass:
                                            FS_INFORMATION_CLASS) -> NTSTATUS;
}
extern "C" {
    pub fn ZwDeviceIoControlFile(FileHandle: HANDLE, Event: HANDLE,
                                 ApcRoutine: PIO_APC_ROUTINE,
                                 ApcContext: PVOID,
                                 IoStatusBlock: PIO_STATUS_BLOCK,
                                 IoControlCode: ULONG, InputBuffer: PVOID,
                                 InputBufferLength: ULONG,
                                 OutputBuffer: PVOID,
                                 OutputBufferLength: ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn ZwDisplayString(String: PUNICODE_STRING) -> NTSTATUS;
}
extern "C" {
    pub fn ZwPowerInformation(InformationLevel: POWER_INFORMATION_LEVEL,
                              InputBuffer: PVOID, InputBufferLength: ULONG,
                              OutputBuffer: PVOID, OutputBufferLength: ULONG)
     -> NTSTATUS;
}
extern "C" {
    pub fn ZwAllocateLocallyUniqueId(Luid: PLUID) -> NTSTATUS;
}
extern "C" {
    pub fn ZwTerminateProcess(ProcessHandle: HANDLE, ExitStatus: NTSTATUS)
     -> NTSTATUS;
}
extern "C" {
    pub fn ZwOpenProcess(ProcessHandle: PHANDLE, DesiredAccess: ACCESS_MASK,
                         ObjectAttributes: POBJECT_ATTRIBUTES,
                         ClientId: PCLIENT_ID) -> NTSTATUS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _WHEA_ERROR_SOURCE_TYPE {
    WheaErrSrcTypeMCE = 0,
    WheaErrSrcTypeCMC = 1,
    WheaErrSrcTypeCPE = 2,
    WheaErrSrcTypeNMI = 3,
    WheaErrSrcTypePCIe = 4,
    WheaErrSrcTypeGeneric = 5,
    WheaErrSrcTypeINIT = 6,
    WheaErrSrcTypeBOOT = 7,
    WheaErrSrcTypeSCIGeneric = 8,
    WheaErrSrcTypeIPFMCA = 9,
    WheaErrSrcTypeIPFCMC = 10,
    WheaErrSrcTypeIPFCPE = 11,
    WheaErrSrcTypeGenericV2 = 12,
    WheaErrSrcTypeSCIGenericV2 = 13,
    WheaErrSrcTypeMax = 14,
}
pub use self::_WHEA_ERROR_SOURCE_TYPE as WHEA_ERROR_SOURCE_TYPE;
pub type PWHEA_ERROR_SOURCE_TYPE = *mut _WHEA_ERROR_SOURCE_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _WHEA_ERROR_SOURCE_STATE {
    WheaErrSrcStateStopped = 1,
    WheaErrSrcStateStarted = 2,
}
pub use self::_WHEA_ERROR_SOURCE_STATE as WHEA_ERROR_SOURCE_STATE;
pub type PWHEA_ERROR_SOURCE_STATE = *mut _WHEA_ERROR_SOURCE_STATE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_NOTIFICATION_FLAGS {
    pub __bindgen_anon_1: __BindgenUnionField<_WHEA_NOTIFICATION_FLAGS__bindgen_ty_1>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: [u8; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_NOTIFICATION_FLAGS__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
impl Clone for _WHEA_NOTIFICATION_FLAGS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_NOTIFICATION_FLAGS__bindgen_ty_1 {
    #[inline]
    pub fn PollIntervalRW(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_PollIntervalRW(&mut self, val: USHORT) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn SwitchToPollingThresholdRW(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u16)) >>
                                        1u32) as u16)
        }
    }
    #[inline]
    pub fn set_SwitchToPollingThresholdRW(&mut self, val: USHORT) {
        self._bitfield_1 &= !(2usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 1u32) & (2usize as u16);
    }
    #[inline]
    pub fn SwitchToPollingWindowRW(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u16)) >>
                                        2u32) as u16)
        }
    }
    #[inline]
    pub fn set_SwitchToPollingWindowRW(&mut self, val: USHORT) {
        self._bitfield_1 &= !(4usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 2u32) & (4usize as u16);
    }
    #[inline]
    pub fn ErrorThresholdRW(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u16)) >>
                                        3u32) as u16)
        }
    }
    #[inline]
    pub fn set_ErrorThresholdRW(&mut self, val: USHORT) {
        self._bitfield_1 &= !(8usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 3u32) & (8usize as u16);
    }
    #[inline]
    pub fn ErrorThresholdWindowRW(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u16)) >>
                                        4u32) as u16)
        }
    }
    #[inline]
    pub fn set_ErrorThresholdWindowRW(&mut self, val: USHORT) {
        self._bitfield_1 &= !(16usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 4u32) & (16usize as u16);
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65504usize as u16))
                                        >> 5u32) as u16)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        self._bitfield_1 &= !(65504usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 5u32) & (65504usize as u16);
    }
}
impl Clone for _WHEA_NOTIFICATION_FLAGS {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_NOTIFICATION_FLAGS as WHEA_NOTIFICATION_FLAGS;
pub type PWHEA_NOTIFICATION_FLAGS = *mut _WHEA_NOTIFICATION_FLAGS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _XPF_MC_BANK_FLAGS {
    pub __bindgen_anon_1: __BindgenUnionField<_XPF_MC_BANK_FLAGS__bindgen_ty_1>,
    pub AsUCHAR: __BindgenUnionField<UCHAR>,
    pub bindgen_union_field: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _XPF_MC_BANK_FLAGS__bindgen_ty_1 {
    pub _bitfield_1: u8,
}
impl Clone for _XPF_MC_BANK_FLAGS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _XPF_MC_BANK_FLAGS__bindgen_ty_1 {
    #[inline]
    pub fn ClearOnInitializationRW(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                        0u32) as u8)
        }
    }
    #[inline]
    pub fn set_ClearOnInitializationRW(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 0u32) & (1usize as u8);
    }
    #[inline]
    pub fn ControlDataRW(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u8)) >>
                                        1u32) as u8)
        }
    }
    #[inline]
    pub fn set_ControlDataRW(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(2usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 1u32) & (2usize as u8);
    }
    #[inline]
    pub fn Reserved(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (252usize as u8)) >>
                                        2u32) as u8)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(252usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 2u32) & (252usize as u8);
    }
}
impl Clone for _XPF_MC_BANK_FLAGS {
    fn clone(&self) -> Self { *self }
}
pub use self::_XPF_MC_BANK_FLAGS as XPF_MC_BANK_FLAGS;
pub type PXPF_MC_BANK_FLAGS = *mut _XPF_MC_BANK_FLAGS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _XPF_MCE_FLAGS {
    pub __bindgen_anon_1: __BindgenUnionField<_XPF_MCE_FLAGS__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: [u8; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _XPF_MCE_FLAGS__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
impl Clone for _XPF_MCE_FLAGS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _XPF_MCE_FLAGS__bindgen_ty_1 {
    #[inline]
    pub fn MCG_CapabilityRW(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_MCG_CapabilityRW(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn MCG_GlobalControlRW(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_MCG_GlobalControlRW(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967292usize as u32)) >> 2u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967292usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 2u32) & (4294967292usize as u32);
    }
}
impl Clone for _XPF_MCE_FLAGS {
    fn clone(&self) -> Self { *self }
}
pub use self::_XPF_MCE_FLAGS as XPF_MCE_FLAGS;
pub type PXPF_MCE_FLAGS = *mut _XPF_MCE_FLAGS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _AER_ROOTPORT_DESCRIPTOR_FLAGS {
    pub __bindgen_anon_1: __BindgenUnionField<_AER_ROOTPORT_DESCRIPTOR_FLAGS__bindgen_ty_1>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: [u8; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _AER_ROOTPORT_DESCRIPTOR_FLAGS__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
impl Clone for _AER_ROOTPORT_DESCRIPTOR_FLAGS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _AER_ROOTPORT_DESCRIPTOR_FLAGS__bindgen_ty_1 {
    #[inline]
    pub fn UncorrectableErrorMaskRW(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_UncorrectableErrorMaskRW(&mut self, val: USHORT) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn UncorrectableErrorSeverityRW(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u16)) >>
                                        1u32) as u16)
        }
    }
    #[inline]
    pub fn set_UncorrectableErrorSeverityRW(&mut self, val: USHORT) {
        self._bitfield_1 &= !(2usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 1u32) & (2usize as u16);
    }
    #[inline]
    pub fn CorrectableErrorMaskRW(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u16)) >>
                                        2u32) as u16)
        }
    }
    #[inline]
    pub fn set_CorrectableErrorMaskRW(&mut self, val: USHORT) {
        self._bitfield_1 &= !(4usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 2u32) & (4usize as u16);
    }
    #[inline]
    pub fn AdvancedCapsAndControlRW(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u16)) >>
                                        3u32) as u16)
        }
    }
    #[inline]
    pub fn set_AdvancedCapsAndControlRW(&mut self, val: USHORT) {
        self._bitfield_1 &= !(8usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 3u32) & (8usize as u16);
    }
    #[inline]
    pub fn RootErrorCommandRW(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u16)) >>
                                        4u32) as u16)
        }
    }
    #[inline]
    pub fn set_RootErrorCommandRW(&mut self, val: USHORT) {
        self._bitfield_1 &= !(16usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 4u32) & (16usize as u16);
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65504usize as u16))
                                        >> 5u32) as u16)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        self._bitfield_1 &= !(65504usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 5u32) & (65504usize as u16);
    }
}
impl Clone for _AER_ROOTPORT_DESCRIPTOR_FLAGS {
    fn clone(&self) -> Self { *self }
}
pub use self::_AER_ROOTPORT_DESCRIPTOR_FLAGS as AER_ROOTPORT_DESCRIPTOR_FLAGS;
pub type PAER_ROOTPORT_DESCRIPTOR_FLAGS = *mut _AER_ROOTPORT_DESCRIPTOR_FLAGS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _AER_ENDPOINT_DESCRIPTOR_FLAGS {
    pub __bindgen_anon_1: __BindgenUnionField<_AER_ENDPOINT_DESCRIPTOR_FLAGS__bindgen_ty_1>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: [u8; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _AER_ENDPOINT_DESCRIPTOR_FLAGS__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
impl Clone for _AER_ENDPOINT_DESCRIPTOR_FLAGS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _AER_ENDPOINT_DESCRIPTOR_FLAGS__bindgen_ty_1 {
    #[inline]
    pub fn UncorrectableErrorMaskRW(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_UncorrectableErrorMaskRW(&mut self, val: USHORT) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn UncorrectableErrorSeverityRW(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u16)) >>
                                        1u32) as u16)
        }
    }
    #[inline]
    pub fn set_UncorrectableErrorSeverityRW(&mut self, val: USHORT) {
        self._bitfield_1 &= !(2usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 1u32) & (2usize as u16);
    }
    #[inline]
    pub fn CorrectableErrorMaskRW(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u16)) >>
                                        2u32) as u16)
        }
    }
    #[inline]
    pub fn set_CorrectableErrorMaskRW(&mut self, val: USHORT) {
        self._bitfield_1 &= !(4usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 2u32) & (4usize as u16);
    }
    #[inline]
    pub fn AdvancedCapsAndControlRW(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u16)) >>
                                        3u32) as u16)
        }
    }
    #[inline]
    pub fn set_AdvancedCapsAndControlRW(&mut self, val: USHORT) {
        self._bitfield_1 &= !(8usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 3u32) & (8usize as u16);
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65520usize as u16))
                                        >> 4u32) as u16)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        self._bitfield_1 &= !(65520usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 4u32) & (65520usize as u16);
    }
}
impl Clone for _AER_ENDPOINT_DESCRIPTOR_FLAGS {
    fn clone(&self) -> Self { *self }
}
pub use self::_AER_ENDPOINT_DESCRIPTOR_FLAGS as AER_ENDPOINT_DESCRIPTOR_FLAGS;
pub type PAER_ENDPOINT_DESCRIPTOR_FLAGS = *mut _AER_ENDPOINT_DESCRIPTOR_FLAGS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _AER_BRIDGE_DESCRIPTOR_FLAGS {
    pub __bindgen_anon_1: __BindgenUnionField<_AER_BRIDGE_DESCRIPTOR_FLAGS__bindgen_ty_1>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: [u8; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _AER_BRIDGE_DESCRIPTOR_FLAGS__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
impl Clone for _AER_BRIDGE_DESCRIPTOR_FLAGS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _AER_BRIDGE_DESCRIPTOR_FLAGS__bindgen_ty_1 {
    #[inline]
    pub fn UncorrectableErrorMaskRW(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_UncorrectableErrorMaskRW(&mut self, val: USHORT) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn UncorrectableErrorSeverityRW(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u16)) >>
                                        1u32) as u16)
        }
    }
    #[inline]
    pub fn set_UncorrectableErrorSeverityRW(&mut self, val: USHORT) {
        self._bitfield_1 &= !(2usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 1u32) & (2usize as u16);
    }
    #[inline]
    pub fn CorrectableErrorMaskRW(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u16)) >>
                                        2u32) as u16)
        }
    }
    #[inline]
    pub fn set_CorrectableErrorMaskRW(&mut self, val: USHORT) {
        self._bitfield_1 &= !(4usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 2u32) & (4usize as u16);
    }
    #[inline]
    pub fn AdvancedCapsAndControlRW(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u16)) >>
                                        3u32) as u16)
        }
    }
    #[inline]
    pub fn set_AdvancedCapsAndControlRW(&mut self, val: USHORT) {
        self._bitfield_1 &= !(8usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 3u32) & (8usize as u16);
    }
    #[inline]
    pub fn SecondaryUncorrectableErrorMaskRW(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u16)) >>
                                        4u32) as u16)
        }
    }
    #[inline]
    pub fn set_SecondaryUncorrectableErrorMaskRW(&mut self, val: USHORT) {
        self._bitfield_1 &= !(16usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 4u32) & (16usize as u16);
    }
    #[inline]
    pub fn SecondaryUncorrectableErrorSevRW(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u16)) >>
                                        5u32) as u16)
        }
    }
    #[inline]
    pub fn set_SecondaryUncorrectableErrorSevRW(&mut self, val: USHORT) {
        self._bitfield_1 &= !(32usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 5u32) & (32usize as u16);
    }
    #[inline]
    pub fn SecondaryCapsAndControlRW(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u16)) >>
                                        6u32) as u16)
        }
    }
    #[inline]
    pub fn set_SecondaryCapsAndControlRW(&mut self, val: USHORT) {
        self._bitfield_1 &= !(64usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 6u32) & (64usize as u16);
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65408usize as u16))
                                        >> 7u32) as u16)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        self._bitfield_1 &= !(65408usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 7u32) & (65408usize as u16);
    }
}
impl Clone for _AER_BRIDGE_DESCRIPTOR_FLAGS {
    fn clone(&self) -> Self { *self }
}
pub use self::_AER_BRIDGE_DESCRIPTOR_FLAGS as AER_BRIDGE_DESCRIPTOR_FLAGS;
pub type PAER_BRIDGE_DESCRIPTOR_FLAGS = *mut _AER_BRIDGE_DESCRIPTOR_FLAGS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_NOTIFICATION_DESCRIPTOR {
    pub Type: UCHAR,
    pub Length: UCHAR,
    pub Flags: WHEA_NOTIFICATION_FLAGS,
    pub u: _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1 {
    pub Polled: __BindgenUnionField<_WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>,
    pub Interrupt: __BindgenUnionField<_WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2>,
    pub LocalInterrupt: __BindgenUnionField<_WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3>,
    pub Sci: __BindgenUnionField<_WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4>,
    pub Nmi: __BindgenUnionField<_WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5>,
    pub Sea: __BindgenUnionField<_WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6>,
    pub Sei: __BindgenUnionField<_WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7>,
    pub Gsiv: __BindgenUnionField<_WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8>,
    pub bindgen_union_field: [u8; 24usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    pub PollInterval: ULONG,
}
impl Clone for _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 {
    pub PollInterval: ULONG,
    pub Vector: ULONG,
    pub SwitchToPollingThreshold: ULONG,
    pub SwitchToPollingWindow: ULONG,
    pub ErrorThreshold: ULONG,
    pub ErrorThresholdWindow: ULONG,
}
impl Clone for _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3 {
    pub PollInterval: ULONG,
    pub Vector: ULONG,
    pub SwitchToPollingThreshold: ULONG,
    pub SwitchToPollingWindow: ULONG,
    pub ErrorThreshold: ULONG,
    pub ErrorThresholdWindow: ULONG,
}
impl Clone for _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4 {
    pub PollInterval: ULONG,
    pub Vector: ULONG,
    pub SwitchToPollingThreshold: ULONG,
    pub SwitchToPollingWindow: ULONG,
    pub ErrorThreshold: ULONG,
    pub ErrorThresholdWindow: ULONG,
}
impl Clone for _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5 {
    pub PollInterval: ULONG,
    pub Vector: ULONG,
    pub SwitchToPollingThreshold: ULONG,
    pub SwitchToPollingWindow: ULONG,
    pub ErrorThreshold: ULONG,
    pub ErrorThresholdWindow: ULONG,
}
impl Clone for _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6 {
    pub PollInterval: ULONG,
    pub Vector: ULONG,
    pub SwitchToPollingThreshold: ULONG,
    pub SwitchToPollingWindow: ULONG,
    pub ErrorThreshold: ULONG,
    pub ErrorThresholdWindow: ULONG,
}
impl Clone for _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7 {
    pub PollInterval: ULONG,
    pub Vector: ULONG,
    pub SwitchToPollingThreshold: ULONG,
    pub SwitchToPollingWindow: ULONG,
    pub ErrorThreshold: ULONG,
    pub ErrorThresholdWindow: ULONG,
}
impl Clone for _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8 {
    pub PollInterval: ULONG,
    pub Vector: ULONG,
    pub SwitchToPollingThreshold: ULONG,
    pub SwitchToPollingWindow: ULONG,
    pub ErrorThreshold: ULONG,
    pub ErrorThresholdWindow: ULONG,
}
impl Clone for _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8 {
    fn clone(&self) -> Self { *self }
}
impl Clone for _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Clone for _WHEA_NOTIFICATION_DESCRIPTOR {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_NOTIFICATION_DESCRIPTOR as WHEA_NOTIFICATION_DESCRIPTOR;
pub type PWHEA_NOTIFICATION_DESCRIPTOR = *mut _WHEA_NOTIFICATION_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_XPF_MC_BANK_DESCRIPTOR {
    pub BankNumber: UCHAR,
    pub ClearOnInitialization: BOOLEAN,
    pub StatusDataFormat: UCHAR,
    pub Flags: XPF_MC_BANK_FLAGS,
    pub ControlMsr: ULONG,
    pub StatusMsr: ULONG,
    pub AddressMsr: ULONG,
    pub MiscMsr: ULONG,
    pub ControlData: ULONGLONG,
}
impl Clone for _WHEA_XPF_MC_BANK_DESCRIPTOR {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_XPF_MC_BANK_DESCRIPTOR as WHEA_XPF_MC_BANK_DESCRIPTOR;
pub type PWHEA_XPF_MC_BANK_DESCRIPTOR = *mut _WHEA_XPF_MC_BANK_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_XPF_MCE_DESCRIPTOR {
    pub Type: USHORT,
    pub Enabled: UCHAR,
    pub NumberOfBanks: UCHAR,
    pub Flags: XPF_MCE_FLAGS,
    pub MCG_Capability: ULONGLONG,
    pub MCG_GlobalControl: ULONGLONG,
    pub Banks: [WHEA_XPF_MC_BANK_DESCRIPTOR; 32usize],
}
impl Clone for _WHEA_XPF_MCE_DESCRIPTOR {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_XPF_MCE_DESCRIPTOR as WHEA_XPF_MCE_DESCRIPTOR;
pub type PWHEA_XPF_MCE_DESCRIPTOR = *mut _WHEA_XPF_MCE_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_XPF_CMC_DESCRIPTOR {
    pub Type: USHORT,
    pub Enabled: BOOLEAN,
    pub NumberOfBanks: UCHAR,
    pub Reserved: ULONG,
    pub Notify: WHEA_NOTIFICATION_DESCRIPTOR,
    pub Banks: [WHEA_XPF_MC_BANK_DESCRIPTOR; 32usize],
}
impl Clone for _WHEA_XPF_CMC_DESCRIPTOR {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_XPF_CMC_DESCRIPTOR as WHEA_XPF_CMC_DESCRIPTOR;
pub type PWHEA_XPF_CMC_DESCRIPTOR = *mut _WHEA_XPF_CMC_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_PCI_SLOT_NUMBER {
    pub u: _WHEA_PCI_SLOT_NUMBER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_PCI_SLOT_NUMBER__bindgen_ty_1 {
    pub bits: __BindgenUnionField<_WHEA_PCI_SLOT_NUMBER__bindgen_ty_1__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: [u8; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_PCI_SLOT_NUMBER__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
impl Clone for _WHEA_PCI_SLOT_NUMBER__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_PCI_SLOT_NUMBER__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn DeviceNumber(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (31usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_DeviceNumber(&mut self, val: ULONG) {
        self._bitfield_1 &= !(31usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (31usize as u32);
    }
    #[inline]
    pub fn FunctionNumber(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (224usize as u32)) >>
                                        5u32) as u32)
        }
    }
    #[inline]
    pub fn set_FunctionNumber(&mut self, val: ULONG) {
        self._bitfield_1 &= !(224usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (224usize as u32);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967040usize as u32)) >> 8u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967040usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 8u32) & (4294967040usize as u32);
    }
}
impl Clone for _WHEA_PCI_SLOT_NUMBER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Clone for _WHEA_PCI_SLOT_NUMBER {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_PCI_SLOT_NUMBER as WHEA_PCI_SLOT_NUMBER;
pub type PWHEA_PCI_SLOT_NUMBER = *mut _WHEA_PCI_SLOT_NUMBER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_XPF_NMI_DESCRIPTOR {
    pub Type: USHORT,
    pub Enabled: BOOLEAN,
}
impl Clone for _WHEA_XPF_NMI_DESCRIPTOR {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_XPF_NMI_DESCRIPTOR as WHEA_XPF_NMI_DESCRIPTOR;
pub type PWHEA_XPF_NMI_DESCRIPTOR = *mut _WHEA_XPF_NMI_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_AER_ROOTPORT_DESCRIPTOR {
    pub Type: USHORT,
    pub Enabled: BOOLEAN,
    pub Reserved: UCHAR,
    pub BusNumber: ULONG,
    pub Slot: WHEA_PCI_SLOT_NUMBER,
    pub DeviceControl: USHORT,
    pub Flags: AER_ROOTPORT_DESCRIPTOR_FLAGS,
    pub UncorrectableErrorMask: ULONG,
    pub UncorrectableErrorSeverity: ULONG,
    pub CorrectableErrorMask: ULONG,
    pub AdvancedCapsAndControl: ULONG,
    pub RootErrorCommand: ULONG,
}
impl Clone for _WHEA_AER_ROOTPORT_DESCRIPTOR {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_AER_ROOTPORT_DESCRIPTOR as WHEA_AER_ROOTPORT_DESCRIPTOR;
pub type PWHEA_AER_ROOTPORT_DESCRIPTOR = *mut _WHEA_AER_ROOTPORT_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_AER_ENDPOINT_DESCRIPTOR {
    pub Type: USHORT,
    pub Enabled: BOOLEAN,
    pub Reserved: UCHAR,
    pub BusNumber: ULONG,
    pub Slot: WHEA_PCI_SLOT_NUMBER,
    pub DeviceControl: USHORT,
    pub Flags: AER_ENDPOINT_DESCRIPTOR_FLAGS,
    pub UncorrectableErrorMask: ULONG,
    pub UncorrectableErrorSeverity: ULONG,
    pub CorrectableErrorMask: ULONG,
    pub AdvancedCapsAndControl: ULONG,
}
impl Clone for _WHEA_AER_ENDPOINT_DESCRIPTOR {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_AER_ENDPOINT_DESCRIPTOR as WHEA_AER_ENDPOINT_DESCRIPTOR;
pub type PWHEA_AER_ENDPOINT_DESCRIPTOR = *mut _WHEA_AER_ENDPOINT_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_AER_BRIDGE_DESCRIPTOR {
    pub Type: USHORT,
    pub Enabled: BOOLEAN,
    pub Reserved: UCHAR,
    pub BusNumber: ULONG,
    pub Slot: WHEA_PCI_SLOT_NUMBER,
    pub DeviceControl: USHORT,
    pub Flags: AER_BRIDGE_DESCRIPTOR_FLAGS,
    pub UncorrectableErrorMask: ULONG,
    pub UncorrectableErrorSeverity: ULONG,
    pub CorrectableErrorMask: ULONG,
    pub AdvancedCapsAndControl: ULONG,
    pub SecondaryUncorrectableErrorMask: ULONG,
    pub SecondaryUncorrectableErrorSev: ULONG,
    pub SecondaryCapsAndControl: ULONG,
}
impl Clone for _WHEA_AER_BRIDGE_DESCRIPTOR {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_AER_BRIDGE_DESCRIPTOR as WHEA_AER_BRIDGE_DESCRIPTOR;
pub type PWHEA_AER_BRIDGE_DESCRIPTOR = *mut _WHEA_AER_BRIDGE_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_GENERIC_ERROR_DESCRIPTOR {
    pub Type: USHORT,
    pub Reserved: UCHAR,
    pub Enabled: UCHAR,
    pub ErrStatusBlockLength: ULONG,
    pub RelatedErrorSourceId: ULONG,
    pub ErrStatusAddressSpaceID: UCHAR,
    pub ErrStatusAddressBitWidth: UCHAR,
    pub ErrStatusAddressBitOffset: UCHAR,
    pub ErrStatusAddressAccessSize: UCHAR,
    pub ErrStatusAddress: LARGE_INTEGER,
    pub Notify: WHEA_NOTIFICATION_DESCRIPTOR,
}
impl Clone for _WHEA_GENERIC_ERROR_DESCRIPTOR {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_GENERIC_ERROR_DESCRIPTOR as WHEA_GENERIC_ERROR_DESCRIPTOR;
pub type PWHEA_GENERIC_ERROR_DESCRIPTOR = *mut _WHEA_GENERIC_ERROR_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_GENERIC_ERROR_DESCRIPTOR_V2 {
    pub Type: USHORT,
    pub Reserved: UCHAR,
    pub Enabled: UCHAR,
    pub ErrStatusBlockLength: ULONG,
    pub RelatedErrorSourceId: ULONG,
    pub ErrStatusAddressSpaceID: UCHAR,
    pub ErrStatusAddressBitWidth: UCHAR,
    pub ErrStatusAddressBitOffset: UCHAR,
    pub ErrStatusAddressAccessSize: UCHAR,
    pub ErrStatusAddress: LARGE_INTEGER,
    pub Notify: WHEA_NOTIFICATION_DESCRIPTOR,
    pub ReadAckAddressSpaceID: UCHAR,
    pub ReadAckAddressBitWidth: UCHAR,
    pub ReadAckAddressBitOffset: UCHAR,
    pub ReadAckAddressAccessSize: UCHAR,
    pub ReadAckAddress: LARGE_INTEGER,
    pub ReadAckPreserveMask: ULONGLONG,
    pub ReadAckWriteMask: ULONGLONG,
}
impl Clone for _WHEA_GENERIC_ERROR_DESCRIPTOR_V2 {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_GENERIC_ERROR_DESCRIPTOR_V2 as
        WHEA_GENERIC_ERROR_DESCRIPTOR_V2;
pub type PWHEA_GENERIC_ERROR_DESCRIPTOR_V2 =
    *mut _WHEA_GENERIC_ERROR_DESCRIPTOR_V2;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_IPF_MCA_DESCRIPTOR {
    pub Type: USHORT,
    pub Enabled: UCHAR,
    pub Reserved: UCHAR,
}
impl Clone for _WHEA_IPF_MCA_DESCRIPTOR {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_IPF_MCA_DESCRIPTOR as WHEA_IPF_MCA_DESCRIPTOR;
pub type PWHEA_IPF_MCA_DESCRIPTOR = *mut _WHEA_IPF_MCA_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_IPF_CMC_DESCRIPTOR {
    pub Type: USHORT,
    pub Enabled: UCHAR,
    pub Reserved: UCHAR,
}
impl Clone for _WHEA_IPF_CMC_DESCRIPTOR {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_IPF_CMC_DESCRIPTOR as WHEA_IPF_CMC_DESCRIPTOR;
pub type PWHEA_IPF_CMC_DESCRIPTOR = *mut _WHEA_IPF_CMC_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_IPF_CPE_DESCRIPTOR {
    pub Type: USHORT,
    pub Enabled: UCHAR,
    pub Reserved: UCHAR,
}
impl Clone for _WHEA_IPF_CPE_DESCRIPTOR {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_IPF_CPE_DESCRIPTOR as WHEA_IPF_CPE_DESCRIPTOR;
pub type PWHEA_IPF_CPE_DESCRIPTOR = *mut _WHEA_IPF_CPE_DESCRIPTOR;
pub use self::_WHEA_ERROR_SOURCE_DESCRIPTOR as WHEA_ERROR_SOURCE_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_REVISION {
    pub __bindgen_anon_1: __BindgenUnionField<_WHEA_REVISION__bindgen_ty_1>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: [u8; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_REVISION__bindgen_ty_1 {
    pub MinorRevision: UCHAR,
    pub MajorRevision: UCHAR,
}
impl Clone for _WHEA_REVISION__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Clone for _WHEA_REVISION {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_REVISION as WHEA_REVISION;
pub type PWHEA_REVISION = *mut _WHEA_REVISION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _WHEA_ERROR_SEVERITY {
    WheaErrSevRecoverable = 0,
    WheaErrSevFatal = 1,
    WheaErrSevCorrected = 2,
    WheaErrSevInformational = 3,
}
pub use self::_WHEA_ERROR_SEVERITY as WHEA_ERROR_SEVERITY;
pub type PWHEA_ERROR_SEVERITY = *mut _WHEA_ERROR_SEVERITY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_TIMESTAMP {
    pub __bindgen_anon_1: __BindgenUnionField<_WHEA_TIMESTAMP__bindgen_ty_1>,
    pub AsLARGE_INTEGER: __BindgenUnionField<LARGE_INTEGER>,
    pub bindgen_union_field: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_TIMESTAMP__bindgen_ty_1 {
    pub _bitfield_1: u64,
}
impl Clone for _WHEA_TIMESTAMP__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_TIMESTAMP__bindgen_ty_1 {
    #[inline]
    pub fn Seconds(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (255usize as u64)) >>
                                        0u32) as u64)
        }
    }
    #[inline]
    pub fn set_Seconds(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(255usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 0u32) & (255usize as u64);
    }
    #[inline]
    pub fn Minutes(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65280usize as u64))
                                        >> 8u32) as u64)
        }
    }
    #[inline]
    pub fn set_Minutes(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(65280usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 8u32) & (65280usize as u64);
    }
    #[inline]
    pub fn Hours(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (16711680usize as u64)) >> 16u32) as
                                       u64)
        }
    }
    #[inline]
    pub fn set_Hours(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(16711680usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 16u32) & (16711680usize as u64);
    }
    #[inline]
    pub fn Precise(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (16777216usize as u64)) >> 24u32) as
                                       u64)
        }
    }
    #[inline]
    pub fn set_Precise(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(16777216usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 24u32) & (16777216usize as u64);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4261412864usize as u64)) >> 25u32)
                                       as u64)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(4261412864usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 25u32) & (4261412864usize as u64);
    }
    #[inline]
    pub fn Day(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (1095216660480usize as u64)) >>
                                        32u32) as u64)
        }
    }
    #[inline]
    pub fn set_Day(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(1095216660480usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 32u32) & (1095216660480usize as u64);
    }
    #[inline]
    pub fn Month(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (280375465082880usize as u64)) >>
                                        40u32) as u64)
        }
    }
    #[inline]
    pub fn set_Month(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(280375465082880usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 40u32) & (280375465082880usize as u64);
    }
    #[inline]
    pub fn Year(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (71776119061217280usize as u64)) >>
                                        48u32) as u64)
        }
    }
    #[inline]
    pub fn set_Year(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(71776119061217280usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 48u32) & (71776119061217280usize as u64);
    }
    #[inline]
    pub fn Century(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (18374686479671623680usize as u64))
                                        >> 56u32) as u64)
        }
    }
    #[inline]
    pub fn set_Century(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(18374686479671623680usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 56u32) &
                (18374686479671623680usize as u64);
    }
}
impl Clone for _WHEA_TIMESTAMP {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_TIMESTAMP as WHEA_TIMESTAMP;
pub type PWHEA_TIMESTAMP = *mut _WHEA_TIMESTAMP;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_PERSISTENCE_INFO {
    pub __bindgen_anon_1: __BindgenUnionField<_WHEA_PERSISTENCE_INFO__bindgen_ty_1>,
    pub AsULONGLONG: __BindgenUnionField<ULONGLONG>,
    pub bindgen_union_field: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_PERSISTENCE_INFO__bindgen_ty_1 {
    pub _bitfield_1: u64,
}
impl Clone for _WHEA_PERSISTENCE_INFO__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_PERSISTENCE_INFO__bindgen_ty_1 {
    #[inline]
    pub fn Signature(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65535usize as u64))
                                        >> 0u32) as u64)
        }
    }
    #[inline]
    pub fn set_Signature(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(65535usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 0u32) & (65535usize as u64);
    }
    #[inline]
    pub fn Length(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (1099511562240usize as u64)) >>
                                        16u32) as u64)
        }
    }
    #[inline]
    pub fn set_Length(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(1099511562240usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 16u32) & (1099511562240usize as u64);
    }
    #[inline]
    pub fn Identifier(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (72056494526300160usize as u64)) >>
                                        40u32) as u64)
        }
    }
    #[inline]
    pub fn set_Identifier(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(72056494526300160usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 40u32) & (72056494526300160usize as u64);
    }
    #[inline]
    pub fn Attributes(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (216172782113783808usize as u64)) >>
                                        56u32) as u64)
        }
    }
    #[inline]
    pub fn set_Attributes(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(216172782113783808usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 56u32) & (216172782113783808usize as u64);
    }
    #[inline]
    pub fn DoNotLog(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (288230376151711744usize as u64)) >>
                                        58u32) as u64)
        }
    }
    #[inline]
    pub fn set_DoNotLog(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(288230376151711744usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 58u32) & (288230376151711744usize as u64);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (17870283321406128128usize as u64))
                                        >> 59u32) as u64)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(17870283321406128128usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 59u32) &
                (17870283321406128128usize as u64);
    }
}
impl Clone for _WHEA_PERSISTENCE_INFO {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_PERSISTENCE_INFO as WHEA_PERSISTENCE_INFO;
pub type PWHEA_PERSISTENCE_INFO = *mut _WHEA_PERSISTENCE_INFO;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ERROR_STATUS {
    pub ErrorStatus: __BindgenUnionField<ULONGLONG>,
    pub __bindgen_anon_1: __BindgenUnionField<_WHEA_ERROR_STATUS__bindgen_ty_1>,
    pub bindgen_union_field: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ERROR_STATUS__bindgen_ty_1 {
    pub _bitfield_1: u64,
}
impl Clone for _WHEA_ERROR_STATUS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_ERROR_STATUS__bindgen_ty_1 {
    #[inline]
    pub fn Reserved1(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (255usize as u64)) >>
                                        0u32) as u64)
        }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(255usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 0u32) & (255usize as u64);
    }
    #[inline]
    pub fn ErrorType(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65280usize as u64))
                                        >> 8u32) as u64)
        }
    }
    #[inline]
    pub fn set_ErrorType(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(65280usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 8u32) & (65280usize as u64);
    }
    #[inline]
    pub fn Address(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65536usize as u64))
                                        >> 16u32) as u64)
        }
    }
    #[inline]
    pub fn set_Address(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(65536usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 16u32) & (65536usize as u64);
    }
    #[inline]
    pub fn Control(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (131072usize as u64))
                                        >> 17u32) as u64)
        }
    }
    #[inline]
    pub fn set_Control(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(131072usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 17u32) & (131072usize as u64);
    }
    #[inline]
    pub fn Data(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (262144usize as u64))
                                        >> 18u32) as u64)
        }
    }
    #[inline]
    pub fn set_Data(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(262144usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 18u32) & (262144usize as u64);
    }
    #[inline]
    pub fn Responder(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (524288usize as u64))
                                        >> 19u32) as u64)
        }
    }
    #[inline]
    pub fn set_Responder(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(524288usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 19u32) & (524288usize as u64);
    }
    #[inline]
    pub fn Requester(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1048576usize as u64))
                                        >> 20u32) as u64)
        }
    }
    #[inline]
    pub fn set_Requester(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(1048576usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 20u32) & (1048576usize as u64);
    }
    #[inline]
    pub fn FirstError(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2097152usize as u64))
                                        >> 21u32) as u64)
        }
    }
    #[inline]
    pub fn set_FirstError(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(2097152usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 21u32) & (2097152usize as u64);
    }
    #[inline]
    pub fn Overflow(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4194304usize as u64))
                                        >> 22u32) as u64)
        }
    }
    #[inline]
    pub fn set_Overflow(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(4194304usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 22u32) & (4194304usize as u64);
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (18446744073701163008usize as u64))
                                        >> 23u32) as u64)
        }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(18446744073701163008usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 23u32) &
                (18446744073701163008usize as u64);
    }
}
impl Clone for _WHEA_ERROR_STATUS {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_ERROR_STATUS as WHEA_ERROR_STATUS;
pub type PWHEA_ERROR_STATUS = *mut _WHEA_ERROR_STATUS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ERROR_RECORD_HEADER_VALIDBITS {
    pub __bindgen_anon_1: __BindgenUnionField<_WHEA_ERROR_RECORD_HEADER_VALIDBITS__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: [u8; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ERROR_RECORD_HEADER_VALIDBITS__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
impl Clone for _WHEA_ERROR_RECORD_HEADER_VALIDBITS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_ERROR_RECORD_HEADER_VALIDBITS__bindgen_ty_1 {
    #[inline]
    pub fn PlatformId(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_PlatformId(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn Timestamp(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_Timestamp(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn PartitionId(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                        2u32) as u32)
        }
    }
    #[inline]
    pub fn set_PartitionId(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967288usize as u32)) >> 3u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967288usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 3u32) & (4294967288usize as u32);
    }
}
impl Clone for _WHEA_ERROR_RECORD_HEADER_VALIDBITS {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_ERROR_RECORD_HEADER_VALIDBITS as
        WHEA_ERROR_RECORD_HEADER_VALIDBITS;
pub type PWHEA_ERROR_RECORD_HEADER_VALIDBITS =
    *mut _WHEA_ERROR_RECORD_HEADER_VALIDBITS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ERROR_RECORD_HEADER_FLAGS {
    pub __bindgen_anon_1: __BindgenUnionField<_WHEA_ERROR_RECORD_HEADER_FLAGS__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: [u8; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ERROR_RECORD_HEADER_FLAGS__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
impl Clone for _WHEA_ERROR_RECORD_HEADER_FLAGS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_ERROR_RECORD_HEADER_FLAGS__bindgen_ty_1 {
    #[inline]
    pub fn Recovered(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_Recovered(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn PreviousError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_PreviousError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn Simulated(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                        2u32) as u32)
        }
    }
    #[inline]
    pub fn set_Simulated(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967288usize as u32)) >> 3u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967288usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 3u32) & (4294967288usize as u32);
    }
}
impl Clone for _WHEA_ERROR_RECORD_HEADER_FLAGS {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_ERROR_RECORD_HEADER_FLAGS as
        WHEA_ERROR_RECORD_HEADER_FLAGS;
pub type PWHEA_ERROR_RECORD_HEADER_FLAGS =
    *mut _WHEA_ERROR_RECORD_HEADER_FLAGS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ERROR_RECORD_HEADER {
    pub Signature: ULONG,
    pub Revision: WHEA_REVISION,
    pub SignatureEnd: ULONG,
    pub SectionCount: USHORT,
    pub Severity: WHEA_ERROR_SEVERITY,
    pub ValidBits: WHEA_ERROR_RECORD_HEADER_VALIDBITS,
    pub Length: ULONG,
    pub Timestamp: WHEA_TIMESTAMP,
    pub PlatformId: GUID,
    pub PartitionId: GUID,
    pub CreatorId: GUID,
    pub NotifyType: GUID,
    pub RecordId: ULONGLONG,
    pub Flags: WHEA_ERROR_RECORD_HEADER_FLAGS,
    pub PersistenceInfo: WHEA_PERSISTENCE_INFO,
    pub Reserved: [UCHAR; 12usize],
}
impl Clone for _WHEA_ERROR_RECORD_HEADER {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_ERROR_RECORD_HEADER as WHEA_ERROR_RECORD_HEADER;
pub type PWHEA_ERROR_RECORD_HEADER = *mut _WHEA_ERROR_RECORD_HEADER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS {
    pub __bindgen_anon_1: __BindgenUnionField<_WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: [u8; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
impl Clone for _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS__bindgen_ty_1 {
    #[inline]
    pub fn Primary(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_Primary(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn ContainmentWarning(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_ContainmentWarning(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn Reset(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                        2u32) as u32)
        }
    }
    #[inline]
    pub fn set_Reset(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn ThresholdExceeded(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u32)) >>
                                        3u32) as u32)
        }
    }
    #[inline]
    pub fn set_ThresholdExceeded(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (8usize as u32);
    }
    #[inline]
    pub fn ResourceNotAvailable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u32)) >>
                                        4u32) as u32)
        }
    }
    #[inline]
    pub fn set_ResourceNotAvailable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (16usize as u32);
    }
    #[inline]
    pub fn LatentError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u32)) >>
                                        5u32) as u32)
        }
    }
    #[inline]
    pub fn set_LatentError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(32usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (32usize as u32);
    }
    #[inline]
    pub fn Propagated(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u32)) >>
                                        6u32) as u32)
        }
    }
    #[inline]
    pub fn set_Propagated(&mut self, val: ULONG) {
        self._bitfield_1 &= !(64usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 6u32) & (64usize as u32);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967168usize as u32)) >> 7u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967168usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 7u32) & (4294967168usize as u32);
    }
}
impl Clone for _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS as
        WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS;
pub type PWHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS =
    *mut _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS {
    pub __bindgen_anon_1: __BindgenUnionField<_WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS__bindgen_ty_1>,
    pub AsUCHAR: __BindgenUnionField<UCHAR>,
    pub bindgen_union_field: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS__bindgen_ty_1 {
    pub _bitfield_1: u8,
}
impl Clone for _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS__bindgen_ty_1 {
    #[inline]
    pub fn FRUId(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                        0u32) as u8)
        }
    }
    #[inline]
    pub fn set_FRUId(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 0u32) & (1usize as u8);
    }
    #[inline]
    pub fn FRUText(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u8)) >>
                                        1u32) as u8)
        }
    }
    #[inline]
    pub fn set_FRUText(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(2usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 1u32) & (2usize as u8);
    }
    #[inline]
    pub fn Reserved(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (252usize as u8)) >>
                                        2u32) as u8)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(252usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 2u32) & (252usize as u8);
    }
}
impl Clone for _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS as
        WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS;
pub type PWHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS =
    *mut _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR {
    pub SectionOffset: ULONG,
    pub SectionLength: ULONG,
    pub Revision: WHEA_REVISION,
    pub ValidBits: WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS,
    pub Reserved: UCHAR,
    pub Flags: WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS,
    pub SectionType: GUID,
    pub FRUId: GUID,
    pub SectionSeverity: WHEA_ERROR_SEVERITY,
    pub FRUText: [CCHAR; 20usize],
}
impl Clone for _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_ERROR_RECORD_SECTION_DESCRIPTOR as
        WHEA_ERROR_RECORD_SECTION_DESCRIPTOR;
pub type PWHEA_ERROR_RECORD_SECTION_DESCRIPTOR =
    *mut _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR;
pub use self::_WHEA_ERROR_RECORD as WHEA_ERROR_RECORD;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_PROCESSOR_FAMILY_INFO {
    pub __bindgen_anon_1: __BindgenUnionField<_WHEA_PROCESSOR_FAMILY_INFO__bindgen_ty_1>,
    pub AsULONGLONG: __BindgenUnionField<ULONGLONG>,
    pub bindgen_union_field: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_PROCESSOR_FAMILY_INFO__bindgen_ty_1 {
    pub _bitfield_1: u32,
    pub Reserved3: ULONG,
}
impl Clone for _WHEA_PROCESSOR_FAMILY_INFO__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_PROCESSOR_FAMILY_INFO__bindgen_ty_1 {
    #[inline]
    pub fn Stepping(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (15usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_Stepping(&mut self, val: ULONG) {
        self._bitfield_1 &= !(15usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (15usize as u32);
    }
    #[inline]
    pub fn Model(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (240usize as u32)) >>
                                        4u32) as u32)
        }
    }
    #[inline]
    pub fn set_Model(&mut self, val: ULONG) {
        self._bitfield_1 &= !(240usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (240usize as u32);
    }
    #[inline]
    pub fn Family(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (3840usize as u32)) >>
                                        8u32) as u32)
        }
    }
    #[inline]
    pub fn set_Family(&mut self, val: ULONG) {
        self._bitfield_1 &= !(3840usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 8u32) & (3840usize as u32);
    }
    #[inline]
    pub fn ProcessorType(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (12288usize as u32))
                                        >> 12u32) as u32)
        }
    }
    #[inline]
    pub fn set_ProcessorType(&mut self, val: ULONG) {
        self._bitfield_1 &= !(12288usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 12u32) & (12288usize as u32);
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (49152usize as u32))
                                        >> 14u32) as u32)
        }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        self._bitfield_1 &= !(49152usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 14u32) & (49152usize as u32);
    }
    #[inline]
    pub fn ExtendedModel(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (983040usize as u32))
                                        >> 16u32) as u32)
        }
    }
    #[inline]
    pub fn set_ExtendedModel(&mut self, val: ULONG) {
        self._bitfield_1 &= !(983040usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (983040usize as u32);
    }
    #[inline]
    pub fn ExtendedFamily(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (267386880usize as u32)) >> 20u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_ExtendedFamily(&mut self, val: ULONG) {
        self._bitfield_1 &= !(267386880usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 20u32) & (267386880usize as u32);
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4026531840usize as u32)) >> 28u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4026531840usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 28u32) & (4026531840usize as u32);
    }
}
impl Clone for _WHEA_PROCESSOR_FAMILY_INFO {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_PROCESSOR_FAMILY_INFO as WHEA_PROCESSOR_FAMILY_INFO;
pub type PWHEA_PROCESSOR_FAMILY_INFO = *mut _WHEA_PROCESSOR_FAMILY_INFO;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS {
    pub __bindgen_anon_1: __BindgenUnionField<_WHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS__bindgen_ty_1>,
    pub ValidBits: __BindgenUnionField<ULONGLONG>,
    pub bindgen_union_field: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS__bindgen_ty_1 {
    pub _bitfield_1: u64,
}
impl Clone for _WHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS__bindgen_ty_1 {
    #[inline]
    pub fn ProcessorType(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u64)) >>
                                        0u32) as u64)
        }
    }
    #[inline]
    pub fn set_ProcessorType(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(1usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 0u32) & (1usize as u64);
    }
    #[inline]
    pub fn InstructionSet(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u64)) >>
                                        1u32) as u64)
        }
    }
    #[inline]
    pub fn set_InstructionSet(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(2usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 1u32) & (2usize as u64);
    }
    #[inline]
    pub fn ErrorType(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u64)) >>
                                        2u32) as u64)
        }
    }
    #[inline]
    pub fn set_ErrorType(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(4usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 2u32) & (4usize as u64);
    }
    #[inline]
    pub fn Operation(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u64)) >>
                                        3u32) as u64)
        }
    }
    #[inline]
    pub fn set_Operation(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(8usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 3u32) & (8usize as u64);
    }
    #[inline]
    pub fn Flags(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u64)) >>
                                        4u32) as u64)
        }
    }
    #[inline]
    pub fn set_Flags(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(16usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 4u32) & (16usize as u64);
    }
    #[inline]
    pub fn Level(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u64)) >>
                                        5u32) as u64)
        }
    }
    #[inline]
    pub fn set_Level(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(32usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 5u32) & (32usize as u64);
    }
    #[inline]
    pub fn CPUVersion(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u64)) >>
                                        6u32) as u64)
        }
    }
    #[inline]
    pub fn set_CPUVersion(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(64usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 6u32) & (64usize as u64);
    }
    #[inline]
    pub fn CPUBrandString(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (128usize as u64)) >>
                                        7u32) as u64)
        }
    }
    #[inline]
    pub fn set_CPUBrandString(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(128usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 7u32) & (128usize as u64);
    }
    #[inline]
    pub fn ProcessorId(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (256usize as u64)) >>
                                        8u32) as u64)
        }
    }
    #[inline]
    pub fn set_ProcessorId(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(256usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 8u32) & (256usize as u64);
    }
    #[inline]
    pub fn TargetAddress(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (512usize as u64)) >>
                                        9u32) as u64)
        }
    }
    #[inline]
    pub fn set_TargetAddress(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(512usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 9u32) & (512usize as u64);
    }
    #[inline]
    pub fn RequesterId(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1024usize as u64)) >>
                                        10u32) as u64)
        }
    }
    #[inline]
    pub fn set_RequesterId(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(1024usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 10u32) & (1024usize as u64);
    }
    #[inline]
    pub fn ResponderId(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2048usize as u64)) >>
                                        11u32) as u64)
        }
    }
    #[inline]
    pub fn set_ResponderId(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(2048usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 11u32) & (2048usize as u64);
    }
    #[inline]
    pub fn InstructionPointer(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4096usize as u64)) >>
                                        12u32) as u64)
        }
    }
    #[inline]
    pub fn set_InstructionPointer(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(4096usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 12u32) & (4096usize as u64);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (18446744073709543424usize as u64))
                                        >> 13u32) as u64)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(18446744073709543424usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 13u32) &
                (18446744073709543424usize as u64);
    }
}
impl Clone for _WHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS as
        WHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS;
pub type PWHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS =
    *mut _WHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS;
#[repr(C)]
pub struct _WHEA_PROCESSOR_GENERIC_ERROR_SECTION {
    pub ValidBits: WHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS,
    pub ProcessorType: UCHAR,
    pub InstructionSet: UCHAR,
    pub ErrorType: UCHAR,
    pub Operation: UCHAR,
    pub Flags: UCHAR,
    pub Level: UCHAR,
    pub Reserved: USHORT,
    pub CPUVersion: ULONGLONG,
    pub CPUBrandString: [UCHAR; 128usize],
    pub ProcessorId: ULONGLONG,
    pub TargetAddress: ULONGLONG,
    pub RequesterId: ULONGLONG,
    pub ResponderId: ULONGLONG,
    pub InstructionPointer: ULONGLONG,
}
pub use self::_WHEA_PROCESSOR_GENERIC_ERROR_SECTION as
        WHEA_PROCESSOR_GENERIC_ERROR_SECTION;
pub type PWHEA_PROCESSOR_GENERIC_ERROR_SECTION =
    *mut _WHEA_PROCESSOR_GENERIC_ERROR_SECTION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_XPF_CACHE_CHECK {
    pub __bindgen_anon_1: __BindgenUnionField<_WHEA_XPF_CACHE_CHECK__bindgen_ty_1>,
    pub XpfCacheCheck: __BindgenUnionField<ULONGLONG>,
    pub bindgen_union_field: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_XPF_CACHE_CHECK__bindgen_ty_1 {
    pub _bitfield_1: u64,
}
impl Clone for _WHEA_XPF_CACHE_CHECK__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_XPF_CACHE_CHECK__bindgen_ty_1 {
    #[inline]
    pub fn TransactionTypeValid(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u64)) >>
                                        0u32) as u64)
        }
    }
    #[inline]
    pub fn set_TransactionTypeValid(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(1usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 0u32) & (1usize as u64);
    }
    #[inline]
    pub fn OperationValid(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u64)) >>
                                        1u32) as u64)
        }
    }
    #[inline]
    pub fn set_OperationValid(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(2usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 1u32) & (2usize as u64);
    }
    #[inline]
    pub fn LevelValid(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u64)) >>
                                        2u32) as u64)
        }
    }
    #[inline]
    pub fn set_LevelValid(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(4usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 2u32) & (4usize as u64);
    }
    #[inline]
    pub fn ProcessorContextCorruptValid(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u64)) >>
                                        3u32) as u64)
        }
    }
    #[inline]
    pub fn set_ProcessorContextCorruptValid(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(8usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 3u32) & (8usize as u64);
    }
    #[inline]
    pub fn UncorrectedValid(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u64)) >>
                                        4u32) as u64)
        }
    }
    #[inline]
    pub fn set_UncorrectedValid(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(16usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 4u32) & (16usize as u64);
    }
    #[inline]
    pub fn PreciseIPValid(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u64)) >>
                                        5u32) as u64)
        }
    }
    #[inline]
    pub fn set_PreciseIPValid(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(32usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 5u32) & (32usize as u64);
    }
    #[inline]
    pub fn RestartableIPValid(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u64)) >>
                                        6u32) as u64)
        }
    }
    #[inline]
    pub fn set_RestartableIPValid(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(64usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 6u32) & (64usize as u64);
    }
    #[inline]
    pub fn OverflowValid(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (128usize as u64)) >>
                                        7u32) as u64)
        }
    }
    #[inline]
    pub fn set_OverflowValid(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(128usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 7u32) & (128usize as u64);
    }
    #[inline]
    pub fn ReservedValid(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65280usize as u64))
                                        >> 8u32) as u64)
        }
    }
    #[inline]
    pub fn set_ReservedValid(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(65280usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 8u32) & (65280usize as u64);
    }
    #[inline]
    pub fn TransactionType(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (196608usize as u64))
                                        >> 16u32) as u64)
        }
    }
    #[inline]
    pub fn set_TransactionType(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(196608usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 16u32) & (196608usize as u64);
    }
    #[inline]
    pub fn Operation(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (3932160usize as u64))
                                        >> 18u32) as u64)
        }
    }
    #[inline]
    pub fn set_Operation(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(3932160usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 18u32) & (3932160usize as u64);
    }
    #[inline]
    pub fn Level(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (29360128usize as u64)) >> 22u32) as
                                       u64)
        }
    }
    #[inline]
    pub fn set_Level(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(29360128usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 22u32) & (29360128usize as u64);
    }
    #[inline]
    pub fn ProcessorContextCorrupt(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (33554432usize as u64)) >> 25u32) as
                                       u64)
        }
    }
    #[inline]
    pub fn set_ProcessorContextCorrupt(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(33554432usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 25u32) & (33554432usize as u64);
    }
    #[inline]
    pub fn Uncorrected(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (67108864usize as u64)) >> 26u32) as
                                       u64)
        }
    }
    #[inline]
    pub fn set_Uncorrected(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(67108864usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 26u32) & (67108864usize as u64);
    }
    #[inline]
    pub fn PreciseIP(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (134217728usize as u64)) >> 27u32) as
                                       u64)
        }
    }
    #[inline]
    pub fn set_PreciseIP(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(134217728usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 27u32) & (134217728usize as u64);
    }
    #[inline]
    pub fn RestartableIP(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (268435456usize as u64)) >> 28u32) as
                                       u64)
        }
    }
    #[inline]
    pub fn set_RestartableIP(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(268435456usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 28u32) & (268435456usize as u64);
    }
    #[inline]
    pub fn Overflow(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (536870912usize as u64)) >> 29u32) as
                                       u64)
        }
    }
    #[inline]
    pub fn set_Overflow(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(536870912usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 29u32) & (536870912usize as u64);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (18446744072635809792usize as u64))
                                        >> 30u32) as u64)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(18446744072635809792usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 30u32) &
                (18446744072635809792usize as u64);
    }
}
impl Clone for _WHEA_XPF_CACHE_CHECK {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_XPF_CACHE_CHECK as WHEA_XPF_CACHE_CHECK;
pub type PWHEA_XPF_CACHE_CHECK = *mut _WHEA_XPF_CACHE_CHECK;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_XPF_TLB_CHECK {
    pub __bindgen_anon_1: __BindgenUnionField<_WHEA_XPF_TLB_CHECK__bindgen_ty_1>,
    pub XpfTLBCheck: __BindgenUnionField<ULONGLONG>,
    pub bindgen_union_field: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_XPF_TLB_CHECK__bindgen_ty_1 {
    pub _bitfield_1: u64,
}
impl Clone for _WHEA_XPF_TLB_CHECK__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_XPF_TLB_CHECK__bindgen_ty_1 {
    #[inline]
    pub fn TransactionTypeValid(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u64)) >>
                                        0u32) as u64)
        }
    }
    #[inline]
    pub fn set_TransactionTypeValid(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(1usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 0u32) & (1usize as u64);
    }
    #[inline]
    pub fn OperationValid(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u64)) >>
                                        1u32) as u64)
        }
    }
    #[inline]
    pub fn set_OperationValid(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(2usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 1u32) & (2usize as u64);
    }
    #[inline]
    pub fn LevelValid(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u64)) >>
                                        2u32) as u64)
        }
    }
    #[inline]
    pub fn set_LevelValid(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(4usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 2u32) & (4usize as u64);
    }
    #[inline]
    pub fn ProcessorContextCorruptValid(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u64)) >>
                                        3u32) as u64)
        }
    }
    #[inline]
    pub fn set_ProcessorContextCorruptValid(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(8usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 3u32) & (8usize as u64);
    }
    #[inline]
    pub fn UncorrectedValid(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u64)) >>
                                        4u32) as u64)
        }
    }
    #[inline]
    pub fn set_UncorrectedValid(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(16usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 4u32) & (16usize as u64);
    }
    #[inline]
    pub fn PreciseIPValid(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u64)) >>
                                        5u32) as u64)
        }
    }
    #[inline]
    pub fn set_PreciseIPValid(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(32usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 5u32) & (32usize as u64);
    }
    #[inline]
    pub fn RestartableIPValid(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u64)) >>
                                        6u32) as u64)
        }
    }
    #[inline]
    pub fn set_RestartableIPValid(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(64usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 6u32) & (64usize as u64);
    }
    #[inline]
    pub fn OverflowValid(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (128usize as u64)) >>
                                        7u32) as u64)
        }
    }
    #[inline]
    pub fn set_OverflowValid(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(128usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 7u32) & (128usize as u64);
    }
    #[inline]
    pub fn ReservedValid(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65280usize as u64))
                                        >> 8u32) as u64)
        }
    }
    #[inline]
    pub fn set_ReservedValid(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(65280usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 8u32) & (65280usize as u64);
    }
    #[inline]
    pub fn TransactionType(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (196608usize as u64))
                                        >> 16u32) as u64)
        }
    }
    #[inline]
    pub fn set_TransactionType(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(196608usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 16u32) & (196608usize as u64);
    }
    #[inline]
    pub fn Operation(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (3932160usize as u64))
                                        >> 18u32) as u64)
        }
    }
    #[inline]
    pub fn set_Operation(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(3932160usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 18u32) & (3932160usize as u64);
    }
    #[inline]
    pub fn Level(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (29360128usize as u64)) >> 22u32) as
                                       u64)
        }
    }
    #[inline]
    pub fn set_Level(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(29360128usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 22u32) & (29360128usize as u64);
    }
    #[inline]
    pub fn ProcessorContextCorrupt(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (33554432usize as u64)) >> 25u32) as
                                       u64)
        }
    }
    #[inline]
    pub fn set_ProcessorContextCorrupt(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(33554432usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 25u32) & (33554432usize as u64);
    }
    #[inline]
    pub fn Uncorrected(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (67108864usize as u64)) >> 26u32) as
                                       u64)
        }
    }
    #[inline]
    pub fn set_Uncorrected(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(67108864usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 26u32) & (67108864usize as u64);
    }
    #[inline]
    pub fn PreciseIP(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (134217728usize as u64)) >> 27u32) as
                                       u64)
        }
    }
    #[inline]
    pub fn set_PreciseIP(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(134217728usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 27u32) & (134217728usize as u64);
    }
    #[inline]
    pub fn RestartableIP(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (268435456usize as u64)) >> 28u32) as
                                       u64)
        }
    }
    #[inline]
    pub fn set_RestartableIP(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(268435456usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 28u32) & (268435456usize as u64);
    }
    #[inline]
    pub fn Overflow(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (536870912usize as u64)) >> 29u32) as
                                       u64)
        }
    }
    #[inline]
    pub fn set_Overflow(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(536870912usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 29u32) & (536870912usize as u64);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (18446744072635809792usize as u64))
                                        >> 30u32) as u64)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(18446744072635809792usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 30u32) &
                (18446744072635809792usize as u64);
    }
}
impl Clone for _WHEA_XPF_TLB_CHECK {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_XPF_TLB_CHECK as WHEA_XPF_TLB_CHECK;
pub type PWHEA_XPF_TLB_CHECK = *mut _WHEA_XPF_TLB_CHECK;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_XPF_BUS_CHECK {
    pub __bindgen_anon_1: __BindgenUnionField<_WHEA_XPF_BUS_CHECK__bindgen_ty_1>,
    pub XpfBusCheck: __BindgenUnionField<ULONGLONG>,
    pub bindgen_union_field: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_XPF_BUS_CHECK__bindgen_ty_1 {
    pub _bitfield_1: u64,
}
impl Clone for _WHEA_XPF_BUS_CHECK__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_XPF_BUS_CHECK__bindgen_ty_1 {
    #[inline]
    pub fn TransactionTypeValid(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u64)) >>
                                        0u32) as u64)
        }
    }
    #[inline]
    pub fn set_TransactionTypeValid(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(1usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 0u32) & (1usize as u64);
    }
    #[inline]
    pub fn OperationValid(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u64)) >>
                                        1u32) as u64)
        }
    }
    #[inline]
    pub fn set_OperationValid(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(2usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 1u32) & (2usize as u64);
    }
    #[inline]
    pub fn LevelValid(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u64)) >>
                                        2u32) as u64)
        }
    }
    #[inline]
    pub fn set_LevelValid(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(4usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 2u32) & (4usize as u64);
    }
    #[inline]
    pub fn ProcessorContextCorruptValid(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u64)) >>
                                        3u32) as u64)
        }
    }
    #[inline]
    pub fn set_ProcessorContextCorruptValid(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(8usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 3u32) & (8usize as u64);
    }
    #[inline]
    pub fn UncorrectedValid(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u64)) >>
                                        4u32) as u64)
        }
    }
    #[inline]
    pub fn set_UncorrectedValid(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(16usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 4u32) & (16usize as u64);
    }
    #[inline]
    pub fn PreciseIPValid(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u64)) >>
                                        5u32) as u64)
        }
    }
    #[inline]
    pub fn set_PreciseIPValid(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(32usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 5u32) & (32usize as u64);
    }
    #[inline]
    pub fn RestartableIPValid(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u64)) >>
                                        6u32) as u64)
        }
    }
    #[inline]
    pub fn set_RestartableIPValid(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(64usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 6u32) & (64usize as u64);
    }
    #[inline]
    pub fn OverflowValid(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (128usize as u64)) >>
                                        7u32) as u64)
        }
    }
    #[inline]
    pub fn set_OverflowValid(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(128usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 7u32) & (128usize as u64);
    }
    #[inline]
    pub fn ParticipationValid(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (256usize as u64)) >>
                                        8u32) as u64)
        }
    }
    #[inline]
    pub fn set_ParticipationValid(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(256usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 8u32) & (256usize as u64);
    }
    #[inline]
    pub fn TimeoutValid(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (512usize as u64)) >>
                                        9u32) as u64)
        }
    }
    #[inline]
    pub fn set_TimeoutValid(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(512usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 9u32) & (512usize as u64);
    }
    #[inline]
    pub fn AddressSpaceValid(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1024usize as u64)) >>
                                        10u32) as u64)
        }
    }
    #[inline]
    pub fn set_AddressSpaceValid(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(1024usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 10u32) & (1024usize as u64);
    }
    #[inline]
    pub fn ReservedValid(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (63488usize as u64))
                                        >> 11u32) as u64)
        }
    }
    #[inline]
    pub fn set_ReservedValid(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(63488usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 11u32) & (63488usize as u64);
    }
    #[inline]
    pub fn TransactionType(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (196608usize as u64))
                                        >> 16u32) as u64)
        }
    }
    #[inline]
    pub fn set_TransactionType(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(196608usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 16u32) & (196608usize as u64);
    }
    #[inline]
    pub fn Operation(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (3932160usize as u64))
                                        >> 18u32) as u64)
        }
    }
    #[inline]
    pub fn set_Operation(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(3932160usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 18u32) & (3932160usize as u64);
    }
    #[inline]
    pub fn Level(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (29360128usize as u64)) >> 22u32) as
                                       u64)
        }
    }
    #[inline]
    pub fn set_Level(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(29360128usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 22u32) & (29360128usize as u64);
    }
    #[inline]
    pub fn ProcessorContextCorrupt(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (33554432usize as u64)) >> 25u32) as
                                       u64)
        }
    }
    #[inline]
    pub fn set_ProcessorContextCorrupt(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(33554432usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 25u32) & (33554432usize as u64);
    }
    #[inline]
    pub fn Uncorrected(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (67108864usize as u64)) >> 26u32) as
                                       u64)
        }
    }
    #[inline]
    pub fn set_Uncorrected(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(67108864usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 26u32) & (67108864usize as u64);
    }
    #[inline]
    pub fn PreciseIP(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (134217728usize as u64)) >> 27u32) as
                                       u64)
        }
    }
    #[inline]
    pub fn set_PreciseIP(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(134217728usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 27u32) & (134217728usize as u64);
    }
    #[inline]
    pub fn RestartableIP(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (268435456usize as u64)) >> 28u32) as
                                       u64)
        }
    }
    #[inline]
    pub fn set_RestartableIP(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(268435456usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 28u32) & (268435456usize as u64);
    }
    #[inline]
    pub fn Overflow(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (536870912usize as u64)) >> 29u32) as
                                       u64)
        }
    }
    #[inline]
    pub fn set_Overflow(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(536870912usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 29u32) & (536870912usize as u64);
    }
    #[inline]
    pub fn Participation(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (3221225472usize as u64)) >> 30u32)
                                       as u64)
        }
    }
    #[inline]
    pub fn set_Participation(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(3221225472usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 30u32) & (3221225472usize as u64);
    }
    #[inline]
    pub fn Timeout(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967296usize as u64)) >> 32u32)
                                       as u64)
        }
    }
    #[inline]
    pub fn set_Timeout(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(4294967296usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 32u32) & (4294967296usize as u64);
    }
    #[inline]
    pub fn AddressSpace(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (25769803776usize as u64)) >> 33u32)
                                       as u64)
        }
    }
    #[inline]
    pub fn set_AddressSpace(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(25769803776usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 33u32) & (25769803776usize as u64);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (18446744039349813248usize as u64))
                                        >> 35u32) as u64)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(18446744039349813248usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 35u32) &
                (18446744039349813248usize as u64);
    }
}
impl Clone for _WHEA_XPF_BUS_CHECK {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_XPF_BUS_CHECK as WHEA_XPF_BUS_CHECK;
pub type PWHEA_XPF_BUS_CHECK = *mut _WHEA_XPF_BUS_CHECK;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_XPF_MS_CHECK {
    pub __bindgen_anon_1: __BindgenUnionField<_WHEA_XPF_MS_CHECK__bindgen_ty_1>,
    pub XpfMsCheck: __BindgenUnionField<ULONGLONG>,
    pub bindgen_union_field: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_XPF_MS_CHECK__bindgen_ty_1 {
    pub _bitfield_1: u64,
}
impl Clone for _WHEA_XPF_MS_CHECK__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_XPF_MS_CHECK__bindgen_ty_1 {
    #[inline]
    pub fn ErrorTypeValid(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u64)) >>
                                        0u32) as u64)
        }
    }
    #[inline]
    pub fn set_ErrorTypeValid(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(1usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 0u32) & (1usize as u64);
    }
    #[inline]
    pub fn ProcessorContextCorruptValid(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u64)) >>
                                        1u32) as u64)
        }
    }
    #[inline]
    pub fn set_ProcessorContextCorruptValid(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(2usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 1u32) & (2usize as u64);
    }
    #[inline]
    pub fn UncorrectedValid(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u64)) >>
                                        2u32) as u64)
        }
    }
    #[inline]
    pub fn set_UncorrectedValid(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(4usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 2u32) & (4usize as u64);
    }
    #[inline]
    pub fn PreciseIPValid(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u64)) >>
                                        3u32) as u64)
        }
    }
    #[inline]
    pub fn set_PreciseIPValid(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(8usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 3u32) & (8usize as u64);
    }
    #[inline]
    pub fn RestartableIPValid(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u64)) >>
                                        4u32) as u64)
        }
    }
    #[inline]
    pub fn set_RestartableIPValid(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(16usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 4u32) & (16usize as u64);
    }
    #[inline]
    pub fn OverflowValid(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u64)) >>
                                        5u32) as u64)
        }
    }
    #[inline]
    pub fn set_OverflowValid(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(32usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 5u32) & (32usize as u64);
    }
    #[inline]
    pub fn ReservedValue(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65472usize as u64))
                                        >> 6u32) as u64)
        }
    }
    #[inline]
    pub fn set_ReservedValue(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(65472usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 6u32) & (65472usize as u64);
    }
    #[inline]
    pub fn ErrorType(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (458752usize as u64))
                                        >> 16u32) as u64)
        }
    }
    #[inline]
    pub fn set_ErrorType(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(458752usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 16u32) & (458752usize as u64);
    }
    #[inline]
    pub fn ProcessorContextCorrupt(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (524288usize as u64))
                                        >> 19u32) as u64)
        }
    }
    #[inline]
    pub fn set_ProcessorContextCorrupt(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(524288usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 19u32) & (524288usize as u64);
    }
    #[inline]
    pub fn Uncorrected(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1048576usize as u64))
                                        >> 20u32) as u64)
        }
    }
    #[inline]
    pub fn set_Uncorrected(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(1048576usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 20u32) & (1048576usize as u64);
    }
    #[inline]
    pub fn PreciseIP(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2097152usize as u64))
                                        >> 21u32) as u64)
        }
    }
    #[inline]
    pub fn set_PreciseIP(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(2097152usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 21u32) & (2097152usize as u64);
    }
    #[inline]
    pub fn RestartableIP(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4194304usize as u64))
                                        >> 22u32) as u64)
        }
    }
    #[inline]
    pub fn set_RestartableIP(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(4194304usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 22u32) & (4194304usize as u64);
    }
    #[inline]
    pub fn Overflow(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8388608usize as u64))
                                        >> 23u32) as u64)
        }
    }
    #[inline]
    pub fn set_Overflow(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(8388608usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 23u32) & (8388608usize as u64);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (18446744073692774400usize as u64))
                                        >> 24u32) as u64)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(18446744073692774400usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 24u32) &
                (18446744073692774400usize as u64);
    }
}
impl Clone for _WHEA_XPF_MS_CHECK {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_XPF_MS_CHECK as WHEA_XPF_MS_CHECK;
pub type PWHEA_XPF_MS_CHECK = *mut _WHEA_XPF_MS_CHECK;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_XPF_PROCINFO_VALIDBITS {
    pub __bindgen_anon_1: __BindgenUnionField<_WHEA_XPF_PROCINFO_VALIDBITS__bindgen_ty_1>,
    pub ValidBits: __BindgenUnionField<ULONGLONG>,
    pub bindgen_union_field: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_XPF_PROCINFO_VALIDBITS__bindgen_ty_1 {
    pub _bitfield_1: u64,
}
impl Clone for _WHEA_XPF_PROCINFO_VALIDBITS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_XPF_PROCINFO_VALIDBITS__bindgen_ty_1 {
    #[inline]
    pub fn CheckInfo(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u64)) >>
                                        0u32) as u64)
        }
    }
    #[inline]
    pub fn set_CheckInfo(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(1usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 0u32) & (1usize as u64);
    }
    #[inline]
    pub fn TargetId(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u64)) >>
                                        1u32) as u64)
        }
    }
    #[inline]
    pub fn set_TargetId(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(2usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 1u32) & (2usize as u64);
    }
    #[inline]
    pub fn RequesterId(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u64)) >>
                                        2u32) as u64)
        }
    }
    #[inline]
    pub fn set_RequesterId(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(4usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 2u32) & (4usize as u64);
    }
    #[inline]
    pub fn ResponderId(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u64)) >>
                                        3u32) as u64)
        }
    }
    #[inline]
    pub fn set_ResponderId(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(8usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 3u32) & (8usize as u64);
    }
    #[inline]
    pub fn InstructionPointer(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u64)) >>
                                        4u32) as u64)
        }
    }
    #[inline]
    pub fn set_InstructionPointer(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(16usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 4u32) & (16usize as u64);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (18446744073709551584usize as u64))
                                        >> 5u32) as u64)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(18446744073709551584usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 5u32) &
                (18446744073709551584usize as u64);
    }
}
impl Clone for _WHEA_XPF_PROCINFO_VALIDBITS {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_XPF_PROCINFO_VALIDBITS as WHEA_XPF_PROCINFO_VALIDBITS;
pub type PWHEA_XPF_PROCINFO_VALIDBITS = *mut _WHEA_XPF_PROCINFO_VALIDBITS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_XPF_PROCINFO {
    pub CheckInfoId: GUID,
    pub ValidBits: WHEA_XPF_PROCINFO_VALIDBITS,
    pub CheckInfo: _WHEA_XPF_PROCINFO__bindgen_ty_1,
    pub TargetId: ULONGLONG,
    pub RequesterId: ULONGLONG,
    pub ResponderId: ULONGLONG,
    pub InstructionPointer: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_XPF_PROCINFO__bindgen_ty_1 {
    pub CacheCheck: __BindgenUnionField<WHEA_XPF_CACHE_CHECK>,
    pub TlbCheck: __BindgenUnionField<WHEA_XPF_TLB_CHECK>,
    pub BusCheck: __BindgenUnionField<WHEA_XPF_BUS_CHECK>,
    pub MsCheck: __BindgenUnionField<WHEA_XPF_MS_CHECK>,
    pub AsULONGLONG: __BindgenUnionField<ULONGLONG>,
    pub bindgen_union_field: [u8; 8usize],
}
impl Clone for _WHEA_XPF_PROCINFO__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Clone for _WHEA_XPF_PROCINFO {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_XPF_PROCINFO as WHEA_XPF_PROCINFO;
pub type PWHEA_XPF_PROCINFO = *mut _WHEA_XPF_PROCINFO;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_X86_REGISTER_STATE {
    pub Eax: ULONG,
    pub Ebx: ULONG,
    pub Ecx: ULONG,
    pub Edx: ULONG,
    pub Esi: ULONG,
    pub Edi: ULONG,
    pub Ebp: ULONG,
    pub Esp: ULONG,
    pub Cs: USHORT,
    pub Ds: USHORT,
    pub Ss: USHORT,
    pub Es: USHORT,
    pub Fs: USHORT,
    pub Gs: USHORT,
    pub Eflags: ULONG,
    pub Eip: ULONG,
    pub Cr0: ULONG,
    pub Cr1: ULONG,
    pub Cr2: ULONG,
    pub Cr3: ULONG,
    pub Cr4: ULONG,
    pub Gdtr: ULONGLONG,
    pub Idtr: ULONGLONG,
    pub Ldtr: USHORT,
    pub Tr: USHORT,
}
impl Clone for _WHEA_X86_REGISTER_STATE {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_X86_REGISTER_STATE as WHEA_X86_REGISTER_STATE;
pub type PWHEA_X86_REGISTER_STATE = *mut _WHEA_X86_REGISTER_STATE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA128A {
    pub Low: ULONGLONG,
    pub High: LONGLONG,
}
impl Clone for _WHEA128A {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA128A as WHEA128A;
pub type PWHEA128A = *mut _WHEA128A;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_X64_REGISTER_STATE {
    pub Rax: ULONGLONG,
    pub Rbx: ULONGLONG,
    pub Rcx: ULONGLONG,
    pub Rdx: ULONGLONG,
    pub Rsi: ULONGLONG,
    pub Rdi: ULONGLONG,
    pub Rbp: ULONGLONG,
    pub Rsp: ULONGLONG,
    pub R8: ULONGLONG,
    pub R9: ULONGLONG,
    pub R10: ULONGLONG,
    pub R11: ULONGLONG,
    pub R12: ULONGLONG,
    pub R13: ULONGLONG,
    pub R14: ULONGLONG,
    pub R15: ULONGLONG,
    pub Cs: USHORT,
    pub Ds: USHORT,
    pub Ss: USHORT,
    pub Es: USHORT,
    pub Fs: USHORT,
    pub Gs: USHORT,
    pub Reserved: ULONG,
    pub Rflags: ULONGLONG,
    pub Eip: ULONGLONG,
    pub Cr0: ULONGLONG,
    pub Cr1: ULONGLONG,
    pub Cr2: ULONGLONG,
    pub Cr3: ULONGLONG,
    pub Cr4: ULONGLONG,
    pub Cr8: ULONGLONG,
    pub Gdtr: WHEA128A,
    pub Idtr: WHEA128A,
    pub Ldtr: USHORT,
    pub Tr: USHORT,
}
impl Clone for _WHEA_X64_REGISTER_STATE {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_X64_REGISTER_STATE as WHEA_X64_REGISTER_STATE;
pub type PWHEA_X64_REGISTER_STATE = *mut _WHEA_X64_REGISTER_STATE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_XPF_CONTEXT_INFO {
    pub RegisterContextType: USHORT,
    pub RegisterDataSize: USHORT,
    pub MSRAddress: ULONG,
    pub MmRegisterAddress: ULONGLONG,
}
impl Clone for _WHEA_XPF_CONTEXT_INFO {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_XPF_CONTEXT_INFO as WHEA_XPF_CONTEXT_INFO;
pub type PWHEA_XPF_CONTEXT_INFO = *mut _WHEA_XPF_CONTEXT_INFO;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS {
    pub __bindgen_anon_1: __BindgenUnionField<_WHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS__bindgen_ty_1>,
    pub ValidBits: __BindgenUnionField<ULONGLONG>,
    pub bindgen_union_field: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS__bindgen_ty_1 {
    pub _bitfield_1: u64,
}
impl Clone for _WHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS__bindgen_ty_1 {
    #[inline]
    pub fn LocalAPICId(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u64)) >>
                                        0u32) as u64)
        }
    }
    #[inline]
    pub fn set_LocalAPICId(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(1usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 0u32) & (1usize as u64);
    }
    #[inline]
    pub fn CpuId(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u64)) >>
                                        1u32) as u64)
        }
    }
    #[inline]
    pub fn set_CpuId(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(2usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 1u32) & (2usize as u64);
    }
    #[inline]
    pub fn ProcInfoCount(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (252usize as u64)) >>
                                        2u32) as u64)
        }
    }
    #[inline]
    pub fn set_ProcInfoCount(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(252usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 2u32) & (252usize as u64);
    }
    #[inline]
    pub fn ContextInfoCount(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16128usize as u64))
                                        >> 8u32) as u64)
        }
    }
    #[inline]
    pub fn set_ContextInfoCount(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(16128usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 8u32) & (16128usize as u64);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (18446744073709535232usize as u64))
                                        >> 14u32) as u64)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(18446744073709535232usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 14u32) &
                (18446744073709535232usize as u64);
    }
}
impl Clone for _WHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS as
        WHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS;
pub type PWHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS =
    *mut _WHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS;
#[repr(C)]
pub struct _WHEA_XPF_PROCESSOR_ERROR_SECTION {
    pub ValidBits: WHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS,
    pub LocalAPICId: ULONGLONG,
    pub CpuId: [UCHAR; 48usize],
    pub VariableInfo: [UCHAR; 1usize],
}
pub use self::_WHEA_XPF_PROCESSOR_ERROR_SECTION as
        WHEA_XPF_PROCESSOR_ERROR_SECTION;
pub type PWHEA_XPF_PROCESSOR_ERROR_SECTION =
    *mut _WHEA_XPF_PROCESSOR_ERROR_SECTION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_MEMORY_ERROR_SECTION_VALIDBITS {
    pub __bindgen_anon_1: __BindgenUnionField<_WHEA_MEMORY_ERROR_SECTION_VALIDBITS__bindgen_ty_1>,
    pub ValidBits: __BindgenUnionField<ULONGLONG>,
    pub bindgen_union_field: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_MEMORY_ERROR_SECTION_VALIDBITS__bindgen_ty_1 {
    pub _bitfield_1: u64,
}
impl Clone for _WHEA_MEMORY_ERROR_SECTION_VALIDBITS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_MEMORY_ERROR_SECTION_VALIDBITS__bindgen_ty_1 {
    #[inline]
    pub fn ErrorStatus(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u64)) >>
                                        0u32) as u64)
        }
    }
    #[inline]
    pub fn set_ErrorStatus(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(1usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 0u32) & (1usize as u64);
    }
    #[inline]
    pub fn PhysicalAddress(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u64)) >>
                                        1u32) as u64)
        }
    }
    #[inline]
    pub fn set_PhysicalAddress(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(2usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 1u32) & (2usize as u64);
    }
    #[inline]
    pub fn PhysicalAddressMask(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u64)) >>
                                        2u32) as u64)
        }
    }
    #[inline]
    pub fn set_PhysicalAddressMask(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(4usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 2u32) & (4usize as u64);
    }
    #[inline]
    pub fn Node(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u64)) >>
                                        3u32) as u64)
        }
    }
    #[inline]
    pub fn set_Node(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(8usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 3u32) & (8usize as u64);
    }
    #[inline]
    pub fn Card(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u64)) >>
                                        4u32) as u64)
        }
    }
    #[inline]
    pub fn set_Card(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(16usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 4u32) & (16usize as u64);
    }
    #[inline]
    pub fn Module(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u64)) >>
                                        5u32) as u64)
        }
    }
    #[inline]
    pub fn set_Module(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(32usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 5u32) & (32usize as u64);
    }
    #[inline]
    pub fn Bank(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u64)) >>
                                        6u32) as u64)
        }
    }
    #[inline]
    pub fn set_Bank(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(64usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 6u32) & (64usize as u64);
    }
    #[inline]
    pub fn Device(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (128usize as u64)) >>
                                        7u32) as u64)
        }
    }
    #[inline]
    pub fn set_Device(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(128usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 7u32) & (128usize as u64);
    }
    #[inline]
    pub fn Row(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (256usize as u64)) >>
                                        8u32) as u64)
        }
    }
    #[inline]
    pub fn set_Row(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(256usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 8u32) & (256usize as u64);
    }
    #[inline]
    pub fn Column(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (512usize as u64)) >>
                                        9u32) as u64)
        }
    }
    #[inline]
    pub fn set_Column(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(512usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 9u32) & (512usize as u64);
    }
    #[inline]
    pub fn BitPosition(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1024usize as u64)) >>
                                        10u32) as u64)
        }
    }
    #[inline]
    pub fn set_BitPosition(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(1024usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 10u32) & (1024usize as u64);
    }
    #[inline]
    pub fn RequesterId(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2048usize as u64)) >>
                                        11u32) as u64)
        }
    }
    #[inline]
    pub fn set_RequesterId(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(2048usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 11u32) & (2048usize as u64);
    }
    #[inline]
    pub fn ResponderId(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4096usize as u64)) >>
                                        12u32) as u64)
        }
    }
    #[inline]
    pub fn set_ResponderId(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(4096usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 12u32) & (4096usize as u64);
    }
    #[inline]
    pub fn TargetId(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8192usize as u64)) >>
                                        13u32) as u64)
        }
    }
    #[inline]
    pub fn set_TargetId(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(8192usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 13u32) & (8192usize as u64);
    }
    #[inline]
    pub fn ErrorType(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16384usize as u64))
                                        >> 14u32) as u64)
        }
    }
    #[inline]
    pub fn set_ErrorType(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(16384usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 14u32) & (16384usize as u64);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (18446744073709518848usize as u64))
                                        >> 15u32) as u64)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(18446744073709518848usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 15u32) &
                (18446744073709518848usize as u64);
    }
}
impl Clone for _WHEA_MEMORY_ERROR_SECTION_VALIDBITS {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_MEMORY_ERROR_SECTION_VALIDBITS as
        WHEA_MEMORY_ERROR_SECTION_VALIDBITS;
pub type PWHEA_MEMORY_ERROR_SECTION_VALIDBITS =
    *mut _WHEA_MEMORY_ERROR_SECTION_VALIDBITS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_MEMORY_ERROR_SECTION {
    pub ValidBits: WHEA_MEMORY_ERROR_SECTION_VALIDBITS,
    pub ErrorStatus: WHEA_ERROR_STATUS,
    pub PhysicalAddress: ULONGLONG,
    pub PhysicalAddressMask: ULONGLONG,
    pub Node: USHORT,
    pub Card: USHORT,
    pub Module: USHORT,
    pub Bank: USHORT,
    pub Device: USHORT,
    pub Row: USHORT,
    pub Column: USHORT,
    pub BitPosition: USHORT,
    pub RequesterId: ULONGLONG,
    pub ResponderId: ULONGLONG,
    pub TargetId: ULONGLONG,
    pub ErrorType: UCHAR,
}
impl Clone for _WHEA_MEMORY_ERROR_SECTION {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_MEMORY_ERROR_SECTION as WHEA_MEMORY_ERROR_SECTION;
pub type PWHEA_MEMORY_ERROR_SECTION = *mut _WHEA_MEMORY_ERROR_SECTION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_PCIEXPRESS_ERROR_SECTION_VALIDBITS {
    pub __bindgen_anon_1: __BindgenUnionField<_WHEA_PCIEXPRESS_ERROR_SECTION_VALIDBITS__bindgen_ty_1>,
    pub ValidBits: __BindgenUnionField<ULONGLONG>,
    pub bindgen_union_field: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_PCIEXPRESS_ERROR_SECTION_VALIDBITS__bindgen_ty_1 {
    pub _bitfield_1: u64,
}
impl Clone for _WHEA_PCIEXPRESS_ERROR_SECTION_VALIDBITS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_PCIEXPRESS_ERROR_SECTION_VALIDBITS__bindgen_ty_1 {
    #[inline]
    pub fn PortType(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u64)) >>
                                        0u32) as u64)
        }
    }
    #[inline]
    pub fn set_PortType(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(1usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 0u32) & (1usize as u64);
    }
    #[inline]
    pub fn Version(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u64)) >>
                                        1u32) as u64)
        }
    }
    #[inline]
    pub fn set_Version(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(2usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 1u32) & (2usize as u64);
    }
    #[inline]
    pub fn CommandStatus(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u64)) >>
                                        2u32) as u64)
        }
    }
    #[inline]
    pub fn set_CommandStatus(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(4usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 2u32) & (4usize as u64);
    }
    #[inline]
    pub fn DeviceId(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u64)) >>
                                        3u32) as u64)
        }
    }
    #[inline]
    pub fn set_DeviceId(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(8usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 3u32) & (8usize as u64);
    }
    #[inline]
    pub fn DeviceSerialNumber(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u64)) >>
                                        4u32) as u64)
        }
    }
    #[inline]
    pub fn set_DeviceSerialNumber(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(16usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 4u32) & (16usize as u64);
    }
    #[inline]
    pub fn BridgeControlStatus(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u64)) >>
                                        5u32) as u64)
        }
    }
    #[inline]
    pub fn set_BridgeControlStatus(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(32usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 5u32) & (32usize as u64);
    }
    #[inline]
    pub fn ExpressCapability(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u64)) >>
                                        6u32) as u64)
        }
    }
    #[inline]
    pub fn set_ExpressCapability(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(64usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 6u32) & (64usize as u64);
    }
    #[inline]
    pub fn AerInfo(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (128usize as u64)) >>
                                        7u32) as u64)
        }
    }
    #[inline]
    pub fn set_AerInfo(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(128usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 7u32) & (128usize as u64);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (18446744073709551360usize as u64))
                                        >> 8u32) as u64)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(18446744073709551360usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 8u32) &
                (18446744073709551360usize as u64);
    }
}
impl Clone for _WHEA_PCIEXPRESS_ERROR_SECTION_VALIDBITS {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_PCIEXPRESS_ERROR_SECTION_VALIDBITS as
        WHEA_PCIEXPRESS_ERROR_SECTION_VALIDBITS;
pub type PWHEA_PCIEXPRESS_ERROR_SECTION_VALIDBITS =
    *mut _WHEA_PCIEXPRESS_ERROR_SECTION_VALIDBITS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_PCIEXPRESS_DEVICE_ID {
    pub VendorID: USHORT,
    pub DeviceID: USHORT,
    pub _bitfield_1: u64,
    pub _bitfield_2: u64,
}
impl Clone for _WHEA_PCIEXPRESS_DEVICE_ID {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_PCIEXPRESS_DEVICE_ID {
    #[inline]
    pub fn ClassCode(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (16777215usize as u64)) >> 0u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_ClassCode(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16777215usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 0u32) & (16777215usize as u64);
    }
    #[inline]
    pub fn FunctionNumber(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4278190080usize as u64)) >> 24u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_FunctionNumber(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4278190080usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 24u32) & (4278190080usize as u64);
    }
    #[inline]
    pub fn DeviceNumber(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (1095216660480usize as u64)) >>
                                        32u32) as u32)
        }
    }
    #[inline]
    pub fn set_DeviceNumber(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1095216660480usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 32u32) & (1095216660480usize as u64);
    }
    #[inline]
    pub fn Segment(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_2 & (65535usize as u64))
                                        >> 0u32) as u32)
        }
    }
    #[inline]
    pub fn set_Segment(&mut self, val: ULONG) {
        self._bitfield_2 &= !(65535usize as u64);
        self._bitfield_2 |=
            ((val as u32 as u64) << 0u32) & (65535usize as u64);
    }
    #[inline]
    pub fn PrimaryBusNumber(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_2 &
                                         (16711680usize as u64)) >> 16u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_PrimaryBusNumber(&mut self, val: ULONG) {
        self._bitfield_2 &= !(16711680usize as u64);
        self._bitfield_2 |=
            ((val as u32 as u64) << 16u32) & (16711680usize as u64);
    }
    #[inline]
    pub fn SecondaryBusNumber(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_2 &
                                         (4278190080usize as u64)) >> 24u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_SecondaryBusNumber(&mut self, val: ULONG) {
        self._bitfield_2 &= !(4278190080usize as u64);
        self._bitfield_2 |=
            ((val as u32 as u64) << 24u32) & (4278190080usize as u64);
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_2 &
                                         (30064771072usize as u64)) >> 32u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        self._bitfield_2 &= !(30064771072usize as u64);
        self._bitfield_2 |=
            ((val as u32 as u64) << 32u32) & (30064771072usize as u64);
    }
    #[inline]
    pub fn SlotNumber(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_2 &
                                         (281440616972288usize as u64)) >>
                                        35u32) as u32)
        }
    }
    #[inline]
    pub fn set_SlotNumber(&mut self, val: ULONG) {
        self._bitfield_2 &= !(281440616972288usize as u64);
        self._bitfield_2 |=
            ((val as u32 as u64) << 35u32) & (281440616972288usize as u64);
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_2 &
                                         (71776119061217280usize as u64)) >>
                                        48u32) as u32)
        }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        self._bitfield_2 &= !(71776119061217280usize as u64);
        self._bitfield_2 |=
            ((val as u32 as u64) << 48u32) & (71776119061217280usize as u64);
    }
}
pub use self::_WHEA_PCIEXPRESS_DEVICE_ID as WHEA_PCIEXPRESS_DEVICE_ID;
pub type PWHEA_PCIEXPRESS_DEVICE_ID = *mut _WHEA_PCIEXPRESS_DEVICE_ID;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_PCIEXPRESS_VERSION {
    pub __bindgen_anon_1: __BindgenUnionField<_WHEA_PCIEXPRESS_VERSION__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: [u8; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_PCIEXPRESS_VERSION__bindgen_ty_1 {
    pub MinorVersion: UCHAR,
    pub MajorVersion: UCHAR,
    pub Reserved: USHORT,
}
impl Clone for _WHEA_PCIEXPRESS_VERSION__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Clone for _WHEA_PCIEXPRESS_VERSION {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_PCIEXPRESS_VERSION as WHEA_PCIEXPRESS_VERSION;
pub type PWHEA_PCIEXPRESS_VERSION = *mut _WHEA_PCIEXPRESS_VERSION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_PCIEXPRESS_COMMAND_STATUS {
    pub __bindgen_anon_1: __BindgenUnionField<_WHEA_PCIEXPRESS_COMMAND_STATUS__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: [u8; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_PCIEXPRESS_COMMAND_STATUS__bindgen_ty_1 {
    pub Command: USHORT,
    pub Status: USHORT,
}
impl Clone for _WHEA_PCIEXPRESS_COMMAND_STATUS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Clone for _WHEA_PCIEXPRESS_COMMAND_STATUS {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_PCIEXPRESS_COMMAND_STATUS as
        WHEA_PCIEXPRESS_COMMAND_STATUS;
pub type PWHEA_PCIEXPRESS_COMMAND_STATUS =
    *mut _WHEA_PCIEXPRESS_COMMAND_STATUS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS {
    pub __bindgen_anon_1: __BindgenUnionField<_WHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: [u8; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS__bindgen_ty_1 {
    pub BridgeSecondaryStatus: USHORT,
    pub BridgeControl: USHORT,
}
impl Clone for _WHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Clone for _WHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS as
        WHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS;
pub type PWHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS =
    *mut _WHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _WHEA_PCIEXPRESS_DEVICE_TYPE {
    WheaPciExpressEndpoint = 0,
    WheaPciExpressLegacyEndpoint = 1,
    WheaPciExpressRootPort = 4,
    WheaPciExpressUpstreamSwitchPort = 5,
    WheaPciExpressDownstreamSwitchPort = 6,
    WheaPciExpressToPciXBridge = 7,
    WheaPciXToExpressBridge = 8,
    WheaPciExpressRootComplexIntegratedEndpoint = 9,
    WheaPciExpressRootComplexEventCollector = 10,
}
pub use self::_WHEA_PCIEXPRESS_DEVICE_TYPE as WHEA_PCIEXPRESS_DEVICE_TYPE;
#[repr(C)]
pub struct _WHEA_PCIEXPRESS_ERROR_SECTION {
    pub ValidBits: WHEA_PCIEXPRESS_ERROR_SECTION_VALIDBITS,
    pub PortType: WHEA_PCIEXPRESS_DEVICE_TYPE,
    pub Version: WHEA_PCIEXPRESS_VERSION,
    pub CommandStatus: WHEA_PCIEXPRESS_COMMAND_STATUS,
    pub Reserved: ULONG,
    pub DeviceId: WHEA_PCIEXPRESS_DEVICE_ID,
    pub DeviceSerialNumber: ULONGLONG,
    pub BridgeControlStatus: WHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS,
    pub ExpressCapability: [UCHAR; 60usize],
    pub AerInfo: [UCHAR; 96usize],
}
pub use self::_WHEA_PCIEXPRESS_ERROR_SECTION as WHEA_PCIEXPRESS_ERROR_SECTION;
pub type PWHEA_PCIEXPRESS_ERROR_SECTION = *mut _WHEA_PCIEXPRESS_ERROR_SECTION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_PCIXBUS_ERROR_SECTION_VALIDBITS {
    pub __bindgen_anon_1: __BindgenUnionField<_WHEA_PCIXBUS_ERROR_SECTION_VALIDBITS__bindgen_ty_1>,
    pub ValidBits: __BindgenUnionField<ULONGLONG>,
    pub bindgen_union_field: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_PCIXBUS_ERROR_SECTION_VALIDBITS__bindgen_ty_1 {
    pub _bitfield_1: u64,
}
impl Clone for _WHEA_PCIXBUS_ERROR_SECTION_VALIDBITS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_PCIXBUS_ERROR_SECTION_VALIDBITS__bindgen_ty_1 {
    #[inline]
    pub fn ErrorStatus(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u64)) >>
                                        0u32) as u64)
        }
    }
    #[inline]
    pub fn set_ErrorStatus(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(1usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 0u32) & (1usize as u64);
    }
    #[inline]
    pub fn ErrorType(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u64)) >>
                                        1u32) as u64)
        }
    }
    #[inline]
    pub fn set_ErrorType(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(2usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 1u32) & (2usize as u64);
    }
    #[inline]
    pub fn BusId(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u64)) >>
                                        2u32) as u64)
        }
    }
    #[inline]
    pub fn set_BusId(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(4usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 2u32) & (4usize as u64);
    }
    #[inline]
    pub fn BusAddress(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u64)) >>
                                        3u32) as u64)
        }
    }
    #[inline]
    pub fn set_BusAddress(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(8usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 3u32) & (8usize as u64);
    }
    #[inline]
    pub fn BusData(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u64)) >>
                                        4u32) as u64)
        }
    }
    #[inline]
    pub fn set_BusData(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(16usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 4u32) & (16usize as u64);
    }
    #[inline]
    pub fn BusCommand(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u64)) >>
                                        5u32) as u64)
        }
    }
    #[inline]
    pub fn set_BusCommand(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(32usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 5u32) & (32usize as u64);
    }
    #[inline]
    pub fn RequesterId(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u64)) >>
                                        6u32) as u64)
        }
    }
    #[inline]
    pub fn set_RequesterId(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(64usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 6u32) & (64usize as u64);
    }
    #[inline]
    pub fn CompleterId(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (128usize as u64)) >>
                                        7u32) as u64)
        }
    }
    #[inline]
    pub fn set_CompleterId(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(128usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 7u32) & (128usize as u64);
    }
    #[inline]
    pub fn TargetId(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (256usize as u64)) >>
                                        8u32) as u64)
        }
    }
    #[inline]
    pub fn set_TargetId(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(256usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 8u32) & (256usize as u64);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (18446744073709551104usize as u64))
                                        >> 9u32) as u64)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(18446744073709551104usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 9u32) &
                (18446744073709551104usize as u64);
    }
}
impl Clone for _WHEA_PCIXBUS_ERROR_SECTION_VALIDBITS {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_PCIXBUS_ERROR_SECTION_VALIDBITS as
        WHEA_PCIXBUS_ERROR_SECTION_VALIDBITS;
pub type PWHEA_PCIXBUS_ERROR_SECTION_VALIDBITS =
    *mut _WHEA_PCIXBUS_ERROR_SECTION_VALIDBITS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_PCIXBUS_ID {
    pub __bindgen_anon_1: __BindgenUnionField<_WHEA_PCIXBUS_ID__bindgen_ty_1>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: [u8; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_PCIXBUS_ID__bindgen_ty_1 {
    pub BusNumber: UCHAR,
    pub BusSegment: UCHAR,
}
impl Clone for _WHEA_PCIXBUS_ID__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Clone for _WHEA_PCIXBUS_ID {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_PCIXBUS_ID as WHEA_PCIXBUS_ID;
pub type PWHEA_PCIXBUS_ID = *mut _WHEA_PCIXBUS_ID;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_PCIXBUS_COMMAND {
    pub __bindgen_anon_1: __BindgenUnionField<_WHEA_PCIXBUS_COMMAND__bindgen_ty_1>,
    pub AsULONGLONG: __BindgenUnionField<ULONGLONG>,
    pub bindgen_union_field: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_PCIXBUS_COMMAND__bindgen_ty_1 {
    pub _bitfield_1: u64,
}
impl Clone for _WHEA_PCIXBUS_COMMAND__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_PCIXBUS_COMMAND__bindgen_ty_1 {
    #[inline]
    pub fn Command(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (72057594037927935usize as u64)) >>
                                        0u32) as u64)
        }
    }
    #[inline]
    pub fn set_Command(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(72057594037927935usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 0u32) & (72057594037927935usize as u64);
    }
    #[inline]
    pub fn PCIXCommand(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (72057594037927936usize as u64)) >>
                                        56u32) as u64)
        }
    }
    #[inline]
    pub fn set_PCIXCommand(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(72057594037927936usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 56u32) & (72057594037927936usize as u64);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (18302628885633695744usize as u64))
                                        >> 57u32) as u64)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(18302628885633695744usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 57u32) &
                (18302628885633695744usize as u64);
    }
}
impl Clone for _WHEA_PCIXBUS_COMMAND {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_PCIXBUS_COMMAND as WHEA_PCIXBUS_COMMAND;
pub type PWHEA_PCIXBUS_COMMAND = *mut _WHEA_PCIXBUS_COMMAND;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_PCIXBUS_ERROR_SECTION {
    pub ValidBits: WHEA_PCIXBUS_ERROR_SECTION_VALIDBITS,
    pub ErrorStatus: WHEA_ERROR_STATUS,
    pub ErrorType: USHORT,
    pub BusId: WHEA_PCIXBUS_ID,
    pub Reserved: ULONG,
    pub BusAddress: ULONGLONG,
    pub BusData: ULONGLONG,
    pub BusCommand: WHEA_PCIXBUS_COMMAND,
    pub RequesterId: ULONGLONG,
    pub CompleterId: ULONGLONG,
    pub TargetId: ULONGLONG,
}
impl Clone for _WHEA_PCIXBUS_ERROR_SECTION {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_PCIXBUS_ERROR_SECTION as WHEA_PCIXBUS_ERROR_SECTION;
pub type PWHEA_PCIXBUS_ERROR_SECTION = *mut _WHEA_PCIXBUS_ERROR_SECTION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_PCIXDEVICE_ERROR_SECTION_VALIDBITS {
    pub __bindgen_anon_1: __BindgenUnionField<_WHEA_PCIXDEVICE_ERROR_SECTION_VALIDBITS__bindgen_ty_1>,
    pub ValidBits: __BindgenUnionField<ULONGLONG>,
    pub bindgen_union_field: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_PCIXDEVICE_ERROR_SECTION_VALIDBITS__bindgen_ty_1 {
    pub _bitfield_1: u64,
}
impl Clone for _WHEA_PCIXDEVICE_ERROR_SECTION_VALIDBITS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_PCIXDEVICE_ERROR_SECTION_VALIDBITS__bindgen_ty_1 {
    #[inline]
    pub fn ErrorStatus(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u64)) >>
                                        0u32) as u64)
        }
    }
    #[inline]
    pub fn set_ErrorStatus(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(1usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 0u32) & (1usize as u64);
    }
    #[inline]
    pub fn IdInfo(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u64)) >>
                                        1u32) as u64)
        }
    }
    #[inline]
    pub fn set_IdInfo(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(2usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 1u32) & (2usize as u64);
    }
    #[inline]
    pub fn MemoryNumber(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u64)) >>
                                        2u32) as u64)
        }
    }
    #[inline]
    pub fn set_MemoryNumber(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(4usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 2u32) & (4usize as u64);
    }
    #[inline]
    pub fn IoNumber(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u64)) >>
                                        3u32) as u64)
        }
    }
    #[inline]
    pub fn set_IoNumber(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(8usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 3u32) & (8usize as u64);
    }
    #[inline]
    pub fn RegisterDataPairs(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u64)) >>
                                        4u32) as u64)
        }
    }
    #[inline]
    pub fn set_RegisterDataPairs(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(16usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 4u32) & (16usize as u64);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (18446744073709551584usize as u64))
                                        >> 5u32) as u64)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        self._bitfield_1 &= !(18446744073709551584usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 5u32) &
                (18446744073709551584usize as u64);
    }
}
impl Clone for _WHEA_PCIXDEVICE_ERROR_SECTION_VALIDBITS {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_PCIXDEVICE_ERROR_SECTION_VALIDBITS as
        WHEA_PCIXDEVICE_ERROR_SECTION_VALIDBITS;
pub type PWHEA_PCIXDEVICE_ERROR_SECTION_VALIDBITS =
    *mut _WHEA_PCIXDEVICE_ERROR_SECTION_VALIDBITS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_PCIXDEVICE_ID {
    pub VendorId: USHORT,
    pub DeviceId: USHORT,
    pub _bitfield_1: u64,
    pub Reserved2: ULONG,
}
impl Clone for _WHEA_PCIXDEVICE_ID {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_PCIXDEVICE_ID {
    #[inline]
    pub fn ClassCode(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (16777215usize as u64)) >> 0u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_ClassCode(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16777215usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 0u32) & (16777215usize as u64);
    }
    #[inline]
    pub fn FunctionNumber(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4278190080usize as u64)) >> 24u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_FunctionNumber(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4278190080usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 24u32) & (4278190080usize as u64);
    }
    #[inline]
    pub fn DeviceNumber(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (1095216660480usize as u64)) >>
                                        32u32) as u32)
        }
    }
    #[inline]
    pub fn set_DeviceNumber(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1095216660480usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 32u32) & (1095216660480usize as u64);
    }
    #[inline]
    pub fn BusNumber(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (280375465082880usize as u64)) >>
                                        40u32) as u32)
        }
    }
    #[inline]
    pub fn set_BusNumber(&mut self, val: ULONG) {
        self._bitfield_1 &= !(280375465082880usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 40u32) & (280375465082880usize as u64);
    }
    #[inline]
    pub fn SegmentNumber(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (71776119061217280usize as u64)) >>
                                        48u32) as u32)
        }
    }
    #[inline]
    pub fn set_SegmentNumber(&mut self, val: ULONG) {
        self._bitfield_1 &= !(71776119061217280usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 48u32) & (71776119061217280usize as u64);
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (18374686479671623680usize as u64))
                                        >> 56u32) as u32)
        }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        self._bitfield_1 &= !(18374686479671623680usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 56u32) &
                (18374686479671623680usize as u64);
    }
}
pub use self::_WHEA_PCIXDEVICE_ID as WHEA_PCIXDEVICE_ID;
pub type PWHEA_PCIXDEVICE_ID = *mut _WHEA_PCIXDEVICE_ID;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct WHEA_PCIXDEVICE_REGISTER_PAIR {
    pub Register: ULONGLONG,
    pub Data: ULONGLONG,
}
impl Clone for WHEA_PCIXDEVICE_REGISTER_PAIR {
    fn clone(&self) -> Self { *self }
}
pub type PWHEA_PCIXDEVICE_REGISTER_PAIR = *mut WHEA_PCIXDEVICE_REGISTER_PAIR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_PCIXDEVICE_ERROR_SECTION {
    pub ValidBits: WHEA_PCIXDEVICE_ERROR_SECTION_VALIDBITS,
    pub ErrorStatus: WHEA_ERROR_STATUS,
    pub IdInfo: WHEA_PCIXDEVICE_ID,
    pub MemoryNumber: ULONG,
    pub IoNumber: ULONG,
    pub RegisterDataPairs: [WHEA_PCIXDEVICE_REGISTER_PAIR; 1usize],
}
impl Clone for _WHEA_PCIXDEVICE_ERROR_SECTION {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_PCIXDEVICE_ERROR_SECTION as WHEA_PCIXDEVICE_ERROR_SECTION;
pub type PWHEA_PCIXDEVICE_ERROR_SECTION = *mut _WHEA_PCIXDEVICE_ERROR_SECTION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_FIRMWARE_ERROR_RECORD_REFERENCE {
    pub Type: UCHAR,
    pub Reserved: [UCHAR; 7usize],
    pub FirmwareRecordId: ULONGLONG,
}
impl Clone for _WHEA_FIRMWARE_ERROR_RECORD_REFERENCE {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_FIRMWARE_ERROR_RECORD_REFERENCE as
        WHEA_FIRMWARE_ERROR_RECORD_REFERENCE;
pub type PWHEA_FIRMWARE_ERROR_RECORD_REFERENCE =
    *mut _WHEA_FIRMWARE_ERROR_RECORD_REFERENCE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _MCG_STATUS {
    pub __bindgen_anon_1: __BindgenUnionField<_MCG_STATUS__bindgen_ty_1>,
    pub QuadPart: __BindgenUnionField<ULONGLONG>,
    pub bindgen_union_field: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _MCG_STATUS__bindgen_ty_1 {
    pub _bitfield_1: u32,
    pub Reserved2: ULONG,
}
impl Clone for _MCG_STATUS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _MCG_STATUS__bindgen_ty_1 {
    #[inline]
    pub fn RestartIpValid(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_RestartIpValid(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn ErrorIpValid(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_ErrorIpValid(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn MachineCheckInProgress(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                        2u32) as u32)
        }
    }
    #[inline]
    pub fn set_MachineCheckInProgress(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967288usize as u32)) >> 3u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967288usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 3u32) & (4294967288usize as u32);
    }
}
impl Clone for _MCG_STATUS {
    fn clone(&self) -> Self { *self }
}
pub use self::_MCG_STATUS as MCG_STATUS;
pub type PMCG_STATUS = *mut _MCG_STATUS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _MCI_STATUS {
    pub __bindgen_anon_1: __BindgenUnionField<_MCI_STATUS__bindgen_ty_1>,
    pub QuadPart: __BindgenUnionField<ULONG64>,
    pub bindgen_union_field: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _MCI_STATUS__bindgen_ty_1 {
    pub McaErrorCode: USHORT,
    pub ModelErrorCode: USHORT,
    pub _bitfield_1: u32,
}
impl Clone for _MCI_STATUS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _MCI_STATUS__bindgen_ty_1 {
    #[inline]
    pub fn OtherInformation(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8388607usize as u32))
                                        >> 0u32) as u32)
        }
    }
    #[inline]
    pub fn set_OtherInformation(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8388607usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 0u32) & (8388607usize as u32);
    }
    #[inline]
    pub fn ActionRequired(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8388608usize as u32))
                                        >> 23u32) as u32)
        }
    }
    #[inline]
    pub fn set_ActionRequired(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8388608usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 23u32) & (8388608usize as u32);
    }
    #[inline]
    pub fn Signalling(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (16777216usize as u32)) >> 24u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_Signalling(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16777216usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 24u32) & (16777216usize as u32);
    }
    #[inline]
    pub fn ContextCorrupt(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (33554432usize as u32)) >> 25u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_ContextCorrupt(&mut self, val: ULONG) {
        self._bitfield_1 &= !(33554432usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 25u32) & (33554432usize as u32);
    }
    #[inline]
    pub fn AddressValid(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (67108864usize as u32)) >> 26u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_AddressValid(&mut self, val: ULONG) {
        self._bitfield_1 &= !(67108864usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 26u32) & (67108864usize as u32);
    }
    #[inline]
    pub fn MiscValid(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (134217728usize as u32)) >> 27u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_MiscValid(&mut self, val: ULONG) {
        self._bitfield_1 &= !(134217728usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 27u32) & (134217728usize as u32);
    }
    #[inline]
    pub fn ErrorEnabled(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (268435456usize as u32)) >> 28u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_ErrorEnabled(&mut self, val: ULONG) {
        self._bitfield_1 &= !(268435456usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 28u32) & (268435456usize as u32);
    }
    #[inline]
    pub fn UncorrectedError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (536870912usize as u32)) >> 29u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_UncorrectedError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(536870912usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 29u32) & (536870912usize as u32);
    }
    #[inline]
    pub fn StatusOverFlow(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (1073741824usize as u32)) >> 30u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_StatusOverFlow(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1073741824usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 30u32) & (1073741824usize as u32);
    }
    #[inline]
    pub fn Valid(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (2147483648usize as u32)) >> 31u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_Valid(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2147483648usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 31u32) & (2147483648usize as u32);
    }
}
impl Clone for _MCI_STATUS {
    fn clone(&self) -> Self { *self }
}
pub use self::_MCI_STATUS as MCI_STATUS;
pub type PMCI_STATUS = *mut _MCI_STATUS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _WHEA_CPU_VENDOR {
    WheaCpuVendorOther = 0,
    WheaCpuVendorIntel = 1,
    WheaCpuVendorAmd = 2,
}
pub use self::_WHEA_CPU_VENDOR as WHEA_CPU_VENDOR;
pub type PWHEA_CPU_VENDOR = *mut _WHEA_CPU_VENDOR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_XPF_MCA_SECTION {
    pub VersionNumber: ULONG,
    pub CpuVendor: WHEA_CPU_VENDOR,
    pub Timestamp: LARGE_INTEGER,
    pub ProcessorNumber: ULONG,
    pub GlobalStatus: MCG_STATUS,
    pub InstructionPointer: ULONGLONG,
    pub BankNumber: ULONG,
    pub Status: MCI_STATUS,
    pub Address: ULONGLONG,
    pub Misc: ULONGLONG,
    pub ExtendedRegisterCount: ULONG,
    pub Reserved2: ULONG,
    pub ExtendedRegisters: [ULONGLONG; 24usize],
}
impl Clone for _WHEA_XPF_MCA_SECTION {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_XPF_MCA_SECTION as WHEA_XPF_MCA_SECTION;
pub type PWHEA_XPF_MCA_SECTION = *mut _WHEA_XPF_MCA_SECTION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_NMI_ERROR_SECTION_FLAGS {
    pub __bindgen_anon_1: __BindgenUnionField<_WHEA_NMI_ERROR_SECTION_FLAGS__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: [u8; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_NMI_ERROR_SECTION_FLAGS__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
impl Clone for _WHEA_NMI_ERROR_SECTION_FLAGS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_NMI_ERROR_SECTION_FLAGS__bindgen_ty_1 {
    #[inline]
    pub fn HypervisorError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_HypervisorError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967294usize as u32)) >> 1u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967294usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 1u32) & (4294967294usize as u32);
    }
}
impl Clone for _WHEA_NMI_ERROR_SECTION_FLAGS {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_NMI_ERROR_SECTION_FLAGS as WHEA_NMI_ERROR_SECTION_FLAGS;
pub type PWHEA_NMI_ERROR_SECTION_FLAGS = *mut _WHEA_NMI_ERROR_SECTION_FLAGS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_NMI_ERROR_SECTION {
    pub Data: [UCHAR; 8usize],
    pub Flags: WHEA_NMI_ERROR_SECTION_FLAGS,
}
impl Clone for _WHEA_NMI_ERROR_SECTION {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_NMI_ERROR_SECTION as WHEA_NMI_ERROR_SECTION;
pub type PWHEA_NMI_ERROR_SECTION = *mut _WHEA_NMI_ERROR_SECTION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ARM_PROCESSOR_ERROR_SECTION_VALID_BITS {
    pub __bindgen_anon_1: __BindgenUnionField<_WHEA_ARM_PROCESSOR_ERROR_SECTION_VALID_BITS__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: [u8; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ARM_PROCESSOR_ERROR_SECTION_VALID_BITS__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
impl Clone for _WHEA_ARM_PROCESSOR_ERROR_SECTION_VALID_BITS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_ARM_PROCESSOR_ERROR_SECTION_VALID_BITS__bindgen_ty_1 {
    #[inline]
    pub fn MPIDR(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_MPIDR(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn AffinityLevel(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_AffinityLevel(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn RunningState(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                        2u32) as u32)
        }
    }
    #[inline]
    pub fn set_RunningState(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn VendorSpecificInfo(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u32)) >>
                                        3u32) as u32)
        }
    }
    #[inline]
    pub fn set_VendorSpecificInfo(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (8usize as u32);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967280usize as u32)) >> 4u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967280usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 4u32) & (4294967280usize as u32);
    }
}
impl Clone for _WHEA_ARM_PROCESSOR_ERROR_SECTION_VALID_BITS {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_ARM_PROCESSOR_ERROR_SECTION_VALID_BITS as
        WHEA_ARM_PROCESSOR_ERROR_SECTION_VALID_BITS;
pub type PWHEA_ARM_PROCESSOR_ERROR_SECTION_VALID_BITS =
    *mut _WHEA_ARM_PROCESSOR_ERROR_SECTION_VALID_BITS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ARM_PROCESSOR_ERROR_SECTION {
    pub ValidBits: WHEA_ARM_PROCESSOR_ERROR_SECTION_VALID_BITS,
    pub ErrorInformationStructures: USHORT,
    pub ContextInformationStructures: USHORT,
    pub SectionLength: ULONG,
    pub ErrorAffinityLevel: UCHAR,
    pub Reserved: [UCHAR; 3usize],
    pub MPIDR_EL1: ULONGLONG,
    pub MIDR_EL1: ULONGLONG,
    pub RunningState: ULONG,
    pub PSCIState: ULONG,
    pub Data: [UCHAR; 1usize],
}
impl Clone for _WHEA_ARM_PROCESSOR_ERROR_SECTION {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_ARM_PROCESSOR_ERROR_SECTION as
        WHEA_ARM_PROCESSOR_ERROR_SECTION;
pub type PWHEA_ARM_PROCESSOR_ERROR_SECTION =
    *mut _WHEA_ARM_PROCESSOR_ERROR_SECTION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ARM_PROCESSOR_ERROR_INFORMATION_VALID_BITS {
    pub __bindgen_anon_1: __BindgenUnionField<_WHEA_ARM_PROCESSOR_ERROR_INFORMATION_VALID_BITS__bindgen_ty_1>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: [u8; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ARM_PROCESSOR_ERROR_INFORMATION_VALID_BITS__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
impl Clone for _WHEA_ARM_PROCESSOR_ERROR_INFORMATION_VALID_BITS__bindgen_ty_1
 {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_ARM_PROCESSOR_ERROR_INFORMATION_VALID_BITS__bindgen_ty_1 {
    #[inline]
    pub fn MultipleError(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_MultipleError(&mut self, val: USHORT) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn Flags(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u16)) >>
                                        1u32) as u16)
        }
    }
    #[inline]
    pub fn set_Flags(&mut self, val: USHORT) {
        self._bitfield_1 &= !(2usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 1u32) & (2usize as u16);
    }
    #[inline]
    pub fn ErrorInformation(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u16)) >>
                                        2u32) as u16)
        }
    }
    #[inline]
    pub fn set_ErrorInformation(&mut self, val: USHORT) {
        self._bitfield_1 &= !(4usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 2u32) & (4usize as u16);
    }
    #[inline]
    pub fn VirtualFaultAddress(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u16)) >>
                                        3u32) as u16)
        }
    }
    #[inline]
    pub fn set_VirtualFaultAddress(&mut self, val: USHORT) {
        self._bitfield_1 &= !(8usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 3u32) & (8usize as u16);
    }
    #[inline]
    pub fn PhysicalFaultAddresss(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u16)) >>
                                        4u32) as u16)
        }
    }
    #[inline]
    pub fn set_PhysicalFaultAddresss(&mut self, val: USHORT) {
        self._bitfield_1 &= !(16usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 4u32) & (16usize as u16);
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65504usize as u16))
                                        >> 5u32) as u16)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        self._bitfield_1 &= !(65504usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 5u32) & (65504usize as u16);
    }
}
impl Clone for _WHEA_ARM_PROCESSOR_ERROR_INFORMATION_VALID_BITS {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_ARM_PROCESSOR_ERROR_INFORMATION_VALID_BITS as
        WHEA_ARM_PROCESSOR_ERROR_INFORMATION_VALID_BITS;
pub type PWHEA_ARM_PROCESSOR_ERROR_INFORMATION_VALID_BITS =
    *mut _WHEA_ARM_PROCESSOR_ERROR_INFORMATION_VALID_BITS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ARM_CACHE_ERROR_VALID_BITS {
    pub __bindgen_anon_1: __BindgenUnionField<_WHEA_ARM_CACHE_ERROR_VALID_BITS__bindgen_ty_1>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: [u8; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ARM_CACHE_ERROR_VALID_BITS__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
impl Clone for _WHEA_ARM_CACHE_ERROR_VALID_BITS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_ARM_CACHE_ERROR_VALID_BITS__bindgen_ty_1 {
    #[inline]
    pub fn TransactionType(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_TransactionType(&mut self, val: USHORT) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn Operation(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u16)) >>
                                        1u32) as u16)
        }
    }
    #[inline]
    pub fn set_Operation(&mut self, val: USHORT) {
        self._bitfield_1 &= !(2usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 1u32) & (2usize as u16);
    }
    #[inline]
    pub fn Level(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u16)) >>
                                        2u32) as u16)
        }
    }
    #[inline]
    pub fn set_Level(&mut self, val: USHORT) {
        self._bitfield_1 &= !(4usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 2u32) & (4usize as u16);
    }
    #[inline]
    pub fn ProcessorContextCorrupt(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u16)) >>
                                        3u32) as u16)
        }
    }
    #[inline]
    pub fn set_ProcessorContextCorrupt(&mut self, val: USHORT) {
        self._bitfield_1 &= !(8usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 3u32) & (8usize as u16);
    }
    #[inline]
    pub fn Corrected(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u16)) >>
                                        4u32) as u16)
        }
    }
    #[inline]
    pub fn set_Corrected(&mut self, val: USHORT) {
        self._bitfield_1 &= !(16usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 4u32) & (16usize as u16);
    }
    #[inline]
    pub fn PrecisePC(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u16)) >>
                                        5u32) as u16)
        }
    }
    #[inline]
    pub fn set_PrecisePC(&mut self, val: USHORT) {
        self._bitfield_1 &= !(32usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 5u32) & (32usize as u16);
    }
    #[inline]
    pub fn RestartablePC(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u16)) >>
                                        6u32) as u16)
        }
    }
    #[inline]
    pub fn set_RestartablePC(&mut self, val: USHORT) {
        self._bitfield_1 &= !(64usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 6u32) & (64usize as u16);
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65408usize as u16))
                                        >> 7u32) as u16)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        self._bitfield_1 &= !(65408usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 7u32) & (65408usize as u16);
    }
}
impl Clone for _WHEA_ARM_CACHE_ERROR_VALID_BITS {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_ARM_CACHE_ERROR_VALID_BITS as
        WHEA_ARM_CACHE_ERROR_VALID_BITS;
pub type PWHEA_ARM_CACHE_ERROR_VALID_BITS =
    *mut _WHEA_ARM_CACHE_ERROR_VALID_BITS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ARM_CACHE_ERROR {
    pub ValidationBit: WHEA_ARM_CACHE_ERROR_VALID_BITS,
    pub _bitfield_1: u16,
    pub _bitfield_2: u64,
}
impl Clone for _WHEA_ARM_CACHE_ERROR {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_ARM_CACHE_ERROR {
    #[inline]
    pub fn TransactionType(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (3usize as u16)) >>
                                        0u32) as u8)
        }
    }
    #[inline]
    pub fn set_TransactionType(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(3usize as u16);
        self._bitfield_1 |= ((val as u8 as u16) << 0u32) & (3usize as u16);
    }
    #[inline]
    pub fn Operation(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (60usize as u16)) >>
                                        2u32) as u8)
        }
    }
    #[inline]
    pub fn set_Operation(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(60usize as u16);
        self._bitfield_1 |= ((val as u8 as u16) << 2u32) & (60usize as u16);
    }
    #[inline]
    pub fn Level(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (448usize as u16)) >>
                                        6u32) as u8)
        }
    }
    #[inline]
    pub fn set_Level(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(448usize as u16);
        self._bitfield_1 |= ((val as u8 as u16) << 6u32) & (448usize as u16);
    }
    #[inline]
    pub fn ProcessorContextCorrupt(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (512usize as u16)) >>
                                        9u32) as u8)
        }
    }
    #[inline]
    pub fn set_ProcessorContextCorrupt(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(512usize as u16);
        self._bitfield_1 |= ((val as u8 as u16) << 9u32) & (512usize as u16);
    }
    #[inline]
    pub fn Corrected(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1024usize as u16)) >>
                                        10u32) as u8)
        }
    }
    #[inline]
    pub fn set_Corrected(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(1024usize as u16);
        self._bitfield_1 |=
            ((val as u8 as u16) << 10u32) & (1024usize as u16);
    }
    #[inline]
    pub fn PrecisePC(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2048usize as u16)) >>
                                        11u32) as u8)
        }
    }
    #[inline]
    pub fn set_PrecisePC(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(2048usize as u16);
        self._bitfield_1 |=
            ((val as u8 as u16) << 11u32) & (2048usize as u16);
    }
    #[inline]
    pub fn RestartablePC(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4096usize as u16)) >>
                                        12u32) as u8)
        }
    }
    #[inline]
    pub fn set_RestartablePC(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(4096usize as u16);
        self._bitfield_1 |=
            ((val as u8 as u16) << 12u32) & (4096usize as u16);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_2 &
                                         (34359738367usize as u64)) >> 0u32)
                                       as u64)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        self._bitfield_2 &= !(34359738367usize as u64);
        self._bitfield_2 |=
            ((val as u64 as u64) << 0u32) & (34359738367usize as u64);
    }
}
pub use self::_WHEA_ARM_CACHE_ERROR as WHEA_ARM_CACHE_ERROR;
pub type PWHEA_ARM_CACHE_ERROR = *mut _WHEA_ARM_CACHE_ERROR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ARM_TLB_ERROR_VALID_BITS {
    pub __bindgen_anon_1: __BindgenUnionField<_WHEA_ARM_TLB_ERROR_VALID_BITS__bindgen_ty_1>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: [u8; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ARM_TLB_ERROR_VALID_BITS__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
impl Clone for _WHEA_ARM_TLB_ERROR_VALID_BITS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_ARM_TLB_ERROR_VALID_BITS__bindgen_ty_1 {
    #[inline]
    pub fn TransactionType(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_TransactionType(&mut self, val: USHORT) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn Operation(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u16)) >>
                                        1u32) as u16)
        }
    }
    #[inline]
    pub fn set_Operation(&mut self, val: USHORT) {
        self._bitfield_1 &= !(2usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 1u32) & (2usize as u16);
    }
    #[inline]
    pub fn Level(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u16)) >>
                                        2u32) as u16)
        }
    }
    #[inline]
    pub fn set_Level(&mut self, val: USHORT) {
        self._bitfield_1 &= !(4usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 2u32) & (4usize as u16);
    }
    #[inline]
    pub fn ProcessorContextCorrupt(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u16)) >>
                                        3u32) as u16)
        }
    }
    #[inline]
    pub fn set_ProcessorContextCorrupt(&mut self, val: USHORT) {
        self._bitfield_1 &= !(8usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 3u32) & (8usize as u16);
    }
    #[inline]
    pub fn Corrected(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u16)) >>
                                        4u32) as u16)
        }
    }
    #[inline]
    pub fn set_Corrected(&mut self, val: USHORT) {
        self._bitfield_1 &= !(16usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 4u32) & (16usize as u16);
    }
    #[inline]
    pub fn PrecisePC(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u16)) >>
                                        5u32) as u16)
        }
    }
    #[inline]
    pub fn set_PrecisePC(&mut self, val: USHORT) {
        self._bitfield_1 &= !(32usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 5u32) & (32usize as u16);
    }
    #[inline]
    pub fn RestartablePC(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u16)) >>
                                        6u32) as u16)
        }
    }
    #[inline]
    pub fn set_RestartablePC(&mut self, val: USHORT) {
        self._bitfield_1 &= !(64usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 6u32) & (64usize as u16);
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65408usize as u16))
                                        >> 7u32) as u16)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        self._bitfield_1 &= !(65408usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 7u32) & (65408usize as u16);
    }
}
impl Clone for _WHEA_ARM_TLB_ERROR_VALID_BITS {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_ARM_TLB_ERROR_VALID_BITS as WHEA_ARM_TLB_ERROR_VALID_BITS;
pub type PWHEA_ARM_TLB_ERROR_VALID_BITS = *mut _WHEA_ARM_TLB_ERROR_VALID_BITS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ARM_TLB_ERROR {
    pub ValidationBit: WHEA_ARM_TLB_ERROR_VALID_BITS,
    pub _bitfield_1: u16,
    pub _bitfield_2: u64,
}
impl Clone for _WHEA_ARM_TLB_ERROR {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_ARM_TLB_ERROR {
    #[inline]
    pub fn TransactionType(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (3usize as u16)) >>
                                        0u32) as u8)
        }
    }
    #[inline]
    pub fn set_TransactionType(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(3usize as u16);
        self._bitfield_1 |= ((val as u8 as u16) << 0u32) & (3usize as u16);
    }
    #[inline]
    pub fn Operation(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (60usize as u16)) >>
                                        2u32) as u8)
        }
    }
    #[inline]
    pub fn set_Operation(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(60usize as u16);
        self._bitfield_1 |= ((val as u8 as u16) << 2u32) & (60usize as u16);
    }
    #[inline]
    pub fn Level(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (448usize as u16)) >>
                                        6u32) as u8)
        }
    }
    #[inline]
    pub fn set_Level(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(448usize as u16);
        self._bitfield_1 |= ((val as u8 as u16) << 6u32) & (448usize as u16);
    }
    #[inline]
    pub fn ProcessorContextCorrupt(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (512usize as u16)) >>
                                        9u32) as u8)
        }
    }
    #[inline]
    pub fn set_ProcessorContextCorrupt(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(512usize as u16);
        self._bitfield_1 |= ((val as u8 as u16) << 9u32) & (512usize as u16);
    }
    #[inline]
    pub fn Corrected(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1024usize as u16)) >>
                                        10u32) as u8)
        }
    }
    #[inline]
    pub fn set_Corrected(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(1024usize as u16);
        self._bitfield_1 |=
            ((val as u8 as u16) << 10u32) & (1024usize as u16);
    }
    #[inline]
    pub fn PrecisePC(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2048usize as u16)) >>
                                        11u32) as u8)
        }
    }
    #[inline]
    pub fn set_PrecisePC(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(2048usize as u16);
        self._bitfield_1 |=
            ((val as u8 as u16) << 11u32) & (2048usize as u16);
    }
    #[inline]
    pub fn RestartablePC(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4096usize as u16)) >>
                                        12u32) as u8)
        }
    }
    #[inline]
    pub fn set_RestartablePC(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(4096usize as u16);
        self._bitfield_1 |=
            ((val as u8 as u16) << 12u32) & (4096usize as u16);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_2 &
                                         (68719476735usize as u64)) >> 0u32)
                                       as u64)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        self._bitfield_2 &= !(68719476735usize as u64);
        self._bitfield_2 |=
            ((val as u64 as u64) << 0u32) & (68719476735usize as u64);
    }
}
pub use self::_WHEA_ARM_TLB_ERROR as WHEA_ARM_TLB_ERROR;
pub type PWHEA_ARM_TLB_ERROR = *mut _WHEA_ARM_TLB_ERROR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ARM_BUS_ERROR_VALID_BITS {
    pub __bindgen_anon_1: __BindgenUnionField<_WHEA_ARM_BUS_ERROR_VALID_BITS__bindgen_ty_1>,
    pub AsUSHORT: __BindgenUnionField<USHORT>,
    pub bindgen_union_field: [u8; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ARM_BUS_ERROR_VALID_BITS__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
impl Clone for _WHEA_ARM_BUS_ERROR_VALID_BITS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_ARM_BUS_ERROR_VALID_BITS__bindgen_ty_1 {
    #[inline]
    pub fn TransactionType(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_TransactionType(&mut self, val: USHORT) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn Operation(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u16)) >>
                                        1u32) as u16)
        }
    }
    #[inline]
    pub fn set_Operation(&mut self, val: USHORT) {
        self._bitfield_1 &= !(2usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 1u32) & (2usize as u16);
    }
    #[inline]
    pub fn Level(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u16)) >>
                                        2u32) as u16)
        }
    }
    #[inline]
    pub fn set_Level(&mut self, val: USHORT) {
        self._bitfield_1 &= !(4usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 2u32) & (4usize as u16);
    }
    #[inline]
    pub fn ProcessorContextCorrupt(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u16)) >>
                                        3u32) as u16)
        }
    }
    #[inline]
    pub fn set_ProcessorContextCorrupt(&mut self, val: USHORT) {
        self._bitfield_1 &= !(8usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 3u32) & (8usize as u16);
    }
    #[inline]
    pub fn Corrected(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u16)) >>
                                        4u32) as u16)
        }
    }
    #[inline]
    pub fn set_Corrected(&mut self, val: USHORT) {
        self._bitfield_1 &= !(16usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 4u32) & (16usize as u16);
    }
    #[inline]
    pub fn PrecisePC(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u16)) >>
                                        5u32) as u16)
        }
    }
    #[inline]
    pub fn set_PrecisePC(&mut self, val: USHORT) {
        self._bitfield_1 &= !(32usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 5u32) & (32usize as u16);
    }
    #[inline]
    pub fn RestartablePC(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u16)) >>
                                        6u32) as u16)
        }
    }
    #[inline]
    pub fn set_RestartablePC(&mut self, val: USHORT) {
        self._bitfield_1 &= !(64usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 6u32) & (64usize as u16);
    }
    #[inline]
    pub fn ParticipationType(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (128usize as u16)) >>
                                        7u32) as u16)
        }
    }
    #[inline]
    pub fn set_ParticipationType(&mut self, val: USHORT) {
        self._bitfield_1 &= !(128usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 7u32) & (128usize as u16);
    }
    #[inline]
    pub fn Timeout(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (256usize as u16)) >>
                                        8u32) as u16)
        }
    }
    #[inline]
    pub fn set_Timeout(&mut self, val: USHORT) {
        self._bitfield_1 &= !(256usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 8u32) & (256usize as u16);
    }
    #[inline]
    pub fn AddressSpace(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (512usize as u16)) >>
                                        9u32) as u16)
        }
    }
    #[inline]
    pub fn set_AddressSpace(&mut self, val: USHORT) {
        self._bitfield_1 &= !(512usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 9u32) & (512usize as u16);
    }
    #[inline]
    pub fn MemoryAttributes(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1024usize as u16)) >>
                                        10u32) as u16)
        }
    }
    #[inline]
    pub fn set_MemoryAttributes(&mut self, val: USHORT) {
        self._bitfield_1 &= !(1024usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 10u32) & (1024usize as u16);
    }
    #[inline]
    pub fn AccessMode(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2048usize as u16)) >>
                                        11u32) as u16)
        }
    }
    #[inline]
    pub fn set_AccessMode(&mut self, val: USHORT) {
        self._bitfield_1 &= !(2048usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 11u32) & (2048usize as u16);
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (61440usize as u16))
                                        >> 12u32) as u16)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        self._bitfield_1 &= !(61440usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 12u32) & (61440usize as u16);
    }
}
impl Clone for _WHEA_ARM_BUS_ERROR_VALID_BITS {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_ARM_BUS_ERROR_VALID_BITS as WHEA_ARM_BUS_ERROR_VALID_BITS;
pub type PWHEA_ARM_BUS_ERROR_VALID_BITS = *mut _WHEA_ARM_BUS_ERROR_VALID_BITS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ARM_BUS_ERROR {
    pub ValidationBit: WHEA_ARM_BUS_ERROR_VALID_BITS,
    pub _bitfield_1: u32,
    pub _bitfield_2: u16,
    pub _bitfield_3: u32,
}
impl Clone for _WHEA_ARM_BUS_ERROR {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_ARM_BUS_ERROR {
    #[inline]
    pub fn TransactionType(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (3usize as u32)) >>
                                        0u32) as u8)
        }
    }
    #[inline]
    pub fn set_TransactionType(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(3usize as u32);
        self._bitfield_1 |= ((val as u8 as u32) << 0u32) & (3usize as u32);
    }
    #[inline]
    pub fn Operation(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (60usize as u32)) >>
                                        2u32) as u8)
        }
    }
    #[inline]
    pub fn set_Operation(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(60usize as u32);
        self._bitfield_1 |= ((val as u8 as u32) << 2u32) & (60usize as u32);
    }
    #[inline]
    pub fn Level(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (448usize as u32)) >>
                                        6u32) as u8)
        }
    }
    #[inline]
    pub fn set_Level(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(448usize as u32);
        self._bitfield_1 |= ((val as u8 as u32) << 6u32) & (448usize as u32);
    }
    #[inline]
    pub fn ProcessorContextCorrupt(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (512usize as u32)) >>
                                        9u32) as u8)
        }
    }
    #[inline]
    pub fn set_ProcessorContextCorrupt(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(512usize as u32);
        self._bitfield_1 |= ((val as u8 as u32) << 9u32) & (512usize as u32);
    }
    #[inline]
    pub fn Corrected(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1024usize as u32)) >>
                                        10u32) as u8)
        }
    }
    #[inline]
    pub fn set_Corrected(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(1024usize as u32);
        self._bitfield_1 |=
            ((val as u8 as u32) << 10u32) & (1024usize as u32);
    }
    #[inline]
    pub fn PrecisePC(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2048usize as u32)) >>
                                        11u32) as u8)
        }
    }
    #[inline]
    pub fn set_PrecisePC(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(2048usize as u32);
        self._bitfield_1 |=
            ((val as u8 as u32) << 11u32) & (2048usize as u32);
    }
    #[inline]
    pub fn RestartablePC(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4096usize as u32)) >>
                                        12u32) as u8)
        }
    }
    #[inline]
    pub fn set_RestartablePC(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(4096usize as u32);
        self._bitfield_1 |=
            ((val as u8 as u32) << 12u32) & (4096usize as u32);
    }
    #[inline]
    pub fn PariticpationType(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (24576usize as u32))
                                        >> 13u32) as u8)
        }
    }
    #[inline]
    pub fn set_PariticpationType(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(24576usize as u32);
        self._bitfield_1 |=
            ((val as u8 as u32) << 13u32) & (24576usize as u32);
    }
    #[inline]
    pub fn TimeOut(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32768usize as u32))
                                        >> 15u32) as u8)
        }
    }
    #[inline]
    pub fn set_TimeOut(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(32768usize as u32);
        self._bitfield_1 |=
            ((val as u8 as u32) << 15u32) & (32768usize as u32);
    }
    #[inline]
    pub fn AddressSpace(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (196608usize as u32))
                                        >> 16u32) as u8)
        }
    }
    #[inline]
    pub fn set_AddressSpace(&mut self, val: UCHAR) {
        self._bitfield_1 &= !(196608usize as u32);
        self._bitfield_1 |=
            ((val as u8 as u32) << 16u32) & (196608usize as u32);
    }
    #[inline]
    pub fn MemoryAccessAttributes(&self) -> USHORT {
        unsafe {
            ::core::mem::transmute(((self._bitfield_2 & (511usize as u16)) >>
                                        0u32) as u16)
        }
    }
    #[inline]
    pub fn set_MemoryAccessAttributes(&mut self, val: USHORT) {
        self._bitfield_2 &= !(511usize as u16);
        self._bitfield_2 |= ((val as u16 as u16) << 0u32) & (511usize as u16);
    }
    #[inline]
    pub fn AccessMode(&self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(((self._bitfield_2 & (512usize as u16)) >>
                                        9u32) as u8)
        }
    }
    #[inline]
    pub fn set_AccessMode(&mut self, val: UCHAR) {
        self._bitfield_2 &= !(512usize as u16);
        self._bitfield_2 |= ((val as u8 as u16) << 9u32) & (512usize as u16);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_3 & (1048575usize as u32))
                                        >> 0u32) as u32)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        self._bitfield_3 &= !(1048575usize as u32);
        self._bitfield_3 |=
            ((val as u32 as u32) << 0u32) & (1048575usize as u32);
    }
}
pub use self::_WHEA_ARM_BUS_ERROR as WHEA_ARM_BUS_ERROR;
pub type PWHEA_ARM_BUS_ERROR = *mut _WHEA_ARM_BUS_ERROR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ARM_PROCESSOR_ERROR {
    pub CacheError: __BindgenUnionField<WHEA_ARM_CACHE_ERROR>,
    pub TlbError: __BindgenUnionField<WHEA_ARM_TLB_ERROR>,
    pub BusError: __BindgenUnionField<WHEA_ARM_BUS_ERROR>,
    pub AsULONGLONG: __BindgenUnionField<ULONGLONG>,
    pub bindgen_union_field: [u8; 12usize],
}
impl Clone for _WHEA_ARM_PROCESSOR_ERROR {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_ARM_PROCESSOR_ERROR as WHEA_ARM_PROCESSOR_ERROR;
pub type PWHEA_ARM_PROCESSOR_ERROR = *mut _WHEA_ARM_PROCESSOR_ERROR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ARM_PROCESSOR_ERROR_INFORMATION {
    pub Version: UCHAR,
    pub Length: UCHAR,
    pub ValidationBit: WHEA_ARM_PROCESSOR_ERROR_INFORMATION_VALID_BITS,
    pub Type: UCHAR,
    pub MultipleError: USHORT,
    pub Flags: UCHAR,
    pub ErrorInformation: ULONGLONG,
    pub VirtualFaultAddress: ULONGLONG,
    pub PhysicalFaultAddresss: ULONGLONG,
}
impl Clone for _WHEA_ARM_PROCESSOR_ERROR_INFORMATION {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_ARM_PROCESSOR_ERROR_INFORMATION as
        WHEA_ARM_PROCESSOR_ERROR_INFORMATION;
pub type PWHEA_ARM_PROCESSOR_ERROR_INFORMATION =
    *mut _WHEA_ARM_PROCESSOR_ERROR_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER_FLAGS {
    pub __bindgen_anon_1: __BindgenUnionField<_WHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER_FLAGS__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: [u8; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER_FLAGS__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
impl Clone for
 _WHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER_FLAGS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER_FLAGS__bindgen_ty_1
 {
    #[inline]
    pub fn ExceptionLevel(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_ExceptionLevel(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn NonSecure(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_NonSecure(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn AArch64(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                        2u32) as u32)
        }
    }
    #[inline]
    pub fn set_AArch64(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967288usize as u32)) >> 3u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967288usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 3u32) & (4294967288usize as u32);
    }
}
impl Clone for _WHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER_FLAGS {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER_FLAGS as
        WHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER_FLAGS;
pub type PWHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER_FLAGS =
    *mut _WHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER_FLAGS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ARMV8_AARCH32_GPRS {
    pub R0: ULONG,
    pub R1: ULONG,
    pub R2: ULONG,
    pub R3: ULONG,
    pub R4: ULONG,
    pub R5: ULONG,
    pub R6: ULONG,
    pub R7: ULONG,
    pub R8: ULONG,
    pub R9: ULONG,
    pub R10: ULONG,
    pub R11: ULONG,
    pub R12: ULONG,
    pub R13: ULONG,
    pub R14: ULONG,
    pub R15: ULONG,
}
impl Clone for _WHEA_ARMV8_AARCH32_GPRS {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_ARMV8_AARCH32_GPRS as WHEA_ARMV8_AARCH32_GPRS;
pub type PWHEA_ARMV8_AARCH32_GPRS = *mut _WHEA_ARMV8_AARCH32_GPRS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ARM_AARCH32_EL1_CSR {
    pub DFAR: ULONG,
    pub DFSR: ULONG,
    pub IFAR: ULONG,
    pub ISR: ULONG,
    pub MAIR0: ULONG,
    pub MAIR1: ULONG,
    pub MIDR: ULONG,
    pub MPIDR: ULONG,
    pub NMRR: ULONG,
    pub PRRR: ULONG,
    pub SCTLR: ULONG,
    pub SPSR: ULONG,
    pub SPSR_abt: ULONG,
    pub SPSR_fiq: ULONG,
    pub SPSR_irq: ULONG,
    pub SPSR_svc: ULONG,
    pub SPSR_und: ULONG,
    pub TPIDRPRW: ULONG,
    pub TPIDRURO: ULONG,
    pub TPIDRURW: ULONG,
    pub TTBCR: ULONG,
    pub TTBR0: ULONG,
    pub TTBR1: ULONG,
    pub DACR: ULONG,
}
impl Clone for _WHEA_ARM_AARCH32_EL1_CSR {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_ARM_AARCH32_EL1_CSR as WHEA_ARM_AARCH32_EL1_CSR;
pub type PWHEA_ARM_AARCH32_EL1 = *mut _WHEA_ARM_AARCH32_EL1_CSR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ARM_AARCH32_EL2_CSR {
    pub ELR_hyp: ULONG,
    pub HAMAIR0: ULONG,
    pub HAMAIR1: ULONG,
    pub HCR: ULONG,
    pub HCR2: ULONG,
    pub HDFAR: ULONG,
    pub HIFAR: ULONG,
    pub HPFAR: ULONG,
    pub HSR: ULONG,
    pub HTCR: ULONG,
    pub HTPIDR: ULONG,
    pub HTTBR: ULONG,
    pub SPSR_hyp: ULONG,
    pub VTCR: ULONG,
    pub VTTBR: ULONG,
    pub DACR32_EL2: ULONG,
}
impl Clone for _WHEA_ARM_AARCH32_EL2_CSR {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_ARM_AARCH32_EL2_CSR as WHEA_ARM_AARCH32_EL2_CSR;
pub type PWHEA_ARM_AARCH32_EL2_CSR = *mut _WHEA_ARM_AARCH32_EL2_CSR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ARM_AARCH32_SECURE_CSR {
    pub SCTLR: ULONG,
    pub SPSR_mon: ULONG,
}
impl Clone for _WHEA_ARM_AARCH32_SECURE_CSR {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_ARM_AARCH32_SECURE_CSR as WHEA_ARM_AARCH32_SECURE_CSR;
pub type PWHEA_ARM_AARCH32_SECURE_CSR = *mut _WHEA_ARM_AARCH32_SECURE_CSR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ARMV8_AARCH64_GPRS {
    pub X0: ULONGLONG,
    pub X1: ULONGLONG,
    pub X2: ULONGLONG,
    pub X3: ULONGLONG,
    pub X4: ULONGLONG,
    pub X5: ULONGLONG,
    pub X6: ULONGLONG,
    pub X7: ULONGLONG,
    pub X8: ULONGLONG,
    pub X9: ULONGLONG,
    pub X10: ULONGLONG,
    pub X11: ULONGLONG,
    pub X12: ULONGLONG,
    pub X13: ULONGLONG,
    pub X14: ULONGLONG,
    pub X15: ULONGLONG,
    pub X16: ULONGLONG,
    pub X17: ULONGLONG,
    pub X18: ULONGLONG,
    pub X19: ULONGLONG,
    pub X20: ULONGLONG,
    pub X21: ULONGLONG,
    pub X22: ULONGLONG,
    pub X23: ULONGLONG,
    pub X24: ULONGLONG,
    pub X25: ULONGLONG,
    pub X26: ULONGLONG,
    pub X27: ULONGLONG,
    pub X28: ULONGLONG,
    pub X29: ULONGLONG,
    pub X30: ULONGLONG,
    pub SP: ULONGLONG,
}
impl Clone for _WHEA_ARMV8_AARCH64_GPRS {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_ARMV8_AARCH64_GPRS as WHEA_ARMV8_AARCH64_GPRS;
pub type PWHEA_ARMV8_AARCH64_GPRS = *mut _WHEA_ARMV8_AARCH64_GPRS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ARM_AARCH64_EL1_CSR {
    pub ELR_EL1: ULONGLONG,
    pub ESR_EL2: ULONGLONG,
    pub FAR_EL1: ULONGLONG,
    pub ISR_EL1: ULONGLONG,
    pub MAIR_EL1: ULONGLONG,
    pub MIDR_EL1: ULONGLONG,
    pub MPIDR_EL1: ULONGLONG,
    pub SCTLR_EL1: ULONGLONG,
    pub SP_EL0: ULONGLONG,
    pub SP_EL1: ULONGLONG,
    pub SPSR_EL1: ULONGLONG,
    pub TCR_EL1: ULONGLONG,
    pub TPIDR_EL0: ULONGLONG,
    pub TPIDR_EL1: ULONGLONG,
    pub TPIDRRO_EL0: ULONGLONG,
    pub TTBR0_EL1: ULONGLONG,
    pub TTBR1_EL1: ULONGLONG,
}
impl Clone for _WHEA_ARM_AARCH64_EL1_CSR {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_ARM_AARCH64_EL1_CSR as WHEA_ARM_AARCH64_EL1_CSR;
pub type PWHEA_ARM_AARCH64_EL1_CSR = *mut _WHEA_ARM_AARCH64_EL1_CSR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ARM_AARCH64_EL2_CSR {
    pub ELR_EL2: ULONGLONG,
    pub ESR_EL2: ULONGLONG,
    pub FAR_EL2: ULONGLONG,
    pub HACR_EL2: ULONGLONG,
    pub HCR_EL2: ULONGLONG,
    pub HPFAR_EL2: ULONGLONG,
    pub MAIR_EL2: ULONGLONG,
    pub SCTLR_EL2: ULONGLONG,
    pub SP_EL2: ULONGLONG,
    pub SPSR_EL2: ULONGLONG,
    pub TCR_EL2: ULONGLONG,
    pub TPIDR_EL2: ULONGLONG,
    pub TTBR0_EL2: ULONGLONG,
    pub VTCR_EL2: ULONGLONG,
    pub VTTBR_EL2: ULONGLONG,
}
impl Clone for _WHEA_ARM_AARCH64_EL2_CSR {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_ARM_AARCH64_EL2_CSR as WHEA_ARM_AARCH64_EL2_CSR;
pub type PWHEA_ARM_AARCH64_EL2_CSR = *mut _WHEA_ARM_AARCH64_EL2_CSR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ARMV8_AARCH64_EL3_CSR {
    pub ELR_EL3: ULONGLONG,
    pub ESR_EL3: ULONGLONG,
    pub FAR_EL3: ULONGLONG,
    pub MAIR_EL3: ULONGLONG,
    pub SCTLR_EL3: ULONGLONG,
    pub SP_EL3: ULONGLONG,
    pub SPSR_EL3: ULONGLONG,
    pub TCR_EL3: ULONGLONG,
    pub TPIDR_EL3: ULONGLONG,
    pub TTBR0_EL3: ULONGLONG,
}
impl Clone for _WHEA_ARMV8_AARCH64_EL3_CSR {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_ARMV8_AARCH64_EL3_CSR as WHEA_ARMV8_AARCH64_EL3_CSR;
pub type PWHEA_ARMV8_AARCH64_EL3_CSR = *mut _WHEA_ARMV8_AARCH64_EL3_CSR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ARM_MISC_CSR {
    pub MRSEncoding: USHORT,
    pub Value: ULONGLONG,
}
impl Clone for _WHEA_ARM_MISC_CSR {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_ARM_MISC_CSR as WHEA_ARM_MISC_CSR;
pub type PWHEA_ARM_MISC_CSR = *mut _WHEA_ARM_MISC_CSR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER {
    pub Version: USHORT,
    pub RegisterContextType: USHORT,
    pub RegisterArraySize: ULONG,
    pub RegisterArray: [UCHAR; 1usize],
}
impl Clone for _WHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER as
        WHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER;
pub type PWHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER =
    *mut _WHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER;
extern "C" {
    #[link_name = "CMC_NOTIFY_TYPE_GUID"]
    pub static CMC_NOTIFY_TYPE_GUID: GUID;
}
extern "C" {
    #[link_name = "CPE_NOTIFY_TYPE_GUID"]
    pub static CPE_NOTIFY_TYPE_GUID: GUID;
}
extern "C" {
    #[link_name = "MCE_NOTIFY_TYPE_GUID"]
    pub static MCE_NOTIFY_TYPE_GUID: GUID;
}
extern "C" {
    #[link_name = "PCIe_NOTIFY_TYPE_GUID"]
    pub static PCIe_NOTIFY_TYPE_GUID: GUID;
}
extern "C" {
    #[link_name = "INIT_NOTIFY_TYPE_GUID"]
    pub static INIT_NOTIFY_TYPE_GUID: GUID;
}
extern "C" {
    #[link_name = "NMI_NOTIFY_TYPE_GUID"]
    pub static NMI_NOTIFY_TYPE_GUID: GUID;
}
extern "C" {
    #[link_name = "BOOT_NOTIFY_TYPE_GUID"]
    pub static BOOT_NOTIFY_TYPE_GUID: GUID;
}
extern "C" {
    #[link_name = "SEA_NOTIFY_TYPE_GUID"]
    pub static SEA_NOTIFY_TYPE_GUID: GUID;
}
extern "C" {
    #[link_name = "SEI_NOTIFY_TYPE_GUID"]
    pub static SEI_NOTIFY_TYPE_GUID: GUID;
}
extern "C" {
    #[link_name = "PEI_NOTIFY_TYPE_GUID"]
    pub static PEI_NOTIFY_TYPE_GUID: GUID;
}
extern "C" {
    #[link_name = "PROCESSOR_GENERIC_ERROR_SECTION_GUID"]
    pub static PROCESSOR_GENERIC_ERROR_SECTION_GUID: GUID;
}
extern "C" {
    #[link_name = "XPF_PROCESSOR_ERROR_SECTION_GUID"]
    pub static XPF_PROCESSOR_ERROR_SECTION_GUID: GUID;
}
extern "C" {
    #[link_name = "IPF_PROCESSOR_ERROR_SECTION_GUID"]
    pub static IPF_PROCESSOR_ERROR_SECTION_GUID: GUID;
}
extern "C" {
    #[link_name = "ARM_PROCESSOR_ERROR_SECTION_GUID"]
    pub static ARM_PROCESSOR_ERROR_SECTION_GUID: GUID;
}
extern "C" {
    #[link_name = "MEMORY_ERROR_SECTION_GUID"]
    pub static MEMORY_ERROR_SECTION_GUID: GUID;
}
extern "C" {
    #[link_name = "PCIEXPRESS_ERROR_SECTION_GUID"]
    pub static PCIEXPRESS_ERROR_SECTION_GUID: GUID;
}
extern "C" {
    #[link_name = "PCIXBUS_ERROR_SECTION_GUID"]
    pub static PCIXBUS_ERROR_SECTION_GUID: GUID;
}
extern "C" {
    #[link_name = "PCIXDEVICE_ERROR_SECTION_GUID"]
    pub static PCIXDEVICE_ERROR_SECTION_GUID: GUID;
}
extern "C" {
    #[link_name = "FIRMWARE_ERROR_RECORD_REFERENCE_GUID"]
    pub static FIRMWARE_ERROR_RECORD_REFERENCE_GUID: GUID;
}
extern "C" {
    #[link_name = "WHEA_CACHECHECK_GUID"]
    pub static WHEA_CACHECHECK_GUID: GUID;
}
extern "C" {
    #[link_name = "WHEA_TLBCHECK_GUID"]
    pub static WHEA_TLBCHECK_GUID: GUID;
}
extern "C" {
    #[link_name = "WHEA_BUSCHECK_GUID"]
    pub static WHEA_BUSCHECK_GUID: GUID;
}
extern "C" {
    #[link_name = "WHEA_MSCHECK_GUID"]
    pub static WHEA_MSCHECK_GUID: GUID;
}
extern "C" {
    #[link_name = "WHEA_RECORD_CREATOR_GUID"]
    pub static WHEA_RECORD_CREATOR_GUID: GUID;
}
extern "C" {
    #[link_name = "GENERIC_NOTIFY_TYPE_GUID"]
    pub static GENERIC_NOTIFY_TYPE_GUID: GUID;
}
extern "C" {
    #[link_name = "IPF_SAL_RECORD_SECTION_GUID"]
    pub static IPF_SAL_RECORD_SECTION_GUID: GUID;
}
extern "C" {
    #[link_name = "XPF_MCA_SECTION_GUID"]
    pub static XPF_MCA_SECTION_GUID: GUID;
}
extern "C" {
    #[link_name = "NMI_SECTION_GUID"]
    pub static NMI_SECTION_GUID: GUID;
}
extern "C" {
    #[link_name = "GENERIC_SECTION_GUID"]
    pub static GENERIC_SECTION_GUID: GUID;
}
extern "C" {
    #[link_name = "WHEA_ERROR_PACKET_SECTION_GUID"]
    pub static WHEA_ERROR_PACKET_SECTION_GUID: GUID;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _WHEA_ERROR_TYPE {
    WheaErrTypeProcessor = 0,
    WheaErrTypeMemory = 1,
    WheaErrTypePCIExpress = 2,
    WheaErrTypeNMI = 3,
    WheaErrTypePCIXBus = 4,
    WheaErrTypePCIXDevice = 5,
    WheaErrTypeGeneric = 6,
}
pub use self::_WHEA_ERROR_TYPE as WHEA_ERROR_TYPE;
pub type PWHEA_ERROR_TYPE = *mut _WHEA_ERROR_TYPE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ERROR_PACKET_FLAGS {
    pub __bindgen_anon_1: __BindgenUnionField<_WHEA_ERROR_PACKET_FLAGS__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: [u8; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ERROR_PACKET_FLAGS__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
impl Clone for _WHEA_ERROR_PACKET_FLAGS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_ERROR_PACKET_FLAGS__bindgen_ty_1 {
    #[inline]
    pub fn PreviousError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_PreviousError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn HypervisorError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                        2u32) as u32)
        }
    }
    #[inline]
    pub fn set_HypervisorError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn Simulated(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u32)) >>
                                        3u32) as u32)
        }
    }
    #[inline]
    pub fn set_Simulated(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (8usize as u32);
    }
    #[inline]
    pub fn PlatformPfaControl(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u32)) >>
                                        4u32) as u32)
        }
    }
    #[inline]
    pub fn set_PlatformPfaControl(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (16usize as u32);
    }
    #[inline]
    pub fn PlatformDirectedOffline(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u32)) >>
                                        5u32) as u32)
        }
    }
    #[inline]
    pub fn set_PlatformDirectedOffline(&mut self, val: ULONG) {
        self._bitfield_1 &= !(32usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (32usize as u32);
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294967232usize as u32)) >> 6u32) as
                                       u32)
        }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294967232usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 6u32) & (4294967232usize as u32);
    }
}
impl Clone for _WHEA_ERROR_PACKET_FLAGS {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_ERROR_PACKET_FLAGS as WHEA_ERROR_PACKET_FLAGS;
pub type PWHEA_ERROR_PACKET_FLAGS = *mut _WHEA_ERROR_PACKET_FLAGS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _WHEA_ERROR_PACKET_DATA_FORMAT {
    WheaDataFormatIPFSalRecord = 0,
    WheaDataFormatXPFMCA = 1,
    WheaDataFormatMemory = 2,
    WheaDataFormatPCIExpress = 3,
    WheaDataFormatNMIPort = 4,
    WheaDataFormatPCIXBus = 5,
    WheaDataFormatPCIXDevice = 6,
    WheaDataFormatGeneric = 7,
    WheaDataFormatMax = 8,
}
pub use self::_WHEA_ERROR_PACKET_DATA_FORMAT as WHEA_ERROR_PACKET_DATA_FORMAT;
pub type PWHEA_ERROR_PACKET_DATA_FORMAT = *mut _WHEA_ERROR_PACKET_DATA_FORMAT;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _WHEA_RAW_DATA_FORMAT {
    WheaRawDataFormatIPFSalRecord = 0,
    WheaRawDataFormatIA32MCA = 1,
    WheaRawDataFormatIntel64MCA = 2,
    WheaRawDataFormatAMD64MCA = 3,
    WheaRawDataFormatMemory = 4,
    WheaRawDataFormatPCIExpress = 5,
    WheaRawDataFormatNMIPort = 6,
    WheaRawDataFormatPCIXBus = 7,
    WheaRawDataFormatPCIXDevice = 8,
    WheaRawDataFormatGeneric = 9,
    WheaRawDataFormatMax = 10,
}
pub use self::_WHEA_RAW_DATA_FORMAT as WHEA_RAW_DATA_FORMAT;
pub type PWHEA_RAW_DATA_FORMAT = *mut _WHEA_RAW_DATA_FORMAT;
#[repr(C)]
#[derive(Copy)]
pub struct _WHEA_ERROR_PACKET_V1 {
    pub Signature: ULONG,
    pub Flags: WHEA_ERROR_PACKET_FLAGS,
    pub Size: ULONG,
    pub RawDataLength: ULONG,
    pub Reserved1: ULONGLONG,
    pub Context: ULONGLONG,
    pub ErrorType: WHEA_ERROR_TYPE,
    pub ErrorSeverity: WHEA_ERROR_SEVERITY,
    pub ErrorSourceId: ULONG,
    pub ErrorSourceType: WHEA_ERROR_SOURCE_TYPE,
    pub Reserved2: ULONG,
    pub Version: ULONG,
    pub Cpu: ULONGLONG,
    pub u: _WHEA_ERROR_PACKET_V1__bindgen_ty_1,
    pub RawDataFormat: WHEA_RAW_DATA_FORMAT,
    pub RawDataOffset: ULONG,
    pub RawData: [UCHAR; 1usize],
}
#[repr(C)]
#[derive(Copy)]
pub struct _WHEA_ERROR_PACKET_V1__bindgen_ty_1 {
    pub ProcessorError: __BindgenUnionField<WHEA_PROCESSOR_GENERIC_ERROR_SECTION>,
    pub MemoryError: __BindgenUnionField<WHEA_MEMORY_ERROR_SECTION>,
    pub NmiError: __BindgenUnionField<WHEA_NMI_ERROR_SECTION>,
    pub PciExpressError: __BindgenUnionField<WHEA_PCIEXPRESS_ERROR_SECTION>,
    pub PciXBusError: __BindgenUnionField<WHEA_PCIXBUS_ERROR_SECTION>,
    pub PciXDeviceError: __BindgenUnionField<WHEA_PCIXDEVICE_ERROR_SECTION>,
    pub bindgen_union_field: [u8; 208usize],
}
impl Clone for _WHEA_ERROR_PACKET_V1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Clone for _WHEA_ERROR_PACKET_V1 {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_ERROR_PACKET_V1 as WHEA_ERROR_PACKET_V1;
pub type PWHEA_ERROR_PACKET_V1 = *mut _WHEA_ERROR_PACKET_V1;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ERROR_PACKET_V2 {
    pub Signature: ULONG,
    pub Version: ULONG,
    pub Length: ULONG,
    pub Flags: WHEA_ERROR_PACKET_FLAGS,
    pub ErrorType: WHEA_ERROR_TYPE,
    pub ErrorSeverity: WHEA_ERROR_SEVERITY,
    pub ErrorSourceId: ULONG,
    pub ErrorSourceType: WHEA_ERROR_SOURCE_TYPE,
    pub NotifyType: GUID,
    pub Context: ULONGLONG,
    pub DataFormat: WHEA_ERROR_PACKET_DATA_FORMAT,
    pub Reserved1: ULONG,
    pub DataOffset: ULONG,
    pub DataLength: ULONG,
    pub PshedDataOffset: ULONG,
    pub PshedDataLength: ULONG,
}
impl Clone for _WHEA_ERROR_PACKET_V2 {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_ERROR_PACKET_V2 as WHEA_ERROR_PACKET_V2;
pub type PWHEA_ERROR_PACKET_V2 = *mut _WHEA_ERROR_PACKET_V2;
pub use self::_WHEA_ERROR_PACKET_V2 as WHEA_ERROR_PACKET;
pub type PWHEA_ERROR_PACKET = *mut _WHEA_ERROR_PACKET_V2;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_GENERIC_ERROR_BLOCKSTATUS {
    pub __bindgen_anon_1: __BindgenUnionField<_WHEA_GENERIC_ERROR_BLOCKSTATUS__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: [u8; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_GENERIC_ERROR_BLOCKSTATUS__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
impl Clone for _WHEA_GENERIC_ERROR_BLOCKSTATUS__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_GENERIC_ERROR_BLOCKSTATUS__bindgen_ty_1 {
    #[inline]
    pub fn UncorrectableError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_UncorrectableError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn CorrectableError(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_CorrectableError(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn MultipleUncorrectableErrors(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                        2u32) as u32)
        }
    }
    #[inline]
    pub fn set_MultipleUncorrectableErrors(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn MultipleCorrectableErrors(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u32)) >>
                                        3u32) as u32)
        }
    }
    #[inline]
    pub fn set_MultipleCorrectableErrors(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (8usize as u32);
    }
    #[inline]
    pub fn ErrorDataEntryCount(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16368usize as u32))
                                        >> 4u32) as u32)
        }
    }
    #[inline]
    pub fn set_ErrorDataEntryCount(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16368usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 4u32) & (16368usize as u32);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294950912usize as u32)) >> 14u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294950912usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 14u32) & (4294950912usize as u32);
    }
}
impl Clone for _WHEA_GENERIC_ERROR_BLOCKSTATUS {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_GENERIC_ERROR_BLOCKSTATUS as
        WHEA_GENERIC_ERROR_BLOCKSTATUS;
pub type PWHEA_GENERIC_ERROR_BLOCKSTATUS =
    *mut _WHEA_GENERIC_ERROR_BLOCKSTATUS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_GENERIC_ERROR {
    pub BlockStatus: WHEA_GENERIC_ERROR_BLOCKSTATUS,
    pub RawDataOffset: ULONG,
    pub RawDataLength: ULONG,
    pub DataLength: ULONG,
    pub ErrorSeverity: WHEA_ERROR_SEVERITY,
    pub Data: [UCHAR; 1usize],
}
impl Clone for _WHEA_GENERIC_ERROR {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_GENERIC_ERROR as WHEA_GENERIC_ERROR;
pub type PWHEA_GENERIC_ERROR = *mut _WHEA_GENERIC_ERROR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_GENERIC_ERROR_DATA_ENTRY_V1 {
    pub SectionType: GUID,
    pub ErrorSeverity: WHEA_ERROR_SEVERITY,
    pub Revision: WHEA_REVISION,
    pub ValidBits: UCHAR,
    pub Flags: UCHAR,
    pub ErrorDataLength: ULONG,
    pub FRUId: GUID,
    pub FRUText: [UCHAR; 20usize],
    pub Data: [UCHAR; 1usize],
}
impl Clone for _WHEA_GENERIC_ERROR_DATA_ENTRY_V1 {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_GENERIC_ERROR_DATA_ENTRY_V1 as
        WHEA_GENERIC_ERROR_DATA_ENTRY_V1;
pub type PWHEA_GENERIC_ERROR_DATA_ENTRY_V1 =
    *mut _WHEA_GENERIC_ERROR_DATA_ENTRY_V1;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_GENERIC_ERROR_DATA_ENTRY_V2 {
    pub SectionType: GUID,
    pub ErrorSeverity: WHEA_ERROR_SEVERITY,
    pub Revision: WHEA_REVISION,
    pub ValidBits: UCHAR,
    pub Flags: UCHAR,
    pub ErrorDataLength: ULONG,
    pub FRUId: GUID,
    pub FRUText: [UCHAR; 20usize],
    pub Timestamp: WHEA_TIMESTAMP,
    pub Data: [UCHAR; 1usize],
}
impl Clone for _WHEA_GENERIC_ERROR_DATA_ENTRY_V2 {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_GENERIC_ERROR_DATA_ENTRY_V2 as
        WHEA_GENERIC_ERROR_DATA_ENTRY_V2;
pub type PWHEA_GENERIC_ERROR_DATA_ENTRY_V2 =
    *mut _WHEA_GENERIC_ERROR_DATA_ENTRY_V2;
pub use self::_WHEA_GENERIC_ERROR_DATA_ENTRY_V2 as
        WHEA_GENERIC_ERROR_DATA_ENTRY;
pub type PWHEA_GENERIC_ERROR_DATA_ENTRY =
    *mut _WHEA_GENERIC_ERROR_DATA_ENTRY_V2;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ERROR_INJECTION_CAPABILITIES {
    pub __bindgen_anon_1: __BindgenUnionField<_WHEA_ERROR_INJECTION_CAPABILITIES__bindgen_ty_1>,
    pub AsULONG: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_ERROR_INJECTION_CAPABILITIES__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__WHEA_ERROR_INJECTION_CAPABILITIES__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_WHEA_ERROR_INJECTION_CAPABILITIES__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::core::mem::align_of::<_WHEA_ERROR_INJECTION_CAPABILITIES__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _WHEA_ERROR_INJECTION_CAPABILITIES__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _WHEA_ERROR_INJECTION_CAPABILITIES__bindgen_ty_1 {
    #[inline]
    pub fn ProcessorCorrectable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                        0u32) as u32)
        }
    }
    #[inline]
    pub fn set_ProcessorCorrectable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn ProcessorUncorrectableNonFatal(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                        1u32) as u32)
        }
    }
    #[inline]
    pub fn set_ProcessorUncorrectableNonFatal(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn ProcessorUncorrectableFatal(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                        2u32) as u32)
        }
    }
    #[inline]
    pub fn set_ProcessorUncorrectableFatal(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn MemoryCorrectable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8usize as u32)) >>
                                        3u32) as u32)
        }
    }
    #[inline]
    pub fn set_MemoryCorrectable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (8usize as u32);
    }
    #[inline]
    pub fn MemoryUncorrectableNonFatal(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16usize as u32)) >>
                                        4u32) as u32)
        }
    }
    #[inline]
    pub fn set_MemoryUncorrectableNonFatal(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (16usize as u32);
    }
    #[inline]
    pub fn MemoryUncorrectableFatal(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32usize as u32)) >>
                                        5u32) as u32)
        }
    }
    #[inline]
    pub fn set_MemoryUncorrectableFatal(&mut self, val: ULONG) {
        self._bitfield_1 &= !(32usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (32usize as u32);
    }
    #[inline]
    pub fn PCIExpressCorrectable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (64usize as u32)) >>
                                        6u32) as u32)
        }
    }
    #[inline]
    pub fn set_PCIExpressCorrectable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(64usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 6u32) & (64usize as u32);
    }
    #[inline]
    pub fn PCIExpressUncorrectableNonFatal(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (128usize as u32)) >>
                                        7u32) as u32)
        }
    }
    #[inline]
    pub fn set_PCIExpressUncorrectableNonFatal(&mut self, val: ULONG) {
        self._bitfield_1 &= !(128usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 7u32) & (128usize as u32);
    }
    #[inline]
    pub fn PCIExpressUncorrectableFatal(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (256usize as u32)) >>
                                        8u32) as u32)
        }
    }
    #[inline]
    pub fn set_PCIExpressUncorrectableFatal(&mut self, val: ULONG) {
        self._bitfield_1 &= !(256usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 8u32) & (256usize as u32);
    }
    #[inline]
    pub fn PlatformCorrectable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (512usize as u32)) >>
                                        9u32) as u32)
        }
    }
    #[inline]
    pub fn set_PlatformCorrectable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(512usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 9u32) & (512usize as u32);
    }
    #[inline]
    pub fn PlatformUncorrectableNonFatal(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (1024usize as u32)) >>
                                        10u32) as u32)
        }
    }
    #[inline]
    pub fn set_PlatformUncorrectableNonFatal(&mut self, val: ULONG) {
        self._bitfield_1 &= !(1024usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 10u32) & (1024usize as u32);
    }
    #[inline]
    pub fn PlatformUncorrectableFatal(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (2048usize as u32)) >>
                                        11u32) as u32)
        }
    }
    #[inline]
    pub fn set_PlatformUncorrectableFatal(&mut self, val: ULONG) {
        self._bitfield_1 &= !(2048usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 11u32) & (2048usize as u32);
    }
    #[inline]
    pub fn IA64Corrected(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4096usize as u32)) >>
                                        12u32) as u32)
        }
    }
    #[inline]
    pub fn set_IA64Corrected(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4096usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 12u32) & (4096usize as u32);
    }
    #[inline]
    pub fn IA64Recoverable(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (8192usize as u32)) >>
                                        13u32) as u32)
        }
    }
    #[inline]
    pub fn set_IA64Recoverable(&mut self, val: ULONG) {
        self._bitfield_1 &= !(8192usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 13u32) & (8192usize as u32);
    }
    #[inline]
    pub fn IA64Fatal(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (16384usize as u32))
                                        >> 14u32) as u32)
        }
    }
    #[inline]
    pub fn set_IA64Fatal(&mut self, val: ULONG) {
        self._bitfield_1 &= !(16384usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 14u32) & (16384usize as u32);
    }
    #[inline]
    pub fn IA64RecoverableCache(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (32768usize as u32))
                                        >> 15u32) as u32)
        }
    }
    #[inline]
    pub fn set_IA64RecoverableCache(&mut self, val: ULONG) {
        self._bitfield_1 &= !(32768usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 15u32) & (32768usize as u32);
    }
    #[inline]
    pub fn IA64RecoverableRegFile(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (65536usize as u32))
                                        >> 16u32) as u32)
        }
    }
    #[inline]
    pub fn set_IA64RecoverableRegFile(&mut self, val: ULONG) {
        self._bitfield_1 &= !(65536usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (65536usize as u32);
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (4294836224usize as u32)) >> 17u32)
                                       as u32)
        }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        self._bitfield_1 &= !(4294836224usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 17u32) & (4294836224usize as u32);
    }
}
#[test]
fn bindgen_test_layout__WHEA_ERROR_INJECTION_CAPABILITIES() {
    assert_eq!(::core::mem::size_of::<_WHEA_ERROR_INJECTION_CAPABILITIES>() ,
               4usize);
    assert_eq!(::core::mem::align_of::<_WHEA_ERROR_INJECTION_CAPABILITIES>() ,
               4usize);
}
impl Clone for _WHEA_ERROR_INJECTION_CAPABILITIES {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_ERROR_INJECTION_CAPABILITIES as
        WHEA_ERROR_INJECTION_CAPABILITIES;
pub type PWHEA_ERROR_INJECTION_CAPABILITIES =
    *mut _WHEA_ERROR_INJECTION_CAPABILITIES;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_RECOVERY_CONTEXT {
    pub __bindgen_anon_1: _WHEA_RECOVERY_CONTEXT__bindgen_ty_1,
    pub PartitionId: UINT64,
    pub VpIndex: UINT32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_RECOVERY_CONTEXT__bindgen_ty_1 {
    pub MemoryError: __BindgenUnionField<_WHEA_RECOVERY_CONTEXT__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_RECOVERY_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    pub Address: ULONG_PTR,
    pub Consumed: BOOLEAN,
    pub ErrorCode: UINT16,
    pub ErrorIpValid: BOOLEAN,
    pub RestartIpValid: BOOLEAN,
}
#[test]
fn bindgen_test_layout__WHEA_RECOVERY_CONTEXT__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_WHEA_RECOVERY_CONTEXT__bindgen_ty_1__bindgen_ty_1>()
               , 16usize);
    assert_eq!(::core::mem::align_of::<_WHEA_RECOVERY_CONTEXT__bindgen_ty_1__bindgen_ty_1>()
               , 8usize);
}
impl Clone for _WHEA_RECOVERY_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__WHEA_RECOVERY_CONTEXT__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_WHEA_RECOVERY_CONTEXT__bindgen_ty_1>()
               , 16usize);
    assert_eq!(::core::mem::align_of::<_WHEA_RECOVERY_CONTEXT__bindgen_ty_1>()
               , 8usize);
}
impl Clone for _WHEA_RECOVERY_CONTEXT__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__WHEA_RECOVERY_CONTEXT() {
    assert_eq!(::core::mem::size_of::<_WHEA_RECOVERY_CONTEXT>() , 32usize);
    assert_eq!(::core::mem::align_of::<_WHEA_RECOVERY_CONTEXT>() , 8usize);
}
impl Clone for _WHEA_RECOVERY_CONTEXT {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_RECOVERY_CONTEXT as WHEA_RECOVERY_CONTEXT;
pub type PWHEA_RECOVERY_CONTEXT = *mut _WHEA_RECOVERY_CONTEXT;
pub type HVL_WHEA_ERROR_NOTIFICATION =
    ::core::option::Option<unsafe extern "C" fn(RecoveryContext:
                                                    PWHEA_RECOVERY_CONTEXT,
                                                PlatformDirected: BOOLEAN,
                                                Poisoned: BOOLEAN)
                               -> libc::c_long>;
pub type PHVL_WHEA_ERROR_NOTIFICATION = HVL_WHEA_ERROR_NOTIFICATION;
extern "C" {
    #[link_name = "HvlpWheaErrorNotificationCallback"]
    pub static mut HvlpWheaErrorNotificationCallback:
               PHVL_WHEA_ERROR_NOTIFICATION;
}
extern "C" {
    pub fn HvlRegisterWheaErrorNotification(Callback:
                                                PHVL_WHEA_ERROR_NOTIFICATION)
     -> NTSTATUS;
}
extern "C" {
    pub fn HvlUnregisterWheaErrorNotification(Callback:
                                                  PHVL_WHEA_ERROR_NOTIFICATION)
     -> NTSTATUS;
}
pub type PSHED_PI_GET_ALL_ERROR_SOURCES =
    ::core::option::Option<unsafe extern "C" fn(PluginContext: PVOID,
                                                Count: PULONG,
                                                ErrorSrcs:
                                                    *mut PWHEA_ERROR_SOURCE_DESCRIPTOR,
                                                Length: PULONG)
                               -> libc::c_long>;
pub type PSHED_PI_GET_ERROR_SOURCE_INFO =
    ::core::option::Option<unsafe extern "C" fn(PluginContext: PVOID,
                                                ErrorSource:
                                                    PWHEA_ERROR_SOURCE_DESCRIPTOR)
                               -> libc::c_long>;
pub type PSHED_PI_SET_ERROR_SOURCE_INFO =
    ::core::option::Option<unsafe extern "C" fn(PluginContext: PVOID,
                                                ErrorSource:
                                                    PWHEA_ERROR_SOURCE_DESCRIPTOR)
                               -> libc::c_long>;
pub type PSHED_PI_ENABLE_ERROR_SOURCE =
    ::core::option::Option<unsafe extern "C" fn(PluginContext: PVOID,
                                                ErrorSource:
                                                    PWHEA_ERROR_SOURCE_DESCRIPTOR)
                               -> libc::c_long>;
pub type PSHED_PI_DISABLE_ERROR_SOURCE =
    ::core::option::Option<unsafe extern "C" fn(PluginContext: PVOID,
                                                ErrorSource:
                                                    PWHEA_ERROR_SOURCE_DESCRIPTOR)
                               -> libc::c_long>;
pub type PSHED_PI_WRITE_ERROR_RECORD =
    ::core::option::Option<unsafe extern "C" fn(PluginContext: PVOID,
                                                Flags: ULONG,
                                                RecordLength: ULONG,
                                                ErrorRecord:
                                                    PWHEA_ERROR_RECORD)
                               -> libc::c_long>;
pub type PSHED_PI_READ_ERROR_RECORD =
    ::core::option::Option<unsafe extern "C" fn(PluginContext: PVOID,
                                                Flags: ULONG,
                                                ErrorRecordId: ULONGLONG,
                                                NextErrorRecordId: PULONGLONG,
                                                RecordLength: PULONG,
                                                ErrorRecord:
                                                    PWHEA_ERROR_RECORD)
                               -> libc::c_long>;
pub type PSHED_PI_CLEAR_ERROR_RECORD =
    ::core::option::Option<unsafe extern "C" fn(PluginContext: PVOID,
                                                Flags: ULONG,
                                                ErrorRecordId: ULONGLONG)
                               -> libc::c_long>;
pub type PSHED_PI_RETRIEVE_ERROR_INFO =
    ::core::option::Option<unsafe extern "C" fn(PluginContext: PVOID,
                                                ErrorSource:
                                                    PWHEA_ERROR_SOURCE_DESCRIPTOR,
                                                BufferLength: ULONGLONG,
                                                Packet: PWHEA_ERROR_PACKET)
                               -> libc::c_long>;
pub type PSHED_PI_FINALIZE_ERROR_RECORD =
    ::core::option::Option<unsafe extern "C" fn(PluginContext: PVOID,
                                                ErrorSource:
                                                    PWHEA_ERROR_SOURCE_DESCRIPTOR,
                                                BufferLength: ULONG,
                                                ErrorRecord:
                                                    PWHEA_ERROR_RECORD)
                               -> libc::c_long>;
pub type PSHED_PI_CLEAR_ERROR_STATUS =
    ::core::option::Option<unsafe extern "C" fn(PluginContext: PVOID,
                                                ErrorSource:
                                                    PWHEA_ERROR_SOURCE_DESCRIPTOR,
                                                BufferLength: ULONG,
                                                ErrorRecord:
                                                    PWHEA_ERROR_RECORD)
                               -> libc::c_long>;
pub type PSHED_PI_ATTEMPT_ERROR_RECOVERY =
    ::core::option::Option<unsafe extern "C" fn(PluginContext: PVOID,
                                                BufferLength: ULONG,
                                                ErrorRecord:
                                                    PWHEA_ERROR_RECORD)
                               -> libc::c_long>;
pub type PSHED_PI_GET_INJECTION_CAPABILITIES =
    ::core::option::Option<unsafe extern "C" fn(PluginContext: PVOID,
                                                Capabilities:
                                                    PWHEA_ERROR_INJECTION_CAPABILITIES)
                               -> libc::c_long>;
pub type PSHED_PI_INJECT_ERROR =
    ::core::option::Option<unsafe extern "C" fn(PluginContext: PVOID,
                                                ErrorType: ULONGLONG,
                                                Parameter1: ULONGLONG,
                                                Parameter2: ULONGLONG,
                                                Parameter3: ULONGLONG,
                                                Parameter4: ULONGLONG)
                               -> libc::c_long>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_PSHED_PLUGIN_CALLBACKS {
    pub GetAllErrorSources: PSHED_PI_GET_ALL_ERROR_SOURCES,
    pub Reserved: PVOID,
    pub GetErrorSourceInfo: PSHED_PI_GET_ERROR_SOURCE_INFO,
    pub SetErrorSourceInfo: PSHED_PI_SET_ERROR_SOURCE_INFO,
    pub EnableErrorSource: PSHED_PI_ENABLE_ERROR_SOURCE,
    pub DisableErrorSource: PSHED_PI_DISABLE_ERROR_SOURCE,
    pub WriteErrorRecord: PSHED_PI_WRITE_ERROR_RECORD,
    pub ReadErrorRecord: PSHED_PI_READ_ERROR_RECORD,
    pub ClearErrorRecord: PSHED_PI_CLEAR_ERROR_RECORD,
    pub RetrieveErrorInfo: PSHED_PI_RETRIEVE_ERROR_INFO,
    pub FinalizeErrorRecord: PSHED_PI_FINALIZE_ERROR_RECORD,
    pub ClearErrorStatus: PSHED_PI_CLEAR_ERROR_STATUS,
    pub AttemptRecovery: PSHED_PI_ATTEMPT_ERROR_RECOVERY,
    pub GetInjectionCapabilities: PSHED_PI_GET_INJECTION_CAPABILITIES,
    pub InjectError: PSHED_PI_INJECT_ERROR,
}
#[test]
fn bindgen_test_layout__WHEA_PSHED_PLUGIN_CALLBACKS() {
    assert_eq!(::core::mem::size_of::<_WHEA_PSHED_PLUGIN_CALLBACKS>() ,
               120usize);
    assert_eq!(::core::mem::align_of::<_WHEA_PSHED_PLUGIN_CALLBACKS>() ,
               8usize);
}
impl Clone for _WHEA_PSHED_PLUGIN_CALLBACKS {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_PSHED_PLUGIN_CALLBACKS as WHEA_PSHED_PLUGIN_CALLBACKS;
pub type PWHEA_PSHED_PLUGIN_CALLBACKS = *mut _WHEA_PSHED_PLUGIN_CALLBACKS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _WHEA_PSHED_PLUGIN_REGISTRATION_PACKET {
    pub Length: ULONG,
    pub Version: ULONG,
    pub Context: PVOID,
    pub FunctionalAreaMask: ULONG,
    pub Reserved: ULONG,
    pub Callbacks: WHEA_PSHED_PLUGIN_CALLBACKS,
}
#[test]
fn bindgen_test_layout__WHEA_PSHED_PLUGIN_REGISTRATION_PACKET() {
    assert_eq!(::core::mem::size_of::<_WHEA_PSHED_PLUGIN_REGISTRATION_PACKET>()
               , 144usize);
    assert_eq!(::core::mem::align_of::<_WHEA_PSHED_PLUGIN_REGISTRATION_PACKET>()
               , 8usize);
}
impl Clone for _WHEA_PSHED_PLUGIN_REGISTRATION_PACKET {
    fn clone(&self) -> Self { *self }
}
pub use self::_WHEA_PSHED_PLUGIN_REGISTRATION_PACKET as
        WHEA_PSHED_PLUGIN_REGISTRATION_PACKET;
pub type PWHEA_PSHED_PLUGIN_REGISTRATION_PACKET =
    *mut _WHEA_PSHED_PLUGIN_REGISTRATION_PACKET;
extern "C" {
    pub fn PshedAllocateMemory(Size: ULONG) -> PVOID;
}
extern "C" {
    pub fn PshedFreeMemory(Address: PVOID);
}
extern "C" {
    pub fn PshedIsSystemWheaEnabled() -> BOOLEAN;
}
extern "C" {
    pub fn PshedRegisterPlugin(Packet: PWHEA_PSHED_PLUGIN_REGISTRATION_PACKET)
     -> NTSTATUS;
}
extern "C" {
    pub fn PshedSynchronizeExecution(ErrorSource:
                                         PWHEA_ERROR_SOURCE_DESCRIPTOR,
                                     SynchronizeRoutine:
                                         PKSYNCHRONIZE_ROUTINE,
                                     SynchronizeContext: PVOID) -> BOOLEAN;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _SOC_SUBSYSTEM_TYPE {
    SOC_SUBSYS_WIRELESS_MODEM = 0,
    SOC_SUBSYS_AUDIO_DSP = 1,
    SOC_SUBSYS_WIRELSS_CONNECTIVITY = 2,
    SOC_SUBSYS_SENSORS = 3,
    SOC_SUBSYS_VENDOR_DEFINED = 65536,
}
pub use self::_SOC_SUBSYSTEM_TYPE as SOC_SUBSYSTEM_TYPE;
pub type PSOC_SUBSYSTEM_TYPE = *mut _SOC_SUBSYSTEM_TYPE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SOC_SUBSYSTEM_FAILURE_DETAILS {
    pub SubsysType: SOC_SUBSYSTEM_TYPE,
    pub FirmwareVersion: ULONG64,
    pub HardwareVersion: ULONG64,
    pub UnifiedFailureRegionSize: ULONG,
    pub UnifiedFailureRegion: [CHAR; 1usize],
}
#[test]
fn bindgen_test_layout__SOC_SUBSYSTEM_FAILURE_DETAILS() {
    assert_eq!(::core::mem::size_of::<_SOC_SUBSYSTEM_FAILURE_DETAILS>() ,
               32usize);
    assert_eq!(::core::mem::align_of::<_SOC_SUBSYSTEM_FAILURE_DETAILS>() ,
               8usize);
}
impl Clone for _SOC_SUBSYSTEM_FAILURE_DETAILS {
    fn clone(&self) -> Self { *self }
}
pub use self::_SOC_SUBSYSTEM_FAILURE_DETAILS as SOC_SUBSYSTEM_FAILURE_DETAILS;
pub type PSOC_SUBSYSTEM_FAILURE_DETAILS = *mut _SOC_SUBSYSTEM_FAILURE_DETAILS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _COMPRESSED_DATA_INFO {
    pub _address: u8,
}
impl Clone for _COMPRESSED_DATA_INFO {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CREATE_DISK {
    pub _address: u8,
}
impl Clone for _CREATE_DISK {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DRIVE_LAYOUT_INFORMATION_EX {
    pub _address: u8,
}
impl Clone for _DRIVE_LAYOUT_INFORMATION_EX {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SET_PARTITION_INFORMATION_EX {
    pub _address: u8,
}
impl Clone for _SET_PARTITION_INFORMATION_EX {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _LOADER_PARAMETER_BLOCK {
    pub _address: u8,
}
impl Clone for _LOADER_PARAMETER_BLOCK {
    fn clone(&self) -> Self { *self }
}
